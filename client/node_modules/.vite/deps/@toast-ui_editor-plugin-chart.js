import {
  __commonJS
} from "./chunk-USJHI7ER.js";

// node_modules/@toast-ui/chart/dist/toastui-chart.js
var require_toastui_chart = __commonJS({
  "node_modules/@toast-ui/chart/dist/toastui-chart.js"(exports, module) {
    (function webpackUniversalModuleDefinition(root, factory) {
      if (typeof exports === "object" && typeof module === "object")
        module.exports = factory();
      else if (typeof define === "function" && define.amd)
        define([], factory);
      else if (typeof exports === "object")
        exports["toastui"] = factory();
      else
        root["toastui"] = root["toastui"] || {}, root["toastui"]["Chart"] = factory();
    })(self, function() {
      return (
        /******/
        function() {
          var __webpack_modules__ = {
            /***/
            3819: (
              /***/
              function(module2) {
                module2.exports = function(it) {
                  if (typeof it != "function") {
                    throw TypeError(String(it) + " is not a function");
                  }
                  return it;
                };
              }
            ),
            /***/
            8505: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var isObject = __webpack_require__2(5052);
                module2.exports = function(it) {
                  if (!isObject(it) && it !== null) {
                    throw TypeError("Can't set " + String(it) + " as a prototype");
                  }
                  return it;
                };
              }
            ),
            /***/
            9736: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var wellKnownSymbol = __webpack_require__2(95);
                var create = __webpack_require__2(2391);
                var definePropertyModule = __webpack_require__2(1787);
                var UNSCOPABLES = wellKnownSymbol("unscopables");
                var ArrayPrototype = Array.prototype;
                if (ArrayPrototype[UNSCOPABLES] == void 0) {
                  definePropertyModule.f(ArrayPrototype, UNSCOPABLES, {
                    configurable: true,
                    value: create(null)
                  });
                }
                module2.exports = function(key) {
                  ArrayPrototype[UNSCOPABLES][key] = true;
                };
              }
            ),
            /***/
            6637: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var charAt = __webpack_require__2(966).charAt;
                module2.exports = function(S, index, unicode) {
                  return index + (unicode ? charAt(S, index).length : 1);
                };
              }
            ),
            /***/
            7728: (
              /***/
              function(module2) {
                module2.exports = function(it, Constructor, name) {
                  if (!(it instanceof Constructor)) {
                    throw TypeError("Incorrect " + (name ? name + " " : "") + "invocation");
                  }
                  return it;
                };
              }
            ),
            /***/
            1176: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var isObject = __webpack_require__2(5052);
                module2.exports = function(it) {
                  if (!isObject(it)) {
                    throw TypeError(String(it) + " is not an object");
                  }
                  return it;
                };
              }
            ),
            /***/
            3339: (
              /***/
              function(module2) {
                module2.exports = typeof ArrayBuffer !== "undefined" && typeof DataView !== "undefined";
              }
            ),
            /***/
            9918: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var NATIVE_ARRAY_BUFFER = __webpack_require__2(3339);
                var DESCRIPTORS = __webpack_require__2(7400);
                var global = __webpack_require__2(9859);
                var isObject = __webpack_require__2(5052);
                var has = __webpack_require__2(816);
                var classof = __webpack_require__2(1589);
                var createNonEnumerableProperty = __webpack_require__2(5762);
                var redefine = __webpack_require__2(7487);
                var defineProperty = __webpack_require__2(1787).f;
                var getPrototypeOf = __webpack_require__2(7567);
                var setPrototypeOf = __webpack_require__2(6540);
                var wellKnownSymbol = __webpack_require__2(95);
                var uid = __webpack_require__2(1441);
                var Int8Array2 = global.Int8Array;
                var Int8ArrayPrototype = Int8Array2 && Int8Array2.prototype;
                var Uint8ClampedArray = global.Uint8ClampedArray;
                var Uint8ClampedArrayPrototype = Uint8ClampedArray && Uint8ClampedArray.prototype;
                var TypedArray = Int8Array2 && getPrototypeOf(Int8Array2);
                var TypedArrayPrototype = Int8ArrayPrototype && getPrototypeOf(Int8ArrayPrototype);
                var ObjectPrototype = Object.prototype;
                var isPrototypeOf = ObjectPrototype.isPrototypeOf;
                var TO_STRING_TAG = wellKnownSymbol("toStringTag");
                var TYPED_ARRAY_TAG = uid("TYPED_ARRAY_TAG");
                var NATIVE_ARRAY_BUFFER_VIEWS = NATIVE_ARRAY_BUFFER && !!setPrototypeOf && classof(global.opera) !== "Opera";
                var TYPED_ARRAY_TAG_REQIRED = false;
                var NAME;
                var TypedArrayConstructorsList = {
                  Int8Array: 1,
                  Uint8Array: 1,
                  Uint8ClampedArray: 1,
                  Int16Array: 2,
                  Uint16Array: 2,
                  Int32Array: 4,
                  Uint32Array: 4,
                  Float32Array: 4,
                  Float64Array: 8
                };
                var BigIntArrayConstructorsList = {
                  BigInt64Array: 8,
                  BigUint64Array: 8
                };
                var isView = function isView2(it) {
                  if (!isObject(it))
                    return false;
                  var klass = classof(it);
                  return klass === "DataView" || has(TypedArrayConstructorsList, klass) || has(BigIntArrayConstructorsList, klass);
                };
                var isTypedArray = function(it) {
                  if (!isObject(it))
                    return false;
                  var klass = classof(it);
                  return has(TypedArrayConstructorsList, klass) || has(BigIntArrayConstructorsList, klass);
                };
                var aTypedArray = function(it) {
                  if (isTypedArray(it))
                    return it;
                  throw TypeError("Target is not a typed array");
                };
                var aTypedArrayConstructor = function(C) {
                  if (setPrototypeOf) {
                    if (isPrototypeOf.call(TypedArray, C))
                      return C;
                  } else
                    for (var ARRAY in TypedArrayConstructorsList)
                      if (has(TypedArrayConstructorsList, NAME)) {
                        var TypedArrayConstructor = global[ARRAY];
                        if (TypedArrayConstructor && (C === TypedArrayConstructor || isPrototypeOf.call(TypedArrayConstructor, C))) {
                          return C;
                        }
                      }
                  throw TypeError("Target is not a typed array constructor");
                };
                var exportTypedArrayMethod = function(KEY, property, forced) {
                  if (!DESCRIPTORS)
                    return;
                  if (forced)
                    for (var ARRAY in TypedArrayConstructorsList) {
                      var TypedArrayConstructor = global[ARRAY];
                      if (TypedArrayConstructor && has(TypedArrayConstructor.prototype, KEY))
                        try {
                          delete TypedArrayConstructor.prototype[KEY];
                        } catch (error) {
                        }
                    }
                  if (!TypedArrayPrototype[KEY] || forced) {
                    redefine(TypedArrayPrototype, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS && Int8ArrayPrototype[KEY] || property);
                  }
                };
                var exportTypedArrayStaticMethod = function(KEY, property, forced) {
                  var ARRAY, TypedArrayConstructor;
                  if (!DESCRIPTORS)
                    return;
                  if (setPrototypeOf) {
                    if (forced)
                      for (ARRAY in TypedArrayConstructorsList) {
                        TypedArrayConstructor = global[ARRAY];
                        if (TypedArrayConstructor && has(TypedArrayConstructor, KEY))
                          try {
                            delete TypedArrayConstructor[KEY];
                          } catch (error) {
                          }
                      }
                    if (!TypedArray[KEY] || forced) {
                      try {
                        return redefine(TypedArray, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS && TypedArray[KEY] || property);
                      } catch (error) {
                      }
                    } else
                      return;
                  }
                  for (ARRAY in TypedArrayConstructorsList) {
                    TypedArrayConstructor = global[ARRAY];
                    if (TypedArrayConstructor && (!TypedArrayConstructor[KEY] || forced)) {
                      redefine(TypedArrayConstructor, KEY, property);
                    }
                  }
                };
                for (NAME in TypedArrayConstructorsList) {
                  if (!global[NAME])
                    NATIVE_ARRAY_BUFFER_VIEWS = false;
                }
                if (!NATIVE_ARRAY_BUFFER_VIEWS || typeof TypedArray != "function" || TypedArray === Function.prototype) {
                  TypedArray = function TypedArray2() {
                    throw TypeError("Incorrect invocation");
                  };
                  if (NATIVE_ARRAY_BUFFER_VIEWS)
                    for (NAME in TypedArrayConstructorsList) {
                      if (global[NAME])
                        setPrototypeOf(global[NAME], TypedArray);
                    }
                }
                if (!NATIVE_ARRAY_BUFFER_VIEWS || !TypedArrayPrototype || TypedArrayPrototype === ObjectPrototype) {
                  TypedArrayPrototype = TypedArray.prototype;
                  if (NATIVE_ARRAY_BUFFER_VIEWS)
                    for (NAME in TypedArrayConstructorsList) {
                      if (global[NAME])
                        setPrototypeOf(global[NAME].prototype, TypedArrayPrototype);
                    }
                }
                if (NATIVE_ARRAY_BUFFER_VIEWS && getPrototypeOf(Uint8ClampedArrayPrototype) !== TypedArrayPrototype) {
                  setPrototypeOf(Uint8ClampedArrayPrototype, TypedArrayPrototype);
                }
                if (DESCRIPTORS && !has(TypedArrayPrototype, TO_STRING_TAG)) {
                  TYPED_ARRAY_TAG_REQIRED = true;
                  defineProperty(TypedArrayPrototype, TO_STRING_TAG, { get: function() {
                    return isObject(this) ? this[TYPED_ARRAY_TAG] : void 0;
                  } });
                  for (NAME in TypedArrayConstructorsList)
                    if (global[NAME]) {
                      createNonEnumerableProperty(global[NAME], TYPED_ARRAY_TAG, NAME);
                    }
                }
                module2.exports = {
                  NATIVE_ARRAY_BUFFER_VIEWS,
                  TYPED_ARRAY_TAG: TYPED_ARRAY_TAG_REQIRED && TYPED_ARRAY_TAG,
                  aTypedArray,
                  aTypedArrayConstructor,
                  exportTypedArrayMethod,
                  exportTypedArrayStaticMethod,
                  isView,
                  isTypedArray,
                  TypedArray,
                  TypedArrayPrototype
                };
              }
            ),
            /***/
            3816: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var global = __webpack_require__2(9859);
                var DESCRIPTORS = __webpack_require__2(7400);
                var NATIVE_ARRAY_BUFFER = __webpack_require__2(3339);
                var createNonEnumerableProperty = __webpack_require__2(5762);
                var redefineAll = __webpack_require__2(8787);
                var fails = __webpack_require__2(4229);
                var anInstance = __webpack_require__2(7728);
                var toInteger = __webpack_require__2(6051);
                var toLength = __webpack_require__2(4237);
                var toIndex = __webpack_require__2(7331);
                var IEEE754 = __webpack_require__2(6201);
                var getPrototypeOf = __webpack_require__2(7567);
                var setPrototypeOf = __webpack_require__2(6540);
                var getOwnPropertyNames = __webpack_require__2(8151).f;
                var defineProperty = __webpack_require__2(1787).f;
                var arrayFill = __webpack_require__2(7065);
                var setToStringTag = __webpack_require__2(4555);
                var InternalStateModule = __webpack_require__2(6407);
                var getInternalState = InternalStateModule.get;
                var setInternalState = InternalStateModule.set;
                var ARRAY_BUFFER = "ArrayBuffer";
                var DATA_VIEW = "DataView";
                var PROTOTYPE = "prototype";
                var WRONG_LENGTH = "Wrong length";
                var WRONG_INDEX = "Wrong index";
                var NativeArrayBuffer = global[ARRAY_BUFFER];
                var $ArrayBuffer = NativeArrayBuffer;
                var $DataView = global[DATA_VIEW];
                var $DataViewPrototype = $DataView && $DataView[PROTOTYPE];
                var ObjectPrototype = Object.prototype;
                var RangeError2 = global.RangeError;
                var packIEEE754 = IEEE754.pack;
                var unpackIEEE754 = IEEE754.unpack;
                var packInt8 = function(number) {
                  return [number & 255];
                };
                var packInt16 = function(number) {
                  return [number & 255, number >> 8 & 255];
                };
                var packInt32 = function(number) {
                  return [number & 255, number >> 8 & 255, number >> 16 & 255, number >> 24 & 255];
                };
                var unpackInt32 = function(buffer) {
                  return buffer[3] << 24 | buffer[2] << 16 | buffer[1] << 8 | buffer[0];
                };
                var packFloat32 = function(number) {
                  return packIEEE754(number, 23, 4);
                };
                var packFloat64 = function(number) {
                  return packIEEE754(number, 52, 8);
                };
                var addGetter = function(Constructor, key2) {
                  defineProperty(Constructor[PROTOTYPE], key2, { get: function() {
                    return getInternalState(this)[key2];
                  } });
                };
                var get = function(view, count, index, isLittleEndian) {
                  var intIndex = toIndex(index);
                  var store = getInternalState(view);
                  if (intIndex + count > store.byteLength)
                    throw RangeError2(WRONG_INDEX);
                  var bytes = getInternalState(store.buffer).bytes;
                  var start = intIndex + store.byteOffset;
                  var pack = bytes.slice(start, start + count);
                  return isLittleEndian ? pack : pack.reverse();
                };
                var set = function(view, count, index, conversion, value, isLittleEndian) {
                  var intIndex = toIndex(index);
                  var store = getInternalState(view);
                  if (intIndex + count > store.byteLength)
                    throw RangeError2(WRONG_INDEX);
                  var bytes = getInternalState(store.buffer).bytes;
                  var start = intIndex + store.byteOffset;
                  var pack = conversion(+value);
                  for (var i = 0; i < count; i++)
                    bytes[start + i] = pack[isLittleEndian ? i : count - i - 1];
                };
                if (!NATIVE_ARRAY_BUFFER) {
                  $ArrayBuffer = function ArrayBuffer2(length) {
                    anInstance(this, $ArrayBuffer, ARRAY_BUFFER);
                    var byteLength = toIndex(length);
                    setInternalState(this, {
                      bytes: arrayFill.call(new Array(byteLength), 0),
                      byteLength
                    });
                    if (!DESCRIPTORS)
                      this.byteLength = byteLength;
                  };
                  $DataView = function DataView2(buffer, byteOffset, byteLength) {
                    anInstance(this, $DataView, DATA_VIEW);
                    anInstance(buffer, $ArrayBuffer, DATA_VIEW);
                    var bufferLength = getInternalState(buffer).byteLength;
                    var offset = toInteger(byteOffset);
                    if (offset < 0 || offset > bufferLength)
                      throw RangeError2("Wrong offset");
                    byteLength = byteLength === void 0 ? bufferLength - offset : toLength(byteLength);
                    if (offset + byteLength > bufferLength)
                      throw RangeError2(WRONG_LENGTH);
                    setInternalState(this, {
                      buffer,
                      byteLength,
                      byteOffset: offset
                    });
                    if (!DESCRIPTORS) {
                      this.buffer = buffer;
                      this.byteLength = byteLength;
                      this.byteOffset = offset;
                    }
                  };
                  if (DESCRIPTORS) {
                    addGetter($ArrayBuffer, "byteLength");
                    addGetter($DataView, "buffer");
                    addGetter($DataView, "byteLength");
                    addGetter($DataView, "byteOffset");
                  }
                  redefineAll($DataView[PROTOTYPE], {
                    getInt8: function getInt8(byteOffset) {
                      return get(this, 1, byteOffset)[0] << 24 >> 24;
                    },
                    getUint8: function getUint8(byteOffset) {
                      return get(this, 1, byteOffset)[0];
                    },
                    getInt16: function getInt16(byteOffset) {
                      var bytes = get(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : void 0);
                      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
                    },
                    getUint16: function getUint16(byteOffset) {
                      var bytes = get(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : void 0);
                      return bytes[1] << 8 | bytes[0];
                    },
                    getInt32: function getInt32(byteOffset) {
                      return unpackInt32(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : void 0));
                    },
                    getUint32: function getUint32(byteOffset) {
                      return unpackInt32(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : void 0)) >>> 0;
                    },
                    getFloat32: function getFloat32(byteOffset) {
                      return unpackIEEE754(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : void 0), 23);
                    },
                    getFloat64: function getFloat64(byteOffset) {
                      return unpackIEEE754(get(this, 8, byteOffset, arguments.length > 1 ? arguments[1] : void 0), 52);
                    },
                    setInt8: function setInt8(byteOffset, value) {
                      set(this, 1, byteOffset, packInt8, value);
                    },
                    setUint8: function setUint8(byteOffset, value) {
                      set(this, 1, byteOffset, packInt8, value);
                    },
                    setInt16: function setInt16(byteOffset, value) {
                      set(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : void 0);
                    },
                    setUint16: function setUint16(byteOffset, value) {
                      set(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : void 0);
                    },
                    setInt32: function setInt32(byteOffset, value) {
                      set(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : void 0);
                    },
                    setUint32: function setUint32(byteOffset, value) {
                      set(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : void 0);
                    },
                    setFloat32: function setFloat32(byteOffset, value) {
                      set(this, 4, byteOffset, packFloat32, value, arguments.length > 2 ? arguments[2] : void 0);
                    },
                    setFloat64: function setFloat64(byteOffset, value) {
                      set(this, 8, byteOffset, packFloat64, value, arguments.length > 2 ? arguments[2] : void 0);
                    }
                  });
                } else {
                  if (!fails(function() {
                    NativeArrayBuffer(1);
                  }) || !fails(function() {
                    new NativeArrayBuffer(-1);
                  }) || fails(function() {
                    new NativeArrayBuffer();
                    new NativeArrayBuffer(1.5);
                    new NativeArrayBuffer(NaN);
                    return NativeArrayBuffer.name != ARRAY_BUFFER;
                  })) {
                    $ArrayBuffer = function ArrayBuffer2(length) {
                      anInstance(this, $ArrayBuffer);
                      return new NativeArrayBuffer(toIndex(length));
                    };
                    var ArrayBufferPrototype = $ArrayBuffer[PROTOTYPE] = NativeArrayBuffer[PROTOTYPE];
                    for (var keys = getOwnPropertyNames(NativeArrayBuffer), j = 0, key; keys.length > j; ) {
                      if (!((key = keys[j++]) in $ArrayBuffer)) {
                        createNonEnumerableProperty($ArrayBuffer, key, NativeArrayBuffer[key]);
                      }
                    }
                    ArrayBufferPrototype.constructor = $ArrayBuffer;
                  }
                  if (setPrototypeOf && getPrototypeOf($DataViewPrototype) !== ObjectPrototype) {
                    setPrototypeOf($DataViewPrototype, ObjectPrototype);
                  }
                  var testView = new $DataView(new $ArrayBuffer(2));
                  var $setInt8 = $DataViewPrototype.setInt8;
                  testView.setInt8(0, 2147483648);
                  testView.setInt8(1, 2147483649);
                  if (testView.getInt8(0) || !testView.getInt8(1))
                    redefineAll($DataViewPrototype, {
                      setInt8: function setInt8(byteOffset, value) {
                        $setInt8.call(this, byteOffset, value << 24 >> 24);
                      },
                      setUint8: function setUint8(byteOffset, value) {
                        $setInt8.call(this, byteOffset, value << 24 >> 24);
                      }
                    }, { unsafe: true });
                }
                setToStringTag($ArrayBuffer, ARRAY_BUFFER);
                setToStringTag($DataView, DATA_VIEW);
                module2.exports = {
                  ArrayBuffer: $ArrayBuffer,
                  DataView: $DataView
                };
              }
            ),
            /***/
            7154: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var toObject = __webpack_require__2(2991);
                var toAbsoluteIndex = __webpack_require__2(3231);
                var toLength = __webpack_require__2(4237);
                var min = Math.min;
                module2.exports = [].copyWithin || function copyWithin(target, start) {
                  var O = toObject(this);
                  var len = toLength(O.length);
                  var to = toAbsoluteIndex(target, len);
                  var from = toAbsoluteIndex(start, len);
                  var end = arguments.length > 2 ? arguments[2] : void 0;
                  var count = min((end === void 0 ? len : toAbsoluteIndex(end, len)) - from, len - to);
                  var inc = 1;
                  if (from < to && to < from + count) {
                    inc = -1;
                    from += count - 1;
                    to += count - 1;
                  }
                  while (count-- > 0) {
                    if (from in O)
                      O[to] = O[from];
                    else
                      delete O[to];
                    to += inc;
                    from += inc;
                  }
                  return O;
                };
              }
            ),
            /***/
            7065: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var toObject = __webpack_require__2(2991);
                var toAbsoluteIndex = __webpack_require__2(3231);
                var toLength = __webpack_require__2(4237);
                module2.exports = function fill(value) {
                  var O = toObject(this);
                  var length = toLength(O.length);
                  var argumentsLength = arguments.length;
                  var index = toAbsoluteIndex(argumentsLength > 1 ? arguments[1] : void 0, length);
                  var end = argumentsLength > 2 ? arguments[2] : void 0;
                  var endPos = end === void 0 ? length : toAbsoluteIndex(end, length);
                  while (endPos > index)
                    O[index++] = value;
                  return O;
                };
              }
            ),
            /***/
            6570: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var $forEach = __webpack_require__2(9996).forEach;
                var arrayMethodIsStrict = __webpack_require__2(6038);
                var STRICT_METHOD = arrayMethodIsStrict("forEach");
                module2.exports = !STRICT_METHOD ? function forEach(callbackfn) {
                  return $forEach(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
                } : [].forEach;
              }
            ),
            /***/
            507: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var bind = __webpack_require__2(7636);
                var toObject = __webpack_require__2(2991);
                var callWithSafeIterationClosing = __webpack_require__2(4960);
                var isArrayIteratorMethod = __webpack_require__2(1943);
                var toLength = __webpack_require__2(4237);
                var createProperty = __webpack_require__2(2324);
                var getIteratorMethod = __webpack_require__2(8830);
                module2.exports = function from(arrayLike) {
                  var O = toObject(arrayLike);
                  var C = typeof this == "function" ? this : Array;
                  var argumentsLength = arguments.length;
                  var mapfn = argumentsLength > 1 ? arguments[1] : void 0;
                  var mapping = mapfn !== void 0;
                  var iteratorMethod = getIteratorMethod(O);
                  var index = 0;
                  var length, result, step, iterator, next, value;
                  if (mapping)
                    mapfn = bind(mapfn, argumentsLength > 2 ? arguments[2] : void 0, 2);
                  if (iteratorMethod != void 0 && !(C == Array && isArrayIteratorMethod(iteratorMethod))) {
                    iterator = iteratorMethod.call(O);
                    next = iterator.next;
                    result = new C();
                    for (; !(step = next.call(iterator)).done; index++) {
                      value = mapping ? callWithSafeIterationClosing(iterator, mapfn, [step.value, index], true) : step.value;
                      createProperty(result, index, value);
                    }
                  } else {
                    length = toLength(O.length);
                    result = new C(length);
                    for (; length > index; index++) {
                      value = mapping ? mapfn(O[index], index) : O[index];
                      createProperty(result, index, value);
                    }
                  }
                  result.length = index;
                  return result;
                };
              }
            ),
            /***/
            9540: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var toIndexedObject = __webpack_require__2(905);
                var toLength = __webpack_require__2(4237);
                var toAbsoluteIndex = __webpack_require__2(3231);
                var createMethod = function(IS_INCLUDES) {
                  return function($this, el, fromIndex) {
                    var O = toIndexedObject($this);
                    var length = toLength(O.length);
                    var index = toAbsoluteIndex(fromIndex, length);
                    var value;
                    if (IS_INCLUDES && el != el)
                      while (length > index) {
                        value = O[index++];
                        if (value != value)
                          return true;
                      }
                    else
                      for (; length > index; index++) {
                        if ((IS_INCLUDES || index in O) && O[index] === el)
                          return IS_INCLUDES || index || 0;
                      }
                    return !IS_INCLUDES && -1;
                  };
                };
                module2.exports = {
                  // `Array.prototype.includes` method
                  // https://tc39.es/ecma262/#sec-array.prototype.includes
                  includes: createMethod(true),
                  // `Array.prototype.indexOf` method
                  // https://tc39.es/ecma262/#sec-array.prototype.indexof
                  indexOf: createMethod(false)
                };
              }
            ),
            /***/
            9996: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var bind = __webpack_require__2(7636);
                var IndexedObject = __webpack_require__2(9337);
                var toObject = __webpack_require__2(2991);
                var toLength = __webpack_require__2(4237);
                var arraySpeciesCreate = __webpack_require__2(7501);
                var push = [].push;
                var createMethod = function(TYPE) {
                  var IS_MAP = TYPE == 1;
                  var IS_FILTER = TYPE == 2;
                  var IS_SOME = TYPE == 3;
                  var IS_EVERY = TYPE == 4;
                  var IS_FIND_INDEX = TYPE == 6;
                  var IS_FILTER_OUT = TYPE == 7;
                  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
                  return function($this, callbackfn, that, specificCreate) {
                    var O = toObject($this);
                    var self2 = IndexedObject(O);
                    var boundFunction = bind(callbackfn, that, 3);
                    var length = toLength(self2.length);
                    var index = 0;
                    var create = specificCreate || arraySpeciesCreate;
                    var target = IS_MAP ? create($this, length) : IS_FILTER || IS_FILTER_OUT ? create($this, 0) : void 0;
                    var value, result;
                    for (; length > index; index++)
                      if (NO_HOLES || index in self2) {
                        value = self2[index];
                        result = boundFunction(value, index, O);
                        if (TYPE) {
                          if (IS_MAP)
                            target[index] = result;
                          else if (result)
                            switch (TYPE) {
                              case 3:
                                return true;
                              case 5:
                                return value;
                              case 6:
                                return index;
                              case 2:
                                push.call(target, value);
                            }
                          else
                            switch (TYPE) {
                              case 4:
                                return false;
                              case 7:
                                push.call(target, value);
                            }
                        }
                      }
                    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
                  };
                };
                module2.exports = {
                  // `Array.prototype.forEach` method
                  // https://tc39.es/ecma262/#sec-array.prototype.foreach
                  forEach: createMethod(0),
                  // `Array.prototype.map` method
                  // https://tc39.es/ecma262/#sec-array.prototype.map
                  map: createMethod(1),
                  // `Array.prototype.filter` method
                  // https://tc39.es/ecma262/#sec-array.prototype.filter
                  filter: createMethod(2),
                  // `Array.prototype.some` method
                  // https://tc39.es/ecma262/#sec-array.prototype.some
                  some: createMethod(3),
                  // `Array.prototype.every` method
                  // https://tc39.es/ecma262/#sec-array.prototype.every
                  every: createMethod(4),
                  // `Array.prototype.find` method
                  // https://tc39.es/ecma262/#sec-array.prototype.find
                  find: createMethod(5),
                  // `Array.prototype.findIndex` method
                  // https://tc39.es/ecma262/#sec-array.prototype.findIndex
                  findIndex: createMethod(6),
                  // `Array.prototype.filterOut` method
                  // https://github.com/tc39/proposal-array-filtering
                  filterOut: createMethod(7)
                };
              }
            ),
            /***/
            6462: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var toIndexedObject = __webpack_require__2(905);
                var toInteger = __webpack_require__2(6051);
                var toLength = __webpack_require__2(4237);
                var arrayMethodIsStrict = __webpack_require__2(6038);
                var min = Math.min;
                var $lastIndexOf = [].lastIndexOf;
                var NEGATIVE_ZERO = !!$lastIndexOf && 1 / [1].lastIndexOf(1, -0) < 0;
                var STRICT_METHOD = arrayMethodIsStrict("lastIndexOf");
                var FORCED = NEGATIVE_ZERO || !STRICT_METHOD;
                module2.exports = FORCED ? function lastIndexOf(searchElement) {
                  if (NEGATIVE_ZERO)
                    return $lastIndexOf.apply(this, arguments) || 0;
                  var O = toIndexedObject(this);
                  var length = toLength(O.length);
                  var index = length - 1;
                  if (arguments.length > 1)
                    index = min(index, toInteger(arguments[1]));
                  if (index < 0)
                    index = length + index;
                  for (; index >= 0; index--)
                    if (index in O && O[index] === searchElement)
                      return index || 0;
                  return -1;
                } : $lastIndexOf;
              }
            ),
            /***/
            1460: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var fails = __webpack_require__2(4229);
                var wellKnownSymbol = __webpack_require__2(95);
                var V8_VERSION = __webpack_require__2(6358);
                var SPECIES = wellKnownSymbol("species");
                module2.exports = function(METHOD_NAME) {
                  return V8_VERSION >= 51 || !fails(function() {
                    var array = [];
                    var constructor = array.constructor = {};
                    constructor[SPECIES] = function() {
                      return { foo: 1 };
                    };
                    return array[METHOD_NAME](Boolean).foo !== 1;
                  });
                };
              }
            ),
            /***/
            6038: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var fails = __webpack_require__2(4229);
                module2.exports = function(METHOD_NAME, argument) {
                  var method = [][METHOD_NAME];
                  return !!method && fails(function() {
                    method.call(null, argument || function() {
                      throw 1;
                    }, 1);
                  });
                };
              }
            ),
            /***/
            3143: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var aFunction = __webpack_require__2(3819);
                var toObject = __webpack_require__2(2991);
                var IndexedObject = __webpack_require__2(9337);
                var toLength = __webpack_require__2(4237);
                var createMethod = function(IS_RIGHT) {
                  return function(that, callbackfn, argumentsLength, memo) {
                    aFunction(callbackfn);
                    var O = toObject(that);
                    var self2 = IndexedObject(O);
                    var length = toLength(O.length);
                    var index = IS_RIGHT ? length - 1 : 0;
                    var i = IS_RIGHT ? -1 : 1;
                    if (argumentsLength < 2)
                      while (true) {
                        if (index in self2) {
                          memo = self2[index];
                          index += i;
                          break;
                        }
                        index += i;
                        if (IS_RIGHT ? index < 0 : length <= index) {
                          throw TypeError("Reduce of empty array with no initial value");
                        }
                      }
                    for (; IS_RIGHT ? index >= 0 : length > index; index += i)
                      if (index in self2) {
                        memo = callbackfn(memo, self2[index], index, O);
                      }
                    return memo;
                  };
                };
                module2.exports = {
                  // `Array.prototype.reduce` method
                  // https://tc39.es/ecma262/#sec-array.prototype.reduce
                  left: createMethod(false),
                  // `Array.prototype.reduceRight` method
                  // https://tc39.es/ecma262/#sec-array.prototype.reduceright
                  right: createMethod(true)
                };
              }
            ),
            /***/
            7501: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var isObject = __webpack_require__2(5052);
                var isArray = __webpack_require__2(3718);
                var wellKnownSymbol = __webpack_require__2(95);
                var SPECIES = wellKnownSymbol("species");
                module2.exports = function(originalArray, length) {
                  var C;
                  if (isArray(originalArray)) {
                    C = originalArray.constructor;
                    if (typeof C == "function" && (C === Array || isArray(C.prototype)))
                      C = void 0;
                    else if (isObject(C)) {
                      C = C[SPECIES];
                      if (C === null)
                        C = void 0;
                    }
                  }
                  return new (C === void 0 ? Array : C)(length === 0 ? 0 : length);
                };
              }
            ),
            /***/
            4960: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var anObject = __webpack_require__2(1176);
                var iteratorClose = __webpack_require__2(7281);
                module2.exports = function(iterator, fn, value, ENTRIES) {
                  try {
                    return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value);
                  } catch (error) {
                    iteratorClose(iterator);
                    throw error;
                  }
                };
              }
            ),
            /***/
            4575: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var wellKnownSymbol = __webpack_require__2(95);
                var ITERATOR = wellKnownSymbol("iterator");
                var SAFE_CLOSING = false;
                try {
                  var called = 0;
                  var iteratorWithReturn = {
                    next: function() {
                      return { done: !!called++ };
                    },
                    "return": function() {
                      SAFE_CLOSING = true;
                    }
                  };
                  iteratorWithReturn[ITERATOR] = function() {
                    return this;
                  };
                  Array.from(iteratorWithReturn, function() {
                    throw 2;
                  });
                } catch (error) {
                }
                module2.exports = function(exec, SKIP_CLOSING) {
                  if (!SKIP_CLOSING && !SAFE_CLOSING)
                    return false;
                  var ITERATION_SUPPORT = false;
                  try {
                    var object = {};
                    object[ITERATOR] = function() {
                      return {
                        next: function() {
                          return { done: ITERATION_SUPPORT = true };
                        }
                      };
                    };
                    exec(object);
                  } catch (error) {
                  }
                  return ITERATION_SUPPORT;
                };
              }
            ),
            /***/
            7079: (
              /***/
              function(module2) {
                var toString = {}.toString;
                module2.exports = function(it) {
                  return toString.call(it).slice(8, -1);
                };
              }
            ),
            /***/
            1589: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var TO_STRING_TAG_SUPPORT = __webpack_require__2(1601);
                var classofRaw = __webpack_require__2(7079);
                var wellKnownSymbol = __webpack_require__2(95);
                var TO_STRING_TAG = wellKnownSymbol("toStringTag");
                var CORRECT_ARGUMENTS = classofRaw(function() {
                  return arguments;
                }()) == "Arguments";
                var tryGet = function(it, key) {
                  try {
                    return it[key];
                  } catch (error) {
                  }
                };
                module2.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function(it) {
                  var O, tag, result;
                  return it === void 0 ? "Undefined" : it === null ? "Null" : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG)) == "string" ? tag : CORRECT_ARGUMENTS ? classofRaw(O) : (result = classofRaw(O)) == "Object" && typeof O.callee == "function" ? "Arguments" : result;
                };
              }
            ),
            /***/
            8081: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var defineProperty = __webpack_require__2(1787).f;
                var create = __webpack_require__2(2391);
                var redefineAll = __webpack_require__2(8787);
                var bind = __webpack_require__2(7636);
                var anInstance = __webpack_require__2(7728);
                var iterate = __webpack_require__2(9003);
                var defineIterator = __webpack_require__2(7675);
                var setSpecies = __webpack_require__2(1832);
                var DESCRIPTORS = __webpack_require__2(7400);
                var fastKey = __webpack_require__2(5926).fastKey;
                var InternalStateModule = __webpack_require__2(6407);
                var setInternalState = InternalStateModule.set;
                var internalStateGetterFor = InternalStateModule.getterFor;
                module2.exports = {
                  getConstructor: function(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
                    var C = wrapper(function(that, iterable) {
                      anInstance(that, C, CONSTRUCTOR_NAME);
                      setInternalState(that, {
                        type: CONSTRUCTOR_NAME,
                        index: create(null),
                        first: void 0,
                        last: void 0,
                        size: 0
                      });
                      if (!DESCRIPTORS)
                        that.size = 0;
                      if (iterable != void 0)
                        iterate(iterable, that[ADDER], { that, AS_ENTRIES: IS_MAP });
                    });
                    var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);
                    var define2 = function(that, key, value) {
                      var state = getInternalState(that);
                      var entry = getEntry(that, key);
                      var previous, index;
                      if (entry) {
                        entry.value = value;
                      } else {
                        state.last = entry = {
                          index: index = fastKey(key, true),
                          key,
                          value,
                          previous: previous = state.last,
                          next: void 0,
                          removed: false
                        };
                        if (!state.first)
                          state.first = entry;
                        if (previous)
                          previous.next = entry;
                        if (DESCRIPTORS)
                          state.size++;
                        else
                          that.size++;
                        if (index !== "F")
                          state.index[index] = entry;
                      }
                      return that;
                    };
                    var getEntry = function(that, key) {
                      var state = getInternalState(that);
                      var index = fastKey(key);
                      var entry;
                      if (index !== "F")
                        return state.index[index];
                      for (entry = state.first; entry; entry = entry.next) {
                        if (entry.key == key)
                          return entry;
                      }
                    };
                    redefineAll(C.prototype, {
                      // 23.1.3.1 Map.prototype.clear()
                      // 23.2.3.2 Set.prototype.clear()
                      clear: function clear() {
                        var that = this;
                        var state = getInternalState(that);
                        var data = state.index;
                        var entry = state.first;
                        while (entry) {
                          entry.removed = true;
                          if (entry.previous)
                            entry.previous = entry.previous.next = void 0;
                          delete data[entry.index];
                          entry = entry.next;
                        }
                        state.first = state.last = void 0;
                        if (DESCRIPTORS)
                          state.size = 0;
                        else
                          that.size = 0;
                      },
                      // 23.1.3.3 Map.prototype.delete(key)
                      // 23.2.3.4 Set.prototype.delete(value)
                      "delete": function(key) {
                        var that = this;
                        var state = getInternalState(that);
                        var entry = getEntry(that, key);
                        if (entry) {
                          var next = entry.next;
                          var prev = entry.previous;
                          delete state.index[entry.index];
                          entry.removed = true;
                          if (prev)
                            prev.next = next;
                          if (next)
                            next.previous = prev;
                          if (state.first == entry)
                            state.first = next;
                          if (state.last == entry)
                            state.last = prev;
                          if (DESCRIPTORS)
                            state.size--;
                          else
                            that.size--;
                        }
                        return !!entry;
                      },
                      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
                      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
                      forEach: function forEach(callbackfn) {
                        var state = getInternalState(this);
                        var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : void 0, 3);
                        var entry;
                        while (entry = entry ? entry.next : state.first) {
                          boundFunction(entry.value, entry.key, this);
                          while (entry && entry.removed)
                            entry = entry.previous;
                        }
                      },
                      // 23.1.3.7 Map.prototype.has(key)
                      // 23.2.3.7 Set.prototype.has(value)
                      has: function has(key) {
                        return !!getEntry(this, key);
                      }
                    });
                    redefineAll(C.prototype, IS_MAP ? {
                      // 23.1.3.6 Map.prototype.get(key)
                      get: function get(key) {
                        var entry = getEntry(this, key);
                        return entry && entry.value;
                      },
                      // 23.1.3.9 Map.prototype.set(key, value)
                      set: function set(key, value) {
                        return define2(this, key === 0 ? 0 : key, value);
                      }
                    } : {
                      // 23.2.3.1 Set.prototype.add(value)
                      add: function add(value) {
                        return define2(this, value = value === 0 ? 0 : value, value);
                      }
                    });
                    if (DESCRIPTORS)
                      defineProperty(C.prototype, "size", {
                        get: function() {
                          return getInternalState(this).size;
                        }
                      });
                    return C;
                  },
                  setStrong: function(C, CONSTRUCTOR_NAME, IS_MAP) {
                    var ITERATOR_NAME = CONSTRUCTOR_NAME + " Iterator";
                    var getInternalCollectionState = internalStateGetterFor(CONSTRUCTOR_NAME);
                    var getInternalIteratorState = internalStateGetterFor(ITERATOR_NAME);
                    defineIterator(C, CONSTRUCTOR_NAME, function(iterated, kind) {
                      setInternalState(this, {
                        type: ITERATOR_NAME,
                        target: iterated,
                        state: getInternalCollectionState(iterated),
                        kind,
                        last: void 0
                      });
                    }, function() {
                      var state = getInternalIteratorState(this);
                      var kind = state.kind;
                      var entry = state.last;
                      while (entry && entry.removed)
                        entry = entry.previous;
                      if (!state.target || !(state.last = entry = entry ? entry.next : state.state.first)) {
                        state.target = void 0;
                        return { value: void 0, done: true };
                      }
                      if (kind == "keys")
                        return { value: entry.key, done: false };
                      if (kind == "values")
                        return { value: entry.value, done: false };
                      return { value: [entry.key, entry.value], done: false };
                    }, IS_MAP ? "entries" : "values", !IS_MAP, true);
                    setSpecies(CONSTRUCTOR_NAME);
                  }
                };
              }
            ),
            /***/
            9789: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var $ = __webpack_require__2(3103);
                var global = __webpack_require__2(9859);
                var isForced = __webpack_require__2(6541);
                var redefine = __webpack_require__2(7487);
                var InternalMetadataModule = __webpack_require__2(5926);
                var iterate = __webpack_require__2(9003);
                var anInstance = __webpack_require__2(7728);
                var isObject = __webpack_require__2(5052);
                var fails = __webpack_require__2(4229);
                var checkCorrectnessOfIteration = __webpack_require__2(4575);
                var setToStringTag = __webpack_require__2(4555);
                var inheritIfRequired = __webpack_require__2(835);
                module2.exports = function(CONSTRUCTOR_NAME, wrapper, common) {
                  var IS_MAP = CONSTRUCTOR_NAME.indexOf("Map") !== -1;
                  var IS_WEAK = CONSTRUCTOR_NAME.indexOf("Weak") !== -1;
                  var ADDER = IS_MAP ? "set" : "add";
                  var NativeConstructor = global[CONSTRUCTOR_NAME];
                  var NativePrototype = NativeConstructor && NativeConstructor.prototype;
                  var Constructor = NativeConstructor;
                  var exported = {};
                  var fixMethod = function(KEY) {
                    var nativeMethod = NativePrototype[KEY];
                    redefine(
                      NativePrototype,
                      KEY,
                      KEY == "add" ? function add(value) {
                        nativeMethod.call(this, value === 0 ? 0 : value);
                        return this;
                      } : KEY == "delete" ? function(key) {
                        return IS_WEAK && !isObject(key) ? false : nativeMethod.call(this, key === 0 ? 0 : key);
                      } : KEY == "get" ? function get(key) {
                        return IS_WEAK && !isObject(key) ? void 0 : nativeMethod.call(this, key === 0 ? 0 : key);
                      } : KEY == "has" ? function has(key) {
                        return IS_WEAK && !isObject(key) ? false : nativeMethod.call(this, key === 0 ? 0 : key);
                      } : function set(key, value) {
                        nativeMethod.call(this, key === 0 ? 0 : key, value);
                        return this;
                      }
                    );
                  };
                  var REPLACE = isForced(
                    CONSTRUCTOR_NAME,
                    typeof NativeConstructor != "function" || !(IS_WEAK || NativePrototype.forEach && !fails(function() {
                      new NativeConstructor().entries().next();
                    }))
                  );
                  if (REPLACE) {
                    Constructor = common.getConstructor(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER);
                    InternalMetadataModule.REQUIRED = true;
                  } else if (isForced(CONSTRUCTOR_NAME, true)) {
                    var instance = new Constructor();
                    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;
                    var THROWS_ON_PRIMITIVES = fails(function() {
                      instance.has(1);
                    });
                    var ACCEPT_ITERABLES = checkCorrectnessOfIteration(function(iterable) {
                      new NativeConstructor(iterable);
                    });
                    var BUGGY_ZERO = !IS_WEAK && fails(function() {
                      var $instance = new NativeConstructor();
                      var index = 5;
                      while (index--)
                        $instance[ADDER](index, index);
                      return !$instance.has(-0);
                    });
                    if (!ACCEPT_ITERABLES) {
                      Constructor = wrapper(function(dummy, iterable) {
                        anInstance(dummy, Constructor, CONSTRUCTOR_NAME);
                        var that = inheritIfRequired(new NativeConstructor(), dummy, Constructor);
                        if (iterable != void 0)
                          iterate(iterable, that[ADDER], { that, AS_ENTRIES: IS_MAP });
                        return that;
                      });
                      Constructor.prototype = NativePrototype;
                      NativePrototype.constructor = Constructor;
                    }
                    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
                      fixMethod("delete");
                      fixMethod("has");
                      IS_MAP && fixMethod("get");
                    }
                    if (BUGGY_ZERO || HASNT_CHAINING)
                      fixMethod(ADDER);
                    if (IS_WEAK && NativePrototype.clear)
                      delete NativePrototype.clear;
                  }
                  exported[CONSTRUCTOR_NAME] = Constructor;
                  $({ global: true, forced: Constructor != NativeConstructor }, exported);
                  setToStringTag(Constructor, CONSTRUCTOR_NAME);
                  if (!IS_WEAK)
                    common.setStrong(Constructor, CONSTRUCTOR_NAME, IS_MAP);
                  return Constructor;
                };
              }
            ),
            /***/
            7081: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var has = __webpack_require__2(816);
                var ownKeys = __webpack_require__2(4826);
                var getOwnPropertyDescriptorModule = __webpack_require__2(7933);
                var definePropertyModule = __webpack_require__2(1787);
                module2.exports = function(target, source) {
                  var keys = ownKeys(source);
                  var defineProperty = definePropertyModule.f;
                  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
                  for (var i = 0; i < keys.length; i++) {
                    var key = keys[i];
                    if (!has(target, key))
                      defineProperty(target, key, getOwnPropertyDescriptor(source, key));
                  }
                };
              }
            ),
            /***/
            8127: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var wellKnownSymbol = __webpack_require__2(95);
                var MATCH = wellKnownSymbol("match");
                module2.exports = function(METHOD_NAME) {
                  var regexp = /./;
                  try {
                    "/./"[METHOD_NAME](regexp);
                  } catch (error1) {
                    try {
                      regexp[MATCH] = false;
                      return "/./"[METHOD_NAME](regexp);
                    } catch (error2) {
                    }
                  }
                  return false;
                };
              }
            ),
            /***/
            7528: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var fails = __webpack_require__2(4229);
                module2.exports = !fails(function() {
                  function F() {
                  }
                  F.prototype.constructor = null;
                  return Object.getPrototypeOf(new F()) !== F.prototype;
                });
              }
            ),
            /***/
            1720: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var requireObjectCoercible = __webpack_require__2(8885);
                var quot = /"/g;
                module2.exports = function(string, tag, attribute, value) {
                  var S = String(requireObjectCoercible(string));
                  var p1 = "<" + tag;
                  if (attribute !== "")
                    p1 += " " + attribute + '="' + String(value).replace(quot, "&quot;") + '"';
                  return p1 + ">" + S + "</" + tag + ">";
                };
              }
            ),
            /***/
            3723: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var IteratorPrototype = __webpack_require__2(693).IteratorPrototype;
                var create = __webpack_require__2(2391);
                var createPropertyDescriptor = __webpack_require__2(5358);
                var setToStringTag = __webpack_require__2(4555);
                var Iterators = __webpack_require__2(5495);
                var returnThis = function() {
                  return this;
                };
                module2.exports = function(IteratorConstructor, NAME, next) {
                  var TO_STRING_TAG = NAME + " Iterator";
                  IteratorConstructor.prototype = create(IteratorPrototype, { next: createPropertyDescriptor(1, next) });
                  setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);
                  Iterators[TO_STRING_TAG] = returnThis;
                  return IteratorConstructor;
                };
              }
            ),
            /***/
            5762: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var DESCRIPTORS = __webpack_require__2(7400);
                var definePropertyModule = __webpack_require__2(1787);
                var createPropertyDescriptor = __webpack_require__2(5358);
                module2.exports = DESCRIPTORS ? function(object, key, value) {
                  return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
                } : function(object, key, value) {
                  object[key] = value;
                  return object;
                };
              }
            ),
            /***/
            5358: (
              /***/
              function(module2) {
                module2.exports = function(bitmap, value) {
                  return {
                    enumerable: !(bitmap & 1),
                    configurable: !(bitmap & 2),
                    writable: !(bitmap & 4),
                    value
                  };
                };
              }
            ),
            /***/
            2324: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var toPrimitive = __webpack_require__2(2066);
                var definePropertyModule = __webpack_require__2(1787);
                var createPropertyDescriptor = __webpack_require__2(5358);
                module2.exports = function(object, key, value) {
                  var propertyKey = toPrimitive(key);
                  if (propertyKey in object)
                    definePropertyModule.f(object, propertyKey, createPropertyDescriptor(0, value));
                  else
                    object[propertyKey] = value;
                };
              }
            ),
            /***/
            7675: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var $ = __webpack_require__2(3103);
                var createIteratorConstructor = __webpack_require__2(3723);
                var getPrototypeOf = __webpack_require__2(7567);
                var setPrototypeOf = __webpack_require__2(6540);
                var setToStringTag = __webpack_require__2(4555);
                var createNonEnumerableProperty = __webpack_require__2(5762);
                var redefine = __webpack_require__2(7487);
                var wellKnownSymbol = __webpack_require__2(95);
                var IS_PURE = __webpack_require__2(4231);
                var Iterators = __webpack_require__2(5495);
                var IteratorsCore = __webpack_require__2(693);
                var IteratorPrototype = IteratorsCore.IteratorPrototype;
                var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
                var ITERATOR = wellKnownSymbol("iterator");
                var KEYS = "keys";
                var VALUES = "values";
                var ENTRIES = "entries";
                var returnThis = function() {
                  return this;
                };
                module2.exports = function(Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
                  createIteratorConstructor(IteratorConstructor, NAME, next);
                  var getIterationMethod = function(KIND) {
                    if (KIND === DEFAULT && defaultIterator)
                      return defaultIterator;
                    if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype)
                      return IterablePrototype[KIND];
                    switch (KIND) {
                      case KEYS:
                        return function keys() {
                          return new IteratorConstructor(this, KIND);
                        };
                      case VALUES:
                        return function values() {
                          return new IteratorConstructor(this, KIND);
                        };
                      case ENTRIES:
                        return function entries() {
                          return new IteratorConstructor(this, KIND);
                        };
                    }
                    return function() {
                      return new IteratorConstructor(this);
                    };
                  };
                  var TO_STRING_TAG = NAME + " Iterator";
                  var INCORRECT_VALUES_NAME = false;
                  var IterablePrototype = Iterable.prototype;
                  var nativeIterator = IterablePrototype[ITERATOR] || IterablePrototype["@@iterator"] || DEFAULT && IterablePrototype[DEFAULT];
                  var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
                  var anyNativeIterator = NAME == "Array" ? IterablePrototype.entries || nativeIterator : nativeIterator;
                  var CurrentIteratorPrototype, methods, KEY;
                  if (anyNativeIterator) {
                    CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));
                    if (IteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
                      if (!IS_PURE && getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
                        if (setPrototypeOf) {
                          setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
                        } else if (typeof CurrentIteratorPrototype[ITERATOR] != "function") {
                          createNonEnumerableProperty(CurrentIteratorPrototype, ITERATOR, returnThis);
                        }
                      }
                      setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
                      if (IS_PURE)
                        Iterators[TO_STRING_TAG] = returnThis;
                    }
                  }
                  if (DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
                    INCORRECT_VALUES_NAME = true;
                    defaultIterator = function values() {
                      return nativeIterator.call(this);
                    };
                  }
                  if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {
                    createNonEnumerableProperty(IterablePrototype, ITERATOR, defaultIterator);
                  }
                  Iterators[NAME] = defaultIterator;
                  if (DEFAULT) {
                    methods = {
                      values: getIterationMethod(VALUES),
                      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
                      entries: getIterationMethod(ENTRIES)
                    };
                    if (FORCED)
                      for (KEY in methods) {
                        if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
                          redefine(IterablePrototype, KEY, methods[KEY]);
                        }
                      }
                    else
                      $({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);
                  }
                  return methods;
                };
              }
            ),
            /***/
            8423: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var path = __webpack_require__2(9276);
                var has = __webpack_require__2(816);
                var wrappedWellKnownSymbolModule = __webpack_require__2(5391);
                var defineProperty = __webpack_require__2(1787).f;
                module2.exports = function(NAME) {
                  var Symbol2 = path.Symbol || (path.Symbol = {});
                  if (!has(Symbol2, NAME))
                    defineProperty(Symbol2, NAME, {
                      value: wrappedWellKnownSymbolModule.f(NAME)
                    });
                };
              }
            ),
            /***/
            7400: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var fails = __webpack_require__2(4229);
                module2.exports = !fails(function() {
                  return Object.defineProperty({}, 1, { get: function() {
                    return 7;
                  } })[1] != 7;
                });
              }
            ),
            /***/
            2635: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var global = __webpack_require__2(9859);
                var isObject = __webpack_require__2(5052);
                var document2 = global.document;
                var EXISTS = isObject(document2) && isObject(document2.createElement);
                module2.exports = function(it) {
                  return EXISTS ? document2.createElement(it) : {};
                };
              }
            ),
            /***/
            5694: (
              /***/
              function(module2) {
                module2.exports = {
                  CSSRuleList: 0,
                  CSSStyleDeclaration: 0,
                  CSSValueList: 0,
                  ClientRectList: 0,
                  DOMRectList: 0,
                  DOMStringList: 0,
                  DOMTokenList: 1,
                  DataTransferItemList: 0,
                  FileList: 0,
                  HTMLAllCollection: 0,
                  HTMLCollection: 0,
                  HTMLFormElement: 0,
                  HTMLSelectElement: 0,
                  MediaList: 0,
                  MimeTypeArray: 0,
                  NamedNodeMap: 0,
                  NodeList: 1,
                  PaintRequestList: 0,
                  Plugin: 0,
                  PluginArray: 0,
                  SVGLengthList: 0,
                  SVGNumberList: 0,
                  SVGPathSegList: 0,
                  SVGPointList: 0,
                  SVGStringList: 0,
                  SVGTransformList: 0,
                  SourceBufferList: 0,
                  StyleSheetList: 0,
                  TextTrackCueList: 0,
                  TextTrackList: 0,
                  TouchList: 0
                };
              }
            ),
            /***/
            8801: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var classof = __webpack_require__2(7079);
                var global = __webpack_require__2(9859);
                module2.exports = classof(global.process) == "process";
              }
            ),
            /***/
            598: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var getBuiltIn = __webpack_require__2(1333);
                module2.exports = getBuiltIn("navigator", "userAgent") || "";
              }
            ),
            /***/
            6358: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var global = __webpack_require__2(9859);
                var userAgent = __webpack_require__2(598);
                var process2 = global.process;
                var versions = process2 && process2.versions;
                var v8 = versions && versions.v8;
                var match, version;
                if (v8) {
                  match = v8.split(".");
                  version = match[0] + match[1];
                } else if (userAgent) {
                  match = userAgent.match(/Edge\/(\d+)/);
                  if (!match || match[1] >= 74) {
                    match = userAgent.match(/Chrome\/(\d+)/);
                    if (match)
                      version = match[1];
                  }
                }
                module2.exports = version && +version;
              }
            ),
            /***/
            3837: (
              /***/
              function(module2) {
                module2.exports = [
                  "constructor",
                  "hasOwnProperty",
                  "isPrototypeOf",
                  "propertyIsEnumerable",
                  "toLocaleString",
                  "toString",
                  "valueOf"
                ];
              }
            ),
            /***/
            3103: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var global = __webpack_require__2(9859);
                var getOwnPropertyDescriptor = __webpack_require__2(7933).f;
                var createNonEnumerableProperty = __webpack_require__2(5762);
                var redefine = __webpack_require__2(7487);
                var setGlobal = __webpack_require__2(2079);
                var copyConstructorProperties = __webpack_require__2(7081);
                var isForced = __webpack_require__2(6541);
                module2.exports = function(options, source) {
                  var TARGET = options.target;
                  var GLOBAL = options.global;
                  var STATIC = options.stat;
                  var FORCED, target, key, targetProperty, sourceProperty, descriptor;
                  if (GLOBAL) {
                    target = global;
                  } else if (STATIC) {
                    target = global[TARGET] || setGlobal(TARGET, {});
                  } else {
                    target = (global[TARGET] || {}).prototype;
                  }
                  if (target)
                    for (key in source) {
                      sourceProperty = source[key];
                      if (options.noTargetGet) {
                        descriptor = getOwnPropertyDescriptor(target, key);
                        targetProperty = descriptor && descriptor.value;
                      } else
                        targetProperty = target[key];
                      FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? "." : "#") + key, options.forced);
                      if (!FORCED && targetProperty !== void 0) {
                        if (typeof sourceProperty === typeof targetProperty)
                          continue;
                        copyConstructorProperties(sourceProperty, targetProperty);
                      }
                      if (options.sham || targetProperty && targetProperty.sham) {
                        createNonEnumerableProperty(sourceProperty, "sham", true);
                      }
                      redefine(target, key, sourceProperty, options);
                    }
                };
              }
            ),
            /***/
            4229: (
              /***/
              function(module2) {
                module2.exports = function(exec) {
                  try {
                    return !!exec();
                  } catch (error) {
                    return true;
                  }
                };
              }
            ),
            /***/
            4954: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                __webpack_require__2(7950);
                var redefine = __webpack_require__2(7487);
                var fails = __webpack_require__2(4229);
                var wellKnownSymbol = __webpack_require__2(95);
                var createNonEnumerableProperty = __webpack_require__2(5762);
                var SPECIES = wellKnownSymbol("species");
                var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function() {
                  var re = /./;
                  re.exec = function() {
                    var result = [];
                    result.groups = { a: "7" };
                    return result;
                  };
                  return "".replace(re, "$<a>") !== "7";
                });
                var REPLACE_KEEPS_$0 = function() {
                  return "a".replace(/./, "$0") === "$0";
                }();
                var REPLACE = wellKnownSymbol("replace");
                var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = function() {
                  if (/./[REPLACE]) {
                    return /./[REPLACE]("a", "$0") === "";
                  }
                  return false;
                }();
                var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = !fails(function() {
                  var re = /(?:)/;
                  var originalExec = re.exec;
                  re.exec = function() {
                    return originalExec.apply(this, arguments);
                  };
                  var result = "ab".split(re);
                  return result.length !== 2 || result[0] !== "a" || result[1] !== "b";
                });
                module2.exports = function(KEY, length, exec, sham) {
                  var SYMBOL = wellKnownSymbol(KEY);
                  var DELEGATES_TO_SYMBOL = !fails(function() {
                    var O = {};
                    O[SYMBOL] = function() {
                      return 7;
                    };
                    return ""[KEY](O) != 7;
                  });
                  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails(function() {
                    var execCalled = false;
                    var re = /a/;
                    if (KEY === "split") {
                      re = {};
                      re.constructor = {};
                      re.constructor[SPECIES] = function() {
                        return re;
                      };
                      re.flags = "";
                      re[SYMBOL] = /./[SYMBOL];
                    }
                    re.exec = function() {
                      execCalled = true;
                      return null;
                    };
                    re[SYMBOL]("");
                    return !execCalled;
                  });
                  if (!DELEGATES_TO_SYMBOL || !DELEGATES_TO_EXEC || KEY === "replace" && !(REPLACE_SUPPORTS_NAMED_GROUPS && REPLACE_KEEPS_$0 && !REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE) || KEY === "split" && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC) {
                    var nativeRegExpMethod = /./[SYMBOL];
                    var methods = exec(SYMBOL, ""[KEY], function(nativeMethod, regexp, str, arg2, forceStringMethod) {
                      if (regexp.exec === RegExp.prototype.exec) {
                        if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
                          return { done: true, value: nativeRegExpMethod.call(regexp, str, arg2) };
                        }
                        return { done: true, value: nativeMethod.call(str, regexp, arg2) };
                      }
                      return { done: false };
                    }, {
                      REPLACE_KEEPS_$0,
                      REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE
                    });
                    var stringMethod = methods[0];
                    var regexMethod = methods[1];
                    redefine(String.prototype, KEY, stringMethod);
                    redefine(
                      RegExp.prototype,
                      SYMBOL,
                      length == 2 ? function(string, arg) {
                        return regexMethod.call(string, this, arg);
                      } : function(string) {
                        return regexMethod.call(string, this);
                      }
                    );
                  }
                  if (sham)
                    createNonEnumerableProperty(RegExp.prototype[SYMBOL], "sham", true);
                };
              }
            ),
            /***/
            4990: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var isArray = __webpack_require__2(3718);
                var toLength = __webpack_require__2(4237);
                var bind = __webpack_require__2(7636);
                var flattenIntoArray = function(target, original, source, sourceLen, start, depth, mapper, thisArg) {
                  var targetIndex = start;
                  var sourceIndex = 0;
                  var mapFn = mapper ? bind(mapper, thisArg, 3) : false;
                  var element;
                  while (sourceIndex < sourceLen) {
                    if (sourceIndex in source) {
                      element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];
                      if (depth > 0 && isArray(element)) {
                        targetIndex = flattenIntoArray(target, original, element, toLength(element.length), targetIndex, depth - 1) - 1;
                      } else {
                        if (targetIndex >= 9007199254740991)
                          throw TypeError("Exceed the acceptable array length");
                        target[targetIndex] = element;
                      }
                      targetIndex++;
                    }
                    sourceIndex++;
                  }
                  return targetIndex;
                };
                module2.exports = flattenIntoArray;
              }
            ),
            /***/
            8476: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var fails = __webpack_require__2(4229);
                module2.exports = !fails(function() {
                  return Object.isExtensible(Object.preventExtensions({}));
                });
              }
            ),
            /***/
            7636: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var aFunction = __webpack_require__2(3819);
                module2.exports = function(fn, that, length) {
                  aFunction(fn);
                  if (that === void 0)
                    return fn;
                  switch (length) {
                    case 0:
                      return function() {
                        return fn.call(that);
                      };
                    case 1:
                      return function(a) {
                        return fn.call(that, a);
                      };
                    case 2:
                      return function(a, b) {
                        return fn.call(that, a, b);
                      };
                    case 3:
                      return function(a, b, c) {
                        return fn.call(that, a, b, c);
                      };
                  }
                  return function() {
                    return fn.apply(that, arguments);
                  };
                };
              }
            ),
            /***/
            4128: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var aFunction = __webpack_require__2(3819);
                var isObject = __webpack_require__2(5052);
                var slice = [].slice;
                var factories = {};
                var construct = function(C, argsLength, args) {
                  if (!(argsLength in factories)) {
                    for (var list = [], i = 0; i < argsLength; i++)
                      list[i] = "a[" + i + "]";
                    factories[argsLength] = Function("C,a", "return new C(" + list.join(",") + ")");
                  }
                  return factories[argsLength](C, args);
                };
                module2.exports = Function.bind || function bind(that) {
                  var fn = aFunction(this);
                  var partArgs = slice.call(arguments, 1);
                  var boundFunction = function bound() {
                    var args = partArgs.concat(slice.call(arguments));
                    return this instanceof boundFunction ? construct(fn, args.length, args) : fn.apply(that, args);
                  };
                  if (isObject(fn.prototype))
                    boundFunction.prototype = fn.prototype;
                  return boundFunction;
                };
              }
            ),
            /***/
            1333: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var path = __webpack_require__2(9276);
                var global = __webpack_require__2(9859);
                var aFunction = function(variable) {
                  return typeof variable == "function" ? variable : void 0;
                };
                module2.exports = function(namespace, method) {
                  return arguments.length < 2 ? aFunction(path[namespace]) || aFunction(global[namespace]) : path[namespace] && path[namespace][method] || global[namespace] && global[namespace][method];
                };
              }
            ),
            /***/
            8830: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var classof = __webpack_require__2(1589);
                var Iterators = __webpack_require__2(5495);
                var wellKnownSymbol = __webpack_require__2(95);
                var ITERATOR = wellKnownSymbol("iterator");
                module2.exports = function(it) {
                  if (it != void 0)
                    return it[ITERATOR] || it["@@iterator"] || Iterators[classof(it)];
                };
              }
            ),
            /***/
            17: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var toObject = __webpack_require__2(2991);
                var floor = Math.floor;
                var replace = "".replace;
                var SUBSTITUTION_SYMBOLS = /\$([$&'`]|\d{1,2}|<[^>]*>)/g;
                var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&'`]|\d{1,2})/g;
                module2.exports = function(matched, str, position, captures, namedCaptures, replacement) {
                  var tailPos = position + matched.length;
                  var m = captures.length;
                  var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
                  if (namedCaptures !== void 0) {
                    namedCaptures = toObject(namedCaptures);
                    symbols = SUBSTITUTION_SYMBOLS;
                  }
                  return replace.call(replacement, symbols, function(match, ch) {
                    var capture;
                    switch (ch.charAt(0)) {
                      case "$":
                        return "$";
                      case "&":
                        return matched;
                      case "`":
                        return str.slice(0, position);
                      case "'":
                        return str.slice(tailPos);
                      case "<":
                        capture = namedCaptures[ch.slice(1, -1)];
                        break;
                      default:
                        var n = +ch;
                        if (n === 0)
                          return match;
                        if (n > m) {
                          var f = floor(n / 10);
                          if (f === 0)
                            return match;
                          if (f <= m)
                            return captures[f - 1] === void 0 ? ch.charAt(1) : captures[f - 1] + ch.charAt(1);
                          return match;
                        }
                        capture = captures[n - 1];
                    }
                    return capture === void 0 ? "" : capture;
                  });
                };
              }
            ),
            /***/
            9859: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var check = function(it) {
                  return it && it.Math == Math && it;
                };
                module2.exports = // eslint-disable-next-line es/no-global-this -- safe
                check(typeof globalThis == "object" && globalThis) || check(typeof window == "object" && window) || // eslint-disable-next-line no-restricted-globals -- safe
                check(typeof self == "object" && self) || check(typeof __webpack_require__2.g == "object" && __webpack_require__2.g) || // eslint-disable-next-line no-new-func -- fallback
                function() {
                  return this;
                }() || Function("return this")();
              }
            ),
            /***/
            816: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var toObject = __webpack_require__2(2991);
                var hasOwnProperty = {}.hasOwnProperty;
                module2.exports = function hasOwn(it, key) {
                  return hasOwnProperty.call(toObject(it), key);
                };
              }
            ),
            /***/
            5977: (
              /***/
              function(module2) {
                module2.exports = {};
              }
            ),
            /***/
            3777: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var getBuiltIn = __webpack_require__2(1333);
                module2.exports = getBuiltIn("document", "documentElement");
              }
            ),
            /***/
            4394: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var DESCRIPTORS = __webpack_require__2(7400);
                var fails = __webpack_require__2(4229);
                var createElement = __webpack_require__2(2635);
                module2.exports = !DESCRIPTORS && !fails(function() {
                  return Object.defineProperty(createElement("div"), "a", {
                    get: function() {
                      return 7;
                    }
                  }).a != 7;
                });
              }
            ),
            /***/
            6201: (
              /***/
              function(module2) {
                var abs = Math.abs;
                var pow = Math.pow;
                var floor = Math.floor;
                var log = Math.log;
                var LN2 = Math.LN2;
                var pack = function(number, mantissaLength, bytes) {
                  var buffer = new Array(bytes);
                  var exponentLength = bytes * 8 - mantissaLength - 1;
                  var eMax = (1 << exponentLength) - 1;
                  var eBias = eMax >> 1;
                  var rt = mantissaLength === 23 ? pow(2, -24) - pow(2, -77) : 0;
                  var sign = number < 0 || number === 0 && 1 / number < 0 ? 1 : 0;
                  var index = 0;
                  var exponent, mantissa, c;
                  number = abs(number);
                  if (number != number || number === Infinity) {
                    mantissa = number != number ? 1 : 0;
                    exponent = eMax;
                  } else {
                    exponent = floor(log(number) / LN2);
                    if (number * (c = pow(2, -exponent)) < 1) {
                      exponent--;
                      c *= 2;
                    }
                    if (exponent + eBias >= 1) {
                      number += rt / c;
                    } else {
                      number += rt * pow(2, 1 - eBias);
                    }
                    if (number * c >= 2) {
                      exponent++;
                      c /= 2;
                    }
                    if (exponent + eBias >= eMax) {
                      mantissa = 0;
                      exponent = eMax;
                    } else if (exponent + eBias >= 1) {
                      mantissa = (number * c - 1) * pow(2, mantissaLength);
                      exponent = exponent + eBias;
                    } else {
                      mantissa = number * pow(2, eBias - 1) * pow(2, mantissaLength);
                      exponent = 0;
                    }
                  }
                  for (; mantissaLength >= 8; buffer[index++] = mantissa & 255, mantissa /= 256, mantissaLength -= 8)
                    ;
                  exponent = exponent << mantissaLength | mantissa;
                  exponentLength += mantissaLength;
                  for (; exponentLength > 0; buffer[index++] = exponent & 255, exponent /= 256, exponentLength -= 8)
                    ;
                  buffer[--index] |= sign * 128;
                  return buffer;
                };
                var unpack = function(buffer, mantissaLength) {
                  var bytes = buffer.length;
                  var exponentLength = bytes * 8 - mantissaLength - 1;
                  var eMax = (1 << exponentLength) - 1;
                  var eBias = eMax >> 1;
                  var nBits = exponentLength - 7;
                  var index = bytes - 1;
                  var sign = buffer[index--];
                  var exponent = sign & 127;
                  var mantissa;
                  sign >>= 7;
                  for (; nBits > 0; exponent = exponent * 256 + buffer[index], index--, nBits -= 8)
                    ;
                  mantissa = exponent & (1 << -nBits) - 1;
                  exponent >>= -nBits;
                  nBits += mantissaLength;
                  for (; nBits > 0; mantissa = mantissa * 256 + buffer[index], index--, nBits -= 8)
                    ;
                  if (exponent === 0) {
                    exponent = 1 - eBias;
                  } else if (exponent === eMax) {
                    return mantissa ? NaN : sign ? -Infinity : Infinity;
                  } else {
                    mantissa = mantissa + pow(2, mantissaLength);
                    exponent = exponent - eBias;
                  }
                  return (sign ? -1 : 1) * mantissa * pow(2, exponent - mantissaLength);
                };
                module2.exports = {
                  pack,
                  unpack
                };
              }
            ),
            /***/
            9337: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var fails = __webpack_require__2(4229);
                var classof = __webpack_require__2(7079);
                var split = "".split;
                module2.exports = fails(function() {
                  return !Object("z").propertyIsEnumerable(0);
                }) ? function(it) {
                  return classof(it) == "String" ? split.call(it, "") : Object(it);
                } : Object;
              }
            ),
            /***/
            835: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var isObject = __webpack_require__2(5052);
                var setPrototypeOf = __webpack_require__2(6540);
                module2.exports = function($this, dummy, Wrapper) {
                  var NewTarget, NewTargetPrototype;
                  if (
                    // it can work only with native `setPrototypeOf`
                    setPrototypeOf && // we haven't completely correct pre-ES6 way for getting `new.target`, so use this
                    typeof (NewTarget = dummy.constructor) == "function" && NewTarget !== Wrapper && isObject(NewTargetPrototype = NewTarget.prototype) && NewTargetPrototype !== Wrapper.prototype
                  )
                    setPrototypeOf($this, NewTargetPrototype);
                  return $this;
                };
              }
            ),
            /***/
            8511: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var store = __webpack_require__2(5353);
                var functionToString = Function.toString;
                if (typeof store.inspectSource != "function") {
                  store.inspectSource = function(it) {
                    return functionToString.call(it);
                  };
                }
                module2.exports = store.inspectSource;
              }
            ),
            /***/
            5926: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var hiddenKeys = __webpack_require__2(5977);
                var isObject = __webpack_require__2(5052);
                var has = __webpack_require__2(816);
                var defineProperty = __webpack_require__2(1787).f;
                var uid = __webpack_require__2(1441);
                var FREEZING = __webpack_require__2(8476);
                var METADATA = uid("meta");
                var id = 0;
                var isExtensible = Object.isExtensible || function() {
                  return true;
                };
                var setMetadata = function(it) {
                  defineProperty(it, METADATA, { value: {
                    objectID: "O" + ++id,
                    // object ID
                    weakData: {}
                    // weak collections IDs
                  } });
                };
                var fastKey = function(it, create) {
                  if (!isObject(it))
                    return typeof it == "symbol" ? it : (typeof it == "string" ? "S" : "P") + it;
                  if (!has(it, METADATA)) {
                    if (!isExtensible(it))
                      return "F";
                    if (!create)
                      return "E";
                    setMetadata(it);
                  }
                  return it[METADATA].objectID;
                };
                var getWeakData = function(it, create) {
                  if (!has(it, METADATA)) {
                    if (!isExtensible(it))
                      return true;
                    if (!create)
                      return false;
                    setMetadata(it);
                  }
                  return it[METADATA].weakData;
                };
                var onFreeze = function(it) {
                  if (FREEZING && meta.REQUIRED && isExtensible(it) && !has(it, METADATA))
                    setMetadata(it);
                  return it;
                };
                var meta = module2.exports = {
                  REQUIRED: false,
                  fastKey,
                  getWeakData,
                  onFreeze
                };
                hiddenKeys[METADATA] = true;
              }
            ),
            /***/
            6407: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var NATIVE_WEAK_MAP = __webpack_require__2(8694);
                var global = __webpack_require__2(9859);
                var isObject = __webpack_require__2(5052);
                var createNonEnumerableProperty = __webpack_require__2(5762);
                var objectHas = __webpack_require__2(816);
                var shared = __webpack_require__2(5353);
                var sharedKey = __webpack_require__2(4399);
                var hiddenKeys = __webpack_require__2(5977);
                var OBJECT_ALREADY_INITIALIZED = "Object already initialized";
                var WeakMap = global.WeakMap;
                var set, get, has;
                var enforce = function(it) {
                  return has(it) ? get(it) : set(it, {});
                };
                var getterFor = function(TYPE) {
                  return function(it) {
                    var state;
                    if (!isObject(it) || (state = get(it)).type !== TYPE) {
                      throw TypeError("Incompatible receiver, " + TYPE + " required");
                    }
                    return state;
                  };
                };
                if (NATIVE_WEAK_MAP) {
                  var store = shared.state || (shared.state = new WeakMap());
                  var wmget = store.get;
                  var wmhas = store.has;
                  var wmset = store.set;
                  set = function(it, metadata) {
                    if (wmhas.call(store, it))
                      throw new TypeError(OBJECT_ALREADY_INITIALIZED);
                    metadata.facade = it;
                    wmset.call(store, it, metadata);
                    return metadata;
                  };
                  get = function(it) {
                    return wmget.call(store, it) || {};
                  };
                  has = function(it) {
                    return wmhas.call(store, it);
                  };
                } else {
                  var STATE = sharedKey("state");
                  hiddenKeys[STATE] = true;
                  set = function(it, metadata) {
                    if (objectHas(it, STATE))
                      throw new TypeError(OBJECT_ALREADY_INITIALIZED);
                    metadata.facade = it;
                    createNonEnumerableProperty(it, STATE, metadata);
                    return metadata;
                  };
                  get = function(it) {
                    return objectHas(it, STATE) ? it[STATE] : {};
                  };
                  has = function(it) {
                    return objectHas(it, STATE);
                  };
                }
                module2.exports = {
                  set,
                  get,
                  has,
                  enforce,
                  getterFor
                };
              }
            ),
            /***/
            1943: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var wellKnownSymbol = __webpack_require__2(95);
                var Iterators = __webpack_require__2(5495);
                var ITERATOR = wellKnownSymbol("iterator");
                var ArrayPrototype = Array.prototype;
                module2.exports = function(it) {
                  return it !== void 0 && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);
                };
              }
            ),
            /***/
            3718: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var classof = __webpack_require__2(7079);
                module2.exports = Array.isArray || function isArray(arg) {
                  return classof(arg) == "Array";
                };
              }
            ),
            /***/
            6541: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var fails = __webpack_require__2(4229);
                var replacement = /#|\.prototype\./;
                var isForced = function(feature, detection) {
                  var value = data[normalize(feature)];
                  return value == POLYFILL ? true : value == NATIVE ? false : typeof detection == "function" ? fails(detection) : !!detection;
                };
                var normalize = isForced.normalize = function(string) {
                  return String(string).replace(replacement, ".").toLowerCase();
                };
                var data = isForced.data = {};
                var NATIVE = isForced.NATIVE = "N";
                var POLYFILL = isForced.POLYFILL = "P";
                module2.exports = isForced;
              }
            ),
            /***/
            5052: (
              /***/
              function(module2) {
                module2.exports = function(it) {
                  return typeof it === "object" ? it !== null : typeof it === "function";
                };
              }
            ),
            /***/
            4231: (
              /***/
              function(module2) {
                module2.exports = false;
              }
            ),
            /***/
            8311: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var isObject = __webpack_require__2(5052);
                var classof = __webpack_require__2(7079);
                var wellKnownSymbol = __webpack_require__2(95);
                var MATCH = wellKnownSymbol("match");
                module2.exports = function(it) {
                  var isRegExp;
                  return isObject(it) && ((isRegExp = it[MATCH]) !== void 0 ? !!isRegExp : classof(it) == "RegExp");
                };
              }
            ),
            /***/
            9003: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var anObject = __webpack_require__2(1176);
                var isArrayIteratorMethod = __webpack_require__2(1943);
                var toLength = __webpack_require__2(4237);
                var bind = __webpack_require__2(7636);
                var getIteratorMethod = __webpack_require__2(8830);
                var iteratorClose = __webpack_require__2(7281);
                var Result = function(stopped, result) {
                  this.stopped = stopped;
                  this.result = result;
                };
                module2.exports = function(iterable, unboundFunction, options) {
                  var that = options && options.that;
                  var AS_ENTRIES = !!(options && options.AS_ENTRIES);
                  var IS_ITERATOR = !!(options && options.IS_ITERATOR);
                  var INTERRUPTED = !!(options && options.INTERRUPTED);
                  var fn = bind(unboundFunction, that, 1 + AS_ENTRIES + INTERRUPTED);
                  var iterator, iterFn, index, length, result, next, step;
                  var stop = function(condition) {
                    if (iterator)
                      iteratorClose(iterator);
                    return new Result(true, condition);
                  };
                  var callFn = function(value) {
                    if (AS_ENTRIES) {
                      anObject(value);
                      return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);
                    }
                    return INTERRUPTED ? fn(value, stop) : fn(value);
                  };
                  if (IS_ITERATOR) {
                    iterator = iterable;
                  } else {
                    iterFn = getIteratorMethod(iterable);
                    if (typeof iterFn != "function")
                      throw TypeError("Target is not iterable");
                    if (isArrayIteratorMethod(iterFn)) {
                      for (index = 0, length = toLength(iterable.length); length > index; index++) {
                        result = callFn(iterable[index]);
                        if (result && result instanceof Result)
                          return result;
                      }
                      return new Result(false);
                    }
                    iterator = iterFn.call(iterable);
                  }
                  next = iterator.next;
                  while (!(step = next.call(iterator)).done) {
                    try {
                      result = callFn(step.value);
                    } catch (error) {
                      iteratorClose(iterator);
                      throw error;
                    }
                    if (typeof result == "object" && result && result instanceof Result)
                      return result;
                  }
                  return new Result(false);
                };
              }
            ),
            /***/
            7281: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var anObject = __webpack_require__2(1176);
                module2.exports = function(iterator) {
                  var returnMethod = iterator["return"];
                  if (returnMethod !== void 0) {
                    return anObject(returnMethod.call(iterator)).value;
                  }
                };
              }
            ),
            /***/
            693: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var fails = __webpack_require__2(4229);
                var getPrototypeOf = __webpack_require__2(7567);
                var createNonEnumerableProperty = __webpack_require__2(5762);
                var has = __webpack_require__2(816);
                var wellKnownSymbol = __webpack_require__2(95);
                var IS_PURE = __webpack_require__2(4231);
                var ITERATOR = wellKnownSymbol("iterator");
                var BUGGY_SAFARI_ITERATORS = false;
                var returnThis = function() {
                  return this;
                };
                var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;
                if ([].keys) {
                  arrayIterator = [].keys();
                  if (!("next" in arrayIterator))
                    BUGGY_SAFARI_ITERATORS = true;
                  else {
                    PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));
                    if (PrototypeOfArrayIteratorPrototype !== Object.prototype)
                      IteratorPrototype = PrototypeOfArrayIteratorPrototype;
                  }
                }
                var NEW_ITERATOR_PROTOTYPE = IteratorPrototype == void 0 || fails(function() {
                  var test = {};
                  return IteratorPrototype[ITERATOR].call(test) !== test;
                });
                if (NEW_ITERATOR_PROTOTYPE)
                  IteratorPrototype = {};
                if ((!IS_PURE || NEW_ITERATOR_PROTOTYPE) && !has(IteratorPrototype, ITERATOR)) {
                  createNonEnumerableProperty(IteratorPrototype, ITERATOR, returnThis);
                }
                module2.exports = {
                  IteratorPrototype,
                  BUGGY_SAFARI_ITERATORS
                };
              }
            ),
            /***/
            5495: (
              /***/
              function(module2) {
                module2.exports = {};
              }
            ),
            /***/
            3839: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var IS_NODE = __webpack_require__2(8801);
                var V8_VERSION = __webpack_require__2(6358);
                var fails = __webpack_require__2(4229);
                module2.exports = !!Object.getOwnPropertySymbols && !fails(function() {
                  return !Symbol.sham && // Chrome 38 Symbol has incorrect toString conversion
                  // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
                  (IS_NODE ? V8_VERSION === 38 : V8_VERSION > 37 && V8_VERSION < 41);
                });
              }
            ),
            /***/
            8694: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var global = __webpack_require__2(9859);
                var inspectSource = __webpack_require__2(8511);
                var WeakMap = global.WeakMap;
                module2.exports = typeof WeakMap === "function" && /native code/.test(inspectSource(WeakMap));
              }
            ),
            /***/
            7272: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var isRegExp = __webpack_require__2(8311);
                module2.exports = function(it) {
                  if (isRegExp(it)) {
                    throw TypeError("The method doesn't accept regular expressions");
                  }
                  return it;
                };
              }
            ),
            /***/
            2391: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var anObject = __webpack_require__2(1176);
                var defineProperties = __webpack_require__2(219);
                var enumBugKeys = __webpack_require__2(3837);
                var hiddenKeys = __webpack_require__2(5977);
                var html = __webpack_require__2(3777);
                var documentCreateElement = __webpack_require__2(2635);
                var sharedKey = __webpack_require__2(4399);
                var GT = ">";
                var LT = "<";
                var PROTOTYPE = "prototype";
                var SCRIPT = "script";
                var IE_PROTO = sharedKey("IE_PROTO");
                var EmptyConstructor = function() {
                };
                var scriptTag = function(content) {
                  return LT + SCRIPT + GT + content + LT + "/" + SCRIPT + GT;
                };
                var NullProtoObjectViaActiveX = function(activeXDocument2) {
                  activeXDocument2.write(scriptTag(""));
                  activeXDocument2.close();
                  var temp = activeXDocument2.parentWindow.Object;
                  activeXDocument2 = null;
                  return temp;
                };
                var NullProtoObjectViaIFrame = function() {
                  var iframe = documentCreateElement("iframe");
                  var JS = "java" + SCRIPT + ":";
                  var iframeDocument;
                  iframe.style.display = "none";
                  html.appendChild(iframe);
                  iframe.src = String(JS);
                  iframeDocument = iframe.contentWindow.document;
                  iframeDocument.open();
                  iframeDocument.write(scriptTag("document.F=Object"));
                  iframeDocument.close();
                  return iframeDocument.F;
                };
                var activeXDocument;
                var NullProtoObject = function() {
                  try {
                    activeXDocument = document.domain && new ActiveXObject("htmlfile");
                  } catch (error) {
                  }
                  NullProtoObject = activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame();
                  var length = enumBugKeys.length;
                  while (length--)
                    delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
                  return NullProtoObject();
                };
                hiddenKeys[IE_PROTO] = true;
                module2.exports = Object.create || function create(O, Properties) {
                  var result;
                  if (O !== null) {
                    EmptyConstructor[PROTOTYPE] = anObject(O);
                    result = new EmptyConstructor();
                    EmptyConstructor[PROTOTYPE] = null;
                    result[IE_PROTO] = O;
                  } else
                    result = NullProtoObject();
                  return Properties === void 0 ? result : defineProperties(result, Properties);
                };
              }
            ),
            /***/
            219: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var DESCRIPTORS = __webpack_require__2(7400);
                var definePropertyModule = __webpack_require__2(1787);
                var anObject = __webpack_require__2(1176);
                var objectKeys = __webpack_require__2(5632);
                module2.exports = DESCRIPTORS ? Object.defineProperties : function defineProperties(O, Properties) {
                  anObject(O);
                  var keys = objectKeys(Properties);
                  var length = keys.length;
                  var index = 0;
                  var key;
                  while (length > index)
                    definePropertyModule.f(O, key = keys[index++], Properties[key]);
                  return O;
                };
              }
            ),
            /***/
            1787: (
              /***/
              function(__unused_webpack_module, exports2, __webpack_require__2) {
                var DESCRIPTORS = __webpack_require__2(7400);
                var IE8_DOM_DEFINE = __webpack_require__2(4394);
                var anObject = __webpack_require__2(1176);
                var toPrimitive = __webpack_require__2(2066);
                var $defineProperty = Object.defineProperty;
                exports2.f = DESCRIPTORS ? $defineProperty : function defineProperty(O, P, Attributes) {
                  anObject(O);
                  P = toPrimitive(P, true);
                  anObject(Attributes);
                  if (IE8_DOM_DEFINE)
                    try {
                      return $defineProperty(O, P, Attributes);
                    } catch (error) {
                    }
                  if ("get" in Attributes || "set" in Attributes)
                    throw TypeError("Accessors not supported");
                  if ("value" in Attributes)
                    O[P] = Attributes.value;
                  return O;
                };
              }
            ),
            /***/
            7933: (
              /***/
              function(__unused_webpack_module, exports2, __webpack_require__2) {
                var DESCRIPTORS = __webpack_require__2(7400);
                var propertyIsEnumerableModule = __webpack_require__2(9195);
                var createPropertyDescriptor = __webpack_require__2(5358);
                var toIndexedObject = __webpack_require__2(905);
                var toPrimitive = __webpack_require__2(2066);
                var has = __webpack_require__2(816);
                var IE8_DOM_DEFINE = __webpack_require__2(4394);
                var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
                exports2.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
                  O = toIndexedObject(O);
                  P = toPrimitive(P, true);
                  if (IE8_DOM_DEFINE)
                    try {
                      return $getOwnPropertyDescriptor(O, P);
                    } catch (error) {
                    }
                  if (has(O, P))
                    return createPropertyDescriptor(!propertyIsEnumerableModule.f.call(O, P), O[P]);
                };
              }
            ),
            /***/
            166: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var toIndexedObject = __webpack_require__2(905);
                var $getOwnPropertyNames = __webpack_require__2(8151).f;
                var toString = {}.toString;
                var windowNames = typeof window == "object" && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
                var getWindowNames = function(it) {
                  try {
                    return $getOwnPropertyNames(it);
                  } catch (error) {
                    return windowNames.slice();
                  }
                };
                module2.exports.f = function getOwnPropertyNames(it) {
                  return windowNames && toString.call(it) == "[object Window]" ? getWindowNames(it) : $getOwnPropertyNames(toIndexedObject(it));
                };
              }
            ),
            /***/
            8151: (
              /***/
              function(__unused_webpack_module, exports2, __webpack_require__2) {
                var internalObjectKeys = __webpack_require__2(140);
                var enumBugKeys = __webpack_require__2(3837);
                var hiddenKeys = enumBugKeys.concat("length", "prototype");
                exports2.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
                  return internalObjectKeys(O, hiddenKeys);
                };
              }
            ),
            /***/
            894: (
              /***/
              function(__unused_webpack_module, exports2) {
                exports2.f = Object.getOwnPropertySymbols;
              }
            ),
            /***/
            7567: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var has = __webpack_require__2(816);
                var toObject = __webpack_require__2(2991);
                var sharedKey = __webpack_require__2(4399);
                var CORRECT_PROTOTYPE_GETTER = __webpack_require__2(7528);
                var IE_PROTO = sharedKey("IE_PROTO");
                var ObjectPrototype = Object.prototype;
                module2.exports = CORRECT_PROTOTYPE_GETTER ? Object.getPrototypeOf : function(O) {
                  O = toObject(O);
                  if (has(O, IE_PROTO))
                    return O[IE_PROTO];
                  if (typeof O.constructor == "function" && O instanceof O.constructor) {
                    return O.constructor.prototype;
                  }
                  return O instanceof Object ? ObjectPrototype : null;
                };
              }
            ),
            /***/
            140: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var has = __webpack_require__2(816);
                var toIndexedObject = __webpack_require__2(905);
                var indexOf = __webpack_require__2(9540).indexOf;
                var hiddenKeys = __webpack_require__2(5977);
                module2.exports = function(object, names) {
                  var O = toIndexedObject(object);
                  var i = 0;
                  var result = [];
                  var key;
                  for (key in O)
                    !has(hiddenKeys, key) && has(O, key) && result.push(key);
                  while (names.length > i)
                    if (has(O, key = names[i++])) {
                      ~indexOf(result, key) || result.push(key);
                    }
                  return result;
                };
              }
            ),
            /***/
            5632: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var internalObjectKeys = __webpack_require__2(140);
                var enumBugKeys = __webpack_require__2(3837);
                module2.exports = Object.keys || function keys(O) {
                  return internalObjectKeys(O, enumBugKeys);
                };
              }
            ),
            /***/
            9195: (
              /***/
              function(__unused_webpack_module, exports2) {
                "use strict";
                var $propertyIsEnumerable = {}.propertyIsEnumerable;
                var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
                var NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);
                exports2.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
                  var descriptor = getOwnPropertyDescriptor(this, V);
                  return !!descriptor && descriptor.enumerable;
                } : $propertyIsEnumerable;
              }
            ),
            /***/
            6540: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var anObject = __webpack_require__2(1176);
                var aPossiblePrototype = __webpack_require__2(8505);
                module2.exports = Object.setPrototypeOf || ("__proto__" in {} ? function() {
                  var CORRECT_SETTER = false;
                  var test = {};
                  var setter;
                  try {
                    setter = Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set;
                    setter.call(test, []);
                    CORRECT_SETTER = test instanceof Array;
                  } catch (error) {
                  }
                  return function setPrototypeOf(O, proto) {
                    anObject(O);
                    aPossiblePrototype(proto);
                    if (CORRECT_SETTER)
                      setter.call(O, proto);
                    else
                      O.__proto__ = proto;
                    return O;
                  };
                }() : void 0);
              }
            ),
            /***/
            7664: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var DESCRIPTORS = __webpack_require__2(7400);
                var objectKeys = __webpack_require__2(5632);
                var toIndexedObject = __webpack_require__2(905);
                var propertyIsEnumerable = __webpack_require__2(9195).f;
                var createMethod = function(TO_ENTRIES) {
                  return function(it) {
                    var O = toIndexedObject(it);
                    var keys = objectKeys(O);
                    var length = keys.length;
                    var i = 0;
                    var result = [];
                    var key;
                    while (length > i) {
                      key = keys[i++];
                      if (!DESCRIPTORS || propertyIsEnumerable.call(O, key)) {
                        result.push(TO_ENTRIES ? [key, O[key]] : O[key]);
                      }
                    }
                    return result;
                  };
                };
                module2.exports = {
                  // `Object.entries` method
                  // https://tc39.es/ecma262/#sec-object.entries
                  entries: createMethod(true),
                  // `Object.values` method
                  // https://tc39.es/ecma262/#sec-object.values
                  values: createMethod(false)
                };
              }
            ),
            /***/
            4059: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var TO_STRING_TAG_SUPPORT = __webpack_require__2(1601);
                var classof = __webpack_require__2(1589);
                module2.exports = TO_STRING_TAG_SUPPORT ? {}.toString : function toString() {
                  return "[object " + classof(this) + "]";
                };
              }
            ),
            /***/
            4826: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var getBuiltIn = __webpack_require__2(1333);
                var getOwnPropertyNamesModule = __webpack_require__2(8151);
                var getOwnPropertySymbolsModule = __webpack_require__2(894);
                var anObject = __webpack_require__2(1176);
                module2.exports = getBuiltIn("Reflect", "ownKeys") || function ownKeys(it) {
                  var keys = getOwnPropertyNamesModule.f(anObject(it));
                  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
                  return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;
                };
              }
            ),
            /***/
            9276: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var global = __webpack_require__2(9859);
                module2.exports = global;
              }
            ),
            /***/
            8787: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var redefine = __webpack_require__2(7487);
                module2.exports = function(target, src, options) {
                  for (var key in src)
                    redefine(target, key, src[key], options);
                  return target;
                };
              }
            ),
            /***/
            7487: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var global = __webpack_require__2(9859);
                var createNonEnumerableProperty = __webpack_require__2(5762);
                var has = __webpack_require__2(816);
                var setGlobal = __webpack_require__2(2079);
                var inspectSource = __webpack_require__2(8511);
                var InternalStateModule = __webpack_require__2(6407);
                var getInternalState = InternalStateModule.get;
                var enforceInternalState = InternalStateModule.enforce;
                var TEMPLATE = String(String).split("String");
                (module2.exports = function(O, key, value, options) {
                  var unsafe = options ? !!options.unsafe : false;
                  var simple = options ? !!options.enumerable : false;
                  var noTargetGet = options ? !!options.noTargetGet : false;
                  var state;
                  if (typeof value == "function") {
                    if (typeof key == "string" && !has(value, "name")) {
                      createNonEnumerableProperty(value, "name", key);
                    }
                    state = enforceInternalState(value);
                    if (!state.source) {
                      state.source = TEMPLATE.join(typeof key == "string" ? key : "");
                    }
                  }
                  if (O === global) {
                    if (simple)
                      O[key] = value;
                    else
                      setGlobal(key, value);
                    return;
                  } else if (!unsafe) {
                    delete O[key];
                  } else if (!noTargetGet && O[key]) {
                    simple = true;
                  }
                  if (simple)
                    O[key] = value;
                  else
                    createNonEnumerableProperty(O, key, value);
                })(Function.prototype, "toString", function toString() {
                  return typeof this == "function" && getInternalState(this).source || inspectSource(this);
                });
              }
            ),
            /***/
            8115: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var classof = __webpack_require__2(7079);
                var regexpExec = __webpack_require__2(3466);
                module2.exports = function(R, S) {
                  var exec = R.exec;
                  if (typeof exec === "function") {
                    var result = exec.call(R, S);
                    if (typeof result !== "object") {
                      throw TypeError("RegExp exec method returned something other than an Object or null");
                    }
                    return result;
                  }
                  if (classof(R) !== "RegExp") {
                    throw TypeError("RegExp#exec called on incompatible receiver");
                  }
                  return regexpExec.call(R, S);
                };
              }
            ),
            /***/
            3466: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var regexpFlags = __webpack_require__2(895);
                var stickyHelpers = __webpack_require__2(5650);
                var shared = __webpack_require__2(3036);
                var nativeExec = RegExp.prototype.exec;
                var nativeReplace = shared("native-string-replace", String.prototype.replace);
                var patchedExec = nativeExec;
                var UPDATES_LAST_INDEX_WRONG = function() {
                  var re1 = /a/;
                  var re2 = /b*/g;
                  nativeExec.call(re1, "a");
                  nativeExec.call(re2, "a");
                  return re1.lastIndex !== 0 || re2.lastIndex !== 0;
                }();
                var UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y || stickyHelpers.BROKEN_CARET;
                var NPCG_INCLUDED = /()??/.exec("")[1] !== void 0;
                var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y;
                if (PATCH) {
                  patchedExec = function exec(str) {
                    var re = this;
                    var lastIndex, reCopy, match, i;
                    var sticky = UNSUPPORTED_Y && re.sticky;
                    var flags = regexpFlags.call(re);
                    var source = re.source;
                    var charsAdded = 0;
                    var strCopy = str;
                    if (sticky) {
                      flags = flags.replace("y", "");
                      if (flags.indexOf("g") === -1) {
                        flags += "g";
                      }
                      strCopy = String(str).slice(re.lastIndex);
                      if (re.lastIndex > 0 && (!re.multiline || re.multiline && str[re.lastIndex - 1] !== "\n")) {
                        source = "(?: " + source + ")";
                        strCopy = " " + strCopy;
                        charsAdded++;
                      }
                      reCopy = new RegExp("^(?:" + source + ")", flags);
                    }
                    if (NPCG_INCLUDED) {
                      reCopy = new RegExp("^" + source + "$(?!\\s)", flags);
                    }
                    if (UPDATES_LAST_INDEX_WRONG)
                      lastIndex = re.lastIndex;
                    match = nativeExec.call(sticky ? reCopy : re, strCopy);
                    if (sticky) {
                      if (match) {
                        match.input = match.input.slice(charsAdded);
                        match[0] = match[0].slice(charsAdded);
                        match.index = re.lastIndex;
                        re.lastIndex += match[0].length;
                      } else
                        re.lastIndex = 0;
                    } else if (UPDATES_LAST_INDEX_WRONG && match) {
                      re.lastIndex = re.global ? match.index + match[0].length : lastIndex;
                    }
                    if (NPCG_INCLUDED && match && match.length > 1) {
                      nativeReplace.call(match[0], reCopy, function() {
                        for (i = 1; i < arguments.length - 2; i++) {
                          if (arguments[i] === void 0)
                            match[i] = void 0;
                        }
                      });
                    }
                    return match;
                  };
                }
                module2.exports = patchedExec;
              }
            ),
            /***/
            895: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var anObject = __webpack_require__2(1176);
                module2.exports = function() {
                  var that = anObject(this);
                  var result = "";
                  if (that.global)
                    result += "g";
                  if (that.ignoreCase)
                    result += "i";
                  if (that.multiline)
                    result += "m";
                  if (that.dotAll)
                    result += "s";
                  if (that.unicode)
                    result += "u";
                  if (that.sticky)
                    result += "y";
                  return result;
                };
              }
            ),
            /***/
            5650: (
              /***/
              function(__unused_webpack_module, exports2, __webpack_require__2) {
                "use strict";
                var fails = __webpack_require__2(4229);
                function RE(s, f) {
                  return RegExp(s, f);
                }
                exports2.UNSUPPORTED_Y = fails(function() {
                  var re = RE("a", "y");
                  re.lastIndex = 2;
                  return re.exec("abcd") != null;
                });
                exports2.BROKEN_CARET = fails(function() {
                  var re = RE("^r", "gy");
                  re.lastIndex = 2;
                  return re.exec("str") != null;
                });
              }
            ),
            /***/
            8885: (
              /***/
              function(module2) {
                module2.exports = function(it) {
                  if (it == void 0)
                    throw TypeError("Can't call method on " + it);
                  return it;
                };
              }
            ),
            /***/
            2079: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var global = __webpack_require__2(9859);
                var createNonEnumerableProperty = __webpack_require__2(5762);
                module2.exports = function(key, value) {
                  try {
                    createNonEnumerableProperty(global, key, value);
                  } catch (error) {
                    global[key] = value;
                  }
                  return value;
                };
              }
            ),
            /***/
            1832: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var getBuiltIn = __webpack_require__2(1333);
                var definePropertyModule = __webpack_require__2(1787);
                var wellKnownSymbol = __webpack_require__2(95);
                var DESCRIPTORS = __webpack_require__2(7400);
                var SPECIES = wellKnownSymbol("species");
                module2.exports = function(CONSTRUCTOR_NAME) {
                  var Constructor = getBuiltIn(CONSTRUCTOR_NAME);
                  var defineProperty = definePropertyModule.f;
                  if (DESCRIPTORS && Constructor && !Constructor[SPECIES]) {
                    defineProperty(Constructor, SPECIES, {
                      configurable: true,
                      get: function() {
                        return this;
                      }
                    });
                  }
                };
              }
            ),
            /***/
            4555: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var defineProperty = __webpack_require__2(1787).f;
                var has = __webpack_require__2(816);
                var wellKnownSymbol = __webpack_require__2(95);
                var TO_STRING_TAG = wellKnownSymbol("toStringTag");
                module2.exports = function(it, TAG, STATIC) {
                  if (it && !has(it = STATIC ? it : it.prototype, TO_STRING_TAG)) {
                    defineProperty(it, TO_STRING_TAG, { configurable: true, value: TAG });
                  }
                };
              }
            ),
            /***/
            4399: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var shared = __webpack_require__2(3036);
                var uid = __webpack_require__2(1441);
                var keys = shared("keys");
                module2.exports = function(key) {
                  return keys[key] || (keys[key] = uid(key));
                };
              }
            ),
            /***/
            5353: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var global = __webpack_require__2(9859);
                var setGlobal = __webpack_require__2(2079);
                var SHARED = "__core-js_shared__";
                var store = global[SHARED] || setGlobal(SHARED, {});
                module2.exports = store;
              }
            ),
            /***/
            3036: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var IS_PURE = __webpack_require__2(4231);
                var store = __webpack_require__2(5353);
                (module2.exports = function(key, value) {
                  return store[key] || (store[key] = value !== void 0 ? value : {});
                })("versions", []).push({
                  version: "3.11.3",
                  mode: IS_PURE ? "pure" : "global",
                  copyright: " 2021 Denis Pushkarev (zloirock.ru)"
                });
              }
            ),
            /***/
            7942: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var anObject = __webpack_require__2(1176);
                var aFunction = __webpack_require__2(3819);
                var wellKnownSymbol = __webpack_require__2(95);
                var SPECIES = wellKnownSymbol("species");
                module2.exports = function(O, defaultConstructor) {
                  var C = anObject(O).constructor;
                  var S;
                  return C === void 0 || (S = anObject(C)[SPECIES]) == void 0 ? defaultConstructor : aFunction(S);
                };
              }
            ),
            /***/
            3689: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var fails = __webpack_require__2(4229);
                module2.exports = function(METHOD_NAME) {
                  return fails(function() {
                    var test = ""[METHOD_NAME]('"');
                    return test !== test.toLowerCase() || test.split('"').length > 3;
                  });
                };
              }
            ),
            /***/
            966: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var toInteger = __webpack_require__2(6051);
                var requireObjectCoercible = __webpack_require__2(8885);
                var createMethod = function(CONVERT_TO_STRING) {
                  return function($this, pos) {
                    var S = String(requireObjectCoercible($this));
                    var position = toInteger(pos);
                    var size = S.length;
                    var first, second;
                    if (position < 0 || position >= size)
                      return CONVERT_TO_STRING ? "" : void 0;
                    first = S.charCodeAt(position);
                    return first < 55296 || first > 56319 || position + 1 === size || (second = S.charCodeAt(position + 1)) < 56320 || second > 57343 ? CONVERT_TO_STRING ? S.charAt(position) : first : CONVERT_TO_STRING ? S.slice(position, position + 2) : (first - 55296 << 10) + (second - 56320) + 65536;
                  };
                };
                module2.exports = {
                  // `String.prototype.codePointAt` method
                  // https://tc39.es/ecma262/#sec-string.prototype.codepointat
                  codeAt: createMethod(false),
                  // `String.prototype.at` method
                  // https://github.com/mathiasbynens/String.prototype.at
                  charAt: createMethod(true)
                };
              }
            ),
            /***/
            3124: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var toInteger = __webpack_require__2(6051);
                var requireObjectCoercible = __webpack_require__2(8885);
                module2.exports = function repeat(count) {
                  var str = String(requireObjectCoercible(this));
                  var result = "";
                  var n = toInteger(count);
                  if (n < 0 || n == Infinity)
                    throw RangeError("Wrong number of repetitions");
                  for (; n > 0; (n >>>= 1) && (str += str))
                    if (n & 1)
                      result += str;
                  return result;
                };
              }
            ),
            /***/
            1017: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var requireObjectCoercible = __webpack_require__2(8885);
                var whitespaces = __webpack_require__2(1647);
                var whitespace = "[" + whitespaces + "]";
                var ltrim = RegExp("^" + whitespace + whitespace + "*");
                var rtrim = RegExp(whitespace + whitespace + "*$");
                var createMethod = function(TYPE) {
                  return function($this) {
                    var string = String(requireObjectCoercible($this));
                    if (TYPE & 1)
                      string = string.replace(ltrim, "");
                    if (TYPE & 2)
                      string = string.replace(rtrim, "");
                    return string;
                  };
                };
                module2.exports = {
                  // `String.prototype.{ trimLeft, trimStart }` methods
                  // https://tc39.es/ecma262/#sec-string.prototype.trimstart
                  start: createMethod(1),
                  // `String.prototype.{ trimRight, trimEnd }` methods
                  // https://tc39.es/ecma262/#sec-string.prototype.trimend
                  end: createMethod(2),
                  // `String.prototype.trim` method
                  // https://tc39.es/ecma262/#sec-string.prototype.trim
                  trim: createMethod(3)
                };
              }
            ),
            /***/
            143: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var classof = __webpack_require__2(7079);
                module2.exports = function(value) {
                  if (typeof value != "number" && classof(value) != "Number") {
                    throw TypeError("Incorrect invocation");
                  }
                  return +value;
                };
              }
            ),
            /***/
            3231: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var toInteger = __webpack_require__2(6051);
                var max = Math.max;
                var min = Math.min;
                module2.exports = function(index, length) {
                  var integer = toInteger(index);
                  return integer < 0 ? max(integer + length, 0) : min(integer, length);
                };
              }
            ),
            /***/
            7331: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var toInteger = __webpack_require__2(6051);
                var toLength = __webpack_require__2(4237);
                module2.exports = function(it) {
                  if (it === void 0)
                    return 0;
                  var number = toInteger(it);
                  var length = toLength(number);
                  if (number !== length)
                    throw RangeError("Wrong length or index");
                  return length;
                };
              }
            ),
            /***/
            905: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var IndexedObject = __webpack_require__2(9337);
                var requireObjectCoercible = __webpack_require__2(8885);
                module2.exports = function(it) {
                  return IndexedObject(requireObjectCoercible(it));
                };
              }
            ),
            /***/
            6051: (
              /***/
              function(module2) {
                var ceil = Math.ceil;
                var floor = Math.floor;
                module2.exports = function(argument) {
                  return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument);
                };
              }
            ),
            /***/
            4237: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var toInteger = __webpack_require__2(6051);
                var min = Math.min;
                module2.exports = function(argument) {
                  return argument > 0 ? min(toInteger(argument), 9007199254740991) : 0;
                };
              }
            ),
            /***/
            2991: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var requireObjectCoercible = __webpack_require__2(8885);
                module2.exports = function(argument) {
                  return Object(requireObjectCoercible(argument));
                };
              }
            ),
            /***/
            4262: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var toPositiveInteger = __webpack_require__2(2002);
                module2.exports = function(it, BYTES) {
                  var offset = toPositiveInteger(it);
                  if (offset % BYTES)
                    throw RangeError("Wrong offset");
                  return offset;
                };
              }
            ),
            /***/
            2002: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var toInteger = __webpack_require__2(6051);
                module2.exports = function(it) {
                  var result = toInteger(it);
                  if (result < 0)
                    throw RangeError("The argument can't be less than 0");
                  return result;
                };
              }
            ),
            /***/
            2066: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var isObject = __webpack_require__2(5052);
                module2.exports = function(input, PREFERRED_STRING) {
                  if (!isObject(input))
                    return input;
                  var fn, val;
                  if (PREFERRED_STRING && typeof (fn = input.toString) == "function" && !isObject(val = fn.call(input)))
                    return val;
                  if (typeof (fn = input.valueOf) == "function" && !isObject(val = fn.call(input)))
                    return val;
                  if (!PREFERRED_STRING && typeof (fn = input.toString) == "function" && !isObject(val = fn.call(input)))
                    return val;
                  throw TypeError("Can't convert object to primitive value");
                };
              }
            ),
            /***/
            1601: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var wellKnownSymbol = __webpack_require__2(95);
                var TO_STRING_TAG = wellKnownSymbol("toStringTag");
                var test = {};
                test[TO_STRING_TAG] = "z";
                module2.exports = String(test) === "[object z]";
              }
            ),
            /***/
            2574: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var $ = __webpack_require__2(3103);
                var global = __webpack_require__2(9859);
                var DESCRIPTORS = __webpack_require__2(7400);
                var TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS = __webpack_require__2(8200);
                var ArrayBufferViewCore = __webpack_require__2(9918);
                var ArrayBufferModule = __webpack_require__2(3816);
                var anInstance = __webpack_require__2(7728);
                var createPropertyDescriptor = __webpack_require__2(5358);
                var createNonEnumerableProperty = __webpack_require__2(5762);
                var toLength = __webpack_require__2(4237);
                var toIndex = __webpack_require__2(7331);
                var toOffset = __webpack_require__2(4262);
                var toPrimitive = __webpack_require__2(2066);
                var has = __webpack_require__2(816);
                var classof = __webpack_require__2(1589);
                var isObject = __webpack_require__2(5052);
                var create = __webpack_require__2(2391);
                var setPrototypeOf = __webpack_require__2(6540);
                var getOwnPropertyNames = __webpack_require__2(8151).f;
                var typedArrayFrom = __webpack_require__2(5215);
                var forEach = __webpack_require__2(9996).forEach;
                var setSpecies = __webpack_require__2(1832);
                var definePropertyModule = __webpack_require__2(1787);
                var getOwnPropertyDescriptorModule = __webpack_require__2(7933);
                var InternalStateModule = __webpack_require__2(6407);
                var inheritIfRequired = __webpack_require__2(835);
                var getInternalState = InternalStateModule.get;
                var setInternalState = InternalStateModule.set;
                var nativeDefineProperty = definePropertyModule.f;
                var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
                var round = Math.round;
                var RangeError2 = global.RangeError;
                var ArrayBuffer2 = ArrayBufferModule.ArrayBuffer;
                var DataView2 = ArrayBufferModule.DataView;
                var NATIVE_ARRAY_BUFFER_VIEWS = ArrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS;
                var TYPED_ARRAY_TAG = ArrayBufferViewCore.TYPED_ARRAY_TAG;
                var TypedArray = ArrayBufferViewCore.TypedArray;
                var TypedArrayPrototype = ArrayBufferViewCore.TypedArrayPrototype;
                var aTypedArrayConstructor = ArrayBufferViewCore.aTypedArrayConstructor;
                var isTypedArray = ArrayBufferViewCore.isTypedArray;
                var BYTES_PER_ELEMENT = "BYTES_PER_ELEMENT";
                var WRONG_LENGTH = "Wrong length";
                var fromList = function(C, list) {
                  var index = 0;
                  var length = list.length;
                  var result = new (aTypedArrayConstructor(C))(length);
                  while (length > index)
                    result[index] = list[index++];
                  return result;
                };
                var addGetter = function(it, key) {
                  nativeDefineProperty(it, key, { get: function() {
                    return getInternalState(this)[key];
                  } });
                };
                var isArrayBuffer = function(it) {
                  var klass;
                  return it instanceof ArrayBuffer2 || (klass = classof(it)) == "ArrayBuffer" || klass == "SharedArrayBuffer";
                };
                var isTypedArrayIndex = function(target, key) {
                  return isTypedArray(target) && typeof key != "symbol" && key in target && String(+key) == String(key);
                };
                var wrappedGetOwnPropertyDescriptor = function getOwnPropertyDescriptor(target, key) {
                  return isTypedArrayIndex(target, key = toPrimitive(key, true)) ? createPropertyDescriptor(2, target[key]) : nativeGetOwnPropertyDescriptor(target, key);
                };
                var wrappedDefineProperty = function defineProperty(target, key, descriptor) {
                  if (isTypedArrayIndex(target, key = toPrimitive(key, true)) && isObject(descriptor) && has(descriptor, "value") && !has(descriptor, "get") && !has(descriptor, "set") && !descriptor.configurable && (!has(descriptor, "writable") || descriptor.writable) && (!has(descriptor, "enumerable") || descriptor.enumerable)) {
                    target[key] = descriptor.value;
                    return target;
                  }
                  return nativeDefineProperty(target, key, descriptor);
                };
                if (DESCRIPTORS) {
                  if (!NATIVE_ARRAY_BUFFER_VIEWS) {
                    getOwnPropertyDescriptorModule.f = wrappedGetOwnPropertyDescriptor;
                    definePropertyModule.f = wrappedDefineProperty;
                    addGetter(TypedArrayPrototype, "buffer");
                    addGetter(TypedArrayPrototype, "byteOffset");
                    addGetter(TypedArrayPrototype, "byteLength");
                    addGetter(TypedArrayPrototype, "length");
                  }
                  $({ target: "Object", stat: true, forced: !NATIVE_ARRAY_BUFFER_VIEWS }, {
                    getOwnPropertyDescriptor: wrappedGetOwnPropertyDescriptor,
                    defineProperty: wrappedDefineProperty
                  });
                  module2.exports = function(TYPE, wrapper, CLAMPED) {
                    var BYTES = TYPE.match(/\d+$/)[0] / 8;
                    var CONSTRUCTOR_NAME = TYPE + (CLAMPED ? "Clamped" : "") + "Array";
                    var GETTER = "get" + TYPE;
                    var SETTER = "set" + TYPE;
                    var NativeTypedArrayConstructor = global[CONSTRUCTOR_NAME];
                    var TypedArrayConstructor = NativeTypedArrayConstructor;
                    var TypedArrayConstructorPrototype = TypedArrayConstructor && TypedArrayConstructor.prototype;
                    var exported = {};
                    var getter = function(that, index) {
                      var data = getInternalState(that);
                      return data.view[GETTER](index * BYTES + data.byteOffset, true);
                    };
                    var setter = function(that, index, value) {
                      var data = getInternalState(that);
                      if (CLAMPED)
                        value = (value = round(value)) < 0 ? 0 : value > 255 ? 255 : value & 255;
                      data.view[SETTER](index * BYTES + data.byteOffset, value, true);
                    };
                    var addElement = function(that, index) {
                      nativeDefineProperty(that, index, {
                        get: function() {
                          return getter(this, index);
                        },
                        set: function(value) {
                          return setter(this, index, value);
                        },
                        enumerable: true
                      });
                    };
                    if (!NATIVE_ARRAY_BUFFER_VIEWS) {
                      TypedArrayConstructor = wrapper(function(that, data, offset, $length) {
                        anInstance(that, TypedArrayConstructor, CONSTRUCTOR_NAME);
                        var index = 0;
                        var byteOffset = 0;
                        var buffer, byteLength, length;
                        if (!isObject(data)) {
                          length = toIndex(data);
                          byteLength = length * BYTES;
                          buffer = new ArrayBuffer2(byteLength);
                        } else if (isArrayBuffer(data)) {
                          buffer = data;
                          byteOffset = toOffset(offset, BYTES);
                          var $len = data.byteLength;
                          if ($length === void 0) {
                            if ($len % BYTES)
                              throw RangeError2(WRONG_LENGTH);
                            byteLength = $len - byteOffset;
                            if (byteLength < 0)
                              throw RangeError2(WRONG_LENGTH);
                          } else {
                            byteLength = toLength($length) * BYTES;
                            if (byteLength + byteOffset > $len)
                              throw RangeError2(WRONG_LENGTH);
                          }
                          length = byteLength / BYTES;
                        } else if (isTypedArray(data)) {
                          return fromList(TypedArrayConstructor, data);
                        } else {
                          return typedArrayFrom.call(TypedArrayConstructor, data);
                        }
                        setInternalState(that, {
                          buffer,
                          byteOffset,
                          byteLength,
                          length,
                          view: new DataView2(buffer)
                        });
                        while (index < length)
                          addElement(that, index++);
                      });
                      if (setPrototypeOf)
                        setPrototypeOf(TypedArrayConstructor, TypedArray);
                      TypedArrayConstructorPrototype = TypedArrayConstructor.prototype = create(TypedArrayPrototype);
                    } else if (TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS) {
                      TypedArrayConstructor = wrapper(function(dummy, data, typedArrayOffset, $length) {
                        anInstance(dummy, TypedArrayConstructor, CONSTRUCTOR_NAME);
                        return inheritIfRequired(function() {
                          if (!isObject(data))
                            return new NativeTypedArrayConstructor(toIndex(data));
                          if (isArrayBuffer(data))
                            return $length !== void 0 ? new NativeTypedArrayConstructor(data, toOffset(typedArrayOffset, BYTES), $length) : typedArrayOffset !== void 0 ? new NativeTypedArrayConstructor(data, toOffset(typedArrayOffset, BYTES)) : new NativeTypedArrayConstructor(data);
                          if (isTypedArray(data))
                            return fromList(TypedArrayConstructor, data);
                          return typedArrayFrom.call(TypedArrayConstructor, data);
                        }(), dummy, TypedArrayConstructor);
                      });
                      if (setPrototypeOf)
                        setPrototypeOf(TypedArrayConstructor, TypedArray);
                      forEach(getOwnPropertyNames(NativeTypedArrayConstructor), function(key) {
                        if (!(key in TypedArrayConstructor)) {
                          createNonEnumerableProperty(TypedArrayConstructor, key, NativeTypedArrayConstructor[key]);
                        }
                      });
                      TypedArrayConstructor.prototype = TypedArrayConstructorPrototype;
                    }
                    if (TypedArrayConstructorPrototype.constructor !== TypedArrayConstructor) {
                      createNonEnumerableProperty(TypedArrayConstructorPrototype, "constructor", TypedArrayConstructor);
                    }
                    if (TYPED_ARRAY_TAG) {
                      createNonEnumerableProperty(TypedArrayConstructorPrototype, TYPED_ARRAY_TAG, CONSTRUCTOR_NAME);
                    }
                    exported[CONSTRUCTOR_NAME] = TypedArrayConstructor;
                    $({
                      global: true,
                      forced: TypedArrayConstructor != NativeTypedArrayConstructor,
                      sham: !NATIVE_ARRAY_BUFFER_VIEWS
                    }, exported);
                    if (!(BYTES_PER_ELEMENT in TypedArrayConstructor)) {
                      createNonEnumerableProperty(TypedArrayConstructor, BYTES_PER_ELEMENT, BYTES);
                    }
                    if (!(BYTES_PER_ELEMENT in TypedArrayConstructorPrototype)) {
                      createNonEnumerableProperty(TypedArrayConstructorPrototype, BYTES_PER_ELEMENT, BYTES);
                    }
                    setSpecies(CONSTRUCTOR_NAME);
                  };
                } else
                  module2.exports = function() {
                  };
              }
            ),
            /***/
            8200: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var global = __webpack_require__2(9859);
                var fails = __webpack_require__2(4229);
                var checkCorrectnessOfIteration = __webpack_require__2(4575);
                var NATIVE_ARRAY_BUFFER_VIEWS = __webpack_require__2(9918).NATIVE_ARRAY_BUFFER_VIEWS;
                var ArrayBuffer2 = global.ArrayBuffer;
                var Int8Array2 = global.Int8Array;
                module2.exports = !NATIVE_ARRAY_BUFFER_VIEWS || !fails(function() {
                  Int8Array2(1);
                }) || !fails(function() {
                  new Int8Array2(-1);
                }) || !checkCorrectnessOfIteration(function(iterable) {
                  new Int8Array2();
                  new Int8Array2(null);
                  new Int8Array2(1.5);
                  new Int8Array2(iterable);
                }, true) || fails(function() {
                  return new Int8Array2(new ArrayBuffer2(2), 1, void 0).length !== 1;
                });
              }
            ),
            /***/
            8874: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var aTypedArrayConstructor = __webpack_require__2(9918).aTypedArrayConstructor;
                var speciesConstructor = __webpack_require__2(7942);
                module2.exports = function(instance, list) {
                  var C = speciesConstructor(instance, instance.constructor);
                  var index = 0;
                  var length = list.length;
                  var result = new (aTypedArrayConstructor(C))(length);
                  while (length > index)
                    result[index] = list[index++];
                  return result;
                };
              }
            ),
            /***/
            5215: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var toObject = __webpack_require__2(2991);
                var toLength = __webpack_require__2(4237);
                var getIteratorMethod = __webpack_require__2(8830);
                var isArrayIteratorMethod = __webpack_require__2(1943);
                var bind = __webpack_require__2(7636);
                var aTypedArrayConstructor = __webpack_require__2(9918).aTypedArrayConstructor;
                module2.exports = function from(source) {
                  var O = toObject(source);
                  var argumentsLength = arguments.length;
                  var mapfn = argumentsLength > 1 ? arguments[1] : void 0;
                  var mapping = mapfn !== void 0;
                  var iteratorMethod = getIteratorMethod(O);
                  var i, length, result, step, iterator, next;
                  if (iteratorMethod != void 0 && !isArrayIteratorMethod(iteratorMethod)) {
                    iterator = iteratorMethod.call(O);
                    next = iterator.next;
                    O = [];
                    while (!(step = next.call(iterator)).done) {
                      O.push(step.value);
                    }
                  }
                  if (mapping && argumentsLength > 2) {
                    mapfn = bind(mapfn, arguments[2], 2);
                  }
                  length = toLength(O.length);
                  result = new (aTypedArrayConstructor(this))(length);
                  for (i = 0; length > i; i++) {
                    result[i] = mapping ? mapfn(O[i], i) : O[i];
                  }
                  return result;
                };
              }
            ),
            /***/
            1441: (
              /***/
              function(module2) {
                var id = 0;
                var postfix = Math.random();
                module2.exports = function(key) {
                  return "Symbol(" + String(key === void 0 ? "" : key) + ")_" + (++id + postfix).toString(36);
                };
              }
            ),
            /***/
            6969: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var NATIVE_SYMBOL = __webpack_require__2(3839);
                module2.exports = NATIVE_SYMBOL && !Symbol.sham && typeof Symbol.iterator == "symbol";
              }
            ),
            /***/
            5391: (
              /***/
              function(__unused_webpack_module, exports2, __webpack_require__2) {
                var wellKnownSymbol = __webpack_require__2(95);
                exports2.f = wellKnownSymbol;
              }
            ),
            /***/
            95: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                var global = __webpack_require__2(9859);
                var shared = __webpack_require__2(3036);
                var has = __webpack_require__2(816);
                var uid = __webpack_require__2(1441);
                var NATIVE_SYMBOL = __webpack_require__2(3839);
                var USE_SYMBOL_AS_UID = __webpack_require__2(6969);
                var WellKnownSymbolsStore = shared("wks");
                var Symbol2 = global.Symbol;
                var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol2 : Symbol2 && Symbol2.withoutSetter || uid;
                module2.exports = function(name) {
                  if (!has(WellKnownSymbolsStore, name) || !(NATIVE_SYMBOL || typeof WellKnownSymbolsStore[name] == "string")) {
                    if (NATIVE_SYMBOL && has(Symbol2, name)) {
                      WellKnownSymbolsStore[name] = Symbol2[name];
                    } else {
                      WellKnownSymbolsStore[name] = createWellKnownSymbol("Symbol." + name);
                    }
                  }
                  return WellKnownSymbolsStore[name];
                };
              }
            ),
            /***/
            1647: (
              /***/
              function(module2) {
                module2.exports = "	\n\v\f\r \u2028\u2029\uFEFF";
              }
            ),
            /***/
            2994: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var $ = __webpack_require__2(3103);
                var fails = __webpack_require__2(4229);
                var ArrayBufferModule = __webpack_require__2(3816);
                var anObject = __webpack_require__2(1176);
                var toAbsoluteIndex = __webpack_require__2(3231);
                var toLength = __webpack_require__2(4237);
                var speciesConstructor = __webpack_require__2(7942);
                var ArrayBuffer2 = ArrayBufferModule.ArrayBuffer;
                var DataView2 = ArrayBufferModule.DataView;
                var nativeArrayBufferSlice = ArrayBuffer2.prototype.slice;
                var INCORRECT_SLICE = fails(function() {
                  return !new ArrayBuffer2(2).slice(1, void 0).byteLength;
                });
                $({ target: "ArrayBuffer", proto: true, unsafe: true, forced: INCORRECT_SLICE }, {
                  slice: function slice(start, end) {
                    if (nativeArrayBufferSlice !== void 0 && end === void 0) {
                      return nativeArrayBufferSlice.call(anObject(this), start);
                    }
                    var length = anObject(this).byteLength;
                    var first = toAbsoluteIndex(start, length);
                    var fin = toAbsoluteIndex(end === void 0 ? length : end, length);
                    var result = new (speciesConstructor(this, ArrayBuffer2))(toLength(fin - first));
                    var viewSource = new DataView2(this);
                    var viewTarget = new DataView2(result);
                    var index = 0;
                    while (first < fin) {
                      viewTarget.setUint8(index++, viewSource.getUint8(first++));
                    }
                    return result;
                  }
                });
              }
            ),
            /***/
            8178: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var $ = __webpack_require__2(3103);
                var fails = __webpack_require__2(4229);
                var isArray = __webpack_require__2(3718);
                var isObject = __webpack_require__2(5052);
                var toObject = __webpack_require__2(2991);
                var toLength = __webpack_require__2(4237);
                var createProperty = __webpack_require__2(2324);
                var arraySpeciesCreate = __webpack_require__2(7501);
                var arrayMethodHasSpeciesSupport = __webpack_require__2(1460);
                var wellKnownSymbol = __webpack_require__2(95);
                var V8_VERSION = __webpack_require__2(6358);
                var IS_CONCAT_SPREADABLE = wellKnownSymbol("isConcatSpreadable");
                var MAX_SAFE_INTEGER = 9007199254740991;
                var MAXIMUM_ALLOWED_INDEX_EXCEEDED = "Maximum allowed index exceeded";
                var IS_CONCAT_SPREADABLE_SUPPORT = V8_VERSION >= 51 || !fails(function() {
                  var array = [];
                  array[IS_CONCAT_SPREADABLE] = false;
                  return array.concat()[0] !== array;
                });
                var SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("concat");
                var isConcatSpreadable = function(O) {
                  if (!isObject(O))
                    return false;
                  var spreadable = O[IS_CONCAT_SPREADABLE];
                  return spreadable !== void 0 ? !!spreadable : isArray(O);
                };
                var FORCED = !IS_CONCAT_SPREADABLE_SUPPORT || !SPECIES_SUPPORT;
                $({ target: "Array", proto: true, forced: FORCED }, {
                  // eslint-disable-next-line no-unused-vars -- required for `.length`
                  concat: function concat(arg) {
                    var O = toObject(this);
                    var A = arraySpeciesCreate(O, 0);
                    var n = 0;
                    var i, k, length, len, E;
                    for (i = -1, length = arguments.length; i < length; i++) {
                      E = i === -1 ? O : arguments[i];
                      if (isConcatSpreadable(E)) {
                        len = toLength(E.length);
                        if (n + len > MAX_SAFE_INTEGER)
                          throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
                        for (k = 0; k < len; k++, n++)
                          if (k in E)
                            createProperty(A, n, E[k]);
                      } else {
                        if (n >= MAX_SAFE_INTEGER)
                          throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
                        createProperty(A, n++, E);
                      }
                    }
                    A.length = n;
                    return A;
                  }
                });
              }
            ),
            /***/
            2656: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                var $ = __webpack_require__2(3103);
                var fill = __webpack_require__2(7065);
                var addToUnscopables = __webpack_require__2(9736);
                $({ target: "Array", proto: true }, {
                  fill
                });
                addToUnscopables("fill");
              }
            ),
            /***/
            5342: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var $ = __webpack_require__2(3103);
                var $filter = __webpack_require__2(9996).filter;
                var arrayMethodHasSpeciesSupport = __webpack_require__2(1460);
                var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("filter");
                $({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT }, {
                  filter: function filter(callbackfn) {
                    return $filter(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
                  }
                });
              }
            ),
            /***/
            9949: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var $ = __webpack_require__2(3103);
                var $findIndex = __webpack_require__2(9996).findIndex;
                var addToUnscopables = __webpack_require__2(9736);
                var FIND_INDEX = "findIndex";
                var SKIPS_HOLES = true;
                if (FIND_INDEX in [])
                  Array(1)[FIND_INDEX](function() {
                    SKIPS_HOLES = false;
                  });
                $({ target: "Array", proto: true, forced: SKIPS_HOLES }, {
                  findIndex: function findIndex(callbackfn) {
                    return $findIndex(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
                  }
                });
                addToUnscopables(FIND_INDEX);
              }
            ),
            /***/
            9228: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var $ = __webpack_require__2(3103);
                var $find = __webpack_require__2(9996).find;
                var addToUnscopables = __webpack_require__2(9736);
                var FIND = "find";
                var SKIPS_HOLES = true;
                if (FIND in [])
                  Array(1)[FIND](function() {
                    SKIPS_HOLES = false;
                  });
                $({ target: "Array", proto: true, forced: SKIPS_HOLES }, {
                  find: function find(callbackfn) {
                    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
                  }
                });
                addToUnscopables(FIND);
              }
            ),
            /***/
            4870: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var $ = __webpack_require__2(3103);
                var flattenIntoArray = __webpack_require__2(4990);
                var toObject = __webpack_require__2(2991);
                var toLength = __webpack_require__2(4237);
                var aFunction = __webpack_require__2(3819);
                var arraySpeciesCreate = __webpack_require__2(7501);
                $({ target: "Array", proto: true }, {
                  flatMap: function flatMap(callbackfn) {
                    var O = toObject(this);
                    var sourceLen = toLength(O.length);
                    var A;
                    aFunction(callbackfn);
                    A = arraySpeciesCreate(O, 0);
                    A.length = flattenIntoArray(A, O, O, sourceLen, 0, 1, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
                    return A;
                  }
                });
              }
            ),
            /***/
            7233: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                var $ = __webpack_require__2(3103);
                var from = __webpack_require__2(507);
                var checkCorrectnessOfIteration = __webpack_require__2(4575);
                var INCORRECT_ITERATION = !checkCorrectnessOfIteration(function(iterable) {
                  Array.from(iterable);
                });
                $({ target: "Array", stat: true, forced: INCORRECT_ITERATION }, {
                  from
                });
              }
            ),
            /***/
            9529: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var $ = __webpack_require__2(3103);
                var $includes = __webpack_require__2(9540).includes;
                var addToUnscopables = __webpack_require__2(9736);
                $({ target: "Array", proto: true }, {
                  includes: function includes(el) {
                    return $includes(this, el, arguments.length > 1 ? arguments[1] : void 0);
                  }
                });
                addToUnscopables("includes");
              }
            ),
            /***/
            5735: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var toIndexedObject = __webpack_require__2(905);
                var addToUnscopables = __webpack_require__2(9736);
                var Iterators = __webpack_require__2(5495);
                var InternalStateModule = __webpack_require__2(6407);
                var defineIterator = __webpack_require__2(7675);
                var ARRAY_ITERATOR = "Array Iterator";
                var setInternalState = InternalStateModule.set;
                var getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);
                module2.exports = defineIterator(Array, "Array", function(iterated, kind) {
                  setInternalState(this, {
                    type: ARRAY_ITERATOR,
                    target: toIndexedObject(iterated),
                    // target
                    index: 0,
                    // next index
                    kind
                    // kind
                  });
                }, function() {
                  var state = getInternalState(this);
                  var target = state.target;
                  var kind = state.kind;
                  var index = state.index++;
                  if (!target || index >= target.length) {
                    state.target = void 0;
                    return { value: void 0, done: true };
                  }
                  if (kind == "keys")
                    return { value: index, done: false };
                  if (kind == "values")
                    return { value: target[index], done: false };
                  return { value: [index, target[index]], done: false };
                }, "values");
                Iterators.Arguments = Iterators.Array;
                addToUnscopables("keys");
                addToUnscopables("values");
                addToUnscopables("entries");
              }
            ),
            /***/
            6781: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var $ = __webpack_require__2(3103);
                var IndexedObject = __webpack_require__2(9337);
                var toIndexedObject = __webpack_require__2(905);
                var arrayMethodIsStrict = __webpack_require__2(6038);
                var nativeJoin = [].join;
                var ES3_STRINGS = IndexedObject != Object;
                var STRICT_METHOD = arrayMethodIsStrict("join", ",");
                $({ target: "Array", proto: true, forced: ES3_STRINGS || !STRICT_METHOD }, {
                  join: function join(separator) {
                    return nativeJoin.call(toIndexedObject(this), separator === void 0 ? "," : separator);
                  }
                });
              }
            ),
            /***/
            3450: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var $ = __webpack_require__2(3103);
                var $map = __webpack_require__2(9996).map;
                var arrayMethodHasSpeciesSupport = __webpack_require__2(1460);
                var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("map");
                $({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT }, {
                  map: function map(callbackfn) {
                    return $map(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
                  }
                });
              }
            ),
            /***/
            2501: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var $ = __webpack_require__2(3103);
                var isObject = __webpack_require__2(5052);
                var isArray = __webpack_require__2(3718);
                var toAbsoluteIndex = __webpack_require__2(3231);
                var toLength = __webpack_require__2(4237);
                var toIndexedObject = __webpack_require__2(905);
                var createProperty = __webpack_require__2(2324);
                var wellKnownSymbol = __webpack_require__2(95);
                var arrayMethodHasSpeciesSupport = __webpack_require__2(1460);
                var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("slice");
                var SPECIES = wellKnownSymbol("species");
                var nativeSlice = [].slice;
                var max = Math.max;
                $({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT }, {
                  slice: function slice(start, end) {
                    var O = toIndexedObject(this);
                    var length = toLength(O.length);
                    var k = toAbsoluteIndex(start, length);
                    var fin = toAbsoluteIndex(end === void 0 ? length : end, length);
                    var Constructor, result, n;
                    if (isArray(O)) {
                      Constructor = O.constructor;
                      if (typeof Constructor == "function" && (Constructor === Array || isArray(Constructor.prototype))) {
                        Constructor = void 0;
                      } else if (isObject(Constructor)) {
                        Constructor = Constructor[SPECIES];
                        if (Constructor === null)
                          Constructor = void 0;
                      }
                      if (Constructor === Array || Constructor === void 0) {
                        return nativeSlice.call(O, k, fin);
                      }
                    }
                    result = new (Constructor === void 0 ? Array : Constructor)(max(fin - k, 0));
                    for (n = 0; k < fin; k++, n++)
                      if (k in O)
                        createProperty(result, n, O[k]);
                    result.length = n;
                    return result;
                  }
                });
              }
            ),
            /***/
            9805: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var $ = __webpack_require__2(3103);
                var toAbsoluteIndex = __webpack_require__2(3231);
                var toInteger = __webpack_require__2(6051);
                var toLength = __webpack_require__2(4237);
                var toObject = __webpack_require__2(2991);
                var arraySpeciesCreate = __webpack_require__2(7501);
                var createProperty = __webpack_require__2(2324);
                var arrayMethodHasSpeciesSupport = __webpack_require__2(1460);
                var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("splice");
                var max = Math.max;
                var min = Math.min;
                var MAX_SAFE_INTEGER = 9007199254740991;
                var MAXIMUM_ALLOWED_LENGTH_EXCEEDED = "Maximum allowed length exceeded";
                $({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT }, {
                  splice: function splice(start, deleteCount) {
                    var O = toObject(this);
                    var len = toLength(O.length);
                    var actualStart = toAbsoluteIndex(start, len);
                    var argumentsLength = arguments.length;
                    var insertCount, actualDeleteCount, A, k, from, to;
                    if (argumentsLength === 0) {
                      insertCount = actualDeleteCount = 0;
                    } else if (argumentsLength === 1) {
                      insertCount = 0;
                      actualDeleteCount = len - actualStart;
                    } else {
                      insertCount = argumentsLength - 2;
                      actualDeleteCount = min(max(toInteger(deleteCount), 0), len - actualStart);
                    }
                    if (len + insertCount - actualDeleteCount > MAX_SAFE_INTEGER) {
                      throw TypeError(MAXIMUM_ALLOWED_LENGTH_EXCEEDED);
                    }
                    A = arraySpeciesCreate(O, actualDeleteCount);
                    for (k = 0; k < actualDeleteCount; k++) {
                      from = actualStart + k;
                      if (from in O)
                        createProperty(A, k, O[from]);
                    }
                    A.length = actualDeleteCount;
                    if (insertCount < actualDeleteCount) {
                      for (k = actualStart; k < len - actualDeleteCount; k++) {
                        from = k + actualDeleteCount;
                        to = k + insertCount;
                        if (from in O)
                          O[to] = O[from];
                        else
                          delete O[to];
                      }
                      for (k = len; k > len - actualDeleteCount + insertCount; k--)
                        delete O[k - 1];
                    } else if (insertCount > actualDeleteCount) {
                      for (k = len - actualDeleteCount; k > actualStart; k--) {
                        from = k + actualDeleteCount - 1;
                        to = k + insertCount - 1;
                        if (from in O)
                          O[to] = O[from];
                        else
                          delete O[to];
                      }
                    }
                    for (k = 0; k < insertCount; k++) {
                      O[k + actualStart] = arguments[k + 2];
                    }
                    O.length = len - actualDeleteCount + insertCount;
                    return A;
                  }
                });
              }
            ),
            /***/
            3985: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                var addToUnscopables = __webpack_require__2(9736);
                addToUnscopables("flatMap");
              }
            ),
            /***/
            6936: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                var DESCRIPTORS = __webpack_require__2(7400);
                var defineProperty = __webpack_require__2(1787).f;
                var FunctionPrototype = Function.prototype;
                var FunctionPrototypeToString = FunctionPrototype.toString;
                var nameRE = /^\s*function ([^ (]*)/;
                var NAME = "name";
                if (DESCRIPTORS && !(NAME in FunctionPrototype)) {
                  defineProperty(FunctionPrototype, NAME, {
                    configurable: true,
                    get: function() {
                      try {
                        return FunctionPrototypeToString.call(this).match(nameRE)[1];
                      } catch (error) {
                        return "";
                      }
                    }
                  });
                }
              }
            ),
            /***/
            1245: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var DESCRIPTORS = __webpack_require__2(7400);
                var global = __webpack_require__2(9859);
                var isForced = __webpack_require__2(6541);
                var redefine = __webpack_require__2(7487);
                var has = __webpack_require__2(816);
                var classof = __webpack_require__2(7079);
                var inheritIfRequired = __webpack_require__2(835);
                var toPrimitive = __webpack_require__2(2066);
                var fails = __webpack_require__2(4229);
                var create = __webpack_require__2(2391);
                var getOwnPropertyNames = __webpack_require__2(8151).f;
                var getOwnPropertyDescriptor = __webpack_require__2(7933).f;
                var defineProperty = __webpack_require__2(1787).f;
                var trim = __webpack_require__2(1017).trim;
                var NUMBER = "Number";
                var NativeNumber = global[NUMBER];
                var NumberPrototype = NativeNumber.prototype;
                var BROKEN_CLASSOF = classof(create(NumberPrototype)) == NUMBER;
                var toNumber = function(argument) {
                  var it = toPrimitive(argument, false);
                  var first, third, radix, maxCode, digits, length, index, code;
                  if (typeof it == "string" && it.length > 2) {
                    it = trim(it);
                    first = it.charCodeAt(0);
                    if (first === 43 || first === 45) {
                      third = it.charCodeAt(2);
                      if (third === 88 || third === 120)
                        return NaN;
                    } else if (first === 48) {
                      switch (it.charCodeAt(1)) {
                        case 66:
                        case 98:
                          radix = 2;
                          maxCode = 49;
                          break;
                        case 79:
                        case 111:
                          radix = 8;
                          maxCode = 55;
                          break;
                        default:
                          return +it;
                      }
                      digits = it.slice(2);
                      length = digits.length;
                      for (index = 0; index < length; index++) {
                        code = digits.charCodeAt(index);
                        if (code < 48 || code > maxCode)
                          return NaN;
                      }
                      return parseInt(digits, radix);
                    }
                  }
                  return +it;
                };
                if (isForced(NUMBER, !NativeNumber(" 0o1") || !NativeNumber("0b1") || NativeNumber("+0x1"))) {
                  var NumberWrapper = function Number2(value) {
                    var it = arguments.length < 1 ? 0 : value;
                    var dummy = this;
                    return dummy instanceof NumberWrapper && (BROKEN_CLASSOF ? fails(function() {
                      NumberPrototype.valueOf.call(dummy);
                    }) : classof(dummy) != NUMBER) ? inheritIfRequired(new NativeNumber(toNumber(it)), dummy, NumberWrapper) : toNumber(it);
                  };
                  for (var keys = DESCRIPTORS ? getOwnPropertyNames(NativeNumber) : (
                    // ES3:
                    "MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger,fromString,range".split(",")
                  ), j = 0, key; keys.length > j; j++) {
                    if (has(NativeNumber, key = keys[j]) && !has(NumberWrapper, key)) {
                      defineProperty(NumberWrapper, key, getOwnPropertyDescriptor(NativeNumber, key));
                    }
                  }
                  NumberWrapper.prototype = NumberPrototype;
                  NumberPrototype.constructor = NumberWrapper;
                  redefine(global, NUMBER, NumberWrapper);
                }
              }
            ),
            /***/
            8143: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                var $ = __webpack_require__2(3103);
                $({ target: "Number", stat: true }, {
                  MAX_SAFE_INTEGER: 9007199254740991
                });
              }
            ),
            /***/
            2023: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                var $ = __webpack_require__2(3103);
                $({ target: "Number", stat: true }, {
                  MIN_SAFE_INTEGER: -9007199254740991
                });
              }
            ),
            /***/
            1321: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var $ = __webpack_require__2(3103);
                var toInteger = __webpack_require__2(6051);
                var thisNumberValue = __webpack_require__2(143);
                var repeat = __webpack_require__2(3124);
                var fails = __webpack_require__2(4229);
                var nativeToFixed = 1 .toFixed;
                var floor = Math.floor;
                var pow = function(x, n, acc) {
                  return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);
                };
                var log = function(x) {
                  var n = 0;
                  var x2 = x;
                  while (x2 >= 4096) {
                    n += 12;
                    x2 /= 4096;
                  }
                  while (x2 >= 2) {
                    n += 1;
                    x2 /= 2;
                  }
                  return n;
                };
                var multiply = function(data, n, c) {
                  var index = -1;
                  var c2 = c;
                  while (++index < 6) {
                    c2 += n * data[index];
                    data[index] = c2 % 1e7;
                    c2 = floor(c2 / 1e7);
                  }
                };
                var divide = function(data, n) {
                  var index = 6;
                  var c = 0;
                  while (--index >= 0) {
                    c += data[index];
                    data[index] = floor(c / n);
                    c = c % n * 1e7;
                  }
                };
                var dataToString = function(data) {
                  var index = 6;
                  var s = "";
                  while (--index >= 0) {
                    if (s !== "" || index === 0 || data[index] !== 0) {
                      var t = String(data[index]);
                      s = s === "" ? t : s + repeat.call("0", 7 - t.length) + t;
                    }
                  }
                  return s;
                };
                var FORCED = nativeToFixed && (8e-5.toFixed(3) !== "0.000" || 0.9.toFixed(0) !== "1" || 1.255.toFixed(2) !== "1.25" || 1000000000000000100 .toFixed(0) !== "1000000000000000128") || !fails(function() {
                  nativeToFixed.call({});
                });
                $({ target: "Number", proto: true, forced: FORCED }, {
                  toFixed: function toFixed(fractionDigits) {
                    var number = thisNumberValue(this);
                    var fractDigits = toInteger(fractionDigits);
                    var data = [0, 0, 0, 0, 0, 0];
                    var sign = "";
                    var result = "0";
                    var e, z, j, k;
                    if (fractDigits < 0 || fractDigits > 20)
                      throw RangeError("Incorrect fraction digits");
                    if (number != number)
                      return "NaN";
                    if (number <= -1e21 || number >= 1e21)
                      return String(number);
                    if (number < 0) {
                      sign = "-";
                      number = -number;
                    }
                    if (number > 1e-21) {
                      e = log(number * pow(2, 69, 1)) - 69;
                      z = e < 0 ? number * pow(2, -e, 1) : number / pow(2, e, 1);
                      z *= 4503599627370496;
                      e = 52 - e;
                      if (e > 0) {
                        multiply(data, 0, z);
                        j = fractDigits;
                        while (j >= 7) {
                          multiply(data, 1e7, 0);
                          j -= 7;
                        }
                        multiply(data, pow(10, j, 1), 0);
                        j = e - 1;
                        while (j >= 23) {
                          divide(data, 1 << 23);
                          j -= 23;
                        }
                        divide(data, 1 << j);
                        multiply(data, 1, 1);
                        divide(data, 2);
                        result = dataToString(data);
                      } else {
                        multiply(data, 0, z);
                        multiply(data, 1 << -e, 0);
                        result = dataToString(data) + repeat.call("0", fractDigits);
                      }
                    }
                    if (fractDigits > 0) {
                      k = result.length;
                      result = sign + (k <= fractDigits ? "0." + repeat.call("0", fractDigits - k) + result : result.slice(0, k - fractDigits) + "." + result.slice(k - fractDigits));
                    } else {
                      result = sign + result;
                    }
                    return result;
                  }
                });
              }
            ),
            /***/
            2144: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                var $ = __webpack_require__2(3103);
                var FREEZING = __webpack_require__2(8476);
                var fails = __webpack_require__2(4229);
                var isObject = __webpack_require__2(5052);
                var onFreeze = __webpack_require__2(5926).onFreeze;
                var $freeze = Object.freeze;
                var FAILS_ON_PRIMITIVES = fails(function() {
                  $freeze(1);
                });
                $({ target: "Object", stat: true, forced: FAILS_ON_PRIMITIVES, sham: !FREEZING }, {
                  freeze: function freeze(it) {
                    return $freeze && isObject(it) ? $freeze(onFreeze(it)) : it;
                  }
                });
              }
            ),
            /***/
            8625: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                var $ = __webpack_require__2(3103);
                var fails = __webpack_require__2(4229);
                var toIndexedObject = __webpack_require__2(905);
                var nativeGetOwnPropertyDescriptor = __webpack_require__2(7933).f;
                var DESCRIPTORS = __webpack_require__2(7400);
                var FAILS_ON_PRIMITIVES = fails(function() {
                  nativeGetOwnPropertyDescriptor(1);
                });
                var FORCED = !DESCRIPTORS || FAILS_ON_PRIMITIVES;
                $({ target: "Object", stat: true, forced: FORCED, sham: !DESCRIPTORS }, {
                  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(it, key) {
                    return nativeGetOwnPropertyDescriptor(toIndexedObject(it), key);
                  }
                });
              }
            ),
            /***/
            2775: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                var $ = __webpack_require__2(3103);
                var DESCRIPTORS = __webpack_require__2(7400);
                var ownKeys = __webpack_require__2(4826);
                var toIndexedObject = __webpack_require__2(905);
                var getOwnPropertyDescriptorModule = __webpack_require__2(7933);
                var createProperty = __webpack_require__2(2324);
                $({ target: "Object", stat: true, sham: !DESCRIPTORS }, {
                  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
                    var O = toIndexedObject(object);
                    var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
                    var keys = ownKeys(O);
                    var result = {};
                    var index = 0;
                    var key, descriptor;
                    while (keys.length > index) {
                      descriptor = getOwnPropertyDescriptor(O, key = keys[index++]);
                      if (descriptor !== void 0)
                        createProperty(result, key, descriptor);
                    }
                    return result;
                  }
                });
              }
            ),
            /***/
            6928: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                var $ = __webpack_require__2(3103);
                var fails = __webpack_require__2(4229);
                var toObject = __webpack_require__2(2991);
                var nativeGetPrototypeOf = __webpack_require__2(7567);
                var CORRECT_PROTOTYPE_GETTER = __webpack_require__2(7528);
                var FAILS_ON_PRIMITIVES = fails(function() {
                  nativeGetPrototypeOf(1);
                });
                $({ target: "Object", stat: true, forced: FAILS_ON_PRIMITIVES, sham: !CORRECT_PROTOTYPE_GETTER }, {
                  getPrototypeOf: function getPrototypeOf(it) {
                    return nativeGetPrototypeOf(toObject(it));
                  }
                });
              }
            ),
            /***/
            4769: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                var $ = __webpack_require__2(3103);
                var toObject = __webpack_require__2(2991);
                var nativeKeys = __webpack_require__2(5632);
                var fails = __webpack_require__2(4229);
                var FAILS_ON_PRIMITIVES = fails(function() {
                  nativeKeys(1);
                });
                $({ target: "Object", stat: true, forced: FAILS_ON_PRIMITIVES }, {
                  keys: function keys(it) {
                    return nativeKeys(toObject(it));
                  }
                });
              }
            ),
            /***/
            2506: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                var $ = __webpack_require__2(3103);
                var setPrototypeOf = __webpack_require__2(6540);
                $({ target: "Object", stat: true }, {
                  setPrototypeOf
                });
              }
            ),
            /***/
            8188: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                var TO_STRING_TAG_SUPPORT = __webpack_require__2(1601);
                var redefine = __webpack_require__2(7487);
                var toString = __webpack_require__2(4059);
                if (!TO_STRING_TAG_SUPPORT) {
                  redefine(Object.prototype, "toString", toString, { unsafe: true });
                }
              }
            ),
            /***/
            7890: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                var $ = __webpack_require__2(3103);
                var $values = __webpack_require__2(7664).values;
                $({ target: "Object", stat: true }, {
                  values: function values(O) {
                    return $values(O);
                  }
                });
              }
            ),
            /***/
            1229: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                var $ = __webpack_require__2(3103);
                var getBuiltIn = __webpack_require__2(1333);
                var aFunction = __webpack_require__2(3819);
                var anObject = __webpack_require__2(1176);
                var isObject = __webpack_require__2(5052);
                var create = __webpack_require__2(2391);
                var bind = __webpack_require__2(4128);
                var fails = __webpack_require__2(4229);
                var nativeConstruct = getBuiltIn("Reflect", "construct");
                var NEW_TARGET_BUG = fails(function() {
                  function F() {
                  }
                  return !(nativeConstruct(function() {
                  }, [], F) instanceof F);
                });
                var ARGS_BUG = !fails(function() {
                  nativeConstruct(function() {
                  });
                });
                var FORCED = NEW_TARGET_BUG || ARGS_BUG;
                $({ target: "Reflect", stat: true, forced: FORCED, sham: FORCED }, {
                  construct: function construct(Target, args) {
                    aFunction(Target);
                    anObject(args);
                    var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);
                    if (ARGS_BUG && !NEW_TARGET_BUG)
                      return nativeConstruct(Target, args, newTarget);
                    if (Target == newTarget) {
                      switch (args.length) {
                        case 0:
                          return new Target();
                        case 1:
                          return new Target(args[0]);
                        case 2:
                          return new Target(args[0], args[1]);
                        case 3:
                          return new Target(args[0], args[1], args[2]);
                        case 4:
                          return new Target(args[0], args[1], args[2], args[3]);
                      }
                      var $args = [null];
                      $args.push.apply($args, args);
                      return new (bind.apply(Target, $args))();
                    }
                    var proto = newTarget.prototype;
                    var instance = create(isObject(proto) ? proto : Object.prototype);
                    var result = Function.apply.call(Target, instance, args);
                    return isObject(result) ? result : instance;
                  }
                });
              }
            ),
            /***/
            4565: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                var $ = __webpack_require__2(3103);
                var isObject = __webpack_require__2(5052);
                var anObject = __webpack_require__2(1176);
                var has = __webpack_require__2(816);
                var getOwnPropertyDescriptorModule = __webpack_require__2(7933);
                var getPrototypeOf = __webpack_require__2(7567);
                function get(target, propertyKey) {
                  var receiver = arguments.length < 3 ? target : arguments[2];
                  var descriptor, prototype;
                  if (anObject(target) === receiver)
                    return target[propertyKey];
                  if (descriptor = getOwnPropertyDescriptorModule.f(target, propertyKey))
                    return has(descriptor, "value") ? descriptor.value : descriptor.get === void 0 ? void 0 : descriptor.get.call(receiver);
                  if (isObject(prototype = getPrototypeOf(target)))
                    return get(prototype, propertyKey, receiver);
                }
                $({ target: "Reflect", stat: true }, {
                  get
                });
              }
            ),
            /***/
            7368: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                var DESCRIPTORS = __webpack_require__2(7400);
                var global = __webpack_require__2(9859);
                var isForced = __webpack_require__2(6541);
                var inheritIfRequired = __webpack_require__2(835);
                var defineProperty = __webpack_require__2(1787).f;
                var getOwnPropertyNames = __webpack_require__2(8151).f;
                var isRegExp = __webpack_require__2(8311);
                var getFlags = __webpack_require__2(895);
                var stickyHelpers = __webpack_require__2(5650);
                var redefine = __webpack_require__2(7487);
                var fails = __webpack_require__2(4229);
                var enforceInternalState = __webpack_require__2(6407).enforce;
                var setSpecies = __webpack_require__2(1832);
                var wellKnownSymbol = __webpack_require__2(95);
                var MATCH = wellKnownSymbol("match");
                var NativeRegExp = global.RegExp;
                var RegExpPrototype = NativeRegExp.prototype;
                var re1 = /a/g;
                var re2 = /a/g;
                var CORRECT_NEW = new NativeRegExp(re1) !== re1;
                var UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y;
                var FORCED = DESCRIPTORS && isForced("RegExp", !CORRECT_NEW || UNSUPPORTED_Y || fails(function() {
                  re2[MATCH] = false;
                  return NativeRegExp(re1) != re1 || NativeRegExp(re2) == re2 || NativeRegExp(re1, "i") != "/a/i";
                }));
                if (FORCED) {
                  var RegExpWrapper = function RegExp2(pattern, flags) {
                    var thisIsRegExp = this instanceof RegExpWrapper;
                    var patternIsRegExp = isRegExp(pattern);
                    var flagsAreUndefined = flags === void 0;
                    var sticky;
                    if (!thisIsRegExp && patternIsRegExp && pattern.constructor === RegExpWrapper && flagsAreUndefined) {
                      return pattern;
                    }
                    if (CORRECT_NEW) {
                      if (patternIsRegExp && !flagsAreUndefined)
                        pattern = pattern.source;
                    } else if (pattern instanceof RegExpWrapper) {
                      if (flagsAreUndefined)
                        flags = getFlags.call(pattern);
                      pattern = pattern.source;
                    }
                    if (UNSUPPORTED_Y) {
                      sticky = !!flags && flags.indexOf("y") > -1;
                      if (sticky)
                        flags = flags.replace(/y/g, "");
                    }
                    var result = inheritIfRequired(
                      CORRECT_NEW ? new NativeRegExp(pattern, flags) : NativeRegExp(pattern, flags),
                      thisIsRegExp ? this : RegExpPrototype,
                      RegExpWrapper
                    );
                    if (UNSUPPORTED_Y && sticky) {
                      var state = enforceInternalState(result);
                      state.sticky = true;
                    }
                    return result;
                  };
                  var proxy = function(key) {
                    key in RegExpWrapper || defineProperty(RegExpWrapper, key, {
                      configurable: true,
                      get: function() {
                        return NativeRegExp[key];
                      },
                      set: function(it) {
                        NativeRegExp[key] = it;
                      }
                    });
                  };
                  var keys = getOwnPropertyNames(NativeRegExp);
                  var index = 0;
                  while (keys.length > index)
                    proxy(keys[index++]);
                  RegExpPrototype.constructor = RegExpWrapper;
                  RegExpWrapper.prototype = RegExpPrototype;
                  redefine(global, "RegExp", RegExpWrapper);
                }
                setSpecies("RegExp");
              }
            ),
            /***/
            7950: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var $ = __webpack_require__2(3103);
                var exec = __webpack_require__2(3466);
                $({ target: "RegExp", proto: true, forced: /./.exec !== exec }, {
                  exec
                });
              }
            ),
            /***/
            8233: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var redefine = __webpack_require__2(7487);
                var anObject = __webpack_require__2(1176);
                var fails = __webpack_require__2(4229);
                var flags = __webpack_require__2(895);
                var TO_STRING = "toString";
                var RegExpPrototype = RegExp.prototype;
                var nativeToString = RegExpPrototype[TO_STRING];
                var NOT_GENERIC = fails(function() {
                  return nativeToString.call({ source: "a", flags: "b" }) != "/a/b";
                });
                var INCORRECT_NAME = nativeToString.name != TO_STRING;
                if (NOT_GENERIC || INCORRECT_NAME) {
                  redefine(RegExp.prototype, TO_STRING, function toString() {
                    var R = anObject(this);
                    var p = String(R.source);
                    var rf = R.flags;
                    var f = String(rf === void 0 && R instanceof RegExp && !("flags" in RegExpPrototype) ? flags.call(R) : rf);
                    return "/" + p + "/" + f;
                  }, { unsafe: true });
                }
              }
            ),
            /***/
            3244: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var collection = __webpack_require__2(9789);
                var collectionStrong = __webpack_require__2(8081);
                module2.exports = collection("Set", function(init) {
                  return function Set2() {
                    return init(this, arguments.length ? arguments[0] : void 0);
                  };
                }, collectionStrong);
              }
            ),
            /***/
            1549: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var $ = __webpack_require__2(3103);
                var createHTML = __webpack_require__2(1720);
                var forcedStringHTMLMethod = __webpack_require__2(3689);
                $({ target: "String", proto: true, forced: forcedStringHTMLMethod("anchor") }, {
                  anchor: function anchor(name) {
                    return createHTML(this, "a", "name", name);
                  }
                });
              }
            ),
            /***/
            1235: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var $ = __webpack_require__2(3103);
                var notARegExp = __webpack_require__2(7272);
                var requireObjectCoercible = __webpack_require__2(8885);
                var correctIsRegExpLogic = __webpack_require__2(8127);
                $({ target: "String", proto: true, forced: !correctIsRegExpLogic("includes") }, {
                  includes: function includes(searchString) {
                    return !!~String(requireObjectCoercible(this)).indexOf(notARegExp(searchString), arguments.length > 1 ? arguments[1] : void 0);
                  }
                });
              }
            ),
            /***/
            8673: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var charAt = __webpack_require__2(966).charAt;
                var InternalStateModule = __webpack_require__2(6407);
                var defineIterator = __webpack_require__2(7675);
                var STRING_ITERATOR = "String Iterator";
                var setInternalState = InternalStateModule.set;
                var getInternalState = InternalStateModule.getterFor(STRING_ITERATOR);
                defineIterator(String, "String", function(iterated) {
                  setInternalState(this, {
                    type: STRING_ITERATOR,
                    string: String(iterated),
                    index: 0
                  });
                }, function next() {
                  var state = getInternalState(this);
                  var string = state.string;
                  var index = state.index;
                  var point;
                  if (index >= string.length)
                    return { value: void 0, done: true };
                  point = charAt(string, index);
                  state.index += point.length;
                  return { value: point, done: false };
                });
              }
            ),
            /***/
            4069: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var fixRegExpWellKnownSymbolLogic = __webpack_require__2(4954);
                var anObject = __webpack_require__2(1176);
                var toLength = __webpack_require__2(4237);
                var requireObjectCoercible = __webpack_require__2(8885);
                var advanceStringIndex = __webpack_require__2(6637);
                var regExpExec = __webpack_require__2(8115);
                fixRegExpWellKnownSymbolLogic("match", 1, function(MATCH, nativeMatch, maybeCallNative) {
                  return [
                    // `String.prototype.match` method
                    // https://tc39.es/ecma262/#sec-string.prototype.match
                    function match(regexp) {
                      var O = requireObjectCoercible(this);
                      var matcher = regexp == void 0 ? void 0 : regexp[MATCH];
                      return matcher !== void 0 ? matcher.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
                    },
                    // `RegExp.prototype[@@match]` method
                    // https://tc39.es/ecma262/#sec-regexp.prototype-@@match
                    function(regexp) {
                      var res = maybeCallNative(nativeMatch, regexp, this);
                      if (res.done)
                        return res.value;
                      var rx = anObject(regexp);
                      var S = String(this);
                      if (!rx.global)
                        return regExpExec(rx, S);
                      var fullUnicode = rx.unicode;
                      rx.lastIndex = 0;
                      var A = [];
                      var n = 0;
                      var result;
                      while ((result = regExpExec(rx, S)) !== null) {
                        var matchStr = String(result[0]);
                        A[n] = matchStr;
                        if (matchStr === "")
                          rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
                        n++;
                      }
                      return n === 0 ? null : A;
                    }
                  ];
                });
              }
            ),
            /***/
            5940: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var fixRegExpWellKnownSymbolLogic = __webpack_require__2(4954);
                var anObject = __webpack_require__2(1176);
                var toLength = __webpack_require__2(4237);
                var toInteger = __webpack_require__2(6051);
                var requireObjectCoercible = __webpack_require__2(8885);
                var advanceStringIndex = __webpack_require__2(6637);
                var getSubstitution = __webpack_require__2(17);
                var regExpExec = __webpack_require__2(8115);
                var max = Math.max;
                var min = Math.min;
                var maybeToString = function(it) {
                  return it === void 0 ? it : String(it);
                };
                fixRegExpWellKnownSymbolLogic("replace", 2, function(REPLACE, nativeReplace, maybeCallNative, reason) {
                  var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = reason.REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE;
                  var REPLACE_KEEPS_$0 = reason.REPLACE_KEEPS_$0;
                  var UNSAFE_SUBSTITUTE = REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE ? "$" : "$0";
                  return [
                    // `String.prototype.replace` method
                    // https://tc39.es/ecma262/#sec-string.prototype.replace
                    function replace(searchValue, replaceValue) {
                      var O = requireObjectCoercible(this);
                      var replacer = searchValue == void 0 ? void 0 : searchValue[REPLACE];
                      return replacer !== void 0 ? replacer.call(searchValue, O, replaceValue) : nativeReplace.call(String(O), searchValue, replaceValue);
                    },
                    // `RegExp.prototype[@@replace]` method
                    // https://tc39.es/ecma262/#sec-regexp.prototype-@@replace
                    function(regexp, replaceValue) {
                      if (!REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE && REPLACE_KEEPS_$0 || typeof replaceValue === "string" && replaceValue.indexOf(UNSAFE_SUBSTITUTE) === -1) {
                        var res = maybeCallNative(nativeReplace, regexp, this, replaceValue);
                        if (res.done)
                          return res.value;
                      }
                      var rx = anObject(regexp);
                      var S = String(this);
                      var functionalReplace = typeof replaceValue === "function";
                      if (!functionalReplace)
                        replaceValue = String(replaceValue);
                      var global = rx.global;
                      if (global) {
                        var fullUnicode = rx.unicode;
                        rx.lastIndex = 0;
                      }
                      var results = [];
                      while (true) {
                        var result = regExpExec(rx, S);
                        if (result === null)
                          break;
                        results.push(result);
                        if (!global)
                          break;
                        var matchStr = String(result[0]);
                        if (matchStr === "")
                          rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
                      }
                      var accumulatedResult = "";
                      var nextSourcePosition = 0;
                      for (var i = 0; i < results.length; i++) {
                        result = results[i];
                        var matched = String(result[0]);
                        var position = max(min(toInteger(result.index), S.length), 0);
                        var captures = [];
                        for (var j = 1; j < result.length; j++)
                          captures.push(maybeToString(result[j]));
                        var namedCaptures = result.groups;
                        if (functionalReplace) {
                          var replacerArgs = [matched].concat(captures, position, S);
                          if (namedCaptures !== void 0)
                            replacerArgs.push(namedCaptures);
                          var replacement = String(replaceValue.apply(void 0, replacerArgs));
                        } else {
                          replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
                        }
                        if (position >= nextSourcePosition) {
                          accumulatedResult += S.slice(nextSourcePosition, position) + replacement;
                          nextSourcePosition = position + matched.length;
                        }
                      }
                      return accumulatedResult + S.slice(nextSourcePosition);
                    }
                  ];
                });
              }
            ),
            /***/
            8319: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var fixRegExpWellKnownSymbolLogic = __webpack_require__2(4954);
                var isRegExp = __webpack_require__2(8311);
                var anObject = __webpack_require__2(1176);
                var requireObjectCoercible = __webpack_require__2(8885);
                var speciesConstructor = __webpack_require__2(7942);
                var advanceStringIndex = __webpack_require__2(6637);
                var toLength = __webpack_require__2(4237);
                var callRegExpExec = __webpack_require__2(8115);
                var regexpExec = __webpack_require__2(3466);
                var stickyHelpers = __webpack_require__2(5650);
                var UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y;
                var arrayPush = [].push;
                var min = Math.min;
                var MAX_UINT32 = 4294967295;
                fixRegExpWellKnownSymbolLogic("split", 2, function(SPLIT, nativeSplit, maybeCallNative) {
                  var internalSplit;
                  if ("abbc".split(/(b)*/)[1] == "c" || // eslint-disable-next-line regexp/no-empty-group -- required for testing
                  "test".split(/(?:)/, -1).length != 4 || "ab".split(/(?:ab)*/).length != 2 || ".".split(/(.?)(.?)/).length != 4 || // eslint-disable-next-line regexp/no-assertion-capturing-group, regexp/no-empty-group -- required for testing
                  ".".split(/()()/).length > 1 || "".split(/.?/).length) {
                    internalSplit = function(separator, limit) {
                      var string = String(requireObjectCoercible(this));
                      var lim = limit === void 0 ? MAX_UINT32 : limit >>> 0;
                      if (lim === 0)
                        return [];
                      if (separator === void 0)
                        return [string];
                      if (!isRegExp(separator)) {
                        return nativeSplit.call(string, separator, lim);
                      }
                      var output = [];
                      var flags = (separator.ignoreCase ? "i" : "") + (separator.multiline ? "m" : "") + (separator.unicode ? "u" : "") + (separator.sticky ? "y" : "");
                      var lastLastIndex = 0;
                      var separatorCopy = new RegExp(separator.source, flags + "g");
                      var match, lastIndex, lastLength;
                      while (match = regexpExec.call(separatorCopy, string)) {
                        lastIndex = separatorCopy.lastIndex;
                        if (lastIndex > lastLastIndex) {
                          output.push(string.slice(lastLastIndex, match.index));
                          if (match.length > 1 && match.index < string.length)
                            arrayPush.apply(output, match.slice(1));
                          lastLength = match[0].length;
                          lastLastIndex = lastIndex;
                          if (output.length >= lim)
                            break;
                        }
                        if (separatorCopy.lastIndex === match.index)
                          separatorCopy.lastIndex++;
                      }
                      if (lastLastIndex === string.length) {
                        if (lastLength || !separatorCopy.test(""))
                          output.push("");
                      } else
                        output.push(string.slice(lastLastIndex));
                      return output.length > lim ? output.slice(0, lim) : output;
                    };
                  } else if ("0".split(void 0, 0).length) {
                    internalSplit = function(separator, limit) {
                      return separator === void 0 && limit === 0 ? [] : nativeSplit.call(this, separator, limit);
                    };
                  } else
                    internalSplit = nativeSplit;
                  return [
                    // `String.prototype.split` method
                    // https://tc39.es/ecma262/#sec-string.prototype.split
                    function split(separator, limit) {
                      var O = requireObjectCoercible(this);
                      var splitter = separator == void 0 ? void 0 : separator[SPLIT];
                      return splitter !== void 0 ? splitter.call(separator, O, limit) : internalSplit.call(String(O), separator, limit);
                    },
                    // `RegExp.prototype[@@split]` method
                    // https://tc39.es/ecma262/#sec-regexp.prototype-@@split
                    //
                    // NOTE: This cannot be properly polyfilled in engines that don't support
                    // the 'y' flag.
                    function(regexp, limit) {
                      var res = maybeCallNative(internalSplit, regexp, this, limit, internalSplit !== nativeSplit);
                      if (res.done)
                        return res.value;
                      var rx = anObject(regexp);
                      var S = String(this);
                      var C = speciesConstructor(rx, RegExp);
                      var unicodeMatching = rx.unicode;
                      var flags = (rx.ignoreCase ? "i" : "") + (rx.multiline ? "m" : "") + (rx.unicode ? "u" : "") + (UNSUPPORTED_Y ? "g" : "y");
                      var splitter = new C(UNSUPPORTED_Y ? "^(?:" + rx.source + ")" : rx, flags);
                      var lim = limit === void 0 ? MAX_UINT32 : limit >>> 0;
                      if (lim === 0)
                        return [];
                      if (S.length === 0)
                        return callRegExpExec(splitter, S) === null ? [S] : [];
                      var p = 0;
                      var q = 0;
                      var A = [];
                      while (q < S.length) {
                        splitter.lastIndex = UNSUPPORTED_Y ? 0 : q;
                        var z = callRegExpExec(splitter, UNSUPPORTED_Y ? S.slice(q) : S);
                        var e;
                        if (z === null || (e = min(toLength(splitter.lastIndex + (UNSUPPORTED_Y ? q : 0)), S.length)) === p) {
                          q = advanceStringIndex(S, q, unicodeMatching);
                        } else {
                          A.push(S.slice(p, q));
                          if (A.length === lim)
                            return A;
                          for (var i = 1; i <= z.length - 1; i++) {
                            A.push(z[i]);
                            if (A.length === lim)
                              return A;
                          }
                          q = p = e;
                        }
                      }
                      A.push(S.slice(p));
                      return A;
                    }
                  ];
                }, UNSUPPORTED_Y);
              }
            ),
            /***/
            634: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var $ = __webpack_require__2(3103);
                var DESCRIPTORS = __webpack_require__2(7400);
                var global = __webpack_require__2(9859);
                var has = __webpack_require__2(816);
                var isObject = __webpack_require__2(5052);
                var defineProperty = __webpack_require__2(1787).f;
                var copyConstructorProperties = __webpack_require__2(7081);
                var NativeSymbol = global.Symbol;
                if (DESCRIPTORS && typeof NativeSymbol == "function" && (!("description" in NativeSymbol.prototype) || // Safari 12 bug
                NativeSymbol().description !== void 0)) {
                  var EmptyStringDescriptionStore = {};
                  var SymbolWrapper = function Symbol2() {
                    var description = arguments.length < 1 || arguments[0] === void 0 ? void 0 : String(arguments[0]);
                    var result = this instanceof SymbolWrapper ? new NativeSymbol(description) : description === void 0 ? NativeSymbol() : NativeSymbol(description);
                    if (description === "")
                      EmptyStringDescriptionStore[result] = true;
                    return result;
                  };
                  copyConstructorProperties(SymbolWrapper, NativeSymbol);
                  var symbolPrototype = SymbolWrapper.prototype = NativeSymbol.prototype;
                  symbolPrototype.constructor = SymbolWrapper;
                  var symbolToString = symbolPrototype.toString;
                  var native = String(NativeSymbol("test")) == "Symbol(test)";
                  var regexp = /^Symbol\((.*)\)[^)]+$/;
                  defineProperty(symbolPrototype, "description", {
                    configurable: true,
                    get: function description() {
                      var symbol = isObject(this) ? this.valueOf() : this;
                      var string = symbolToString.call(symbol);
                      if (has(EmptyStringDescriptionStore, symbol))
                        return "";
                      var desc = native ? string.slice(7, -1) : string.replace(regexp, "$1");
                      return desc === "" ? void 0 : desc;
                    }
                  });
                  $({ global: true, forced: true }, {
                    Symbol: SymbolWrapper
                  });
                }
              }
            ),
            /***/
            796: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                var defineWellKnownSymbol = __webpack_require__2(8423);
                defineWellKnownSymbol("iterator");
              }
            ),
            /***/
            4115: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var $ = __webpack_require__2(3103);
                var global = __webpack_require__2(9859);
                var getBuiltIn = __webpack_require__2(1333);
                var IS_PURE = __webpack_require__2(4231);
                var DESCRIPTORS = __webpack_require__2(7400);
                var NATIVE_SYMBOL = __webpack_require__2(3839);
                var USE_SYMBOL_AS_UID = __webpack_require__2(6969);
                var fails = __webpack_require__2(4229);
                var has = __webpack_require__2(816);
                var isArray = __webpack_require__2(3718);
                var isObject = __webpack_require__2(5052);
                var anObject = __webpack_require__2(1176);
                var toObject = __webpack_require__2(2991);
                var toIndexedObject = __webpack_require__2(905);
                var toPrimitive = __webpack_require__2(2066);
                var createPropertyDescriptor = __webpack_require__2(5358);
                var nativeObjectCreate = __webpack_require__2(2391);
                var objectKeys = __webpack_require__2(5632);
                var getOwnPropertyNamesModule = __webpack_require__2(8151);
                var getOwnPropertyNamesExternal = __webpack_require__2(166);
                var getOwnPropertySymbolsModule = __webpack_require__2(894);
                var getOwnPropertyDescriptorModule = __webpack_require__2(7933);
                var definePropertyModule = __webpack_require__2(1787);
                var propertyIsEnumerableModule = __webpack_require__2(9195);
                var createNonEnumerableProperty = __webpack_require__2(5762);
                var redefine = __webpack_require__2(7487);
                var shared = __webpack_require__2(3036);
                var sharedKey = __webpack_require__2(4399);
                var hiddenKeys = __webpack_require__2(5977);
                var uid = __webpack_require__2(1441);
                var wellKnownSymbol = __webpack_require__2(95);
                var wrappedWellKnownSymbolModule = __webpack_require__2(5391);
                var defineWellKnownSymbol = __webpack_require__2(8423);
                var setToStringTag = __webpack_require__2(4555);
                var InternalStateModule = __webpack_require__2(6407);
                var $forEach = __webpack_require__2(9996).forEach;
                var HIDDEN = sharedKey("hidden");
                var SYMBOL = "Symbol";
                var PROTOTYPE = "prototype";
                var TO_PRIMITIVE = wellKnownSymbol("toPrimitive");
                var setInternalState = InternalStateModule.set;
                var getInternalState = InternalStateModule.getterFor(SYMBOL);
                var ObjectPrototype = Object[PROTOTYPE];
                var $Symbol = global.Symbol;
                var $stringify = getBuiltIn("JSON", "stringify");
                var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
                var nativeDefineProperty = definePropertyModule.f;
                var nativeGetOwnPropertyNames = getOwnPropertyNamesExternal.f;
                var nativePropertyIsEnumerable = propertyIsEnumerableModule.f;
                var AllSymbols = shared("symbols");
                var ObjectPrototypeSymbols = shared("op-symbols");
                var StringToSymbolRegistry = shared("string-to-symbol-registry");
                var SymbolToStringRegistry = shared("symbol-to-string-registry");
                var WellKnownSymbolsStore = shared("wks");
                var QObject = global.QObject;
                var USE_SETTER = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;
                var setSymbolDescriptor = DESCRIPTORS && fails(function() {
                  return nativeObjectCreate(nativeDefineProperty({}, "a", {
                    get: function() {
                      return nativeDefineProperty(this, "a", { value: 7 }).a;
                    }
                  })).a != 7;
                }) ? function(O, P, Attributes) {
                  var ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor(ObjectPrototype, P);
                  if (ObjectPrototypeDescriptor)
                    delete ObjectPrototype[P];
                  nativeDefineProperty(O, P, Attributes);
                  if (ObjectPrototypeDescriptor && O !== ObjectPrototype) {
                    nativeDefineProperty(ObjectPrototype, P, ObjectPrototypeDescriptor);
                  }
                } : nativeDefineProperty;
                var wrap = function(tag, description) {
                  var symbol = AllSymbols[tag] = nativeObjectCreate($Symbol[PROTOTYPE]);
                  setInternalState(symbol, {
                    type: SYMBOL,
                    tag,
                    description
                  });
                  if (!DESCRIPTORS)
                    symbol.description = description;
                  return symbol;
                };
                var isSymbol = USE_SYMBOL_AS_UID ? function(it) {
                  return typeof it == "symbol";
                } : function(it) {
                  return Object(it) instanceof $Symbol;
                };
                var $defineProperty = function defineProperty(O, P, Attributes) {
                  if (O === ObjectPrototype)
                    $defineProperty(ObjectPrototypeSymbols, P, Attributes);
                  anObject(O);
                  var key = toPrimitive(P, true);
                  anObject(Attributes);
                  if (has(AllSymbols, key)) {
                    if (!Attributes.enumerable) {
                      if (!has(O, HIDDEN))
                        nativeDefineProperty(O, HIDDEN, createPropertyDescriptor(1, {}));
                      O[HIDDEN][key] = true;
                    } else {
                      if (has(O, HIDDEN) && O[HIDDEN][key])
                        O[HIDDEN][key] = false;
                      Attributes = nativeObjectCreate(Attributes, { enumerable: createPropertyDescriptor(0, false) });
                    }
                    return setSymbolDescriptor(O, key, Attributes);
                  }
                  return nativeDefineProperty(O, key, Attributes);
                };
                var $defineProperties = function defineProperties(O, Properties) {
                  anObject(O);
                  var properties = toIndexedObject(Properties);
                  var keys = objectKeys(properties).concat($getOwnPropertySymbols(properties));
                  $forEach(keys, function(key) {
                    if (!DESCRIPTORS || $propertyIsEnumerable.call(properties, key))
                      $defineProperty(O, key, properties[key]);
                  });
                  return O;
                };
                var $create = function create(O, Properties) {
                  return Properties === void 0 ? nativeObjectCreate(O) : $defineProperties(nativeObjectCreate(O), Properties);
                };
                var $propertyIsEnumerable = function propertyIsEnumerable(V) {
                  var P = toPrimitive(V, true);
                  var enumerable = nativePropertyIsEnumerable.call(this, P);
                  if (this === ObjectPrototype && has(AllSymbols, P) && !has(ObjectPrototypeSymbols, P))
                    return false;
                  return enumerable || !has(this, P) || !has(AllSymbols, P) || has(this, HIDDEN) && this[HIDDEN][P] ? enumerable : true;
                };
                var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(O, P) {
                  var it = toIndexedObject(O);
                  var key = toPrimitive(P, true);
                  if (it === ObjectPrototype && has(AllSymbols, key) && !has(ObjectPrototypeSymbols, key))
                    return;
                  var descriptor = nativeGetOwnPropertyDescriptor(it, key);
                  if (descriptor && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) {
                    descriptor.enumerable = true;
                  }
                  return descriptor;
                };
                var $getOwnPropertyNames = function getOwnPropertyNames(O) {
                  var names = nativeGetOwnPropertyNames(toIndexedObject(O));
                  var result = [];
                  $forEach(names, function(key) {
                    if (!has(AllSymbols, key) && !has(hiddenKeys, key))
                      result.push(key);
                  });
                  return result;
                };
                var $getOwnPropertySymbols = function getOwnPropertySymbols(O) {
                  var IS_OBJECT_PROTOTYPE = O === ObjectPrototype;
                  var names = nativeGetOwnPropertyNames(IS_OBJECT_PROTOTYPE ? ObjectPrototypeSymbols : toIndexedObject(O));
                  var result = [];
                  $forEach(names, function(key) {
                    if (has(AllSymbols, key) && (!IS_OBJECT_PROTOTYPE || has(ObjectPrototype, key))) {
                      result.push(AllSymbols[key]);
                    }
                  });
                  return result;
                };
                if (!NATIVE_SYMBOL) {
                  $Symbol = function Symbol2() {
                    if (this instanceof $Symbol)
                      throw TypeError("Symbol is not a constructor");
                    var description = !arguments.length || arguments[0] === void 0 ? void 0 : String(arguments[0]);
                    var tag = uid(description);
                    var setter = function(value) {
                      if (this === ObjectPrototype)
                        setter.call(ObjectPrototypeSymbols, value);
                      if (has(this, HIDDEN) && has(this[HIDDEN], tag))
                        this[HIDDEN][tag] = false;
                      setSymbolDescriptor(this, tag, createPropertyDescriptor(1, value));
                    };
                    if (DESCRIPTORS && USE_SETTER)
                      setSymbolDescriptor(ObjectPrototype, tag, { configurable: true, set: setter });
                    return wrap(tag, description);
                  };
                  redefine($Symbol[PROTOTYPE], "toString", function toString() {
                    return getInternalState(this).tag;
                  });
                  redefine($Symbol, "withoutSetter", function(description) {
                    return wrap(uid(description), description);
                  });
                  propertyIsEnumerableModule.f = $propertyIsEnumerable;
                  definePropertyModule.f = $defineProperty;
                  getOwnPropertyDescriptorModule.f = $getOwnPropertyDescriptor;
                  getOwnPropertyNamesModule.f = getOwnPropertyNamesExternal.f = $getOwnPropertyNames;
                  getOwnPropertySymbolsModule.f = $getOwnPropertySymbols;
                  wrappedWellKnownSymbolModule.f = function(name) {
                    return wrap(wellKnownSymbol(name), name);
                  };
                  if (DESCRIPTORS) {
                    nativeDefineProperty($Symbol[PROTOTYPE], "description", {
                      configurable: true,
                      get: function description() {
                        return getInternalState(this).description;
                      }
                    });
                    if (!IS_PURE) {
                      redefine(ObjectPrototype, "propertyIsEnumerable", $propertyIsEnumerable, { unsafe: true });
                    }
                  }
                }
                $({ global: true, wrap: true, forced: !NATIVE_SYMBOL, sham: !NATIVE_SYMBOL }, {
                  Symbol: $Symbol
                });
                $forEach(objectKeys(WellKnownSymbolsStore), function(name) {
                  defineWellKnownSymbol(name);
                });
                $({ target: SYMBOL, stat: true, forced: !NATIVE_SYMBOL }, {
                  // `Symbol.for` method
                  // https://tc39.es/ecma262/#sec-symbol.for
                  "for": function(key) {
                    var string = String(key);
                    if (has(StringToSymbolRegistry, string))
                      return StringToSymbolRegistry[string];
                    var symbol = $Symbol(string);
                    StringToSymbolRegistry[string] = symbol;
                    SymbolToStringRegistry[symbol] = string;
                    return symbol;
                  },
                  // `Symbol.keyFor` method
                  // https://tc39.es/ecma262/#sec-symbol.keyfor
                  keyFor: function keyFor(sym) {
                    if (!isSymbol(sym))
                      throw TypeError(sym + " is not a symbol");
                    if (has(SymbolToStringRegistry, sym))
                      return SymbolToStringRegistry[sym];
                  },
                  useSetter: function() {
                    USE_SETTER = true;
                  },
                  useSimple: function() {
                    USE_SETTER = false;
                  }
                });
                $({ target: "Object", stat: true, forced: !NATIVE_SYMBOL, sham: !DESCRIPTORS }, {
                  // `Object.create` method
                  // https://tc39.es/ecma262/#sec-object.create
                  create: $create,
                  // `Object.defineProperty` method
                  // https://tc39.es/ecma262/#sec-object.defineproperty
                  defineProperty: $defineProperty,
                  // `Object.defineProperties` method
                  // https://tc39.es/ecma262/#sec-object.defineproperties
                  defineProperties: $defineProperties,
                  // `Object.getOwnPropertyDescriptor` method
                  // https://tc39.es/ecma262/#sec-object.getownpropertydescriptors
                  getOwnPropertyDescriptor: $getOwnPropertyDescriptor
                });
                $({ target: "Object", stat: true, forced: !NATIVE_SYMBOL }, {
                  // `Object.getOwnPropertyNames` method
                  // https://tc39.es/ecma262/#sec-object.getownpropertynames
                  getOwnPropertyNames: $getOwnPropertyNames,
                  // `Object.getOwnPropertySymbols` method
                  // https://tc39.es/ecma262/#sec-object.getownpropertysymbols
                  getOwnPropertySymbols: $getOwnPropertySymbols
                });
                $({ target: "Object", stat: true, forced: fails(function() {
                  getOwnPropertySymbolsModule.f(1);
                }) }, {
                  getOwnPropertySymbols: function getOwnPropertySymbols(it) {
                    return getOwnPropertySymbolsModule.f(toObject(it));
                  }
                });
                if ($stringify) {
                  var FORCED_JSON_STRINGIFY = !NATIVE_SYMBOL || fails(function() {
                    var symbol = $Symbol();
                    return $stringify([symbol]) != "[null]" || $stringify({ a: symbol }) != "{}" || $stringify(Object(symbol)) != "{}";
                  });
                  $({ target: "JSON", stat: true, forced: FORCED_JSON_STRINGIFY }, {
                    // eslint-disable-next-line no-unused-vars -- required for `.length`
                    stringify: function stringify(it, replacer, space) {
                      var args = [it];
                      var index = 1;
                      var $replacer;
                      while (arguments.length > index)
                        args.push(arguments[index++]);
                      $replacer = replacer;
                      if (!isObject(replacer) && it === void 0 || isSymbol(it))
                        return;
                      if (!isArray(replacer))
                        replacer = function(key, value) {
                          if (typeof $replacer == "function")
                            value = $replacer.call(this, key, value);
                          if (!isSymbol(value))
                            return value;
                        };
                      args[1] = replacer;
                      return $stringify.apply(null, args);
                    }
                  });
                }
                if (!$Symbol[PROTOTYPE][TO_PRIMITIVE]) {
                  createNonEnumerableProperty($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
                }
                setToStringTag($Symbol, SYMBOL);
                hiddenKeys[HIDDEN] = true;
              }
            ),
            /***/
            5825: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var ArrayBufferViewCore = __webpack_require__2(9918);
                var $copyWithin = __webpack_require__2(7154);
                var aTypedArray = ArrayBufferViewCore.aTypedArray;
                var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
                exportTypedArrayMethod("copyWithin", function copyWithin(target, start) {
                  return $copyWithin.call(aTypedArray(this), target, start, arguments.length > 2 ? arguments[2] : void 0);
                });
              }
            ),
            /***/
            7170: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var ArrayBufferViewCore = __webpack_require__2(9918);
                var $every = __webpack_require__2(9996).every;
                var aTypedArray = ArrayBufferViewCore.aTypedArray;
                var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
                exportTypedArrayMethod("every", function every(callbackfn) {
                  return $every(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : void 0);
                });
              }
            ),
            /***/
            8857: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var ArrayBufferViewCore = __webpack_require__2(9918);
                var $fill = __webpack_require__2(7065);
                var aTypedArray = ArrayBufferViewCore.aTypedArray;
                var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
                exportTypedArrayMethod("fill", function fill(value) {
                  return $fill.apply(aTypedArray(this), arguments);
                });
              }
            ),
            /***/
            8329: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var ArrayBufferViewCore = __webpack_require__2(9918);
                var $filter = __webpack_require__2(9996).filter;
                var fromSpeciesAndList = __webpack_require__2(8874);
                var aTypedArray = ArrayBufferViewCore.aTypedArray;
                var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
                exportTypedArrayMethod("filter", function filter(callbackfn) {
                  var list = $filter(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : void 0);
                  return fromSpeciesAndList(this, list);
                });
              }
            ),
            /***/
            427: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var ArrayBufferViewCore = __webpack_require__2(9918);
                var $findIndex = __webpack_require__2(9996).findIndex;
                var aTypedArray = ArrayBufferViewCore.aTypedArray;
                var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
                exportTypedArrayMethod("findIndex", function findIndex(predicate) {
                  return $findIndex(aTypedArray(this), predicate, arguments.length > 1 ? arguments[1] : void 0);
                });
              }
            ),
            /***/
            6279: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var ArrayBufferViewCore = __webpack_require__2(9918);
                var $find = __webpack_require__2(9996).find;
                var aTypedArray = ArrayBufferViewCore.aTypedArray;
                var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
                exportTypedArrayMethod("find", function find(predicate) {
                  return $find(aTypedArray(this), predicate, arguments.length > 1 ? arguments[1] : void 0);
                });
              }
            ),
            /***/
            1159: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var ArrayBufferViewCore = __webpack_require__2(9918);
                var $forEach = __webpack_require__2(9996).forEach;
                var aTypedArray = ArrayBufferViewCore.aTypedArray;
                var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
                exportTypedArrayMethod("forEach", function forEach(callbackfn) {
                  $forEach(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : void 0);
                });
              }
            ),
            /***/
            2516: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var ArrayBufferViewCore = __webpack_require__2(9918);
                var $includes = __webpack_require__2(9540).includes;
                var aTypedArray = ArrayBufferViewCore.aTypedArray;
                var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
                exportTypedArrayMethod("includes", function includes(searchElement) {
                  return $includes(aTypedArray(this), searchElement, arguments.length > 1 ? arguments[1] : void 0);
                });
              }
            ),
            /***/
            4349: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var ArrayBufferViewCore = __webpack_require__2(9918);
                var $indexOf = __webpack_require__2(9540).indexOf;
                var aTypedArray = ArrayBufferViewCore.aTypedArray;
                var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
                exportTypedArrayMethod("indexOf", function indexOf(searchElement) {
                  return $indexOf(aTypedArray(this), searchElement, arguments.length > 1 ? arguments[1] : void 0);
                });
              }
            ),
            /***/
            5273: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var global = __webpack_require__2(9859);
                var ArrayBufferViewCore = __webpack_require__2(9918);
                var ArrayIterators = __webpack_require__2(5735);
                var wellKnownSymbol = __webpack_require__2(95);
                var ITERATOR = wellKnownSymbol("iterator");
                var Uint8Array2 = global.Uint8Array;
                var arrayValues = ArrayIterators.values;
                var arrayKeys = ArrayIterators.keys;
                var arrayEntries = ArrayIterators.entries;
                var aTypedArray = ArrayBufferViewCore.aTypedArray;
                var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
                var nativeTypedArrayIterator = Uint8Array2 && Uint8Array2.prototype[ITERATOR];
                var CORRECT_ITER_NAME = !!nativeTypedArrayIterator && (nativeTypedArrayIterator.name == "values" || nativeTypedArrayIterator.name == void 0);
                var typedArrayValues = function values() {
                  return arrayValues.call(aTypedArray(this));
                };
                exportTypedArrayMethod("entries", function entries() {
                  return arrayEntries.call(aTypedArray(this));
                });
                exportTypedArrayMethod("keys", function keys() {
                  return arrayKeys.call(aTypedArray(this));
                });
                exportTypedArrayMethod("values", typedArrayValues, !CORRECT_ITER_NAME);
                exportTypedArrayMethod(ITERATOR, typedArrayValues, !CORRECT_ITER_NAME);
              }
            ),
            /***/
            6729: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var ArrayBufferViewCore = __webpack_require__2(9918);
                var aTypedArray = ArrayBufferViewCore.aTypedArray;
                var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
                var $join = [].join;
                exportTypedArrayMethod("join", function join(separator) {
                  return $join.apply(aTypedArray(this), arguments);
                });
              }
            ),
            /***/
            1801: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var ArrayBufferViewCore = __webpack_require__2(9918);
                var $lastIndexOf = __webpack_require__2(6462);
                var aTypedArray = ArrayBufferViewCore.aTypedArray;
                var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
                exportTypedArrayMethod("lastIndexOf", function lastIndexOf(searchElement) {
                  return $lastIndexOf.apply(aTypedArray(this), arguments);
                });
              }
            ),
            /***/
            574: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var ArrayBufferViewCore = __webpack_require__2(9918);
                var $map = __webpack_require__2(9996).map;
                var speciesConstructor = __webpack_require__2(7942);
                var aTypedArray = ArrayBufferViewCore.aTypedArray;
                var aTypedArrayConstructor = ArrayBufferViewCore.aTypedArrayConstructor;
                var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
                exportTypedArrayMethod("map", function map(mapfn) {
                  return $map(aTypedArray(this), mapfn, arguments.length > 1 ? arguments[1] : void 0, function(O, length) {
                    return new (aTypedArrayConstructor(speciesConstructor(O, O.constructor)))(length);
                  });
                });
              }
            ),
            /***/
            9271: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var ArrayBufferViewCore = __webpack_require__2(9918);
                var $reduceRight = __webpack_require__2(3143).right;
                var aTypedArray = ArrayBufferViewCore.aTypedArray;
                var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
                exportTypedArrayMethod("reduceRight", function reduceRight(callbackfn) {
                  return $reduceRight(aTypedArray(this), callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : void 0);
                });
              }
            ),
            /***/
            5787: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var ArrayBufferViewCore = __webpack_require__2(9918);
                var $reduce = __webpack_require__2(3143).left;
                var aTypedArray = ArrayBufferViewCore.aTypedArray;
                var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
                exportTypedArrayMethod("reduce", function reduce(callbackfn) {
                  return $reduce(aTypedArray(this), callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : void 0);
                });
              }
            ),
            /***/
            3160: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var ArrayBufferViewCore = __webpack_require__2(9918);
                var aTypedArray = ArrayBufferViewCore.aTypedArray;
                var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
                var floor = Math.floor;
                exportTypedArrayMethod("reverse", function reverse() {
                  var that = this;
                  var length = aTypedArray(that).length;
                  var middle = floor(length / 2);
                  var index = 0;
                  var value;
                  while (index < middle) {
                    value = that[index];
                    that[index++] = that[--length];
                    that[length] = value;
                  }
                  return that;
                });
              }
            ),
            /***/
            5688: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var ArrayBufferViewCore = __webpack_require__2(9918);
                var toLength = __webpack_require__2(4237);
                var toOffset = __webpack_require__2(4262);
                var toObject = __webpack_require__2(2991);
                var fails = __webpack_require__2(4229);
                var aTypedArray = ArrayBufferViewCore.aTypedArray;
                var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
                var FORCED = fails(function() {
                  new Int8Array(1).set({});
                });
                exportTypedArrayMethod("set", function set(arrayLike) {
                  aTypedArray(this);
                  var offset = toOffset(arguments.length > 1 ? arguments[1] : void 0, 1);
                  var length = this.length;
                  var src = toObject(arrayLike);
                  var len = toLength(src.length);
                  var index = 0;
                  if (len + offset > length)
                    throw RangeError("Wrong length");
                  while (index < len)
                    this[offset + index] = src[index++];
                }, FORCED);
              }
            ),
            /***/
            3157: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var ArrayBufferViewCore = __webpack_require__2(9918);
                var speciesConstructor = __webpack_require__2(7942);
                var fails = __webpack_require__2(4229);
                var aTypedArray = ArrayBufferViewCore.aTypedArray;
                var aTypedArrayConstructor = ArrayBufferViewCore.aTypedArrayConstructor;
                var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
                var $slice = [].slice;
                var FORCED = fails(function() {
                  new Int8Array(1).slice();
                });
                exportTypedArrayMethod("slice", function slice(start, end) {
                  var list = $slice.call(aTypedArray(this), start, end);
                  var C = speciesConstructor(this, this.constructor);
                  var index = 0;
                  var length = list.length;
                  var result = new (aTypedArrayConstructor(C))(length);
                  while (length > index)
                    result[index] = list[index++];
                  return result;
                }, FORCED);
              }
            ),
            /***/
            3333: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var ArrayBufferViewCore = __webpack_require__2(9918);
                var $some = __webpack_require__2(9996).some;
                var aTypedArray = ArrayBufferViewCore.aTypedArray;
                var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
                exportTypedArrayMethod("some", function some(callbackfn) {
                  return $some(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : void 0);
                });
              }
            ),
            /***/
            315: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var ArrayBufferViewCore = __webpack_require__2(9918);
                var aTypedArray = ArrayBufferViewCore.aTypedArray;
                var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
                var $sort = [].sort;
                exportTypedArrayMethod("sort", function sort(comparefn) {
                  return $sort.call(aTypedArray(this), comparefn);
                });
              }
            ),
            /***/
            8314: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var ArrayBufferViewCore = __webpack_require__2(9918);
                var toLength = __webpack_require__2(4237);
                var toAbsoluteIndex = __webpack_require__2(3231);
                var speciesConstructor = __webpack_require__2(7942);
                var aTypedArray = ArrayBufferViewCore.aTypedArray;
                var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
                exportTypedArrayMethod("subarray", function subarray(begin, end) {
                  var O = aTypedArray(this);
                  var length = O.length;
                  var beginIndex = toAbsoluteIndex(begin, length);
                  return new (speciesConstructor(O, O.constructor))(
                    O.buffer,
                    O.byteOffset + beginIndex * O.BYTES_PER_ELEMENT,
                    toLength((end === void 0 ? length : toAbsoluteIndex(end, length)) - beginIndex)
                  );
                });
              }
            ),
            /***/
            556: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var global = __webpack_require__2(9859);
                var ArrayBufferViewCore = __webpack_require__2(9918);
                var fails = __webpack_require__2(4229);
                var Int8Array2 = global.Int8Array;
                var aTypedArray = ArrayBufferViewCore.aTypedArray;
                var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
                var $toLocaleString = [].toLocaleString;
                var $slice = [].slice;
                var TO_LOCALE_STRING_BUG = !!Int8Array2 && fails(function() {
                  $toLocaleString.call(new Int8Array2(1));
                });
                var FORCED = fails(function() {
                  return [1, 2].toLocaleString() != new Int8Array2([1, 2]).toLocaleString();
                }) || !fails(function() {
                  Int8Array2.prototype.toLocaleString.call([1, 2]);
                });
                exportTypedArrayMethod("toLocaleString", function toLocaleString() {
                  return $toLocaleString.apply(TO_LOCALE_STRING_BUG ? $slice.call(aTypedArray(this)) : aTypedArray(this), arguments);
                }, FORCED);
              }
            ),
            /***/
            9224: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var exportTypedArrayMethod = __webpack_require__2(9918).exportTypedArrayMethod;
                var fails = __webpack_require__2(4229);
                var global = __webpack_require__2(9859);
                var Uint8Array2 = global.Uint8Array;
                var Uint8ArrayPrototype = Uint8Array2 && Uint8Array2.prototype || {};
                var arrayToString = [].toString;
                var arrayJoin = [].join;
                if (fails(function() {
                  arrayToString.call({});
                })) {
                  arrayToString = function toString() {
                    return arrayJoin.call(this);
                  };
                }
                var IS_NOT_ARRAY_METHOD = Uint8ArrayPrototype.toString != arrayToString;
                exportTypedArrayMethod("toString", arrayToString, IS_NOT_ARRAY_METHOD);
              }
            ),
            /***/
            3675: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                var createTypedArrayConstructor = __webpack_require__2(2574);
                createTypedArrayConstructor("Uint8", function(init) {
                  return function Uint8Array2(data, byteOffset, length) {
                    return init(this, data, byteOffset, length);
                  };
                });
              }
            ),
            /***/
            1939: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                var global = __webpack_require__2(9859);
                var DOMIterables = __webpack_require__2(5694);
                var forEach = __webpack_require__2(6570);
                var createNonEnumerableProperty = __webpack_require__2(5762);
                for (var COLLECTION_NAME in DOMIterables) {
                  var Collection = global[COLLECTION_NAME];
                  var CollectionPrototype = Collection && Collection.prototype;
                  if (CollectionPrototype && CollectionPrototype.forEach !== forEach)
                    try {
                      createNonEnumerableProperty(CollectionPrototype, "forEach", forEach);
                    } catch (error) {
                      CollectionPrototype.forEach = forEach;
                    }
                }
              }
            ),
            /***/
            6886: (
              /***/
              function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
                var global = __webpack_require__2(9859);
                var DOMIterables = __webpack_require__2(5694);
                var ArrayIteratorMethods = __webpack_require__2(5735);
                var createNonEnumerableProperty = __webpack_require__2(5762);
                var wellKnownSymbol = __webpack_require__2(95);
                var ITERATOR = wellKnownSymbol("iterator");
                var TO_STRING_TAG = wellKnownSymbol("toStringTag");
                var ArrayValues = ArrayIteratorMethods.values;
                for (var COLLECTION_NAME in DOMIterables) {
                  var Collection = global[COLLECTION_NAME];
                  var CollectionPrototype = Collection && Collection.prototype;
                  if (CollectionPrototype) {
                    if (CollectionPrototype[ITERATOR] !== ArrayValues)
                      try {
                        createNonEnumerableProperty(CollectionPrototype, ITERATOR, ArrayValues);
                      } catch (error) {
                        CollectionPrototype[ITERATOR] = ArrayValues;
                      }
                    if (!CollectionPrototype[TO_STRING_TAG]) {
                      createNonEnumerableProperty(CollectionPrototype, TO_STRING_TAG, COLLECTION_NAME);
                    }
                    if (DOMIterables[COLLECTION_NAME])
                      for (var METHOD_NAME in ArrayIteratorMethods) {
                        if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME])
                          try {
                            createNonEnumerableProperty(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);
                          } catch (error) {
                            CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];
                          }
                      }
                  }
                }
              }
            )
            /******/
          };
          var __webpack_module_cache__ = {};
          function __webpack_require__(moduleId) {
            var cachedModule = __webpack_module_cache__[moduleId];
            if (cachedModule !== void 0) {
              return cachedModule.exports;
            }
            var module2 = __webpack_module_cache__[moduleId] = {
              /******/
              // no module.id needed
              /******/
              // no module.loaded needed
              /******/
              exports: {}
              /******/
            };
            __webpack_modules__[moduleId](module2, module2.exports, __webpack_require__);
            return module2.exports;
          }
          !function() {
            __webpack_require__.d = function(exports2, definition) {
              for (var key in definition) {
                if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports2, key)) {
                  Object.defineProperty(exports2, key, { enumerable: true, get: definition[key] });
                }
              }
            };
          }();
          !function() {
            __webpack_require__.g = function() {
              if (typeof globalThis === "object")
                return globalThis;
              try {
                return this || new Function("return this")();
              } catch (e) {
                if (typeof window === "object")
                  return window;
              }
            }();
          }();
          !function() {
            __webpack_require__.o = function(obj, prop) {
              return Object.prototype.hasOwnProperty.call(obj, prop);
            };
          }();
          !function() {
            __webpack_require__.r = function(exports2) {
              if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
                Object.defineProperty(exports2, Symbol.toStringTag, { value: "Module" });
              }
              Object.defineProperty(exports2, "__esModule", { value: true });
            };
          }();
          var __webpack_exports__ = {};
          !function() {
            "use strict";
          }();
          !function() {
            "use strict";
            __webpack_require__.d(__webpack_exports__, {
              "default": function() {
                return (
                  /* binding */
                  src_Chart
                );
              }
            });
            var label_namespaceObject = {};
            __webpack_require__.r(label_namespaceObject);
            __webpack_require__.d(label_namespaceObject, {
              "DEFAULT_LABEL_TEXT": function() {
                return DEFAULT_LABEL_TEXT;
              },
              "bubbleLabel": function() {
                return bubbleLabel;
              },
              "label": function() {
                return label;
              },
              "labelStyle": function() {
                return labelStyle;
              },
              "strokeLabelStyle": function() {
                return strokeLabelStyle;
              }
            });
            var basic_namespaceObject = {};
            __webpack_require__.r(basic_namespaceObject);
            __webpack_require__.d(basic_namespaceObject, {
              "arc": function() {
                return arc;
              },
              "circle": function() {
                return circle;
              },
              "clipRectArea": function() {
                return clipRectArea;
              },
              "line": function() {
                return line;
              },
              "pathRect": function() {
                return pathRect;
              },
              "rect": function() {
                return rect;
              }
            });
            var axis_namespaceObject = {};
            __webpack_require__.r(axis_namespaceObject);
            __webpack_require__.d(axis_namespaceObject, {
              "TICK_SIZE": function() {
                return TICK_SIZE;
              },
              "tick": function() {
                return tick;
              }
            });
            var dataLabel_namespaceObject = {};
            __webpack_require__.r(dataLabel_namespaceObject);
            __webpack_require__.d(dataLabel_namespaceObject, {
              "dataLabel": function() {
                return dataLabel;
              },
              "drawBubbleLabel": function() {
                return drawBubbleLabel;
              },
              "getBubbleArrowPoints": function() {
                return getBubbleArrowPoints;
              }
            });
            var spectrumLegend_namespaceObject = {};
            __webpack_require__.r(spectrumLegend_namespaceObject);
            __webpack_require__.d(spectrumLegend_namespaceObject, {
              "SPECTRUM_LEGEND_LABEL_HEIGHT": function() {
                return SPECTRUM_LEGEND_LABEL_HEIGHT;
              },
              "spectrumLegend": function() {
                return spectrumLegend;
              },
              "spectrumLegendBar": function() {
                return spectrumLegendBar;
              },
              "spectrumLegendTooltip": function() {
                return spectrumLegendTooltip;
              },
              "spectrumTooltip": function() {
                return spectrumTooltip;
              }
            });
            var polygon_namespaceObject = {};
            __webpack_require__.r(polygon_namespaceObject);
            __webpack_require__.d(polygon_namespaceObject, {
              "polygon": function() {
                return polygon;
              }
            });
            var scatterSeries_namespaceObject = {};
            __webpack_require__.r(scatterSeries_namespaceObject);
            __webpack_require__.d(scatterSeries_namespaceObject, {
              "scatterSeries": function() {
                return scatterSeries;
              }
            });
            var legend_namespaceObject = {};
            __webpack_require__.r(legend_namespaceObject);
            __webpack_require__.d(legend_namespaceObject, {
              "LEGEND_CHECKBOX_SIZE": function() {
                return LEGEND_CHECKBOX_SIZE;
              },
              "LEGEND_ICON_SIZE": function() {
                return LEGEND_ICON_SIZE;
              },
              "LEGEND_ITEM_MARGIN_X": function() {
                return LEGEND_ITEM_MARGIN_X;
              },
              "LEGEND_MARGIN_X": function() {
                return LEGEND_MARGIN_X;
              },
              "getLegendItemHeight": function() {
                return getLegendItemHeight;
              },
              "legend": function() {
                return legend;
              }
            });
            var brushes_lineSeries_namespaceObject = {};
            __webpack_require__.r(brushes_lineSeries_namespaceObject);
            __webpack_require__.d(brushes_lineSeries_namespaceObject, {
              "areaPoints": function() {
                return areaPoints;
              },
              "linePoints": function() {
                return linePoints;
              }
            });
            var brushes_exportMenu_namespaceObject = {};
            __webpack_require__.r(brushes_exportMenu_namespaceObject);
            __webpack_require__.d(brushes_exportMenu_namespaceObject, {
              "exportMenuButton": function() {
                return exportMenuButton;
              }
            });
            var brushes_resetButton_namespaceObject = {};
            __webpack_require__.r(brushes_resetButton_namespaceObject);
            __webpack_require__.d(brushes_resetButton_namespaceObject, {
              "backButton": function() {
                return backButton;
              },
              "resetButton": function() {
                return resetButton;
              }
            });
            var brushes_sector_namespaceObject = {};
            __webpack_require__.r(brushes_sector_namespaceObject);
            __webpack_require__.d(brushes_sector_namespaceObject, {
              "sector": function() {
                return sector;
              }
            });
            var brushes_circleLegend_namespaceObject = {};
            __webpack_require__.r(brushes_circleLegend_namespaceObject);
            __webpack_require__.d(brushes_circleLegend_namespaceObject, {
              "circleLegend": function() {
                return circleLegend;
              }
            });
            var boxPlot_namespaceObject = {};
            __webpack_require__.r(boxPlot_namespaceObject);
            __webpack_require__.d(boxPlot_namespaceObject, {
              "boxPlot": function() {
                return boxPlot;
              }
            });
            var gauge_namespaceObject = {};
            __webpack_require__.r(gauge_namespaceObject);
            __webpack_require__.d(gauge_namespaceObject, {
              "clockHand": function() {
                return clockHand;
              }
            });
            var es_object_set_prototype_of = __webpack_require__(2506);
            var es_object_get_prototype_of = __webpack_require__(6928);
            var es_reflect_construct = __webpack_require__(1229);
            var es_reflect_get = __webpack_require__(4565);
            var es_object_get_own_property_descriptor = __webpack_require__(8625);
            var es_object_keys = __webpack_require__(4769);
            var es_symbol = __webpack_require__(4115);
            var es_array_filter = __webpack_require__(5342);
            var web_dom_collections_for_each = __webpack_require__(1939);
            var es_object_get_own_property_descriptors = __webpack_require__(2775);
            var es_symbol_description = __webpack_require__(634);
            var es_object_to_string = __webpack_require__(8188);
            var es_symbol_iterator = __webpack_require__(796);
            var es_array_iterator = __webpack_require__(5735);
            var es_string_iterator = __webpack_require__(8673);
            var web_dom_collections_iterator = __webpack_require__(6886);
            var es_array_map = __webpack_require__(3450);
            var es_array_concat = __webpack_require__(8178);
            var es_array_from = __webpack_require__(7233);
            var es_array_slice = __webpack_require__(2501);
            var es_function_name = __webpack_require__(6936);
            var es_regexp_exec = __webpack_require__(7950);
            var es_string_split = __webpack_require__(8319);
            var es_array_splice = __webpack_require__(9805);
            var es_array_includes = __webpack_require__(9529);
            var es_array_find_index = __webpack_require__(9949);
            var es_number_constructor = __webpack_require__(1245);
            var es_array_find = __webpack_require__(9228);
            var es_number_to_fixed = __webpack_require__(1321);
            ;
            function ownKeys(object, enumerableOnly) {
              var keys = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object);
                if (enumerableOnly) {
                  symbols = symbols.filter(function(sym) {
                    return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                  });
                }
                keys.push.apply(keys, symbols);
              }
              return keys;
            }
            function _objectSpread(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i] != null ? arguments[i] : {};
                if (i % 2) {
                  ownKeys(Object(source), true).forEach(function(key) {
                    _defineProperty(target, key, source[key]);
                  });
                } else if (Object.getOwnPropertyDescriptors) {
                  Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                } else {
                  ownKeys(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  });
                }
              }
              return target;
            }
            function _defineProperty(obj, key, value) {
              if (key in obj) {
                Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
              } else {
                obj[key] = value;
              }
              return obj;
            }
            function _createForOfIteratorHelper(o, allowArrayLike) {
              var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
              if (!it) {
                if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
                  if (it)
                    o = it;
                  var i = 0;
                  var F = function F2() {
                  };
                  return { s: F, n: function n() {
                    if (i >= o.length)
                      return { done: true };
                    return { done: false, value: o[i++] };
                  }, e: function e(_e) {
                    throw _e;
                  }, f: F };
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
              }
              var normalCompletion = true, didErr = false, err;
              return { s: function s() {
                it = it.call(o);
              }, n: function n() {
                var step = it.next();
                normalCompletion = step.done;
                return step;
              }, e: function e(_e2) {
                didErr = true;
                err = _e2;
              }, f: function f() {
                try {
                  if (!normalCompletion && it.return != null)
                    it.return();
                } finally {
                  if (didErr)
                    throw err;
                }
              } };
            }
            function _unsupportedIterableToArray(o, minLen) {
              if (!o)
                return;
              if (typeof o === "string")
                return _arrayLikeToArray(o, minLen);
              var n = Object.prototype.toString.call(o).slice(8, -1);
              if (n === "Object" && o.constructor)
                n = o.constructor.name;
              if (n === "Map" || n === "Set")
                return Array.from(o);
              if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                return _arrayLikeToArray(o, minLen);
            }
            function _arrayLikeToArray(arr, len) {
              if (len == null || len > arr.length)
                len = arr.length;
              for (var i = 0, arr2 = new Array(len); i < len; i++) {
                arr2[i] = arr[i];
              }
              return arr2;
            }
            function _typeof(obj) {
              "@babel/helpers - typeof";
              if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                _typeof = function _typeof2(obj2) {
                  return typeof obj2;
                };
              } else {
                _typeof = function _typeof2(obj2) {
                  return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                };
              }
              return _typeof(obj);
            }
            function isExist(value) {
              return !isUndefined(value) && !isNull(value);
            }
            function isDate(value) {
              return value instanceof Date;
            }
            function isUndefined(value) {
              return typeof value === "undefined";
            }
            function isNull(value) {
              return value === null;
            }
            function isBoolean(value) {
              return typeof value === "boolean";
            }
            function isNumber(value) {
              return typeof value === "number";
            }
            function utils_isString(value) {
              return typeof value === "string";
            }
            function isInteger(value) {
              return isNumber(value) && isFinite(value) && Math.floor(value) === value;
            }
            function isObject(obj) {
              return _typeof(obj) === "object" && obj !== null;
            }
            function isFunction(value) {
              return typeof value === "function";
            }
            function forEach(obj, cb) {
              for (var _key in obj) {
                if (obj.hasOwnProperty(_key)) {
                  cb(obj[_key], _key);
                }
              }
            }
            function forEachArray(arr, iteratee) {
              var context = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
              for (var _index = 0, len = arr.length; _index < len; _index += 1) {
                if (iteratee.call(context, arr[_index], _index, arr) === false) {
                  break;
                }
              }
            }
            function range(start, stop, step) {
              if (isUndefined(stop)) {
                stop = start || 0;
                start = 0;
              }
              step = step || 1;
              var arr = [];
              if (stop) {
                var flag = step < 0 ? -1 : 1;
                stop *= flag;
                for (; start * flag < stop; start += step) {
                  arr.push(start);
                }
              }
              return arr;
            }
            function toArray(arrayLike) {
              var arr = [];
              try {
                arr = Array.prototype.slice.call(arrayLike);
              } catch (e) {
                forEachArray(arrayLike, function(value) {
                  arr.push(value);
                });
              }
              return arr;
            }
            function includes(arr, searchItem, searchIndex) {
              if (typeof searchIndex === "number" && arr[searchIndex] !== searchItem) {
                return false;
              }
              var _iterator = _createForOfIteratorHelper(arr), _step;
              try {
                for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                  var _item = _step.value;
                  if (_item === searchItem) {
                    return true;
                  }
                }
              } catch (err) {
                _iterator.e(err);
              } finally {
                _iterator.f();
              }
              return false;
            }
            function pick(obj) {
              for (var _len = arguments.length, propNames = new Array(_len > 1 ? _len - 1 : 0), _key2 = 1; _key2 < _len; _key2++) {
                propNames[_key2 - 1] = arguments[_key2];
              }
              var resultMap = {};
              Object.keys(obj).forEach(function(key) {
                if (includes(propNames, key)) {
                  resultMap[key] = obj[key];
                }
              });
              return resultMap;
            }
            function omit(obj) {
              for (var _len2 = arguments.length, propNames = new Array(_len2 > 1 ? _len2 - 1 : 0), _key3 = 1; _key3 < _len2; _key3++) {
                propNames[_key3 - 1] = arguments[_key3];
              }
              var resultMap = {};
              Object.keys(obj).forEach(function(key) {
                if (!includes(propNames, key)) {
                  resultMap[key] = obj[key];
                }
              });
              return resultMap;
            }
            function pickProperty(target, keys) {
              var length = keys.length;
              if (length) {
                for (var i = 0; i < length; i += 1) {
                  if (isUndefined(target) || isNull(target)) {
                    return null;
                  }
                  target = target[keys[i]];
                }
              }
              return target;
            }
            function pickPropertyWithMakeup(target, args) {
              var length = args.length;
              if (length) {
                for (var i = 0; i < length; i += 1) {
                  if (isUndefined(target[args[i]])) {
                    target[args[i]] = {};
                  }
                  target = target[args[i]];
                }
              }
              return target;
            }
            function debounce(fn) {
              var delay = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
              var timer;
              function debounced() {
                for (var _len3 = arguments.length, args = new Array(_len3), _key4 = 0; _key4 < _len3; _key4++) {
                  args[_key4] = arguments[_key4];
                }
                window.clearTimeout(timer);
                timer = window.setTimeout(function() {
                  fn.apply(void 0, args);
                }, delay);
              }
              return debounced;
            }
            function merge(target) {
              target = target || {};
              for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key5 = 1; _key5 < _len4; _key5++) {
                args[_key5 - 1] = arguments[_key5];
              }
              args.forEach(function(obj) {
                if (!obj) {
                  return;
                }
                forEach(obj, function(item, key) {
                  if (Object.prototype.toString.call(item) === "[object Object]") {
                    target[key] = merge(target[key], item);
                  } else {
                    target[key] = item;
                  }
                });
              });
              return target;
            }
            function throttle(fn) {
              var interval = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
              var base = null;
              var isLeading = true;
              var tick2 = function tick3() {
                fn.apply(void 0, arguments);
                base = null;
              };
              var stamp = 0;
              var debounced = debounce(tick2, interval);
              function throttled() {
                for (var _len5 = arguments.length, args = new Array(_len5), _key6 = 0; _key6 < _len5; _key6++) {
                  args[_key6] = arguments[_key6];
                }
                if (isLeading) {
                  tick2.apply(void 0, args);
                  isLeading = false;
                  return;
                }
                stamp = Number(/* @__PURE__ */ new Date());
                base = base || stamp;
                debounced(args);
                if (stamp - base >= interval) {
                  tick2(args);
                }
              }
              function reset() {
                isLeading = true;
                base = null;
              }
              throttled.reset = reset;
              return throttled;
            }
            function deepMergedCopy(targetObj, obj) {
              var resultObj = _objectSpread({}, targetObj);
              Object.keys(obj).forEach(function(prop) {
                if (isObject(resultObj[prop])) {
                  if (Array.isArray(obj[prop])) {
                    resultObj[prop] = deepCopyArray(obj[prop]);
                  } else if (resultObj.hasOwnProperty(prop)) {
                    resultObj[prop] = deepMergedCopy(resultObj[prop], obj[prop]);
                  } else {
                    resultObj[prop] = deepCopy(obj[prop]);
                  }
                } else {
                  resultObj[prop] = obj[prop];
                }
              });
              return resultObj;
            }
            function deepCopyArray(items) {
              return items.map(function(item) {
                if (isObject(item)) {
                  return Array.isArray(item) ? deepCopyArray(item) : deepCopy(item);
                }
                return item;
              });
            }
            function deepCopy(obj) {
              var resultObj = {};
              var keys = Object.keys(obj);
              if (!keys.length) {
                return obj;
              }
              keys.forEach(function(prop) {
                if (isObject(obj[prop])) {
                  resultObj[prop] = Array.isArray(obj[prop]) ? deepCopyArray(obj[prop]) : deepCopy(obj[prop]);
                } else {
                  resultObj[prop] = obj[prop];
                }
              });
              return resultObj;
            }
            function sortCategories(x, y) {
              return isInteger(x) ? Number(x) - Number(y) : new Date(x).getTime() - new Date(y).getTime();
            }
            function sortNumber(x, y) {
              return x - y;
            }
            function first(items) {
              return items.length ? items[0] : void 0;
            }
            function last(items) {
              return items.length ? items[items.length - 1] : void 0;
            }
            function hasNegative() {
              var values = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
              return values.some(function(value) {
                return Number(value) < 0;
              });
            }
            function sum(items) {
              return items.reduce(function(a, b) {
                return a + b;
              }, 0);
            }
            function hasPositiveOnly(values) {
              return values.every(function(value) {
                return Number(value) >= 0;
              });
            }
            function hasNegativeOnly(values) {
              return values.every(function(value) {
                return Number(value) <= 0;
              });
            }
            function getFirstValidValue(values) {
              return values === null || values === void 0 ? void 0 : values.find(function(value) {
                return value !== null;
              });
            }
            function utils_getPercentageValue(text) {
              return Number(text.substr(0, text.length - 1));
            }
            function calculateSizeWithPercentString(size, value) {
              return isNumber(value) ? value : Number((size * utils_getPercentageValue(value) / 100).toFixed(2));
            }
            function getInitialSize(size) {
              return isNumber(size) ? size : 0;
            }
            function isAutoValue(value) {
              return value === "auto";
            }
            ;
            var message = {
              SELECT_SERIES_API_SELECTABLE_ERROR: "It works only when the selectable option is true.",
              SELECT_SERIES_API_INDEX_ERROR: "The index value is invalid.",
              ALREADY_OBSERVABLE_ERROR: "Source object is observable already",
              CIRCLE_LEGEND_RENDER_ERROR: "circleLegend is only possible when bubble series is present",
              noDataError: function noDataError(chartName) {
                return "There's no ".concat(chartName, " data!");
              },
              noBrushError: function noBrushError(brushName) {
                return "Brush don't exist in painter: ".concat(brushName);
              },
              DASH_SEGMENTS_UNAVAILABLE_ERROR: "DashSegments option is available from IE11 and above.",
              SERIES_INDEX_ERROR: "The seriesIndex value is invalid",
              AUTO_LAYOUT_CONTAINER_SIZE_ERROR: 'To use auto layout, the width or height of the container must be specified as a value such as "%" or "vh", "vw".'
            };
            ;
            function reactive_defineProperty(obj, key, value) {
              if (key in obj) {
                Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
              } else {
                obj[key] = value;
              }
              return obj;
            }
            function reactive_typeof(obj) {
              "@babel/helpers - typeof";
              if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                reactive_typeof = function _typeof2(obj2) {
                  return typeof obj2;
                };
              } else {
                reactive_typeof = function _typeof2(obj2) {
                  return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                };
              }
              return reactive_typeof(obj);
            }
            var currentCollectorObserver = null;
            var currentRunningObserver = null;
            var observerCallCue = [];
            var doingInvisibleWork = false;
            function reactive_observe(fn) {
              var observer = function observer2() {
                if (currentRunningObserver === observer2) {
                  return;
                }
                if (doingInvisibleWork || !isNull(currentRunningObserver)) {
                  if (observerCallCue.includes(observer2)) {
                    observerCallCue.splice(observerCallCue.indexOf(observer2), 1);
                  }
                  observerCallCue.push(observer2);
                } else if (isNull(currentRunningObserver)) {
                  currentRunningObserver = observer2;
                  fn();
                  currentRunningObserver = null;
                  digestObserverCallCue();
                }
              };
              observer.deps = [];
              currentCollectorObserver = observer;
              currentCollectorObserver();
              currentCollectorObserver = null;
              return function() {
                observer.deps.forEach(function(dep) {
                  var index = dep.findIndex(function(ob) {
                    return ob === observer;
                  });
                  dep.splice(index, 1);
                });
                observer.deps = [];
              };
            }
            function digestObserverCallCue() {
              if (observerCallCue.length) {
                var nextObserver = observerCallCue.shift();
                if (nextObserver) {
                  nextObserver();
                }
              }
            }
            function isObservable(target) {
              return reactive_typeof(target) === "object" && target.__toastUIChartOb__;
            }
            function reactive_observable(target) {
              var source = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : target;
              if (isObservable(source)) {
                throw new Error(message.ALREADY_OBSERVABLE_ERROR);
              }
              if (!isObservable(target)) {
                Object.defineProperty(target, "__toastUIChartOb__", {
                  enumerable: false
                });
              }
              var _loop = function _loop2(key2) {
                if (!source.hasOwnProperty(key2)) {
                  return "continue";
                }
                var obs = [];
                var value = source[key2];
                var descriptor = Object.getOwnPropertyDescriptor(source, key2);
                var preGetter = descriptor && descriptor.get;
                var preSetter = descriptor && descriptor.set;
                Object.defineProperty(target, key2, {
                  configurable: true,
                  enumerable: true,
                  get: function get() {
                    if (currentCollectorObserver === observableInfo) {
                      return {
                        target,
                        key: key2,
                        value,
                        obs
                      };
                    }
                    if (!doingInvisibleWork && currentCollectorObserver && !obs.includes(currentCollectorObserver)) {
                      obs.push(currentCollectorObserver);
                      currentCollectorObserver.deps.push(obs);
                    }
                    return value;
                  },
                  set: function set(v) {
                    var prevValue = value;
                    if (preSetter) {
                      preSetter.call(target, v);
                      value = preGetter ? preGetter.call(target) : target[key2];
                    } else {
                      value = v;
                    }
                    if (prevValue !== value) {
                      invokeObs(obs);
                    }
                  }
                });
                if (reactive_typeof(target[key2]) === "object" && !Array.isArray(target[key2])) {
                  reactive_observable(target[key2]);
                }
              };
              for (var key in source) {
                var _ret = _loop(key);
                if (_ret === "continue")
                  continue;
              }
              return target;
            }
            function setValue(target, key, source) {
              return reactive_observable(target, reactive_defineProperty({}, key, source));
            }
            function extend(target, source) {
              if (isObservable(source)) {
                throw new Error(message.ALREADY_OBSERVABLE_ERROR);
              }
              return reactive_observable(target, source);
            }
            function reactive_notify(target, key) {
              var obInfo = observableInfo(target, key);
              if (obInfo) {
                invokeObs(obInfo.obs);
              }
            }
            function invisibleWork(fn) {
              doingInvisibleWork = true;
              fn();
              doingInvisibleWork = false;
              digestObserverCallCue();
            }
            function reactive_notifyByPath(holder, namePath) {
              var splited = namePath.split(".");
              var key = splited.splice(splited.length - 1, 1)[0];
              var target = pickProperty(holder, splited);
              if (target) {
                reactive_notify(target, key);
              }
            }
            function invokeObs(obs) {
              obs.forEach(function(ob) {
                return ob();
              });
            }
            function observableInfo(target, key) {
              currentCollectorObserver = observableInfo;
              var obInfo = target[key];
              currentCollectorObserver = null;
              if (reactive_typeof(obInfo) === "object" && obInfo.hasOwnProperty("target") && obInfo.hasOwnProperty("obs")) {
                return obInfo;
              }
              return null;
            }
            function computed(target, key, fn) {
              var cachedValue;
              var computedBox = {};
              Object.defineProperty(computedBox, key, {
                configurable: true,
                enumerable: true,
                get: function get() {
                  return cachedValue;
                }
              });
              extend(target, computedBox);
              reactive_observe(function() {
                var prevValue = cachedValue;
                cachedValue = fn();
                if (prevValue !== cachedValue) {
                  target[key] = cachedValue;
                }
              });
            }
            function watch(holder, path, fn) {
              var splited = path.split(".");
              var key = splited.splice(splited.length - 1, 1)[0];
              var target = pickProperty(holder, splited);
              if (!target) {
                return null;
              }
              var obInfo = observableInfo(target, key);
              if (!obInfo) {
                return null;
              }
              var watcher = function watcher2() {
                fn(target[key]);
              };
              obInfo.obs.push(watcher);
              return function() {
                var index = obInfo.obs.findIndex(function(ob) {
                  return ob === watcher;
                });
                if (index > -1) {
                  obInfo.obs.splice(index, 1);
                }
              };
            }
            function makeObservableObjectToNormal(obj) {
              return JSON.parse(JSON.stringify(obj));
            }
            ;
            function store_typeof(obj) {
              "@babel/helpers - typeof";
              if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                store_typeof = function _typeof2(obj2) {
                  return typeof obj2;
                };
              } else {
                store_typeof = function _typeof2(obj2) {
                  return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                };
              }
              return store_typeof(obj);
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function _defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            function _createClass(Constructor, protoProps, staticProps) {
              if (protoProps)
                _defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                _defineProperties(Constructor, staticProps);
              return Constructor;
            }
            function store_defineProperty(obj, key, value) {
              if (key in obj) {
                Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
              } else {
                obj[key] = value;
              }
              return obj;
            }
            var Store = function() {
              function Store2(initStoreState) {
                _classCallCheck(this, Store2);
                store_defineProperty(this, "state", void 0);
                store_defineProperty(this, "initStoreState", void 0);
                store_defineProperty(this, "computed", {});
                store_defineProperty(this, "actions", {});
                this.initStoreState = deepCopy(initStoreState);
                this.setRootState({});
              }
              _createClass(Store2, [{
                key: "setRootState",
                value: function setRootState(state) {
                  reactive_observable(state);
                  this.state = state;
                }
              }, {
                key: "setComputed",
                value: function setComputed(namePath, fn) {
                  var holder = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.computed;
                  var splited = namePath.split(".");
                  var key = splited.splice(splited.length - 1, 1)[0];
                  var target = pickPropertyWithMakeup(holder, splited);
                  computed(target, key, fn.bind(null, this.state, this.computed));
                }
              }, {
                key: "setWatch",
                value: function setWatch(namePath, fn) {
                  return watch(this, namePath, fn);
                }
              }, {
                key: "setAction",
                value: function setAction(name, fn) {
                  this.actions[name] = fn;
                }
              }, {
                key: "dispatch",
                value: function dispatch(name, payload, isInvisible) {
                  var _this = this;
                  if (isInvisible) {
                    invisibleWork(function() {
                      _this.actions[name].call(_this, _this, payload);
                    });
                  } else {
                    this.actions[name].call(this, this, payload);
                  }
                }
              }, {
                key: "observe",
                value: function observe(fn) {
                  return reactive_observe(fn.bind(this, this.state, this.computed));
                }
              }, {
                key: "observable",
                value: function observable(target) {
                  return reactive_observable(target);
                }
              }, {
                key: "notifyByPath",
                value: function notifyByPath(namePath) {
                  reactive_notifyByPath(this, namePath);
                }
              }, {
                key: "notify",
                value: function notify(target, key) {
                  reactive_notify(target, key);
                }
              }, {
                key: "setModule",
                value: function setModule(name, param) {
                  var _this2 = this;
                  if (!param) {
                    param = name;
                    name = param.name;
                  }
                  if (param.state) {
                    var moduleState = typeof param.state === "function" ? param.state(this.initStoreState) : param.state;
                    store_extend(this.state, moduleState);
                  }
                  if (param.computed) {
                    forEach(param.computed, function(item, key) {
                      _this2.setComputed(key, item);
                    });
                  }
                  if (param.watch) {
                    forEach(param.watch, function(item, key) {
                      _this2.setWatch(key, item);
                    });
                  }
                  if (param.action) {
                    forEach(param.action, function(item, key) {
                      _this2.setAction(key, item);
                    });
                  }
                  if (param.observe) {
                    forEach(param.observe, function(item) {
                      _this2.observe(item);
                    });
                  }
                }
              }, {
                key: "setValue",
                value: function setValue2(target, key, source) {
                  store_extend(target, store_defineProperty({}, key, source));
                }
              }]);
              return Store2;
            }();
            function store_extend(target, source) {
              var newItems = {};
              for (var k in source) {
                if (!source.hasOwnProperty(k)) {
                  continue;
                }
                if (!isUndefined(target[k])) {
                  if (store_typeof(source[k]) === "object" && !Array.isArray(source[k])) {
                    store_extend(target[k], source[k]);
                  } else {
                    target[k] = source[k];
                  }
                } else {
                  newItems[k] = source[k];
                }
              }
              if (Object.keys(newItems).length) {
                extend(target, newItems);
              }
            }
            ;
            function root_ownKeys(object, enumerableOnly) {
              var keys = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object);
                if (enumerableOnly) {
                  symbols = symbols.filter(function(sym) {
                    return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                  });
                }
                keys.push.apply(keys, symbols);
              }
              return keys;
            }
            function root_objectSpread(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i] != null ? arguments[i] : {};
                if (i % 2) {
                  root_ownKeys(Object(source), true).forEach(function(key) {
                    root_defineProperty(target, key, source[key]);
                  });
                } else if (Object.getOwnPropertyDescriptors) {
                  Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                } else {
                  root_ownKeys(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  });
                }
              }
              return target;
            }
            function root_defineProperty(obj, key, value) {
              if (key in obj) {
                Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
              } else {
                obj[key] = value;
              }
              return obj;
            }
            function initialSize(containerEl, _ref) {
              var width = _ref.width, height = _ref.height;
              return {
                width: width === 0 ? containerEl.offsetWidth : width,
                height: height === 0 ? containerEl.offsetHeight : height
              };
            }
            var root = {
              name: "root",
              state: function state(_ref2) {
                var _options$chart, _options$chart2, _options$chart3, _options$chart4;
                var options2 = _ref2.options;
                return {
                  chart: root_objectSpread(root_objectSpread({}, options2.chart), {}, {
                    width: getInitialSize(options2 === null || options2 === void 0 ? void 0 : (_options$chart = options2.chart) === null || _options$chart === void 0 ? void 0 : _options$chart.width),
                    height: getInitialSize(options2 === null || options2 === void 0 ? void 0 : (_options$chart2 = options2.chart) === null || _options$chart2 === void 0 ? void 0 : _options$chart2.height)
                  }),
                  usingContainerSize: {
                    width: isAutoValue(options2 === null || options2 === void 0 ? void 0 : (_options$chart3 = options2.chart) === null || _options$chart3 === void 0 ? void 0 : _options$chart3.width),
                    height: isAutoValue(options2 === null || options2 === void 0 ? void 0 : (_options$chart4 = options2.chart) === null || _options$chart4 === void 0 ? void 0 : _options$chart4.height)
                  },
                  container: {}
                };
              },
              action: {
                setChartSize: function setChartSize(_ref3, size) {
                  var state = _ref3.state;
                  state.chart.width = size.width;
                  state.chart.height = size.height;
                  this.notify(state, "chart");
                },
                initChartSize: function initChartSize(_ref4, containerEl) {
                  var _this = this;
                  var state = _ref4.state;
                  var _state$chart = state.chart, width = _state$chart.width, height = _state$chart.height;
                  if (width === 0 || height === 0) {
                    if (containerEl.parentNode) {
                      this.dispatch("setChartSize", initialSize(containerEl, {
                        width,
                        height
                      }));
                    } else {
                      setTimeout(function() {
                        _this.dispatch("setChartSize", initialSize(containerEl, {
                          width,
                          height
                        }));
                      }, 0);
                    }
                  }
                },
                setUsingContainerSize: function setUsingContainerSize(_ref5, _ref6) {
                  var state = _ref5.state;
                  var width = _ref6.width, height = _ref6.height;
                  state.usingContainerSize.width = width;
                  state.usingContainerSize.height = height;
                }
              }
            };
            var store_root = root;
            var es_set = __webpack_require__(3244);
            var es_string_match = __webpack_require__(4069);
            var es_array_fill = __webpack_require__(2656);
            var es_string_replace = __webpack_require__(5940);
            var es_regexp_to_string = __webpack_require__(8233);
            ;
            function _slicedToArray(arr, i) {
              return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || color_unsupportedIterableToArray(arr, i) || _nonIterableRest();
            }
            function _nonIterableRest() {
              throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            function color_unsupportedIterableToArray(o, minLen) {
              if (!o)
                return;
              if (typeof o === "string")
                return color_arrayLikeToArray(o, minLen);
              var n = Object.prototype.toString.call(o).slice(8, -1);
              if (n === "Object" && o.constructor)
                n = o.constructor.name;
              if (n === "Map" || n === "Set")
                return Array.from(o);
              if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                return color_arrayLikeToArray(o, minLen);
            }
            function color_arrayLikeToArray(arr, len) {
              if (len == null || len > arr.length)
                len = arr.length;
              for (var i = 0, arr2 = new Array(len); i < len; i++) {
                arr2[i] = arr[i];
              }
              return arr2;
            }
            function _iterableToArrayLimit(arr, i) {
              var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]);
              if (_i == null)
                return;
              var _arr = [];
              var _n = true;
              var _d = false;
              var _s, _e;
              try {
                for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
                  _arr.push(_s.value);
                  if (i && _arr.length === i)
                    break;
                }
              } catch (err) {
                _d = true;
                _e = err;
              } finally {
                try {
                  if (!_n && _i["return"] != null)
                    _i["return"]();
                } finally {
                  if (_d)
                    throw _e;
                }
              }
              return _arr;
            }
            function _arrayWithHoles(arr) {
              if (Array.isArray(arr))
                return arr;
            }
            var hexRX = /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i;
            var rgbRX = /rgb\((\d{1,3}), ?(\d{1,3}), ?(\d{1,3})\)/;
            var rgbaRX = /rgba\((\d{1,3}), ?(\d{1,3}), ?(\d{1,3}), ?(1|0?\.?\d+)\)/;
            var colorMap = {
              aliceblue: "#f0f8ff",
              antiquewhite: "#faebd7",
              aqua: "#00ffff",
              aquamarine: "#7fffd4",
              azure: "#f0ffff",
              beige: "#f5f5dc",
              bisque: "#ffe4c4",
              black: "#000000",
              blanchedalmond: "#ffebcd",
              blue: "#0000ff",
              blueviolet: "#8a2be2",
              brown: "#a52a2a",
              burlywood: "#deb887",
              cadetblue: "#5f9ea0",
              chartreuse: "#7fff00",
              chocolate: "#d2691e",
              coral: "#ff7f50",
              cornflowerblue: "#6495ed",
              cornsilk: "#fff8dc",
              crimson: "#dc143c",
              cyan: "#00ffff",
              darkblue: "#00008b",
              darkcyan: "#008b8b",
              darkgoldenrod: "#b8860b",
              darkgray: "#a9a9a9",
              darkgreen: "#006400",
              darkkhaki: "#bdb76b",
              darkmagenta: "#8b008b",
              darkolivegreen: "#556b2f",
              darkorange: "#ff8c00",
              darkorchid: "#9932cc",
              darkred: "#8b0000",
              darksalmon: "#e9967a",
              darkseagreen: "#8fbc8f",
              darkslateblue: "#483d8b",
              darkslategray: "#2f4f4f",
              darkturquoise: "#00ced1",
              darkviolet: "#9400d3",
              deeppink: "#ff1493",
              deepskyblue: "#00bfff",
              dimgray: "#696969",
              dodgerblue: "#1e90ff",
              firebrick: "#b22222",
              floralwhite: "#fffaf0",
              forestgreen: "#228b22",
              fuchsia: "#ff00ff",
              gainsboro: "#dcdcdc",
              ghostwhite: "#f8f8ff",
              gold: "#ffd700",
              goldenrod: "#daa520",
              gray: "#808080",
              green: "#008000",
              greenyellow: "#adff2f",
              honeydew: "#f0fff0",
              hotpink: "#ff69b4",
              indianred: "#cd5c5c",
              indigo: "#4b0082",
              ivory: "#fffff0",
              khaki: "#f0e68c",
              lavender: "#e6e6fa",
              lavenderblush: "#fff0f5",
              lawngreen: "#7cfc00",
              lemonchiffon: "#fffacd",
              lightblue: "#add8e6",
              lightcoral: "#f08080",
              lightcyan: "#e0ffff",
              lightgoldenrodyellow: "#fafad2",
              lightgrey: "#d3d3d3",
              lightgreen: "#90ee90",
              lightpink: "#ffb6c1",
              lightsalmon: "#ffa07a",
              lightseagreen: "#20b2aa",
              lightskyblue: "#87cefa",
              lightslategray: "#778899",
              lightsteelblue: "#b0c4de",
              lightyellow: "#ffffe0",
              lime: "#00ff00",
              limegreen: "#32cd32",
              linen: "#faf0e6",
              magenta: "#ff00ff",
              maroon: "#800000",
              mediumaquamarine: "#66cdaa",
              mediumblue: "#0000cd",
              mediumorchid: "#ba55d3",
              mediumpurple: "#9370d8",
              mediumseagreen: "#3cb371",
              mediumslateblue: "#7b68ee",
              mediumspringgreen: "#00fa9a",
              mediumturquoise: "#48d1cc",
              mediumvioletred: "#c71585",
              midnightblue: "#191970",
              mintcream: "#f5fffa",
              mistyrose: "#ffe4e1",
              moccasin: "#ffe4b5",
              navajowhite: "#ffdead",
              navy: "#000080",
              oldlace: "#fdf5e6",
              olive: "#808000",
              olivedrab: "#6b8e23",
              orange: "#ffa500",
              orangered: "#ff4500",
              orchid: "#da70d6",
              palegoldenrod: "#eee8aa",
              palegreen: "#98fb98",
              paleturquoise: "#afeeee",
              palevioletred: "#d87093",
              papayawhip: "#ffefd5",
              peachpuff: "#ffdab9",
              peru: "#cd853f",
              pink: "#ffc0cb",
              plum: "#dda0dd",
              powderblue: "#b0e0e6",
              purple: "#800080",
              red: "#ff0000",
              rosybrown: "#bc8f8f",
              royalblue: "#4169e1",
              saddlebrown: "#8b4513",
              salmon: "#fa8072",
              sandybrown: "#f4a460",
              seagreen: "#2e8b57",
              seashell: "#fff5ee",
              sienna: "#a0522d",
              silver: "#c0c0c0",
              skyblue: "#87ceeb",
              slateblue: "#6a5acd",
              slategray: "#708090",
              snow: "#fffafa",
              springgreen: "#00ff7f",
              steelblue: "#4682b4",
              tan: "#d2b48c",
              teal: "#008080",
              thistle: "#d8bfd8",
              tomato: "#ff6347",
              turquoise: "#40e0d0",
              violet: "#ee82ee",
              wheat: "#f5deb3",
              white: "#ffffff",
              whitesmoke: "#f5f5f5",
              yellow: "#ffff00",
              yellowgreen: "#9acd32"
            };
            function leadingZero(number, length) {
              if (number.length > length) {
                return number;
              }
              var res = number;
              range(0, length - 1).forEach(function(_) {
                res = "0" + res;
              });
              return res.slice(length * -1);
            }
            function isValidRGB(str) {
              return hexRX.test(str);
            }
            function colorNameToHex(colorName) {
              return colorMap[colorName.toLowerCase()] || colorName;
            }
            function hexToRGB(str) {
              var hexStr = colorNameToHex(str);
              if (!isValidRGB(hexStr)) {
                return false;
              }
              return hexStr.replace(/^#?([a-f\d])([a-f\d])([a-f\d])$/i, function(m, r, g, b) {
                return "#" + r + r + g + g + b + b;
              }).substring(1).match(/.{2}/g).map(function(x) {
                return parseInt(x, 16);
              });
            }
            function rgbToHEX(r, g, b) {
              var hexPreFix = "#";
              var hexStr = hexPreFix + leadingZero(r.toString(16), 2) + leadingZero(g.toString(16), 2) + leadingZero(b.toString(16), 2);
              if (isValidRGB(hexStr)) {
                return hexStr;
              }
              return false;
            }
            function getRGBA(str, opacity) {
              var hexStr = colorNameToHex(str);
              if (isValidRGB(hexStr)) {
                var _ref = hexToRGB(hexStr), _ref2 = _slicedToArray(_ref, 3), r = _ref2[0], g = _ref2[1], b = _ref2[2];
                return "rgba(".concat(r, ", ").concat(g, ", ").concat(b, ", ").concat(opacity, ")");
              }
              if (rgbRX.test(str)) {
                var match = rgbRX.exec(str);
                return "rgba(".concat(match[1], ", ").concat(match[2], ", ").concat(match[3], ", ").concat(opacity, ")");
              }
              if (rgbaRX.test(str)) {
                var _match = rgbaRX.exec(str);
                return "rgba(".concat(_match[1], ", ").concat(_match[2], ", ").concat(_match[3], ", ").concat(opacity, ")");
              }
              return str;
            }
            function getAlpha(str) {
              if (rgbaRX.test(str)) {
                var match = rgbaRX.exec(str);
                return Number(match[4]);
              }
              return 1;
            }
            function rgba(color) {
              var opacity = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
              var alpha = getAlpha(color) * opacity;
              return getRGBA(color, alpha);
            }
            ;
            function style_ownKeys(object, enumerableOnly) {
              var keys = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object);
                if (enumerableOnly) {
                  symbols = symbols.filter(function(sym) {
                    return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                  });
                }
                keys.push.apply(keys, symbols);
              }
              return keys;
            }
            function style_objectSpread(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i] != null ? arguments[i] : {};
                if (i % 2) {
                  style_ownKeys(Object(source), true).forEach(function(key) {
                    style_defineProperty(target, key, source[key]);
                  });
                } else if (Object.getOwnPropertyDescriptors) {
                  Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                } else {
                  style_ownKeys(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  });
                }
              }
              return target;
            }
            function style_defineProperty(obj, key, value) {
              if (key in obj) {
                Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
              } else {
                obj[key] = value;
              }
              return obj;
            }
            function makeStyleObj(style, styleSet) {
              return style.reduce(function(acc, curValue) {
                if (utils_isString(curValue)) {
                  return style_objectSpread(style_objectSpread({}, acc), styleSet[curValue]);
                }
                return style_objectSpread(style_objectSpread({}, acc), curValue);
              }, {});
            }
            function getTranslateString(x, y) {
              return "translate(".concat(x, "px,").concat(y, "px)");
            }
            function getTitleFontString(fontTheme) {
              var fontFamily = fontTheme.fontFamily, fontSize = fontTheme.fontSize, fontWeight = fontTheme.fontWeight;
              return "".concat(fontWeight, " ").concat(fontSize, "px ").concat(fontFamily);
            }
            function getFontStyleString(theme2) {
              var color = theme2.color, fontSize = theme2.fontSize, fontFamily = theme2.fontFamily, fontWeight = theme2.fontWeight;
              return "font-weight: ".concat(fontWeight, "; font-family: ").concat(fontFamily, "; font-size: ").concat(fontSize, "px; color: ").concat(color, ";");
            }
            function getFont(theme2) {
              return getTitleFontString(pick(theme2, "fontFamily", "fontWeight", "fontSize"));
            }
            function setLineDash(ctx2, dashSegments) {
              if (ctx2.setLineDash) {
                ctx2.setLineDash(dashSegments);
              }
            }
            function getBoxTypeSeriesPadding(tickDistance) {
              return Math.floor(tickDistance * 0.15);
            }
            function fillStyle(ctx2, fillOption) {
              ctx2.fillStyle = fillOption;
              ctx2.fill();
            }
            function strokeWithOptions(ctx2, style) {
              var lineWidth = style.lineWidth, strokeStyle = style.strokeStyle;
              if (strokeStyle) {
                ctx2.strokeStyle = strokeStyle;
              }
              if (lineWidth) {
                ctx2.lineWidth = lineWidth;
              }
              if (ctx2.lineWidth && getAlpha(String(ctx2.strokeStyle))) {
                ctx2.stroke();
              }
            }
            ;
            var DEFAULT_LABEL_TEXT = "normal 11px Arial";
            var labelStyle = {
              default: {
                font: DEFAULT_LABEL_TEXT,
                fillStyle: "#333333",
                textAlign: "left",
                textBaseline: "middle"
              },
              title: {
                textBaseline: "top"
              },
              axisTitle: {
                textBaseline: "top"
              },
              rectLabel: {
                font: DEFAULT_LABEL_TEXT,
                fillStyle: "rgba(0, 0, 0, 0.3)",
                textAlign: "center",
                textBaseline: "middle"
              }
            };
            var strokeLabelStyle = {
              none: {
                lineWidth: 1,
                strokeStyle: "rgba(255, 255, 255, 0)"
              },
              stroke: {
                lineWidth: 4,
                strokeStyle: "rgba(255, 255, 255, 0.5)"
              }
            };
            function label(ctx2, labelModel) {
              var x = labelModel.x, y = labelModel.y, text = labelModel.text, style = labelModel.style, stroke = labelModel.stroke, opacity = labelModel.opacity, radian = labelModel.radian, rotationPosition = labelModel.rotationPosition;
              if (style) {
                var styleObj = makeStyleObj(style, labelStyle);
                Object.keys(styleObj).forEach(function(key) {
                  ctx2[key] = key === "fillStyle" && isNumber(opacity) ? rgba(styleObj[key], opacity) : styleObj[key];
                });
              }
              ctx2.save();
              if (radian) {
                var _rotationPosition$x, _rotationPosition$y, _rotationPosition$x2, _rotationPosition$y2;
                ctx2.translate((_rotationPosition$x = rotationPosition === null || rotationPosition === void 0 ? void 0 : rotationPosition.x) !== null && _rotationPosition$x !== void 0 ? _rotationPosition$x : x, (_rotationPosition$y = rotationPosition === null || rotationPosition === void 0 ? void 0 : rotationPosition.y) !== null && _rotationPosition$y !== void 0 ? _rotationPosition$y : y);
                ctx2.rotate(radian);
                ctx2.translate(-((_rotationPosition$x2 = rotationPosition === null || rotationPosition === void 0 ? void 0 : rotationPosition.x) !== null && _rotationPosition$x2 !== void 0 ? _rotationPosition$x2 : x), -((_rotationPosition$y2 = rotationPosition === null || rotationPosition === void 0 ? void 0 : rotationPosition.y) !== null && _rotationPosition$y2 !== void 0 ? _rotationPosition$y2 : y));
              }
              if (stroke) {
                var strokeStyleObj = makeStyleObj(stroke, strokeLabelStyle);
                var strokeStyleKeys = Object.keys(strokeStyleObj);
                strokeStyleKeys.forEach(function(key) {
                  ctx2[key] = key === "strokeStyle" && isNumber(opacity) ? rgba(strokeStyleObj[key], opacity) : strokeStyleObj[key];
                });
                if (strokeStyleKeys.length) {
                  ctx2.strokeText(text, x, y);
                }
              }
              ctx2.fillText(text, x, y);
              ctx2.restore();
            }
            var textBubbleStyle = {
              shadow: {
                shadowColor: "rgba(0, 0, 0, 0.3)",
                shadowOffsetY: 2,
                shadowBlur: 4
              }
            };
            function bubbleLabel(ctx2, model) {
              var _model$radian = model.radian, radian = _model$radian === void 0 ? 0 : _model$radian, rotationPosition = model.rotationPosition, _model$bubble = model.bubble, x = _model$bubble.x, y = _model$bubble.y, width = _model$bubble.width, height = _model$bubble.height, _model$bubble$radius = _model$bubble.radius, radius = _model$bubble$radius === void 0 ? 0 : _model$bubble$radius, _model$bubble$lineWid = _model$bubble.lineWidth, lineWidth = _model$bubble$lineWid === void 0 ? 1 : _model$bubble$lineWid, direction = _model$bubble.direction, _model$bubble$points = _model$bubble.points, points = _model$bubble$points === void 0 ? [] : _model$bubble$points, _model$bubble$fill = _model$bubble.fill, fill = _model$bubble$fill === void 0 ? "#fff" : _model$bubble$fill, _model$bubble$strokeS = _model$bubble.strokeStyle, strokeStyle = _model$bubble$strokeS === void 0 ? "rgba(0, 0, 0, 0)" : _model$bubble$strokeS, _model$bubble$style = _model$bubble.style, bubbleStyle = _model$bubble$style === void 0 ? null : _model$bubble$style;
              if (width > 0 && height > 0) {
                var _rotationPosition$x3, _rotationPosition$y3;
                drawBubble(ctx2, {
                  x,
                  y,
                  radius,
                  width,
                  height,
                  style: bubbleStyle,
                  fill,
                  strokeStyle,
                  lineWidth,
                  direction,
                  points,
                  radian,
                  rotationPosition: {
                    x: (_rotationPosition$x3 = rotationPosition === null || rotationPosition === void 0 ? void 0 : rotationPosition.x) !== null && _rotationPosition$x3 !== void 0 ? _rotationPosition$x3 : x,
                    y: (_rotationPosition$y3 = rotationPosition === null || rotationPosition === void 0 ? void 0 : rotationPosition.y) !== null && _rotationPosition$y3 !== void 0 ? _rotationPosition$y3 : y
                  }
                });
              }
              if (model.label.text) {
                var _model$label = model.label, labelX = _model$label.x, labelY = _model$label.y, text = _model$label.text, _model$label$strokeSt = _model$label.strokeStyle, labelStrokeColor = _model$label$strokeSt === void 0 ? "rgba(0, 0, 0, 0)" : _model$label$strokeSt, style = _model$label.style;
                ctx2.shadowColor = "rgba(0, 0, 0, 0)";
                label(ctx2, {
                  type: "label",
                  x: labelX,
                  y: labelY,
                  text,
                  style,
                  stroke: [{
                    strokeStyle: labelStrokeColor
                  }],
                  radian,
                  rotationPosition
                });
              }
            }
            function drawBubbleArrow(ctx2, points) {
              if (!points.length) {
                return;
              }
              ctx2.lineTo(points[0].x, points[0].y);
              ctx2.lineTo(points[1].x, points[1].y);
              ctx2.lineTo(points[2].x, points[2].y);
            }
            function drawBubble(ctx2, model) {
              var x = model.x, y = model.y, width = model.width, height = model.height, style = model.style, _model$radius = model.radius, radius = _model$radius === void 0 ? 0 : _model$radius, strokeStyle = model.strokeStyle, fill = model.fill, _model$lineWidth = model.lineWidth, lineWidth = _model$lineWidth === void 0 ? 1 : _model$lineWidth, _model$points = model.points, points = _model$points === void 0 ? [] : _model$points, _model$direction = model.direction, direction = _model$direction === void 0 ? "" : _model$direction, radian = model.radian, rotationPosition = model.rotationPosition;
              var right = x + width;
              var bottom = y + height;
              ctx2.beginPath();
              ctx2.save();
              if (radian && rotationPosition) {
                ctx2.translate(rotationPosition.x, rotationPosition.y);
                ctx2.rotate(radian);
                ctx2.translate(-rotationPosition.x, -rotationPosition.y);
              }
              ctx2.moveTo(x + radius, y);
              if (direction === "top") {
                drawBubbleArrow(ctx2, points);
              }
              ctx2.lineTo(right - radius, y);
              ctx2.quadraticCurveTo(right, y, right, y + radius);
              if (direction === "right") {
                drawBubbleArrow(ctx2, points);
              }
              ctx2.lineTo(right, y + height - radius);
              ctx2.quadraticCurveTo(right, bottom, right - radius, bottom);
              if (direction === "bottom") {
                drawBubbleArrow(ctx2, points);
              }
              ctx2.lineTo(x + radius, bottom);
              ctx2.quadraticCurveTo(x, bottom, x, bottom - radius);
              if (direction === "left") {
                drawBubbleArrow(ctx2, points);
              }
              ctx2.lineTo(x, y + radius);
              ctx2.quadraticCurveTo(x, y, x + radius, y);
              if (style) {
                var styleObj = makeStyleObj(style, textBubbleStyle);
                Object.keys(styleObj).forEach(function(key) {
                  ctx2[key] = styleObj[key];
                });
              }
              if (fill) {
                fillStyle(ctx2, fill);
              }
              if (strokeStyle) {
                strokeWithOptions(ctx2, {
                  strokeStyle,
                  lineWidth
                });
              }
              ctx2.restore();
            }
            var es_string_anchor = __webpack_require__(1549);
            ;
            function sector_ownKeys(object, enumerableOnly) {
              var keys = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object);
                if (enumerableOnly) {
                  symbols = symbols.filter(function(sym) {
                    return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                  });
                }
                keys.push.apply(keys, symbols);
              }
              return keys;
            }
            function sector_objectSpread(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i] != null ? arguments[i] : {};
                if (i % 2) {
                  sector_ownKeys(Object(source), true).forEach(function(key) {
                    sector_defineProperty(target, key, source[key]);
                  });
                } else if (Object.getOwnPropertyDescriptors) {
                  Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                } else {
                  sector_ownKeys(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  });
                }
              }
              return target;
            }
            function sector_defineProperty(obj, key, value) {
              if (key in obj) {
                Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
              } else {
                obj[key] = value;
              }
              return obj;
            }
            var DEGREE_180 = 180;
            var DEGREE_NEGATIVE_180 = -180;
            var DEGREE_360 = 360;
            var DEGREE_0 = 0;
            var DEGREE_NEGATIVE_90 = -90;
            var DEGREE_90 = 90;
            var MINIMUM_RADIUS = 10;
            function makeAnchorPositionParam(anchor, model) {
              return sector_objectSpread({
                anchor
              }, pick(model, "x", "y", "radius", "degree", "drawingStartAngle"));
            }
            function calculateDegreeToRadian(degree) {
              var drawingStartAngle = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : DEGREE_NEGATIVE_90;
              var result = 0;
              if (degree % DEGREE_360 === 0) {
                result = Math.PI / DEGREE_180 * drawingStartAngle;
              } else if (degree >= 0) {
                result = Math.PI / DEGREE_180 * (degree + drawingStartAngle);
              }
              return result;
            }
            function calculateRadianToDegree(radian) {
              var drawingStartAngle = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : DEGREE_NEGATIVE_90;
              return (radian * DEGREE_180 / Math.PI - drawingStartAngle + DEGREE_360) % DEGREE_360;
            }
            function getRadialAnchorPosition(param) {
              var anchor = param.anchor, x = param.x, y = param.y, _param$radius = param.radius, inner = _param$radius.inner, outer = _param$radius.outer, _param$degree = param.degree, start = _param$degree.start, end = _param$degree.end, _param$drawingStartAn = param.drawingStartAngle, drawingStartAngle = _param$drawingStartAn === void 0 ? DEGREE_NEGATIVE_90 : _param$drawingStartAn;
              var halfDegree = start + (end - start) / 2;
              var radian = calculateDegreeToRadian(halfDegree, drawingStartAngle);
              var r = anchor === "outer" ? outer : (outer + inner) / 2;
              return getRadialPosition(x, y, r, radian);
            }
            function getRadialPosition(x, y, r, radian) {
              return {
                x: Math.round(x + r * Math.cos(radian)),
                y: Math.round(y + r * Math.sin(radian))
              };
            }
            function withinRadian(clockwise, startDegree, endDegree, currentDegree) {
              return clockwise ? startDegree <= currentDegree && endDegree >= currentDegree : startDegree >= currentDegree && endDegree <= currentDegree;
            }
            function initSectorOptions(options2) {
              var _options$clockwise, _options$angleRange$s, _options$angleRange, _options$angleRange$e, _options$angleRange2;
              var clockwise = (_options$clockwise = options2 === null || options2 === void 0 ? void 0 : options2.clockwise) !== null && _options$clockwise !== void 0 ? _options$clockwise : true;
              return {
                clockwise,
                startAngle: (_options$angleRange$s = options2 === null || options2 === void 0 ? void 0 : (_options$angleRange = options2.angleRange) === null || _options$angleRange === void 0 ? void 0 : _options$angleRange.start) !== null && _options$angleRange$s !== void 0 ? _options$angleRange$s : clockwise ? DEGREE_0 : DEGREE_360,
                endAngle: (_options$angleRange$e = options2 === null || options2 === void 0 ? void 0 : (_options$angleRange2 = options2.angleRange) === null || _options$angleRange2 === void 0 ? void 0 : _options$angleRange2.end) !== null && _options$angleRange$e !== void 0 ? _options$angleRange$e : clockwise ? DEGREE_360 : DEGREE_0
              };
            }
            function getDefaultRadius(_ref) {
              var width = _ref.width, height = _ref.height;
              var isSemiCircular = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
              var maxLabelWidth = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
              var maxLabelHeight = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
              var result;
              if (isSemiCircular) {
                result = Math.min(width / 2, height) - maxLabelHeight;
              } else if (width > height) {
                result = height / 2 - maxLabelHeight;
              } else {
                result = width / 2 - maxLabelWidth;
              }
              return Math.max(result, MINIMUM_RADIUS);
            }
            function getRadian(startAngle, endAngle, drawingStartAngle, needCalculateByHalf) {
              var degree = needCalculateByHalf ? (endAngle + startAngle) / 2 : startAngle;
              return calculateDegreeToRadian(degree, drawingStartAngle);
            }
            function getRadialLabelAlign(model, anchor) {
              var needCalculateByHalf = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
              var _model$totalAngle = model.totalAngle, totalAngle = _model$totalAngle === void 0 ? DEGREE_360 : _model$totalAngle, _model$degree = model.degree, start = _model$degree.start, end = _model$degree.end, _model$drawingStartAn = model.drawingStartAngle, drawingStartAngle = _model$drawingStartAn === void 0 ? DEGREE_NEGATIVE_90 : _model$drawingStartAn;
              var textAlign = "center";
              if (anchor !== "outer") {
                return textAlign;
              }
              var radian0 = calculateDegreeToRadian(0, drawingStartAngle);
              var halfRadian = calculateDegreeToRadian(totalAngle / 2, drawingStartAngle);
              var radian = getRadian(start, end, drawingStartAngle, needCalculateByHalf);
              if (drawingStartAngle >= DEGREE_NEGATIVE_90 && drawingStartAngle < DEGREE_90) {
                if (radian0 < radian && halfRadian > radian) {
                  textAlign = "left";
                } else if (halfRadian < radian) {
                  textAlign = "right";
                }
              } else if (radian0 < radian && halfRadian > radian) {
                textAlign = "right";
              } else if (halfRadian < radian) {
                textAlign = "left";
              }
              return textAlign;
            }
            function getRadiusRanges(radiusRanges, padding2) {
              return radiusRanges.reduce(function(acc, cur, index) {
                if (index) {
                  acc.push({
                    inner: cur + padding2,
                    outer: radiusRanges[index - 1] - padding2
                  });
                }
                if (index === radiusRanges.length - 1) {
                  acc.push({
                    inner: padding2,
                    outer: cur - padding2
                  });
                }
                return acc;
              }, []);
            }
            function calculateValidAngle(angle) {
              if (angle < DEGREE_0) {
                return DEGREE_360 + angle % DEGREE_360;
              }
              if (angle > DEGREE_360) {
                return angle % DEGREE_360;
              }
              return angle;
            }
            ;
            var circleStyle = {
              default: {
                strokeStyle: "#ffffff",
                lineWidth: 2
              },
              plot: {
                lineWidth: 1,
                strokeStyle: "rgba(0, 0, 0, 0.05)"
              }
            };
            var rectStyle = {
              shadow: {
                shadowColor: "rgba(0, 0, 0, 0.3)",
                shadowOffsetX: 2,
                shadowOffsetY: 2,
                shadowBlur: 6
              }
            };
            function clipRectArea(ctx2, clipRectAreaModel) {
              var x = clipRectAreaModel.x, y = clipRectAreaModel.y, width = clipRectAreaModel.width, height = clipRectAreaModel.height;
              ctx2.beginPath();
              ctx2.rect(x, y, width, height);
              ctx2.clip();
            }
            function pathRect(ctx2, pathRectModel) {
              var x = pathRectModel.x, y = pathRectModel.y, width = pathRectModel.width, height = pathRectModel.height, _pathRectModel$radius = pathRectModel.radius, radius = _pathRectModel$radius === void 0 ? 0 : _pathRectModel$radius, _pathRectModel$stroke = pathRectModel.stroke, strokeStyle = _pathRectModel$stroke === void 0 ? "black" : _pathRectModel$stroke, _pathRectModel$fill = pathRectModel.fill, fill = _pathRectModel$fill === void 0 ? "" : _pathRectModel$fill, _pathRectModel$lineWi = pathRectModel.lineWidth, lineWidth = _pathRectModel$lineWi === void 0 ? 1 : _pathRectModel$lineWi;
              ctx2.beginPath();
              ctx2.moveTo(x + radius, y);
              ctx2.lineTo(x + width - radius, y);
              ctx2.quadraticCurveTo(x + width, y, x + width, y + radius);
              ctx2.lineTo(x + width, y + height - radius);
              ctx2.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
              ctx2.lineTo(x + radius, y + height);
              ctx2.quadraticCurveTo(x, y + height, x, y + height - radius);
              ctx2.lineTo(x, y + radius);
              ctx2.quadraticCurveTo(x, y, x + radius, y);
              ctx2.closePath();
              if (fill) {
                fillStyle(ctx2, fill);
              }
              strokeWithOptions(ctx2, {
                lineWidth,
                strokeStyle
              });
            }
            function circle(ctx2, circleModel) {
              var x = circleModel.x, y = circleModel.y, style = circleModel.style, radius = circleModel.radius, color = circleModel.color, _circleModel$angle = circleModel.angle, angle = _circleModel$angle === void 0 ? {
                start: 0,
                end: Math.PI * 2
              } : _circleModel$angle, lineWidth = circleModel.borderWidth, strokeStyle = circleModel.borderColor;
              ctx2.beginPath();
              if (style) {
                var styleObj = makeStyleObj(style, circleStyle);
                Object.keys(styleObj).forEach(function(key) {
                  ctx2[key] = styleObj[key];
                });
              }
              ctx2.arc(x, y, radius, angle.start, angle.end, true);
              strokeWithOptions(ctx2, {
                lineWidth,
                strokeStyle
              });
              fillStyle(ctx2, color);
              ctx2.closePath();
            }
            function line(ctx2, lineModel) {
              var x = lineModel.x, y = lineModel.y, x2 = lineModel.x2, y2 = lineModel.y2, strokeStyle = lineModel.strokeStyle, lineWidth = lineModel.lineWidth, dashSegments = lineModel.dashSegments;
              ctx2.beginPath();
              if (dashSegments) {
                setLineDash(ctx2, dashSegments);
              }
              ctx2.moveTo(x, y);
              ctx2.lineTo(x2, y2);
              strokeWithOptions(ctx2, {
                strokeStyle,
                lineWidth
              });
              ctx2.closePath();
            }
            function rect(ctx2, model) {
              var x = model.x, y = model.y, width = model.width, height = model.height, style = model.style, _model$thickness = model.thickness, thickness = _model$thickness === void 0 ? 0 : _model$thickness, color = model.color, _model$borderColor = model.borderColor, borderColor = _model$borderColor === void 0 ? "#ffffff" : _model$borderColor;
              ctx2.beginPath();
              if (style) {
                var styleObj = makeStyleObj(style, rectStyle);
                Object.keys(styleObj).forEach(function(key) {
                  ctx2[key] = styleObj[key];
                });
              }
              if (thickness) {
                ctx2.fillStyle = borderColor;
                ctx2.fillRect(x - thickness, y - thickness, width + thickness * 2, height + thickness * 2);
                ctx2.shadowColor = "rgba(0, 0, 0, 0)";
              }
              ctx2.rect(x, y, width, height);
              fillStyle(ctx2, color);
            }
            function arc(ctx2, arcModel) {
              var x = arcModel.x, y = arcModel.y, _arcModel$angle = arcModel.angle, start = _arcModel$angle.start, end = _arcModel$angle.end, lineWidth = arcModel.borderWidth, strokeStyle = arcModel.borderColor, drawingStartAngle = arcModel.drawingStartAngle, radius = arcModel.radius, _arcModel$clockwise = arcModel.clockwise, clockwise = _arcModel$clockwise === void 0 ? true : _arcModel$clockwise;
              ctx2.beginPath();
              var startRadian = calculateDegreeToRadian(start, drawingStartAngle);
              var endRadian = calculateDegreeToRadian(end, drawingStartAngle);
              ctx2.arc(x, y, radius, startRadian, endRadian, !clockwise);
              strokeWithOptions(ctx2, {
                lineWidth,
                strokeStyle
              });
              ctx2.closePath();
            }
            ;
            var TICK_SIZE = 5;
            function tick(ctx2, tickModel) {
              var x = tickModel.x, y = tickModel.y, isYAxis = tickModel.isYAxis, _tickModel$tickSize = tickModel.tickSize, tickSize = _tickModel$tickSize === void 0 ? TICK_SIZE : _tickModel$tickSize, strokeStyle = tickModel.strokeStyle, lineWidth = tickModel.lineWidth;
              var lineModel = {
                type: "line",
                x,
                y,
                x2: x,
                y2: y,
                strokeStyle,
                lineWidth
              };
              if (isYAxis) {
                lineModel.x2 += tickSize;
              } else {
                lineModel.y2 += tickSize;
              }
              line(ctx2, lineModel);
            }
            ;
            function _toConsumableArray(arr) {
              return _arrayWithoutHoles(arr) || _iterableToArray(arr) || calculator_unsupportedIterableToArray(arr) || _nonIterableSpread();
            }
            function _nonIterableSpread() {
              throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            function calculator_unsupportedIterableToArray(o, minLen) {
              if (!o)
                return;
              if (typeof o === "string")
                return calculator_arrayLikeToArray(o, minLen);
              var n = Object.prototype.toString.call(o).slice(8, -1);
              if (n === "Object" && o.constructor)
                n = o.constructor.name;
              if (n === "Map" || n === "Set")
                return Array.from(o);
              if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                return calculator_arrayLikeToArray(o, minLen);
            }
            function _iterableToArray(iter) {
              if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
                return Array.from(iter);
            }
            function _arrayWithoutHoles(arr) {
              if (Array.isArray(arr))
                return calculator_arrayLikeToArray(arr);
            }
            function calculator_arrayLikeToArray(arr, len) {
              if (len == null || len > arr.length)
                len = arr.length;
              for (var i = 0, arr2 = new Array(len); i < len; i++) {
                arr2[i] = arr[i];
              }
              return arr2;
            }
            var LINE_HEIGHT_NORMAL = 1.2;
            var ctx = document.createElement("canvas").getContext("2d");
            function getTextWidth(text) {
              var font = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : DEFAULT_LABEL_TEXT;
              ctx.font = font;
              return Math.ceil(ctx.measureText(text).width);
            }
            function getTextHeight(text) {
              var font = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : DEFAULT_LABEL_TEXT;
              ctx.font = font;
              var _ctx$measureText = ctx.measureText(text), actualBoundingBoxAscent = _ctx$measureText.actualBoundingBoxAscent, actualBoundingBoxDescent = _ctx$measureText.actualBoundingBoxDescent;
              var validActualBoundingBox = isNumber(actualBoundingBoxAscent) && isNumber(actualBoundingBoxDescent);
              return validActualBoundingBox ? Math.ceil(Math.abs(actualBoundingBoxAscent) + Math.abs(actualBoundingBoxDescent)) + 1 : getFontHeight(font);
            }
            function getFontHeight() {
              var font = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : DEFAULT_LABEL_TEXT;
              var fontSize = font.match(/\d+(?=px)/);
              return parseInt(String(Number(fontSize) * LINE_HEIGHT_NORMAL), 10);
            }
            function getAxisLabelAnchorPoint(labelHeight) {
              return crispPixel(TICK_SIZE * 2 + labelHeight / 2);
            }
            function getDecimalLength(value) {
              var _String$split$1$lengt, _String$split$;
              return (_String$split$1$lengt = (_String$split$ = String(value).split(".")[1]) === null || _String$split$ === void 0 ? void 0 : _String$split$.length) !== null && _String$split$1$lengt !== void 0 ? _String$split$1$lengt : 0;
            }
            function findMultipleNum() {
              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }
              var underPointLens = args.map(function(value) {
                return getDecimalLength(value);
              });
              var underPointLen = Math.max.apply(Math, _toConsumableArray(underPointLens));
              return Math.pow(10, underPointLen);
            }
            function add(a, b) {
              var multipleNum = findMultipleNum(a, b);
              return (a * multipleNum + b * multipleNum) / multipleNum;
            }
            function multiply(a, b) {
              var multipleNum = findMultipleNum(a, b);
              return a * multipleNum * (b * multipleNum) / (multipleNum * multipleNum);
            }
            function divide(a, b) {
              var multipleNum = findMultipleNum(a, b);
              return a * multipleNum / (b * multipleNum);
            }
            function calculator_sum(values) {
              var copyArr = values.slice();
              copyArr.unshift(0);
              return copyArr.reduce(function(base, value) {
                return add(parseFloat(String(base)), parseFloat(String(value)));
              });
            }
            function divisors(value) {
              var result = [];
              for (var a = 2, b; a * a <= value; a += 1) {
                if (value % a === 0) {
                  b = value / a;
                  result.push(a);
                  if (b !== a) {
                    result.push(b);
                  }
                }
              }
              return result.sort(function(prev, next) {
                return prev - next;
              });
            }
            function makeLabelsFromLimit(limit, stepSize, isDateType2) {
              var multipleNum = findMultipleNum(stepSize);
              var min = Math.round(limit.min * multipleNum);
              var max2 = Math.round(limit.max * multipleNum);
              var labels = range(min, max2 + 1, stepSize * multipleNum);
              return labels.map(function(label2) {
                return String(isDateType2 ? new Date(label2) : label2 / multipleNum);
              });
            }
            function makeTickPixelPositions(size, count) {
              var additionalPosition = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
              var remainLastBlockIntervalPosition = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
              var positions = [];
              if (count > 0) {
                positions = range(0, count).map(function(index) {
                  var ratio = index === 0 ? 0 : index / (count - 1);
                  return ratio * size + additionalPosition;
                });
              }
              if (remainLastBlockIntervalPosition) {
                positions.push(remainLastBlockIntervalPosition);
              }
              return positions;
            }
            function crispPixel(pixel) {
              var thickness = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
              var halfThickness = thickness / 2;
              return thickness % 2 ? (isInteger(pixel) ? pixel : Math.round(pixel - halfThickness)) + halfThickness : Math.round(pixel);
            }
            function getControlPoints(prev, cur, next) {
              var TENSION = 0.333;
              var x0 = prev.x, y0 = prev.y;
              var x1 = cur.x, y1 = cur.y;
              var x2 = next.x, y2 = next.y;
              var d12 = getDistance(next, cur);
              var d01 = getDistance(cur, prev);
              var fa = TENSION * d01 / (d01 + d12) || 0;
              var fb = TENSION * d12 / (d01 + d12) || 0;
              return {
                prev: {
                  x: x1 - fa * (x2 - x0),
                  // x2-x0 is the width of triangle T
                  y: y1 - fa * (y2 - y0)
                  // y2-y0 is the height of T
                },
                next: {
                  x: x1 + fb * (x2 - x0),
                  y: y1 + fb * (y2 - y0)
                }
              };
            }
            function setSplineControlPoint(points) {
              for (var i = 0, pointsSize = points.length, prev = points[0]; i < pointsSize; i += 1) {
                var point = points[i];
                if (isNull(point)) {
                  prev = points[i + 1];
                  continue;
                }
                var next = points[Math.min(i + 1, pointsSize - 1) % pointsSize];
                if (prev && next) {
                  point.controlPoint = getControlPoints(prev, point, next);
                }
                prev = point;
              }
            }
            function getValueRatio(value, _ref) {
              var min = _ref.min, max2 = _ref.max;
              if (max2 === min) {
                return 0;
              }
              return (value - min) / (max2 - min);
            }
            function getDistance(point1, point2) {
              return Math.sqrt(Math.pow(point2.x - point1.x, 2) + Math.pow(point2.y - point1.y, 2));
            }
            function getMaxLengthLabelWidth(labels) {
              var maxLengthLabel = labels.reduce(function(acc, cur) {
                return acc.length > cur.length ? acc : cur;
              }, "");
              return getTextWidth(maxLengthLabel);
            }
            function getXPosition(axisData, offsetSize, value, dataIndex) {
              var pointOnColumn = axisData.pointOnColumn, tickDistance = axisData.tickDistance, labelRange = axisData.labelRange;
              var x;
              if (labelRange) {
                var xValue = utils_isString(value) ? Number(new Date(value)) : Number(value);
                var xValueRatio = getValueRatio(xValue, labelRange);
                x = xValueRatio * offsetSize;
              } else {
                x = tickDistance * dataIndex + (pointOnColumn ? tickDistance / 2 : 0);
              }
              return x;
            }
            ;
            function arrayUtil_slicedToArray(arr, i) {
              return arrayUtil_arrayWithHoles(arr) || arrayUtil_iterableToArrayLimit(arr, i) || arrayUtil_unsupportedIterableToArray(arr, i) || arrayUtil_nonIterableRest();
            }
            function arrayUtil_nonIterableRest() {
              throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            function arrayUtil_iterableToArrayLimit(arr, i) {
              var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]);
              if (_i == null)
                return;
              var _arr = [];
              var _n = true;
              var _d = false;
              var _s, _e;
              try {
                for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
                  _arr.push(_s.value);
                  if (i && _arr.length === i)
                    break;
                }
              } catch (err) {
                _d = true;
                _e = err;
              } finally {
                try {
                  if (!_n && _i["return"] != null)
                    _i["return"]();
                } finally {
                  if (_d)
                    throw _e;
                }
              }
              return _arr;
            }
            function arrayUtil_arrayWithHoles(arr) {
              if (Array.isArray(arr))
                return arr;
            }
            function arrayUtil_toConsumableArray(arr) {
              return arrayUtil_arrayWithoutHoles(arr) || arrayUtil_iterableToArray(arr) || arrayUtil_unsupportedIterableToArray(arr) || arrayUtil_nonIterableSpread();
            }
            function arrayUtil_nonIterableSpread() {
              throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            function arrayUtil_unsupportedIterableToArray(o, minLen) {
              if (!o)
                return;
              if (typeof o === "string")
                return arrayUtil_arrayLikeToArray(o, minLen);
              var n = Object.prototype.toString.call(o).slice(8, -1);
              if (n === "Object" && o.constructor)
                n = o.constructor.name;
              if (n === "Map" || n === "Set")
                return Array.from(o);
              if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                return arrayUtil_arrayLikeToArray(o, minLen);
            }
            function arrayUtil_iterableToArray(iter) {
              if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
                return Array.from(iter);
            }
            function arrayUtil_arrayWithoutHoles(arr) {
              if (Array.isArray(arr))
                return arrayUtil_arrayLikeToArray(arr);
            }
            function arrayUtil_arrayLikeToArray(arr, len) {
              if (len == null || len > arr.length)
                len = arr.length;
              for (var i = 0, arr2 = new Array(len); i < len; i++) {
                arr2[i] = arr[i];
              }
              return arr2;
            }
            function max(arr, condition, context) {
              var result;
              if (!condition) {
                result = Math.max.apply(Math, arrayUtil_toConsumableArray(arr));
              } else {
                var _arr2 = arrayUtil_slicedToArray(arr, 1);
                result = _arr2[0];
                var rest = arr.slice(1);
                var maxValue = condition.call(context, result, 0);
                rest.forEach(function(item, index) {
                  var compareValue = condition.call(context, item, index + 1);
                  if (compareValue > maxValue) {
                    maxValue = compareValue;
                    result = item;
                  }
                });
              }
              return result;
            }
            function pivot(arr2d) {
              var result = [];
              var len = max(arr2d.map(function(arr) {
                return arr.length;
              }));
              arr2d.forEach(function(arr) {
                for (var index = 0; index < len; index += 1) {
                  if (!result[index]) {
                    result[index] = [];
                  }
                  result[index].push(arr[index]);
                }
              });
              return result;
            }
            function isSameArray(arr1, arr2) {
              if (arr1.length !== arr2.length) {
                return false;
              }
              for (var i = 0; i < arr1.length; i += 1) {
                if (arr1[i] !== arr2[i]) {
                  return false;
                }
              }
              return true;
            }
            function pluck(arr, property) {
              return arr.reduce(function(acc, cur) {
                return [].concat(arrayUtil_toConsumableArray(acc), [cur[property]]);
              }, []);
            }
            ;
            function component_toConsumableArray(arr) {
              return component_arrayWithoutHoles(arr) || component_iterableToArray(arr) || component_unsupportedIterableToArray(arr) || component_nonIterableSpread();
            }
            function component_nonIterableSpread() {
              throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            function component_unsupportedIterableToArray(o, minLen) {
              if (!o)
                return;
              if (typeof o === "string")
                return component_arrayLikeToArray(o, minLen);
              var n = Object.prototype.toString.call(o).slice(8, -1);
              if (n === "Object" && o.constructor)
                n = o.constructor.name;
              if (n === "Map" || n === "Set")
                return Array.from(o);
              if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                return component_arrayLikeToArray(o, minLen);
            }
            function component_iterableToArray(iter) {
              if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
                return Array.from(iter);
            }
            function component_arrayWithoutHoles(arr) {
              if (Array.isArray(arr))
                return component_arrayLikeToArray(arr);
            }
            function component_arrayLikeToArray(arr, len) {
              if (len == null || len > arr.length)
                len = arr.length;
              for (var i = 0, arr2 = new Array(len); i < len; i++) {
                arr2[i] = arr[i];
              }
              return arr2;
            }
            function component_ownKeys(object, enumerableOnly) {
              var keys = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object);
                if (enumerableOnly) {
                  symbols = symbols.filter(function(sym) {
                    return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                  });
                }
                keys.push.apply(keys, symbols);
              }
              return keys;
            }
            function component_objectSpread(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i] != null ? arguments[i] : {};
                if (i % 2) {
                  component_ownKeys(Object(source), true).forEach(function(key) {
                    component_defineProperty(target, key, source[key]);
                  });
                } else if (Object.getOwnPropertyDescriptors) {
                  Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                } else {
                  component_ownKeys(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  });
                }
              }
              return target;
            }
            function component_classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function component_defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            function component_createClass(Constructor, protoProps, staticProps) {
              if (protoProps)
                component_defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                component_defineProperties(Constructor, staticProps);
              return Constructor;
            }
            function component_defineProperty(obj, key, value) {
              if (key in obj) {
                Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
              } else {
                obj[key] = value;
              }
              return obj;
            }
            var Component = function() {
              function Component2(_ref) {
                var store = _ref.store, eventBus = _ref.eventBus;
                component_classCallCheck(this, Component2);
                component_defineProperty(this, "name", "Component");
                component_defineProperty(this, "type", "component");
                component_defineProperty(this, "rect", {
                  x: 0,
                  y: 0,
                  height: 0,
                  width: 0
                });
                component_defineProperty(this, "isShow", true);
                component_defineProperty(this, "selectable", void 0);
                component_defineProperty(this, "store", void 0);
                component_defineProperty(this, "eventBus", void 0);
                component_defineProperty(this, "models", void 0);
                component_defineProperty(this, "drawModels", void 0);
                component_defineProperty(this, "responders", void 0);
                component_defineProperty(this, "activeSeriesMap", void 0);
                this.store = store;
                this.eventBus = eventBus;
              }
              component_createClass(Component2, [{
                key: "update",
                value: function update(delta) {
                  var _this = this;
                  if (!this.drawModels) {
                    return;
                  }
                  if (Array.isArray(this.models)) {
                    this.updateModels(this.drawModels, this.models, delta);
                  } else {
                    Object.keys(this.models).forEach(function(type) {
                      var currentModels = _this.drawModels[type];
                      var targetModels = _this.models[type];
                      _this.updateModels(currentModels, targetModels, delta);
                    });
                  }
                }
              }, {
                key: "initUpdate",
                value: function initUpdate(delta) {
                  this.update(delta);
                }
              }, {
                key: "updateModels",
                value: function updateModels(currentModels, targetModels, delta) {
                  var _this2 = this;
                  currentModels.forEach(function(current, index) {
                    var target = targetModels[index];
                    Object.keys(current).forEach(function(key) {
                      if (!current || !target) {
                        return;
                      }
                      if (key[0] !== "_") {
                        if (isNumber(current[key])) {
                          current[key] = current[key] + (target[key] - current[key]) * delta;
                        } else if (key === "points") {
                          var _this2$store$state$op;
                          var matchedModel = _this2.getCurrentModelToMatchTargetModel(current[key], current[key], target[key]);
                          var newPoints = matchedModel.map(function(curPoint, idx) {
                            var next = target[key][idx];
                            if (curPoint && next) {
                              var x = curPoint.x, y = curPoint.y;
                              var nextX = next.x, nextY = next.y;
                              return component_objectSpread(component_objectSpread({}, next), {}, {
                                x: x + (nextX - x) * delta,
                                y: y + (nextY - y) * delta
                              });
                            }
                            return next;
                          });
                          if ((_this2$store$state$op = _this2.store.state.options.series) !== null && _this2$store$state$op !== void 0 && _this2$store$state$op.spline) {
                            setSplineControlPoint(newPoints);
                          }
                          current[key] = newPoints;
                        } else {
                          current[key] = target[key];
                        }
                      }
                    });
                  });
                }
              }, {
                key: "sync",
                value: function sync() {
                  var _this3 = this;
                  if (!this.drawModels) {
                    return;
                  }
                  if (Array.isArray(this.models)) {
                    this.syncModels(this.drawModels, this.models);
                  } else if (!Object.keys(this.models).length) {
                    this.drawModels = this.models;
                  } else {
                    Object.keys(this.models).forEach(function(type) {
                      var currentModels = _this3.drawModels[type];
                      var targetModels = _this3.models[type];
                      _this3.syncModels(currentModels, targetModels, type);
                    });
                  }
                }
              }, {
                key: "getCurrentModelToMatchTargetModel",
                value: function getCurrentModelToMatchTargetModel(models, currentModels, targetModels) {
                  var _getFirstValidValue;
                  if (!models || !currentModels) {
                    return component_toConsumableArray(targetModels);
                  }
                  if ((_getFirstValidValue = getFirstValidValue(targetModels)) !== null && _getFirstValidValue !== void 0 && _getFirstValidValue.name) {
                    var modelNames = component_toConsumableArray(new Set(models.map(function(_ref2) {
                      var name = _ref2.name;
                      return name;
                    })));
                    var targetNames = component_toConsumableArray(new Set(targetModels.map(function(_ref3) {
                      var name = _ref3.name;
                      return name;
                    })));
                    var same = isSameArray(modelNames, targetNames);
                    if (!same) {
                      return this.getCurrentModelWithDifferentModel(models, currentModels, targetModels, modelNames, targetNames);
                    }
                  }
                  var currentLength = currentModels.length;
                  var targetLength = targetModels.length;
                  if (currentLength < targetLength) {
                    return [].concat(component_toConsumableArray(currentModels), component_toConsumableArray(targetModels.slice(currentLength, targetLength)));
                  }
                  if (currentLength > targetLength) {
                    return currentModels.slice(0, targetLength);
                  }
                  return models;
                }
              }, {
                key: "getCurrentModelWithDifferentModel",
                value: function getCurrentModelWithDifferentModel(models, currentModels, targetModels, modelNames, targetNames) {
                  var currentLength = currentModels.length;
                  var targetLength = targetModels.length;
                  if (currentLength > targetLength) {
                    var newModels = models.filter(function(_ref4) {
                      var name = _ref4.name;
                      return includes(targetNames, name);
                    });
                    return newModels.length !== targetModels.length ? targetModels : newModels;
                  }
                  if (currentLength < targetLength) {
                    var notIncludedModels = targetModels.reduce(function(acc, cur, idx) {
                      var notIncluded = !includes(modelNames, cur.name);
                      return notIncluded ? {
                        models: [].concat(component_toConsumableArray(acc.models), [cur]),
                        modelIdx: [].concat(component_toConsumableArray(acc.modelIdx), [idx])
                      } : acc;
                    }, {
                      models: [],
                      modelIdx: []
                    });
                    if (models.length + notIncludedModels.models.length === targetLength) {
                      var _newModels = component_toConsumableArray(models);
                      notIncludedModels.models.forEach(function(model, idx) {
                        _newModels.splice(notIncludedModels.modelIdx[idx], 0, model);
                      });
                      return _newModels;
                    }
                    return targetModels;
                  }
                  return models;
                }
              }, {
                key: "syncModels",
                value: function syncModels(currentModels, targetModels, type) {
                  var drawModels = type ? this.drawModels[type] : this.drawModels;
                  var model = this.getCurrentModelToMatchTargetModel(drawModels, currentModels, targetModels);
                  if (type) {
                    this.drawModels[type] = model;
                  } else {
                    this.drawModels = model;
                  }
                }
              }, {
                key: "getSelectableOption",
                value: function getSelectableOption(options2) {
                  var _options$series$selec, _options$series;
                  return (_options$series$selec = options2 === null || options2 === void 0 ? void 0 : (_options$series = options2.series) === null || _options$series === void 0 ? void 0 : _options$series.selectable) !== null && _options$series$selec !== void 0 ? _options$series$selec : false;
                }
              }, {
                key: "renderDataLabels",
                value: function renderDataLabels(data, name) {
                  var _this4 = this;
                  setTimeout(function() {
                    _this4.eventBus.emit("renderDataLabels", {
                      data,
                      name: name !== null && name !== void 0 ? name : _this4.name
                    });
                  }, 0);
                }
              }, {
                key: "draw",
                value: function draw(painter) {
                  var models = this.drawModels ? this.drawModels : this.models;
                  if (Array.isArray(models)) {
                    painter.paintForEach(models);
                  } else if (models) {
                    Object.keys(models).forEach(function(item) {
                      painter.paintForEach(models[item]);
                    });
                  }
                }
              }]);
              return Component2;
            }();
            ;
            function axis_typeof(obj) {
              "@babel/helpers - typeof";
              if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                axis_typeof = function _typeof2(obj2) {
                  return typeof obj2;
                };
              } else {
                axis_typeof = function _typeof2(obj2) {
                  return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                };
              }
              return axis_typeof(obj);
            }
            function axis_toConsumableArray(arr) {
              return axis_arrayWithoutHoles(arr) || axis_iterableToArray(arr) || axis_unsupportedIterableToArray(arr) || axis_nonIterableSpread();
            }
            function axis_nonIterableSpread() {
              throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            function axis_unsupportedIterableToArray(o, minLen) {
              if (!o)
                return;
              if (typeof o === "string")
                return axis_arrayLikeToArray(o, minLen);
              var n = Object.prototype.toString.call(o).slice(8, -1);
              if (n === "Object" && o.constructor)
                n = o.constructor.name;
              if (n === "Map" || n === "Set")
                return Array.from(o);
              if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                return axis_arrayLikeToArray(o, minLen);
            }
            function axis_iterableToArray(iter) {
              if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
                return Array.from(iter);
            }
            function axis_arrayWithoutHoles(arr) {
              if (Array.isArray(arr))
                return axis_arrayLikeToArray(arr);
            }
            function axis_arrayLikeToArray(arr, len) {
              if (len == null || len > arr.length)
                len = arr.length;
              for (var i = 0, arr2 = new Array(len); i < len; i++) {
                arr2[i] = arr[i];
              }
              return arr2;
            }
            function axis_ownKeys(object, enumerableOnly) {
              var keys = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object);
                if (enumerableOnly) {
                  symbols = symbols.filter(function(sym) {
                    return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                  });
                }
                keys.push.apply(keys, symbols);
              }
              return keys;
            }
            function axis_objectSpread(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i] != null ? arguments[i] : {};
                if (i % 2) {
                  axis_ownKeys(Object(source), true).forEach(function(key) {
                    axis_defineProperty(target, key, source[key]);
                  });
                } else if (Object.getOwnPropertyDescriptors) {
                  Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                } else {
                  axis_ownKeys(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  });
                }
              }
              return target;
            }
            function axis_classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function axis_defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            function axis_createClass(Constructor, protoProps, staticProps) {
              if (protoProps)
                axis_defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                axis_defineProperties(Constructor, staticProps);
              return Constructor;
            }
            function _inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function");
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
              if (superClass)
                _setPrototypeOf(subClass, superClass);
            }
            function _setPrototypeOf(o, p) {
              _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
                o2.__proto__ = p2;
                return o2;
              };
              return _setPrototypeOf(o, p);
            }
            function _createSuper(Derived) {
              var hasNativeReflectConstruct = _isNativeReflectConstruct();
              return function _createSuperInternal() {
                var Super = _getPrototypeOf(Derived), result;
                if (hasNativeReflectConstruct) {
                  var NewTarget = _getPrototypeOf(this).constructor;
                  result = Reflect.construct(Super, arguments, NewTarget);
                } else {
                  result = Super.apply(this, arguments);
                }
                return _possibleConstructorReturn(this, result);
              };
            }
            function _possibleConstructorReturn(self2, call) {
              if (call && (axis_typeof(call) === "object" || typeof call === "function")) {
                return call;
              }
              return _assertThisInitialized(self2);
            }
            function _assertThisInitialized(self2) {
              if (self2 === void 0) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return self2;
            }
            function _isNativeReflectConstruct() {
              if (typeof Reflect === "undefined" || !Reflect.construct)
                return false;
              if (Reflect.construct.sham)
                return false;
              if (typeof Proxy === "function")
                return true;
              try {
                Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                }));
                return true;
              } catch (e) {
                return false;
              }
            }
            function _getPrototypeOf(o) {
              _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
                return o2.__proto__ || Object.getPrototypeOf(o2);
              };
              return _getPrototypeOf(o);
            }
            function axis_defineProperty(obj, key, value) {
              if (key in obj) {
                Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
              } else {
                obj[key] = value;
              }
              return obj;
            }
            var AxisType;
            (function(AxisType2) {
              AxisType2["X"] = "xAxis";
              AxisType2["Y"] = "yAxis";
              AxisType2["SECONDARY_Y"] = "secondaryYAxis";
              AxisType2["CIRCULAR"] = "circularAxis";
              AxisType2["VERTICAL"] = "verticalAxis";
            })(AxisType || (AxisType = {}));
            function getOffsetAndAnchorKey(hasBasedYAxis) {
              return {
                offsetKey: hasBasedYAxis ? "y" : "x",
                anchorKey: hasBasedYAxis ? "x" : "y"
              };
            }
            var Axis = function(_Component) {
              _inherits(Axis2, _Component);
              var _super = _createSuper(Axis2);
              function Axis2() {
                var _this;
                axis_classCallCheck(this, Axis2);
                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }
                _this = _super.call.apply(_super, [this].concat(args));
                axis_defineProperty(_assertThisInitialized(_this), "models", {
                  label: [],
                  tick: [],
                  axisLine: []
                });
                axis_defineProperty(_assertThisInitialized(_this), "drawModels", void 0);
                axis_defineProperty(_assertThisInitialized(_this), "yAxisComponent", void 0);
                axis_defineProperty(_assertThisInitialized(_this), "theme", void 0);
                axis_defineProperty(_assertThisInitialized(_this), "axisSize", 0);
                return _this;
              }
              axis_createClass(Axis2, [{
                key: "initialize",
                value: function initialize(_ref) {
                  var name = _ref.name;
                  this.type = "axis";
                  this.name = name;
                  this.yAxisComponent = includes([AxisType.Y, AxisType.SECONDARY_Y], name);
                }
              }, {
                key: "render",
                value: function render(_ref2) {
                  var _this2 = this;
                  var layout2 = _ref2.layout, axes2 = _ref2.axes, theme2 = _ref2.theme, scale2 = _ref2.scale;
                  if (axes2.centerYAxis || !axes2[this.name]) {
                    return;
                  }
                  this.theme = getAxisTheme(theme2, this.name);
                  this.rect = layout2[this.name];
                  this.axisSize = this.yAxisComponent ? this.rect.height : this.rect.width;
                  var viewLabels = axes2[this.name].viewLabels;
                  var _getOffsetAndAnchorKe = getOffsetAndAnchorKey(this.yAxisComponent), offsetKey = _getOffsetAndAnchorKe.offsetKey, anchorKey = _getOffsetAndAnchorKe.anchorKey;
                  var renderOptions = this.makeRenderOptions(axes2[this.name], scale2 === null || scale2 === void 0 ? void 0 : scale2[this.name]);
                  var hasOnlyAxisLine = this.hasOnlyAxisLine();
                  if (!hasOnlyAxisLine) {
                    this.models.label = this.renderLabelModels(viewLabels, offsetKey, anchorKey, renderOptions);
                    this.models.tick = this.renderTickModels(offsetKey, anchorKey, renderOptions);
                  }
                  this.models.axisLine = [this.renderAxisLineModel()];
                  if (!this.drawModels) {
                    this.drawModels = {
                      tick: [],
                      label: [],
                      axisLine: this.models.axisLine
                    };
                    ["tick", "label"].forEach(function(type) {
                      _this2.drawModels[type] = _this2.models[type].map(function(m) {
                        var drawModel = axis_objectSpread({}, m);
                        if (_this2.yAxisComponent) {
                          drawModel.y = 0;
                        } else {
                          drawModel.x = 0;
                        }
                        return drawModel;
                      });
                    });
                  }
                }
              }, {
                key: "renderAxisLineModel",
                value: function renderAxisLineModel() {
                  var zeroPixel = crispPixel(0);
                  var lineModel;
                  var _this$theme = this.theme, strokeStyle = _this$theme.color, lineWidth = _this$theme.width;
                  if (this.yAxisComponent) {
                    var x = this.getYAxisXPoint();
                    lineModel = {
                      type: "line",
                      x,
                      y: zeroPixel,
                      x2: x,
                      y2: crispPixel(this.axisSize),
                      strokeStyle,
                      lineWidth
                    };
                  } else {
                    lineModel = {
                      type: "line",
                      x: zeroPixel,
                      y: zeroPixel,
                      x2: crispPixel(this.axisSize),
                      y2: zeroPixel,
                      strokeStyle,
                      lineWidth
                    };
                  }
                  return lineModel;
                }
              }, {
                key: "renderTickModels",
                value: function renderTickModels(offsetKey, anchorKey, renderOptions) {
                  var _this3 = this;
                  var tickAnchorPoint = this.yAxisComponent ? this.getYAxisXPoint() : crispPixel(0);
                  var tickInterval = renderOptions.tickInterval, relativePositions = renderOptions.relativePositions;
                  var tickSize = includes([AxisType.SECONDARY_Y, AxisType.X], this.name) ? TICK_SIZE : -TICK_SIZE;
                  return relativePositions.reduce(function(positions, position, index) {
                    var _ref3;
                    return index % tickInterval ? positions : [].concat(axis_toConsumableArray(positions), [(_ref3 = {
                      type: "tick",
                      isYAxis: _this3.yAxisComponent,
                      tickSize
                    }, axis_defineProperty(_ref3, offsetKey, crispPixel(position)), axis_defineProperty(_ref3, anchorKey, tickAnchorPoint), axis_defineProperty(_ref3, "strokeStyle", _this3.theme.color), axis_defineProperty(_ref3, "lineWidth", _this3.theme.width), _ref3)]);
                  }, []);
                }
              }, {
                key: "renderLabelModels",
                value: function renderLabelModels(labels, offsetKey, anchorKey, renderOptions) {
                  var needRotateLabel = renderOptions.needRotateLabel, radian = renderOptions.radian, offsetY = renderOptions.offsetY;
                  var labelTheme = this.theme.label;
                  var font = getTitleFontString(labelTheme);
                  var textAlign = this.getLabelTextAlign(needRotateLabel);
                  var style = ["default", {
                    textAlign,
                    font,
                    fillStyle: labelTheme.color
                  }];
                  var labelAnchorPoint = this.yAxisComponent ? this.getYAxisAnchorPoint() : offsetY;
                  return labels.map(function(_ref4) {
                    var _ref5;
                    var text = _ref4.text, offsetPos = _ref4.offsetPos;
                    return _ref5 = {
                      type: "label",
                      text,
                      style,
                      radian
                    }, axis_defineProperty(_ref5, offsetKey, crispPixel(offsetPos)), axis_defineProperty(_ref5, anchorKey, labelAnchorPoint), _ref5;
                  });
                }
              }, {
                key: "makeRenderOptions",
                value: function makeRenderOptions(axisData, scale2) {
                  var _scale$sizeRatio, _scale$positionRatio;
                  var tickCount = axisData.tickCount, tickInterval = axisData.tickInterval;
                  var sizeRatio = (_scale$sizeRatio = scale2 === null || scale2 === void 0 ? void 0 : scale2.sizeRatio) !== null && _scale$sizeRatio !== void 0 ? _scale$sizeRatio : 1;
                  var positionRatio = (_scale$positionRatio = scale2 === null || scale2 === void 0 ? void 0 : scale2.positionRatio) !== null && _scale$positionRatio !== void 0 ? _scale$positionRatio : 0;
                  var relativePositions = makeTickPixelPositions(this.axisSize * sizeRatio, tickCount, this.axisSize * positionRatio);
                  if (this.yAxisComponent) {
                    return {
                      relativePositions,
                      tickInterval
                    };
                  }
                  var needRotateLabel = axisData.needRotateLabel, radian = axisData.radian, offsetY = axisData.offsetY;
                  return {
                    relativePositions,
                    tickInterval,
                    needRotateLabel,
                    radian,
                    offsetY
                  };
                }
              }, {
                key: "getYAxisAnchorPoint",
                value: function getYAxisAnchorPoint() {
                  return this.isRightSide() ? crispPixel(this.rect.width) : crispPixel(0);
                }
              }, {
                key: "getLabelTextAlign",
                value: function getLabelTextAlign(needRotateLabel) {
                  var yAxisTextAlign = this.isRightSide() ? "right" : "left";
                  var xAxisTextAlign = needRotateLabel ? "left" : "center";
                  return this.yAxisComponent ? yAxisTextAlign : xAxisTextAlign;
                }
              }, {
                key: "isRightSide",
                value: function isRightSide() {
                  return this.name === AxisType.SECONDARY_Y;
                }
              }, {
                key: "getYAxisXPoint",
                value: function getYAxisXPoint2() {
                  return this.isRightSide() ? crispPixel(0) : crispPixel(this.rect.width);
                }
              }, {
                key: "hasOnlyAxisLine",
                value: function hasOnlyAxisLine() {
                  return this.yAxisComponent && !this.rect.width || this.name === AxisType.X && !this.rect.height;
                }
              }]);
              return Axis2;
            }(Component);
            ;
            var RAD = Math.PI / 180;
            var ANGLE_90 = 90;
            var ANGLE_CANDIDATES = [0, 25, 45, 65, 85, 90];
            function calculateAdjacent(degree, hypotenuse) {
              return Math.cos(degree * RAD) * hypotenuse;
            }
            function calculateOpposite(degree, hypotenuse) {
              return Math.sin(degree * RAD) * hypotenuse;
            }
            function calculateRotatedWidth(degree, width, height) {
              var centerHalf = calculateAdjacent(degree, width / 2);
              var sideHalf = calculateAdjacent(ANGLE_90 - degree, height / 2);
              return (centerHalf + sideHalf) * 2;
            }
            function calculateRotatedHeight(degree, width, height) {
              var centerHalf = calculateOpposite(degree, width / 2);
              var sideHalf = calculateOpposite(ANGLE_90 - degree, height / 2);
              return (centerHalf + sideHalf) * 2;
            }
            ;
            var DEFAULT_DATE_FORMAT = "YY-MM-DD hh:mm:ss";
            function getDateFormat(date) {
              if (!date) {
                return;
              }
              return isObject(date) ? date.format : DEFAULT_DATE_FORMAT;
            }
            var tokens = /[\\]*YYYY|[\\]*YY|[\\]*MMMM|[\\]*MMM|[\\]*MM|[\\]*M|[\\]*DD|[\\]*D|[\\]*HH|[\\]*H|[\\]*mm|[\\]*m|[\\]*ss|[\\]*s|[\\]*A/gi;
            var MONTH_STR = ["Invalid month", "January", "February", "March", "April", "May", "Jun", "Jul", "August", "September", "October", "November", "December"];
            var MONTH_DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
            var replaceMap = {
              M: function M(date) {
                return Number(date.month);
              },
              MM: function MM(date) {
                var month = date.month;
                return Number(month) < 10 ? "0".concat(month) : month;
              },
              MMM: function MMM(date) {
                return MONTH_STR[Number(date.month)].substr(0, 3);
              },
              MMMM: function MMMM(date) {
                return MONTH_STR[Number(date.month)];
              },
              D: function D(date) {
                return Number(date.date);
              },
              d: function d(date) {
                return replaceMap.D(date);
              },
              // eslint-disable-line new-cap
              DD: function DD(date) {
                var dayInMonth = date.date;
                return Number(dayInMonth) < 10 ? "0".concat(dayInMonth) : dayInMonth;
              },
              dd: function dd(date) {
                return replaceMap.DD(date);
              },
              // eslint-disable-line new-cap
              YY: function YY(date) {
                return Number(date.year) % 100;
              },
              yy: function yy(date) {
                return replaceMap.YY(date);
              },
              // eslint-disable-line new-cap
              YYYY: function YYYY(date) {
                var prefix = "20";
                var year = date.year;
                if (year > 69 && year < 100) {
                  prefix = "19";
                }
                return Number(year) < 100 ? prefix + String(year) : year;
              },
              yyyy: function yyyy(date) {
                return replaceMap.YYYY(date);
              },
              // eslint-disable-line new-cap
              A: function A(date) {
                return date.meridiem;
              },
              a: function a(date) {
                return date.meridiem;
              },
              hh: function hh(date) {
                var hour = date.hour;
                return Number(hour) < 10 ? "0" + hour : hour;
              },
              HH: function HH(date) {
                return replaceMap.hh(date);
              },
              h: function h(date) {
                return String(Number(date.hour));
              },
              H: function H(date) {
                return replaceMap.h(date);
              },
              m: function m(date) {
                return String(Number(date.minute));
              },
              mm: function mm(date) {
                var minute = date.minute;
                return Number(minute) < 10 ? "0".concat(minute) : minute;
              },
              s: function s(date) {
                return String(Number(date.second));
              },
              ss: function ss(date) {
                var second = date.second;
                return Number(second) < 10 ? "0".concat(second) : second;
              }
            };
            function isLeapYear(month, year) {
              return month === 2 && year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
            }
            function isValidDate(y, m, d) {
              var year = Number(y);
              var month = Number(m);
              var date = Number(d);
              var isValidYear = year > -1 && year < 100 || year > 1969 && year < 2070;
              var isValidMonth = month > 0 && month < 13;
              if (!isValidYear || !isValidMonth) {
                return false;
              }
              var lastDayInMonth = isLeapYear(month, year) ? 29 : MONTH_DAYS[month];
              return date > 0 && date <= lastDayInMonth;
            }
            function formatDate(form, date, option) {
              var _option$meridiemSet$A;
              var am = (_option$meridiemSet$A = option === null || option === void 0 ? void 0 : option.meridiemSet.AM) !== null && _option$meridiemSet$A !== void 0 ? _option$meridiemSet$A : "AM";
              var pm = (option === null || option === void 0 ? void 0 : option.meridiemSet.PM) || "PM";
              var nDate;
              if (isDate(date)) {
                nDate = {
                  year: date.getFullYear(),
                  month: date.getMonth() + 1,
                  date: date.getDate(),
                  hour: date.getHours(),
                  minute: date.getMinutes(),
                  second: date.getSeconds()
                };
              } else {
                var year = date.year, month = date.month, hour = date.hour, minute = date.minute, second = date.second;
                nDate = {
                  year,
                  month,
                  date: date.date,
                  hour,
                  minute,
                  second
                };
              }
              if (!isValidDate(nDate.year, nDate.month, nDate.date)) {
                return "";
              }
              nDate.meridiem = "";
              if (/([^\\]|^)[aA]\b/.test(form)) {
                if (nDate.hour > 12) {
                  nDate.hour %= 12;
                }
                if (nDate.hour === 0) {
                  nDate.hour = 12;
                }
                nDate.meridiem = nDate.hour > 11 ? pm : am;
              }
              return form.replace(tokens, function(key) {
                if (key.indexOf("\\") > -1) {
                  return key.replace(/\\/, "");
                }
                return replaceMap[key](nDate) || "";
              });
            }
            ;
            var semiCircleCenterYRatio = {
              COUNTER_CLOCKWISE: 0.1,
              CLOCKWISE: 1
            };
            function hasClockwiseSemiCircle(clockwise, startAngle, endAngle) {
              return clockwise && (startAngle >= DEGREE_NEGATIVE_90 && endAngle <= DEGREE_90 || startAngle >= DEGREE_90 && endAngle <= DEGREE_180);
            }
            function hasCounterClockwiseSemiCircle(clockwise, startAngle, endAngle) {
              return !clockwise && (startAngle >= DEGREE_NEGATIVE_180 && endAngle <= DEGREE_90 || startAngle <= DEGREE_90 && endAngle >= DEGREE_NEGATIVE_90);
            }
            function getRadius(defaultRadius, radius) {
              return isString(radius) ? Number((defaultRadius * getPercentageValue(radius) / 100).toFixed(2)) : radius;
            }
            function getTotalAngle(clockwise, startAngle, endAngle) {
              var diffAngle = endAngle - startAngle;
              var absDiff = Math.abs(diffAngle);
              var needSubstractAngle = diffAngle > DEGREE_0 && absDiff !== DEGREE_360 && !clockwise || diffAngle < DEGREE_0 && absDiff !== DEGREE_360 && clockwise;
              return needSubstractAngle ? DEGREE_360 - absDiff : absDiff;
            }
            function isSemiCircle(clockwise, startAngle, endAngle) {
              return getTotalAngle(clockwise, startAngle, endAngle) <= DEGREE_180 && (hasClockwiseSemiCircle(clockwise, startAngle, endAngle) || hasCounterClockwiseSemiCircle(clockwise, startAngle, endAngle));
            }
            function getSemiCircleCenterY(rectHeight, clockwise) {
              return clockwise ? rectHeight * semiCircleCenterYRatio.CLOCKWISE : rectHeight * semiCircleCenterYRatio.COUNTER_CLOCKWISE;
            }
            function makePieTooltipData(seriesRawData) {
              var category2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
              return seriesRawData.filter(function(_ref) {
                var data = _ref.data;
                return !isNull(data);
              }).map(function(_ref2) {
                var data = _ref2.data, name = _ref2.name, color = _ref2.color, rootParentName = _ref2.rootParentName;
                return {
                  label: name,
                  color,
                  value: data,
                  category: category2,
                  rootParentName,
                  templateType: "pie"
                };
              });
            }
            function hasNestedPieSeries(series) {
              var _series$pie$;
              return !!(series.pie && Array.isArray((_series$pie$ = series.pie[0]) === null || _series$pie$ === void 0 ? void 0 : _series$pie$.data));
            }
            function getNestedPieChartAliasNames(series) {
              return series.pie.map(function(_ref3) {
                var name = _ref3.name;
                return name;
              });
            }
            function pieTooltipLabelFormatter(percentValue) {
              var percentageString = percentValue.toFixed(2);
              var percent = parseFloat(percentageString);
              var needSlice = percentageString.length > 5;
              return "".concat(needSlice ? parseFloat(percentageString.substr(0, 4)) : String(percent), "%");
            }
            function hasOuterDataLabel(options2, series) {
              var _options$series, _options$series$dataL;
              return !!series.pie && (options2 === null || options2 === void 0 ? void 0 : (_options$series = options2.series) === null || _options$series === void 0 ? void 0 : (_options$series$dataL = _options$series.dataLabels) === null || _options$series$dataL === void 0 ? void 0 : _options$series$dataL.anchor) === "outer";
            }
            function hasOuterPieSeriesName(options2, series) {
              var _options$series2, _options$series2$data, _options$series2$data2;
              return !!series.pie && (options2 === null || options2 === void 0 ? void 0 : (_options$series2 = options2.series) === null || _options$series2 === void 0 ? void 0 : (_options$series2$data = _options$series2.dataLabels) === null || _options$series2$data === void 0 ? void 0 : (_options$series2$data2 = _options$series2$data.pieSeriesName) === null || _options$series2$data2 === void 0 ? void 0 : _options$series2$data2.anchor) === "outer";
            }
            ;
            var Y_LABEL_PADDING = 5;
            var RADIAL_LABEL_PADDING = 25;
            var RadialAxisType;
            (function(RadialAxisType2) {
              RadialAxisType2["CIRCULAR"] = "circularAxis";
              RadialAxisType2["VERTICAL"] = "verticalAxis";
            })(RadialAxisType || (RadialAxisType = {}));
            function getYAxisLabelAlign() {
              var clockwise = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
              var isLabelOnVerticalAxis = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
              var align = "center";
              if (isLabelOnVerticalAxis) {
                align = clockwise ? "right" : "left";
              }
              return align;
            }
            function getVerticalAxisData(_ref) {
              var labels = _ref.labels, pointOnColumn = _ref.pointOnColumn, intervalData = _ref.intervalData, isLabelOnVerticalAxis = _ref.isLabelOnVerticalAxis, verticalAxisLabelMargin = _ref.verticalAxisLabelMargin, verticalAxisLabelFont = _ref.verticalAxisLabelFont, defaultAxisData = _ref.defaultAxisData, radiusData = _ref.radiusData;
              var clockwise = defaultAxisData.clockwise, axisSize = defaultAxisData.axisSize, centerX = defaultAxisData.centerX, centerY = defaultAxisData.centerY, startAngle = defaultAxisData.startAngle, endAngle = defaultAxisData.endAngle;
              var radiusRanges = radiusData.radiusRanges, innerRadius = radiusData.innerRadius, outerRadius = radiusData.outerRadius;
              var labelInterval = intervalData.labelInterval;
              var _getMaxLabelSize = getMaxLabelSize(labels, verticalAxisLabelMargin, verticalAxisLabelFont), maxLabelWidth = _getMaxLabelSize.maxLabelWidth, maxLabelHeight = _getMaxLabelSize.maxLabelHeight;
              return {
                axisSize,
                centerX,
                centerY,
                label: {
                  labels,
                  interval: labelInterval,
                  margin: verticalAxisLabelMargin,
                  maxWidth: maxLabelWidth,
                  maxHeight: maxLabelHeight,
                  align: getYAxisLabelAlign(clockwise, isLabelOnVerticalAxis)
                },
                radius: {
                  inner: innerRadius,
                  outer: outerRadius,
                  ranges: radiusRanges
                },
                angle: {
                  start: startAngle,
                  end: endAngle
                },
                tickDistance: (outerRadius - innerRadius) / labels.length,
                pointOnColumn
              };
            }
            function getCircularAxisData(_ref2) {
              var labels = _ref2.labels, intervalData = _ref2.intervalData, circularAxisLabelMargin = _ref2.circularAxisLabelMargin, circularAxisLabelFont = _ref2.circularAxisLabelFont, defaultAxisData = _ref2.defaultAxisData, radiusData = _ref2.radiusData;
              var _getMaxLabelSize2 = getMaxLabelSize(labels, circularAxisLabelMargin, circularAxisLabelFont), maxLabelWidth = _getMaxLabelSize2.maxLabelWidth, maxLabelHeight = _getMaxLabelSize2.maxLabelHeight;
              var totalAngle = defaultAxisData.totalAngle, clockwise = defaultAxisData.clockwise, axisSize = defaultAxisData.axisSize, centerX = defaultAxisData.centerX, centerY = defaultAxisData.centerY, startAngle = defaultAxisData.startAngle, endAngle = defaultAxisData.endAngle, drawingStartAngle = defaultAxisData.drawingStartAngle;
              var tickInterval = intervalData.tickInterval, labelInterval = intervalData.labelInterval;
              var innerRadius = radiusData.innerRadius, outerRadius = radiusData.outerRadius;
              var centralAngle = totalAngle / (labels.length + (totalAngle < DEGREE_360 ? -1 : DEGREE_0));
              return {
                axisSize,
                centerX,
                centerY,
                label: {
                  labels,
                  interval: labelInterval,
                  margin: circularAxisLabelMargin,
                  maxWidth: maxLabelWidth,
                  maxHeight: maxLabelHeight
                },
                radius: {
                  inner: innerRadius,
                  outer: outerRadius
                },
                angle: {
                  start: startAngle,
                  end: endAngle,
                  total: totalAngle,
                  central: centralAngle,
                  drawingStart: drawingStartAngle
                },
                tickInterval,
                clockwise
              };
            }
            function makeLabels(options2, rawLabels, axisName) {
              var _options$axisName$lab, _options$axisName, _options$axisName$lab2;
              var formatter = (_options$axisName$lab = (_options$axisName = options2[axisName]) === null || _options$axisName === void 0 ? void 0 : (_options$axisName$lab2 = _options$axisName.label) === null || _options$axisName$lab2 === void 0 ? void 0 : _options$axisName$lab2.formatter) !== null && _options$axisName$lab !== void 0 ? _options$axisName$lab : function(value) {
                return value;
              };
              return rawLabels.map(function(label2, index) {
                return formatter(label2, {
                  index,
                  labels: rawLabels,
                  axisName
                });
              });
            }
            function getAxisLabels(isLabelOnVerticalAxis, options2, categories, scale2) {
              var valueAxisName = isLabelOnVerticalAxis ? RadialAxisType.CIRCULAR : RadialAxisType.VERTICAL;
              var _ref3 = scale2[valueAxisName], limit = _ref3.limit, stepSize = _ref3.stepSize;
              var valueLabels = makeLabels(options2, makeLabelsFromLimit(limit, stepSize), valueAxisName);
              var categoryLabels = makeLabels(options2, categories, isLabelOnVerticalAxis ? RadialAxisType.VERTICAL : RadialAxisType.CIRCULAR);
              return {
                radialAxisLabels: isLabelOnVerticalAxis ? valueLabels : categoryLabels,
                yAxisLabels: isLabelOnVerticalAxis ? categoryLabels : valueLabels
              };
            }
            function getAxisLabelMargin(isLabelOnVerticalAxis, options2) {
              var _verticalAxis$label$m, _verticalAxis, _verticalAxis$label, _options$circularAxis, _options$circularAxis2, _options$circularAxis3;
              return {
                verticalAxisLabelMargin: (_verticalAxis$label$m = options2 === null || options2 === void 0 ? void 0 : (_verticalAxis = options2.verticalAxis) === null || _verticalAxis === void 0 ? void 0 : (_verticalAxis$label = _verticalAxis.label) === null || _verticalAxis$label === void 0 ? void 0 : _verticalAxis$label.margin) !== null && _verticalAxis$label$m !== void 0 ? _verticalAxis$label$m : isLabelOnVerticalAxis ? Y_LABEL_PADDING : 0,
                circularAxisLabelMargin: (_options$circularAxis = options2 === null || options2 === void 0 ? void 0 : (_options$circularAxis2 = options2.circularAxis) === null || _options$circularAxis2 === void 0 ? void 0 : (_options$circularAxis3 = _options$circularAxis2.label) === null || _options$circularAxis3 === void 0 ? void 0 : _options$circularAxis3.margin) !== null && _options$circularAxis !== void 0 ? _options$circularAxis : RADIAL_LABEL_PADDING
              };
            }
            var axes = {
              name: "radialAxes",
              state: function state() {
                return {
                  radialAxes: {}
                };
              },
              action: {
                setRadialAxesData: function setRadialAxesData(_ref4) {
                  var _options$series;
                  var state = _ref4.state;
                  var series = state.series, layout2 = state.layout, scale2 = state.scale;
                  var categories = state.categories;
                  var plot2 = layout2.plot;
                  var isLabelOnVerticalAxis = isLabelAxisOnYAxis({
                    series,
                    categories
                  });
                  var options2 = state.options;
                  var theme2 = state.theme;
                  var circularAxisLabelFont = getTitleFontString(theme2.circularAxis.label);
                  var verticalAxisLabelFont = getTitleFontString(theme2.verticalAxis.label);
                  var _getAxisLabelMargin = getAxisLabelMargin(isLabelOnVerticalAxis, options2), verticalAxisLabelMargin = _getAxisLabelMargin.verticalAxisLabelMargin, circularAxisLabelMargin = _getAxisLabelMargin.circularAxisLabelMargin;
                  var _getAxisLabels = getAxisLabels(isLabelOnVerticalAxis, options2, categories, scale2), radialAxisLabels = _getAxisLabels.radialAxisLabels, yAxisLabels = _getAxisLabels.yAxisLabels;
                  var _getMaxLabelSize3 = getMaxLabelSize(radialAxisLabels, circularAxisLabelMargin, circularAxisLabelFont), maxLabelWidth = _getMaxLabelSize3.maxLabelWidth, maxLabelHeight = _getMaxLabelSize3.maxLabelHeight;
                  var defaultAxisData = getDefaultRadialAxisData(options2, plot2, maxLabelWidth, maxLabelHeight + circularAxisLabelMargin, isLabelOnVerticalAxis);
                  var axisSize = defaultAxisData.axisSize;
                  var radiusData = isLabelOnVerticalAxis ? getRadiusInfo(axisSize, options2 === null || options2 === void 0 ? void 0 : (_options$series = options2.series) === null || _options$series === void 0 ? void 0 : _options$series.radiusRange, yAxisLabels.length + 1) : {
                    radiusRanges: makeTickPixelPositions(axisSize, yAxisLabels.length),
                    innerRadius: 0,
                    outerRadius: axisSize
                  };
                  var verticalAxisData = getVerticalAxisData({
                    labels: yAxisLabels,
                    pointOnColumn: isLabelOnVerticalAxis,
                    isLabelOnVerticalAxis,
                    intervalData: getInitAxisIntervalData(isLabelOnVerticalAxis, {
                      axis: options2.verticalAxis,
                      categories,
                      layout: layout2
                    }),
                    verticalAxisLabelMargin,
                    verticalAxisLabelFont,
                    defaultAxisData,
                    radiusData
                  });
                  state.radialAxes = {
                    circularAxis: getCircularAxisData({
                      labels: radialAxisLabels,
                      intervalData: getInitAxisIntervalData(true, {
                        axis: options2.circularAxis,
                        categories,
                        layout: layout2
                      }),
                      defaultAxisData,
                      circularAxisLabelMargin,
                      circularAxisLabelFont,
                      radiusData
                    }),
                    verticalAxis: verticalAxisData
                  };
                }
              },
              observe: {
                updateRadialAxes: function updateRadialAxes() {
                  this.dispatch("setRadialAxesData");
                }
              }
            };
            var radialAxes = axes;
            ;
            function axes_ownKeys(object, enumerableOnly) {
              var keys = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object);
                if (enumerableOnly) {
                  symbols = symbols.filter(function(sym) {
                    return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                  });
                }
                keys.push.apply(keys, symbols);
              }
              return keys;
            }
            function axes_objectSpread(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i] != null ? arguments[i] : {};
                if (i % 2) {
                  axes_ownKeys(Object(source), true).forEach(function(key) {
                    axes_defineProperty(target, key, source[key]);
                  });
                } else if (Object.getOwnPropertyDescriptors) {
                  Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                } else {
                  axes_ownKeys(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  });
                }
              }
              return target;
            }
            function axes_defineProperty(obj, key, value) {
              if (key in obj) {
                Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
              } else {
                obj[key] = value;
              }
              return obj;
            }
            function axes_toConsumableArray(arr) {
              return axes_arrayWithoutHoles(arr) || axes_iterableToArray(arr) || axes_unsupportedIterableToArray(arr) || axes_nonIterableSpread();
            }
            function axes_nonIterableSpread() {
              throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            function axes_unsupportedIterableToArray(o, minLen) {
              if (!o)
                return;
              if (typeof o === "string")
                return axes_arrayLikeToArray(o, minLen);
              var n = Object.prototype.toString.call(o).slice(8, -1);
              if (n === "Object" && o.constructor)
                n = o.constructor.name;
              if (n === "Map" || n === "Set")
                return Array.from(o);
              if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                return axes_arrayLikeToArray(o, minLen);
            }
            function axes_iterableToArray(iter) {
              if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
                return Array.from(iter);
            }
            function axes_arrayWithoutHoles(arr) {
              if (Array.isArray(arr))
                return axes_arrayLikeToArray(arr);
            }
            function axes_arrayLikeToArray(arr, len) {
              if (len == null || len > arr.length)
                len = arr.length;
              for (var i = 0, arr2 = new Array(len); i < len; i++) {
                arr2[i] = arr[i];
              }
              return arr2;
            }
            function makeAdjustingIntervalInfo(blockCount, axisWidth, blockSize) {
              var remainBlockCount;
              var newBlockCount = Math.floor(axisWidth / blockSize);
              var intervalInfo = null;
              var interval = newBlockCount ? Math.floor(blockCount / newBlockCount) : blockCount;
              if (interval > 1) {
                remainBlockCount = blockCount - interval * newBlockCount;
                if (remainBlockCount >= interval) {
                  newBlockCount += Math.floor(remainBlockCount / interval);
                  remainBlockCount = remainBlockCount % interval;
                }
                intervalInfo = {
                  blockCount: newBlockCount,
                  remainBlockCount,
                  interval
                };
              }
              return intervalInfo;
            }
            function getAutoAdjustingInterval(count, axisWidth, categories) {
              var autoInterval = {
                MIN_WIDTH: 90,
                MAX_WIDTH: 121,
                STEP_SIZE: 5
              };
              var LABEL_MARGIN = 5;
              if (categories !== null && categories !== void 0 && categories[0]) {
                var categoryMinWidth = getTextWidth(categories[0]);
                if (categoryMinWidth < axisWidth / count - LABEL_MARGIN) {
                  return 1;
                }
              }
              var candidates = [];
              divisors(count).forEach(function(interval) {
                var intervalWidth = interval / count * axisWidth;
                if (intervalWidth >= autoInterval.MIN_WIDTH && intervalWidth <= autoInterval.MAX_WIDTH) {
                  candidates.push({
                    interval,
                    blockCount: Math.floor(count / interval),
                    remainBlockCount: 0
                  });
                }
              });
              if (!candidates.length) {
                var blockSizeRange = range(autoInterval.MIN_WIDTH, autoInterval.MAX_WIDTH, autoInterval.STEP_SIZE);
                candidates = blockSizeRange.reduce(function(acc, blockSize) {
                  var candidate2 = makeAdjustingIntervalInfo(count, axisWidth, blockSize);
                  return candidate2 ? [].concat(axes_toConsumableArray(acc), [candidate2]) : acc;
                }, []);
              }
              var tickInterval = 1;
              if (candidates.length) {
                var candidate = candidates.reduce(function(acc, cur) {
                  return cur.blockCount > acc.blockCount ? cur : acc;
                }, {
                  blockCount: 0,
                  interval: 1
                });
                tickInterval = candidate.interval;
              }
              return tickInterval;
            }
            function isLabelAxisOnYAxis(_ref) {
              var _series;
              var series = _ref.series, options2 = _ref.options, categories = _ref.categories;
              return !!series.bar || !!series.radialBar || !!series.gauge && Array.isArray(categories) && !categories.length || !!series.bullet && !(options2 !== null && options2 !== void 0 && (_series = options2.series) !== null && _series !== void 0 && _series.vertical);
            }
            function hasBoxTypeSeries(series) {
              return !!series.column || !!series.bar || !!series.boxPlot || !!series.bullet;
            }
            function isPointOnColumn(series, options2) {
              if (hasBoxTypeSeries(series)) {
                return true;
              }
              if (series.line || series.area) {
                var _options$xAxis;
                return Boolean((_options$xAxis = options2.xAxis) === null || _options$xAxis === void 0 ? void 0 : _options$xAxis.pointOnColumn);
              }
              return false;
            }
            function isSeriesUsingRadialAxes(series) {
              return !!series.radar || !!series.radialBar || !!series.gauge;
            }
            function getAxisNameUsingRadialAxes(labelAxisOnYAxis) {
              return {
                valueAxisName: labelAxisOnYAxis ? "circularAxis" : "verticalAxis",
                labelAxisName: labelAxisOnYAxis ? "verticalAxis" : "circularAxis"
              };
            }
            function getAxisName(labelAxisOnYAxis, series) {
              return isSeriesUsingRadialAxes(series) ? getAxisNameUsingRadialAxes(labelAxisOnYAxis) : {
                valueAxisName: labelAxisOnYAxis ? "xAxis" : "yAxis",
                labelAxisName: labelAxisOnYAxis ? "yAxis" : "xAxis"
              };
            }
            function getSizeKey(labelAxisOnYAxis) {
              return {
                valueSizeKey: labelAxisOnYAxis ? "width" : "height",
                labelSizeKey: labelAxisOnYAxis ? "height" : "width"
              };
            }
            function getLimitOnAxis(labels) {
              var values = labels.map(function(label2) {
                return Number(label2);
              });
              return {
                min: Math.min.apply(Math, axes_toConsumableArray(values)),
                max: Math.max.apply(Math, axes_toConsumableArray(values))
              };
            }
            function hasSecondaryYAxis(options2) {
              return Array.isArray(options2 === null || options2 === void 0 ? void 0 : options2.yAxis) && options2.yAxis.length === 2;
            }
            function getYAxisOption(options2) {
              var secondaryYAxis = hasSecondaryYAxis(options2);
              return {
                yAxis: secondaryYAxis ? options2.yAxis[0] : options2 === null || options2 === void 0 ? void 0 : options2.yAxis,
                secondaryYAxis: secondaryYAxis ? options2.yAxis[1] : null
              };
            }
            function getValueAxisName(options2, seriesName, valueAxisName) {
              var _getYAxisOption = getYAxisOption(options2), secondaryYAxis = _getYAxisOption.secondaryYAxis;
              return (secondaryYAxis === null || secondaryYAxis === void 0 ? void 0 : secondaryYAxis.chartType) === seriesName ? "secondaryYAxis" : valueAxisName;
            }
            function getValueAxisNames(options2, valueAxisName) {
              if (includes([AxisType.X, AxisType.CIRCULAR, AxisType.VERTICAL], valueAxisName)) {
                return [valueAxisName];
              }
              var optionsUsingYAxis = options2;
              var _getYAxisOption2 = getYAxisOption(optionsUsingYAxis), yAxis = _getYAxisOption2.yAxis, secondaryYAxis = _getYAxisOption2.secondaryYAxis;
              return secondaryYAxis ? [yAxis.chartType, secondaryYAxis.chartType].map(function(seriesName, index) {
                return seriesName ? getValueAxisName(optionsUsingYAxis, seriesName, valueAxisName) : ["yAxis", "secondaryYAxis"][index];
              }) : [valueAxisName];
            }
            function getAxisTheme(theme2, name) {
              var xAxis = theme2.xAxis, yAxis = theme2.yAxis, circularAxis = theme2.circularAxis;
              var axisTheme;
              if (name === AxisType.X) {
                axisTheme = xAxis;
              } else if (Array.isArray(yAxis)) {
                axisTheme = name === AxisType.Y ? yAxis[0] : yAxis[1];
              } else if (name === RadialAxisType.CIRCULAR) {
                axisTheme = circularAxis;
              } else {
                axisTheme = yAxis;
              }
              return axisTheme;
            }
            function getRotationDegree(distance, labelWidth, labelHeight, axisLayout) {
              var degree = 0;
              ANGLE_CANDIDATES.every(function(angle) {
                var compareWidth = calculateRotatedWidth(angle, labelWidth, labelHeight);
                degree = angle;
                return compareWidth > distance || compareWidth / 2 > axisLayout.x;
              });
              return distance < labelWidth || labelWidth / 2 > axisLayout.x ? degree : 0;
            }
            function hasYAxisMaxLabelLengthChanged(previousAxes, currentAxes, field) {
              var prevYAxis = previousAxes[field];
              var yAxis = currentAxes[field];
              if (!prevYAxis && !yAxis) {
                return false;
              }
              return (prevYAxis === null || prevYAxis === void 0 ? void 0 : prevYAxis.maxLabelWidth) !== (yAxis === null || yAxis === void 0 ? void 0 : yAxis.maxLabelWidth);
            }
            function hasYAxisTypeMaxLabelChanged(previousAxes, currentAxes) {
              return hasYAxisMaxLabelLengthChanged(previousAxes, currentAxes, "yAxis") || hasYAxisMaxLabelLengthChanged(previousAxes, currentAxes, "secondaryYAxis");
            }
            function hasXAxisSizeChanged(previousAxes, currentAxes) {
              var prevMaxHeight = previousAxes.xAxis.maxHeight;
              var maxHeight = currentAxes.xAxis.maxHeight;
              return prevMaxHeight !== maxHeight;
            }
            function hasAxesLayoutChanged(previousAxes, currentAxes) {
              return hasYAxisTypeMaxLabelChanged(previousAxes, currentAxes) || hasXAxisSizeChanged(previousAxes, currentAxes);
            }
            function getRotatableOption(options2) {
              var _options$xAxis$label$, _options$xAxis2, _options$xAxis2$label;
              return (_options$xAxis$label$ = options2 === null || options2 === void 0 ? void 0 : (_options$xAxis2 = options2.xAxis) === null || _options$xAxis2 === void 0 ? void 0 : (_options$xAxis2$label = _options$xAxis2.label) === null || _options$xAxis2$label === void 0 ? void 0 : _options$xAxis2$label.rotatable) !== null && _options$xAxis$label$ !== void 0 ? _options$xAxis$label$ : true;
            }
            function getViewAxisLabels(axisData, axisSize) {
              var labels = axisData.labels, pointOnColumn = axisData.pointOnColumn, labelDistance = axisData.labelDistance, tickDistance = axisData.tickDistance, labelInterval = axisData.labelInterval, tickInterval = axisData.tickInterval, tickCount = axisData.tickCount, scale2 = axisData.scale;
              var axisSizeAppliedRatio = axisSize;
              var additional = 0;
              var labelAdjustment = 0;
              if (scale2) {
                var _scale$sizeRatio, _scale$positionRatio;
                var sizeRatio = (_scale$sizeRatio = scale2 === null || scale2 === void 0 ? void 0 : scale2.sizeRatio) !== null && _scale$sizeRatio !== void 0 ? _scale$sizeRatio : 1;
                var positionRatio = (_scale$positionRatio = scale2 === null || scale2 === void 0 ? void 0 : scale2.positionRatio) !== null && _scale$positionRatio !== void 0 ? _scale$positionRatio : 0;
                axisSizeAppliedRatio = axisSize * sizeRatio;
                additional = axisSize * positionRatio;
              } else {
                var interval = labelInterval === tickInterval ? labelInterval : 1;
                labelAdjustment = pointOnColumn ? (labelDistance !== null && labelDistance !== void 0 ? labelDistance : tickDistance * interval) / 2 : 0;
              }
              var relativePositions = makeTickPixelPositions(axisSizeAppliedRatio, tickCount, additional);
              return labels.reduce(function(acc, text, index) {
                var offsetPos = relativePositions[index] + labelAdjustment;
                var needRender = !(index % labelInterval) && offsetPos <= axisSize;
                return needRender ? [].concat(axes_toConsumableArray(acc), [{
                  offsetPos,
                  text
                }]) : acc;
              }, []);
            }
            function makeTitleOption(title) {
              if (isUndefined(title)) {
                return title;
              }
              var defaultOption = {
                text: "",
                offsetX: 0,
                offsetY: 0
              };
              return utils_isString(title) ? axes_objectSpread(axes_objectSpread({}, defaultOption), {}, {
                text: title
              }) : axes_objectSpread(axes_objectSpread({}, defaultOption), title);
            }
            function getAxisFormatter(options2, axisName) {
              var _axisOptions$axisName, _axisOptions$axisName2, _axisOptions$axisName3;
              var axisOptions = axes_objectSpread(axes_objectSpread({}, getYAxisOption(options2)), {}, {
                xAxis: options2.xAxis
              });
              return (_axisOptions$axisName = (_axisOptions$axisName2 = axisOptions[axisName]) === null || _axisOptions$axisName2 === void 0 ? void 0 : (_axisOptions$axisName3 = _axisOptions$axisName2.label) === null || _axisOptions$axisName3 === void 0 ? void 0 : _axisOptions$axisName3.formatter) !== null && _axisOptions$axisName !== void 0 ? _axisOptions$axisName : function(value) {
                return value;
              };
            }
            function getLabelsAppliedFormatter(labels, options2, dateType, axisName) {
              var _options$axisName;
              var dateFormatter = getDateFormat(options2 === null || options2 === void 0 ? void 0 : (_options$axisName = options2[axisName]) === null || _options$axisName === void 0 ? void 0 : _options$axisName.date);
              var formattedLabels = dateType && dateFormatter ? labels.map(function(label2) {
                return formatDate(dateFormatter, new Date(label2));
              }) : labels;
              var formatter = getAxisFormatter(options2, axisName);
              return formattedLabels.map(function(label2, index) {
                return formatter(label2, {
                  index,
                  labels,
                  axisName
                });
              });
            }
            function makeRotationData(maxLabelWidth, maxLabelHeight, distance, rotatable, axisLayout) {
              var degree = getRotationDegree(distance, maxLabelWidth, maxLabelHeight, axisLayout);
              if (!rotatable || degree === 0) {
                return {
                  needRotateLabel: false,
                  radian: 0,
                  rotationHeight: maxLabelHeight
                };
              }
              return {
                needRotateLabel: degree > 0,
                radian: calculateDegreeToRadian(degree, 0),
                rotationHeight: calculateRotatedHeight(degree, maxLabelWidth, maxLabelHeight)
              };
            }
            function getMaxLabelSize(labels, xMargin) {
              var font = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : DEFAULT_LABEL_TEXT;
              var maxLengthLabel = labels.reduce(function(acc, cur) {
                return acc.length > cur.length ? acc : cur;
              }, "");
              return {
                maxLabelWidth: getTextWidth(maxLengthLabel, font) + xMargin,
                maxLabelHeight: getTextHeight(maxLengthLabel, font)
              };
            }
            function getLabelXMargin(axisName, options2) {
              var _axisOptions$axisName4, _axisOptions$axisName5, _axisOptions$axisName6;
              if (axisName === "xAxis") {
                return 0;
              }
              var axisOptions = getYAxisOption(options2);
              return Math.abs((_axisOptions$axisName4 = axisOptions === null || axisOptions === void 0 ? void 0 : (_axisOptions$axisName5 = axisOptions[axisName]) === null || _axisOptions$axisName5 === void 0 ? void 0 : (_axisOptions$axisName6 = _axisOptions$axisName5.label) === null || _axisOptions$axisName6 === void 0 ? void 0 : _axisOptions$axisName6.margin) !== null && _axisOptions$axisName4 !== void 0 ? _axisOptions$axisName4 : 0);
            }
            function getInitAxisIntervalData(isLabelAxis, params) {
              var _axis$tick, _axis$label, _axis$scale;
              var axis = params.axis, categories = params.categories, layout2 = params.layout, isCoordinateTypeChart = params.isCoordinateTypeChart;
              var tickInterval = axis === null || axis === void 0 ? void 0 : (_axis$tick = axis.tick) === null || _axis$tick === void 0 ? void 0 : _axis$tick.interval;
              var labelInterval = axis === null || axis === void 0 ? void 0 : (_axis$label = axis.label) === null || _axis$label === void 0 ? void 0 : _axis$label.interval;
              var existIntervalOptions = isNumber(tickInterval) || isNumber(labelInterval);
              var needAdjustInterval = isLabelAxis && !isNumber(axis === null || axis === void 0 ? void 0 : (_axis$scale = axis.scale) === null || _axis$scale === void 0 ? void 0 : _axis$scale.stepSize) && !params.shift && !existIntervalOptions && !isCoordinateTypeChart;
              var initTickInterval = needAdjustInterval ? getInitTickInterval(categories, layout2) : 1;
              var initLabelInterval = needAdjustInterval ? initTickInterval : 1;
              var axisData = {
                tickInterval: tickInterval !== null && tickInterval !== void 0 ? tickInterval : initTickInterval,
                labelInterval: labelInterval !== null && labelInterval !== void 0 ? labelInterval : initLabelInterval
              };
              return axisData;
            }
            function getInitTickInterval(categories, layout2) {
              if (!categories || !layout2) {
                return 1;
              }
              var width = layout2.xAxis.width;
              var count = categories.length;
              return getAutoAdjustingInterval(count, width, categories);
            }
            function getDefaultRadialAxisData(options2, plot2) {
              var maxLabelWidth = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
              var maxLabelHeight = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
              var isLabelOnVerticalAxis = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
              var centerX = plot2.width / 2;
              if (isLabelOnVerticalAxis) {
                var _initSectorOptions = initSectorOptions(options2 === null || options2 === void 0 ? void 0 : options2.series), startAngle = _initSectorOptions.startAngle, endAngle = _initSectorOptions.endAngle, clockwise = _initSectorOptions.clockwise;
                var isSemiCircular = isSemiCircle(clockwise, startAngle, endAngle);
                return {
                  isSemiCircular,
                  axisSize: getDefaultRadius(plot2, isSemiCircular, maxLabelWidth, maxLabelHeight),
                  centerX,
                  centerY: isSemiCircular ? getSemiCircleCenterY(plot2.height, clockwise) : plot2.height / 2,
                  totalAngle: getTotalAngle(clockwise, startAngle, endAngle),
                  drawingStartAngle: startAngle,
                  clockwise,
                  startAngle,
                  endAngle
                };
              }
              return {
                isSemiCircular: false,
                axisSize: getDefaultRadius(plot2, false, maxLabelWidth, maxLabelHeight),
                centerX,
                centerY: plot2.height / 2,
                totalAngle: DEGREE_360,
                drawingStartAngle: DEGREE_0,
                clockwise: true,
                startAngle: DEGREE_0,
                endAngle: DEGREE_360
              };
            }
            function getRadiusInfo(axisSize, radiusRange) {
              var _radiusRange$inner, _radiusRange$outer;
              var count = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
              var innerRadius = calculateSizeWithPercentString(axisSize, (_radiusRange$inner = radiusRange === null || radiusRange === void 0 ? void 0 : radiusRange.inner) !== null && _radiusRange$inner !== void 0 ? _radiusRange$inner : 0);
              var outerRadius = calculateSizeWithPercentString(axisSize, (_radiusRange$outer = radiusRange === null || radiusRange === void 0 ? void 0 : radiusRange.outer) !== null && _radiusRange$outer !== void 0 ? _radiusRange$outer : axisSize);
              return {
                radiusRanges: makeTickPixelPositions(outerRadius - innerRadius, count, innerRadius).splice(innerRadius === 0 ? 1 : 0, count).reverse(),
                innerRadius,
                outerRadius
              };
            }
            function isDateType(options2, axisName) {
              var _options$axisName2;
              return !!((_options$axisName2 = options2[axisName]) !== null && _options$axisName2 !== void 0 && _options$axisName2.date);
            }
            ;
            function getCoordinateYValue(datum) {
              if (isNumber(datum)) {
                return datum;
              }
              return Array.isArray(datum) ? datum[1] : datum.y;
            }
            function getCoordinateXValue(datum) {
              return Array.isArray(datum) ? datum[0] : datum.x;
            }
            function isValueAfterLastCategory(value, categories) {
              var category2 = last(categories);
              if (!category2) {
                return false;
              }
              return isNumber(value) ? value >= Number(category2) : new Date(value) >= new Date(category2);
            }
            function getCoordinateDataIndex(datum, categories, dataIndex, startIndex) {
              if (isNumber(datum)) {
                return dataIndex - startIndex;
              }
              var value = getCoordinateXValue(datum);
              var index = categories.findIndex(function(category2) {
                return category2 === String(value);
              });
              if (index === -1 && isValueAfterLastCategory(value, categories)) {
                index = categories.length;
              }
              return index;
            }
            function isLineCoordinateSeries(series) {
              var _series$line$;
              if (!series.line) {
                return false;
              }
              var firstData = getFirstValidValue((_series$line$ = series.line[0]) === null || _series$line$ === void 0 ? void 0 : _series$line$.data);
              return firstData && (Array.isArray(firstData) || isObject(firstData));
            }
            function isCoordinateSeries(series) {
              return isLineCoordinateSeries(series) || !!series.scatter || !!series.bubble;
            }
            function isModelExistingInRect(rect2, point) {
              var height = rect2.height, width = rect2.width;
              var x = point.x, y = point.y;
              return x >= 0 && x <= width && y >= 0 && y <= height;
            }
            function isMouseInRect(rect2, mousePosition) {
              var x = rect2.x, y = rect2.y, width = rect2.width, height = rect2.height;
              return mousePosition.x >= x && mousePosition.x <= x + width && mousePosition.y >= y && mousePosition.y <= y + height;
            }
            ;
            function store_axes_ownKeys(object, enumerableOnly) {
              var keys = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object);
                if (enumerableOnly) {
                  symbols = symbols.filter(function(sym) {
                    return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                  });
                }
                keys.push.apply(keys, symbols);
              }
              return keys;
            }
            function store_axes_objectSpread(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i] != null ? arguments[i] : {};
                if (i % 2) {
                  store_axes_ownKeys(Object(source), true).forEach(function(key) {
                    store_axes_defineProperty(target, key, source[key]);
                  });
                } else if (Object.getOwnPropertyDescriptors) {
                  Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                } else {
                  store_axes_ownKeys(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  });
                }
              }
              return target;
            }
            function store_axes_defineProperty(obj, key, value) {
              if (key in obj) {
                Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
              } else {
                obj[key] = value;
              }
              return obj;
            }
            function store_axes_toConsumableArray(arr) {
              return store_axes_arrayWithoutHoles(arr) || store_axes_iterableToArray(arr) || store_axes_unsupportedIterableToArray(arr) || store_axes_nonIterableSpread();
            }
            function store_axes_nonIterableSpread() {
              throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            function store_axes_unsupportedIterableToArray(o, minLen) {
              if (!o)
                return;
              if (typeof o === "string")
                return store_axes_arrayLikeToArray(o, minLen);
              var n = Object.prototype.toString.call(o).slice(8, -1);
              if (n === "Object" && o.constructor)
                n = o.constructor.name;
              if (n === "Map" || n === "Set")
                return Array.from(o);
              if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                return store_axes_arrayLikeToArray(o, minLen);
            }
            function store_axes_iterableToArray(iter) {
              if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
                return Array.from(iter);
            }
            function store_axes_arrayWithoutHoles(arr) {
              if (Array.isArray(arr))
                return store_axes_arrayLikeToArray(arr);
            }
            function store_axes_arrayLikeToArray(arr, len) {
              if (len == null || len > arr.length)
                len = arr.length;
              for (var i = 0, arr2 = new Array(len); i < len; i++) {
                arr2[i] = arr[i];
              }
              return arr2;
            }
            function isCenterYAxis(options2) {
              var _options$yAxis;
              var diverging = !!pickProperty(options2, ["series", "diverging"]);
              var alignCenter = (options2 === null || options2 === void 0 ? void 0 : (_options$yAxis = options2.yAxis) === null || _options$yAxis === void 0 ? void 0 : _options$yAxis.align) === "center";
              return diverging && alignCenter;
            }
            function isDivergingBoxSeries(series, options2) {
              var _options$series;
              return hasBoxTypeSeries(series) && !!((_options$series = options2.series) !== null && _options$series !== void 0 && _options$series.diverging);
            }
            function getZeroPosition(limit, axisSize, labelAxisOnYAxis, isDivergingSeries) {
              var min = limit.min, max2 = limit.max;
              var hasZeroValue = min <= 0 && max2 >= 0;
              if (!hasZeroValue || isDivergingSeries) {
                return null;
              }
              var position = (0 - min) / (max2 - min) * axisSize;
              return labelAxisOnYAxis ? position : axisSize - position;
            }
            function getLabelAxisData(stateProp) {
              var axisSize = stateProp.axisSize, categories = stateProp.categories, series = stateProp.series, options2 = stateProp.options, theme2 = stateProp.theme, scale2 = stateProp.scale, initialAxisData = stateProp.initialAxisData, isCoordinateTypeChart = stateProp.isCoordinateTypeChart, axisName = stateProp.axisName;
              var hasLineSeries = !!series.line;
              var pointOnColumn = isPointOnColumn(series, options2);
              var dateType = isDateType(options2, axisName);
              var labelsBeforeFormatting = isCoordinateTypeChart ? makeLabelsFromLimit(scale2.limit, scale2.stepSize, dateType) : categories;
              var labels = getLabelsAppliedFormatter(labelsBeforeFormatting, options2, dateType, axisName);
              var labelRange;
              if (scale2 && hasLineSeries) {
                var baseLabels = pointOnColumn ? labelsBeforeFormatting : categories;
                var values = baseLabels.map(function(value) {
                  return dateType ? Number(new Date(value)) : Number(value);
                });
                labelRange = {
                  min: Math.min.apply(Math, store_axes_toConsumableArray(values)),
                  max: Math.max.apply(Math, store_axes_toConsumableArray(values))
                };
              }
              var rectResponderCount = categories.length;
              var tickIntervalCount = rectResponderCount - (pointOnColumn ? 0 : 1);
              var tickDistance = tickIntervalCount ? axisSize / tickIntervalCount : axisSize;
              var labelDistance = axisSize / (labels.length - (pointOnColumn ? 0 : 1));
              var tickCount = labels.length;
              if (pointOnColumn && !isCoordinateTypeChart) {
                tickCount += 1;
              }
              var viewLabels = getViewAxisLabels(store_axes_objectSpread({
                labels,
                pointOnColumn,
                tickDistance,
                tickCount,
                scale: scale2
              }, initialAxisData), axisSize);
              var axisLabelMargin = getLabelXMargin(axisName, options2);
              return store_axes_objectSpread(store_axes_objectSpread({
                labels,
                viewLabels,
                pointOnColumn,
                labelDistance,
                tickDistance,
                tickCount,
                labelRange,
                rectResponderCount,
                isLabelAxis: true
              }, initialAxisData), getMaxLabelSize(labels, axisLabelMargin, getTitleFontString(theme2.label)));
            }
            function getValueAxisData(stateProp) {
              var scale2 = stateProp.scale, axisSize = stateProp.axisSize, series = stateProp.series, options2 = stateProp.options, centerYAxis = stateProp.centerYAxis, initialAxisData = stateProp.initialAxisData, theme2 = stateProp.theme, labelOnYAxis = stateProp.labelOnYAxis, axisName = stateProp.axisName;
              var limit = scale2.limit, stepSize = scale2.stepSize;
              var size = centerYAxis ? centerYAxis === null || centerYAxis === void 0 ? void 0 : centerYAxis.xAxisHalfSize : axisSize;
              var divergingBoxSeries = isDivergingBoxSeries(series, options2);
              var formatter = getAxisFormatter(options2, axisName);
              var zeroPosition = getZeroPosition(limit, axisSize, isLabelAxisOnYAxis({
                series,
                options: options2
              }), divergingBoxSeries);
              var valueLabels = makeLabelsFromLimit(limit, stepSize);
              if (!centerYAxis && divergingBoxSeries) {
                valueLabels = getDivergingValues(valueLabels);
              }
              var labels = valueLabels.map(function(label2, index) {
                return formatter(label2, {
                  index,
                  labels: valueLabels,
                  axisName
                });
              });
              var tickDistance = size / Math.max(valueLabels.length, 1);
              var tickCount = valueLabels.length;
              var pointOnColumn = false;
              var viewLabels = getViewAxisLabels(store_axes_objectSpread({
                labels: labelOnYAxis ? labels : store_axes_toConsumableArray(labels).reverse(),
                pointOnColumn,
                tickDistance,
                tickCount
              }, initialAxisData), size);
              var axisLabelMargin = getLabelXMargin(axisName, options2);
              var axisData = store_axes_objectSpread(store_axes_objectSpread({
                labels,
                viewLabels,
                pointOnColumn,
                isLabelAxis: false,
                tickCount,
                tickDistance
              }, initialAxisData), getMaxLabelSize(labels, axisLabelMargin, getTitleFontString(theme2.label)));
              if (isNumber(zeroPosition)) {
                axisData.zeroPosition = zeroPosition;
              }
              return axisData;
            }
            function getDivergingValues(valueLabels) {
              return hasNegativeOnly(valueLabels) ? valueLabels.reverse().slice(1).concat(valueLabels) : valueLabels.slice(1).reverse().concat(valueLabels);
            }
            function makeDefaultAxisData(isLabelAxis, params) {
              var _params$axis;
              var axisData = getInitAxisIntervalData(isLabelAxis, params);
              var title = makeTitleOption(params === null || params === void 0 ? void 0 : (_params$axis = params.axis) === null || _params$axis === void 0 ? void 0 : _params$axis.title);
              if (title) {
                axisData.title = title;
              }
              return axisData;
            }
            function getInitialAxisData(options2, labelOnYAxis, categories, layout2, isCoordinateTypeChart) {
              var _options$series2;
              var _getYAxisOption = getYAxisOption(options2), yAxis = _getYAxisOption.yAxis, secondaryYAxis = _getYAxisOption.secondaryYAxis;
              var shift = options2 === null || options2 === void 0 ? void 0 : (_options$series2 = options2.series) === null || _options$series2 === void 0 ? void 0 : _options$series2.shift;
              return {
                xAxis: makeDefaultAxisData(!labelOnYAxis, {
                  categories,
                  axis: options2 === null || options2 === void 0 ? void 0 : options2.xAxis,
                  layout: layout2,
                  shift,
                  isCoordinateTypeChart
                }),
                yAxis: makeDefaultAxisData(labelOnYAxis, {
                  axis: yAxis
                }),
                secondaryYAxis: secondaryYAxis ? makeDefaultAxisData(labelOnYAxis, {
                  axis: secondaryYAxis
                }) : null
              };
            }
            function getSecondaryYAxisData(_ref) {
              var _getYAxisOption$secon, _getYAxisOption$secon2;
              var state = _ref.state, labelOnYAxis = _ref.labelOnYAxis, valueAxisSize = _ref.valueAxisSize, labelAxisSize = _ref.labelAxisSize, initialAxisData = _ref.initialAxisData, isCoordinateTypeChart = _ref.isCoordinateTypeChart;
              var scale2 = state.scale, options2 = state.options, series = state.series, theme2 = state.theme;
              var categories = state.categories;
              return labelOnYAxis ? getLabelAxisData({
                scale: scale2.secondaryYAxis,
                axisSize: labelAxisSize,
                categories: (_getYAxisOption$secon = (_getYAxisOption$secon2 = getYAxisOption(options2).secondaryYAxis) === null || _getYAxisOption$secon2 === void 0 ? void 0 : _getYAxisOption$secon2.categories) !== null && _getYAxisOption$secon !== void 0 ? _getYAxisOption$secon : categories,
                options: options2,
                series,
                theme: getAxisTheme(theme2, AxisType.SECONDARY_Y),
                initialAxisData,
                isCoordinateTypeChart,
                axisName: AxisType.SECONDARY_Y
              }) : getValueAxisData({
                scale: scale2.secondaryYAxis,
                axisSize: valueAxisSize,
                options: options2,
                series,
                theme: getAxisTheme(theme2, AxisType.SECONDARY_Y),
                centerYAxis: null,
                initialAxisData,
                axisName: AxisType.SECONDARY_Y
              });
            }
            function makeXAxisData(_ref2) {
              var axisData = _ref2.axisData, axisSize = _ref2.axisSize, axisLayout = _ref2.axisLayout, centerYAxis = _ref2.centerYAxis, rotatable = _ref2.rotatable, _ref2$labelMargin = _ref2.labelMargin, labelMargin = _ref2$labelMargin === void 0 ? 0 : _ref2$labelMargin;
              var viewLabels = axisData.viewLabels, pointOnColumn = axisData.pointOnColumn, maxLabelWidth = axisData.maxLabelWidth, maxLabelHeight = axisData.maxLabelHeight;
              var offsetY = getAxisLabelAnchorPoint(maxLabelHeight) + labelMargin;
              var size = centerYAxis ? centerYAxis.xAxisHalfSize : axisSize;
              var distance = size / (viewLabels.length - (pointOnColumn ? 0 : 1));
              var rotationData = makeRotationData(maxLabelWidth, maxLabelHeight, distance, rotatable, axisLayout);
              var needRotateLabel = rotationData.needRotateLabel, rotationHeight = rotationData.rotationHeight;
              var maxHeight = (needRotateLabel ? rotationHeight : maxLabelHeight) + offsetY;
              return store_axes_objectSpread(store_axes_objectSpread(store_axes_objectSpread({}, axisData), rotationData), {}, {
                maxHeight,
                offsetY
              });
            }
            function getAxisInfo(labelOnYAxis, plot2, series) {
              var _getAxisName = getAxisName(labelOnYAxis, series), valueAxisName = _getAxisName.valueAxisName, labelAxisName = _getAxisName.labelAxisName;
              var _getSizeKey = getSizeKey(labelOnYAxis), valueSizeKey = _getSizeKey.valueSizeKey, labelSizeKey = _getSizeKey.labelSizeKey;
              var valueAxisSize = plot2[valueSizeKey];
              var labelAxisSize = plot2[labelSizeKey];
              return {
                valueAxisName,
                valueAxisSize,
                labelAxisName,
                labelAxisSize
              };
            }
            function getCategoriesWithTypes(categories, rawCategories) {
              var _ref3, _ref4;
              return {
                categories: (_ref3 = categories) !== null && _ref3 !== void 0 ? _ref3 : [],
                rawCategories: (_ref4 = rawCategories) !== null && _ref4 !== void 0 ? _ref4 : []
              };
            }
            var axes_axes = {
              name: "axes",
              state: function state(_ref5) {
                var series = _ref5.series, options2 = _ref5.options;
                var _getYAxisOption2 = getYAxisOption(options2), secondaryYAxis = _getYAxisOption2.secondaryYAxis;
                var axesState = {
                  xAxis: {},
                  yAxis: {}
                };
                if (!!series.bar && isCenterYAxis(options2)) {
                  axesState.centerYAxis = {};
                }
                if (secondaryYAxis) {
                  axesState.secondaryYAxis = {};
                }
                return {
                  axes: axesState
                };
              },
              action: {
                setAxesData: function setAxesData(_ref6) {
                  var _options$xAxis, _options$xAxis$label;
                  var state = _ref6.state, initStoreState = _ref6.initStoreState;
                  var scale2 = state.scale, options2 = state.options, series = state.series, layout2 = state.layout, theme2 = state.theme;
                  var xAxis = layout2.xAxis, yAxis = layout2.yAxis, plot2 = layout2.plot;
                  var isCoordinateTypeChart = isCoordinateSeries(initStoreState.series);
                  var labelOnYAxis = isLabelAxisOnYAxis({
                    series,
                    options: options2
                  });
                  var _getCategoriesWithTyp = getCategoriesWithTypes(state.categories, state.rawCategories), categories = _getCategoriesWithTyp.categories;
                  var _getAxisInfo = getAxisInfo(labelOnYAxis, plot2, series), valueAxisName = _getAxisInfo.valueAxisName, valueAxisSize = _getAxisInfo.valueAxisSize, labelAxisName = _getAxisInfo.labelAxisName, labelAxisSize = _getAxisInfo.labelAxisSize;
                  var hasCenterYAxis = state.axes.centerYAxis;
                  var initialAxisData = getInitialAxisData(options2, labelOnYAxis, categories, layout2, isCoordinateTypeChart);
                  var valueAxisData = getValueAxisData({
                    scale: scale2[valueAxisName],
                    axisSize: valueAxisSize,
                    options: options2,
                    series,
                    theme: getAxisTheme(theme2, valueAxisName),
                    centerYAxis: hasCenterYAxis ? {
                      xAxisHalfSize: (xAxis.width - yAxis.width) / 2
                    } : null,
                    initialAxisData: initialAxisData[valueAxisName],
                    labelOnYAxis,
                    axisName: valueAxisName
                  });
                  var labelAxisData = getLabelAxisData({
                    scale: scale2[labelAxisName],
                    axisSize: labelAxisSize,
                    categories,
                    options: options2,
                    series,
                    theme: getAxisTheme(theme2, labelAxisName),
                    initialAxisData: initialAxisData[labelAxisName],
                    isCoordinateTypeChart,
                    labelOnYAxis,
                    axisName: labelAxisName
                  });
                  var secondaryYAxis, centerYAxis;
                  if (state.axes.secondaryYAxis) {
                    secondaryYAxis = getSecondaryYAxisData({
                      state,
                      labelOnYAxis,
                      valueAxisSize,
                      labelAxisSize,
                      labelAxisName,
                      valueAxisName,
                      initialAxisData: initialAxisData.secondaryYAxis,
                      isCoordinateTypeChart
                    });
                  }
                  if (hasCenterYAxis) {
                    var xAxisHalfSize = (xAxis.width - yAxis.width) / 2;
                    centerYAxis = deepMergedCopy(valueAxisData, {
                      x: xAxis.x + xAxisHalfSize,
                      xAxisHalfSize,
                      secondStartX: (xAxis.width + yAxis.width) / 2,
                      yAxisLabelAnchorPoint: yAxis.width / 2,
                      yAxisHeight: yAxis.height
                    });
                  }
                  var axesState = {
                    xAxis: makeXAxisData({
                      axisData: labelOnYAxis ? valueAxisData : labelAxisData,
                      axisSize: labelOnYAxis ? valueAxisSize : labelAxisSize,
                      axisLayout: layout2.xAxis,
                      centerYAxis,
                      rotatable: getRotatableOption(options2),
                      labelMargin: (_options$xAxis = options2.xAxis) === null || _options$xAxis === void 0 ? void 0 : (_options$xAxis$label = _options$xAxis.label) === null || _options$xAxis$label === void 0 ? void 0 : _options$xAxis$label.margin
                    }),
                    yAxis: labelOnYAxis ? labelAxisData : valueAxisData,
                    secondaryYAxis,
                    centerYAxis
                  };
                  if (hasAxesLayoutChanged(state.axes, axesState)) {
                    this.notify(state, "layout");
                  }
                  state.axes = axesState;
                }
              },
              computed: {},
              observe: {
                updateAxes: function updateAxes() {
                  this.dispatch("setAxesData");
                }
              }
            };
            var store_axes = axes_axes;
            var es_string_includes = __webpack_require__(1235);
            var es_array_join = __webpack_require__(6781);
            var es_object_freeze = __webpack_require__(2144);
            var es_array_buffer_slice = __webpack_require__(2994);
            var es_typed_array_uint8_array = __webpack_require__(3675);
            var es_typed_array_copy_within = __webpack_require__(5825);
            var es_typed_array_every = __webpack_require__(7170);
            var es_typed_array_fill = __webpack_require__(8857);
            var es_typed_array_filter = __webpack_require__(8329);
            var es_typed_array_find = __webpack_require__(6279);
            var es_typed_array_find_index = __webpack_require__(427);
            var es_typed_array_for_each = __webpack_require__(1159);
            var es_typed_array_includes = __webpack_require__(2516);
            var es_typed_array_index_of = __webpack_require__(4349);
            var es_typed_array_iterator = __webpack_require__(5273);
            var es_typed_array_join = __webpack_require__(6729);
            var es_typed_array_last_index_of = __webpack_require__(1801);
            var es_typed_array_map = __webpack_require__(574);
            var es_typed_array_reduce = __webpack_require__(5787);
            var es_typed_array_reduce_right = __webpack_require__(9271);
            var es_typed_array_reverse = __webpack_require__(3160);
            var es_typed_array_set = __webpack_require__(5688);
            var es_typed_array_slice = __webpack_require__(3157);
            var es_typed_array_some = __webpack_require__(3333);
            var es_typed_array_sort = __webpack_require__(315);
            var es_typed_array_subarray = __webpack_require__(8314);
            var es_typed_array_to_locale_string = __webpack_require__(556);
            var es_typed_array_to_string = __webpack_require__(9224);
            ;
            var _templateObject;
            function _taggedTemplateLiteral(strings, raw) {
              if (!raw) {
                raw = strings.slice(0);
              }
              return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } }));
            }
            function downloader_toConsumableArray(arr) {
              return downloader_arrayWithoutHoles(arr) || downloader_iterableToArray(arr) || downloader_unsupportedIterableToArray(arr) || downloader_nonIterableSpread();
            }
            function downloader_nonIterableSpread() {
              throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            function downloader_unsupportedIterableToArray(o, minLen) {
              if (!o)
                return;
              if (typeof o === "string")
                return downloader_arrayLikeToArray(o, minLen);
              var n = Object.prototype.toString.call(o).slice(8, -1);
              if (n === "Object" && o.constructor)
                n = o.constructor.name;
              if (n === "Map" || n === "Set")
                return Array.from(o);
              if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                return downloader_arrayLikeToArray(o, minLen);
            }
            function downloader_iterableToArray(iter) {
              if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
                return Array.from(iter);
            }
            function downloader_arrayWithoutHoles(arr) {
              if (Array.isArray(arr))
                return downloader_arrayLikeToArray(arr);
            }
            function downloader_arrayLikeToArray(arr, len) {
              if (len == null || len > arr.length)
                len = arr.length;
              for (var i = 0, arr2 = new Array(len); i < len; i++) {
                arr2[i] = arr[i];
              }
              return arr2;
            }
            var DATA_URI_HEADERS = {
              xls: "data:application/vnd.ms-excel;base64,",
              csv: "data:text/csv;charset=utf-8,%EF%BB%BF"
              /* BOM for utf-8 */
            };
            function getDownloadMethod() {
              var method;
              var isDownloadAttributeSupported = !isUndefined(document.createElement("a").download);
              var isMSSaveOrOpenBlobSupported = !isUndefined(window.Blob && window.navigator.msSaveOrOpenBlob);
              if (isMSSaveOrOpenBlobSupported) {
                method = downloadWithMSSaveOrOpenBlob;
              } else if (isDownloadAttributeSupported) {
                method = downloadWithAnchorElementDownloadAttribute;
              }
              return method;
            }
            function base64toBlob(base64String) {
              var contentType = base64String.substr(0, base64String.indexOf(";base64,")).substr(base64String.indexOf(":") + 1);
              var sliceSize = 1024;
              var byteCharacters = atob(base64String.substr(base64String.indexOf(",") + 1));
              var byteArrays = [];
              for (var offset = 0; offset < byteCharacters.length; offset += sliceSize) {
                var slice = byteCharacters.slice(offset, offset + sliceSize);
                var byteNumbers = new Array(slice.length);
                for (var i = 0; i < slice.length; i += 1) {
                  byteNumbers[i] = slice.charCodeAt(i);
                }
                byteArrays.push(new window.Uint8Array(byteNumbers));
              }
              try {
                return new Blob(byteArrays, {
                  type: contentType
                });
              } catch (e) {
                return new Blob(byteArrays.map(function(byteArr) {
                  return byteArr.buffer;
                }), {
                  type: contentType
                });
              }
            }
            function isImageExtension(extension) {
              return extension === "jpeg" || extension === "png";
            }
            function downloadWithMSSaveOrOpenBlob(fileName, extension, content, contentType) {
              var blobObject = isImageExtension(extension) ? base64toBlob(content) : new Blob([content], {
                type: contentType
              });
              window.navigator.msSaveOrOpenBlob(blobObject, "".concat(fileName, ".").concat(extension));
            }
            function downloadWithAnchorElementDownloadAttribute(fileName, extension, content) {
              if (content) {
                var anchorElement = document.createElement("a");
                anchorElement.href = content;
                anchorElement.target = "_blank";
                anchorElement.download = "".concat(fileName, ".").concat(extension);
                document.body.appendChild(anchorElement);
                anchorElement.click();
                anchorElement.remove();
              }
            }
            function oneLineTrim() {
              var normalTag = function normalTag2(template) {
                for (var _len = arguments.length, expressions = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                  expressions[_key - 1] = arguments[_key];
                }
                return template.reduce(function(accumulator, part, i) {
                  return accumulator + expressions[i - 1] + part;
                });
              };
              return normalTag.apply(void 0, arguments).replace(/\n\s*/g, "");
            }
            function isNeedDataEncoding() {
              var isDownloadAttributeSupported = !isUndefined(document.createElement("a").download);
              var isMSSaveOrOpenBlobSupported = !isUndefined(window.Blob && window.navigator.msSaveOrOpenBlob);
              return !isMSSaveOrOpenBlobSupported && isDownloadAttributeSupported;
            }
            function getBulletLongestArrayLength(arr, field) {
              return arr.reduce(function(acc, cur, idx) {
                var _cur$field;
                return !idx || acc < (cur === null || cur === void 0 ? void 0 : (_cur$field = cur[field]) === null || _cur$field === void 0 ? void 0 : _cur$field.length) ? cur[field].length : acc;
              }, 0);
            }
            function makeBulletExportData(_ref) {
              var series = _ref.series;
              var seriesData2 = series.bullet.data;
              var markerCount = getBulletLongestArrayLength(seriesData2, "markers");
              var rangeCount = getBulletLongestArrayLength(seriesData2, "ranges");
              var rangesHeaders = range(0, rangeCount).map(function(idx) {
                return "Range ".concat(idx + 1);
              });
              var markerHeaders = range(0, markerCount).map(function(idx) {
                return "Marker ".concat(idx + 1);
              });
              return seriesData2.reduce(function(acc, _ref2) {
                var data = _ref2.data, markers = _ref2.markers, name = _ref2.name, ranges = _ref2.ranges;
                var rangeDatum = rangesHeaders.map(function(_, index) {
                  var rangeData = ranges === null || ranges === void 0 ? void 0 : ranges[index];
                  return rangeData ? "".concat(rangeData[0], " ~ ").concat(rangeData[1]) : "";
                });
                var markerDatum = markerHeaders.map(function(_, index) {
                  var _markers$index;
                  return (_markers$index = markers === null || markers === void 0 ? void 0 : markers[index]) !== null && _markers$index !== void 0 ? _markers$index : "";
                });
                return [].concat(downloader_toConsumableArray(acc), [[name, data !== null && data !== void 0 ? data : ""].concat(downloader_toConsumableArray(rangeDatum), downloader_toConsumableArray(markerDatum))]);
              }, [["", "Actual"].concat(downloader_toConsumableArray(rangesHeaders), downloader_toConsumableArray(markerHeaders))]);
            }
            function makeHeatmapExportData(_ref3) {
              var categories = _ref3.categories, series = _ref3.series;
              var xCategories = categories.x;
              return series.heatmap.data.reduce(function(acc, _ref4) {
                var data = _ref4.data, yCategory = _ref4.yCategory;
                return [].concat(downloader_toConsumableArray(acc), [[yCategory].concat(downloader_toConsumableArray(data.map(function(datum) {
                  return isNull(datum) ? "" : datum;
                })))]);
              }, [[""].concat(downloader_toConsumableArray(xCategories))]);
            }
            function recursiveTreemapData(_ref5, result) {
              var label2 = _ref5.label, data = _ref5.data, _ref5$children = _ref5.children, children = _ref5$children === void 0 ? [] : _ref5$children;
              if (data) {
                result.push([label2, data]);
              }
              children.forEach(function(childrenData) {
                return recursiveTreemapData(childrenData, result);
              });
              return result;
            }
            function makeTreemapExportData(exportData) {
              var series = exportData.series;
              var result = [["Label", "Data"]];
              series.treemap.data.forEach(function(datum) {
                recursiveTreemapData(datum, result);
              });
              return result;
            }
            function makeBubbleExportData(exportData) {
              var series = exportData.series;
              return series.bubble.data.reduce(function(acc, _ref6) {
                var name = _ref6.name, data = _ref6.data;
                return [].concat(downloader_toConsumableArray(acc), downloader_toConsumableArray(data.map(function(datum) {
                  return isNull(datum) ? [] : [name, datum.label, String(datum.x), datum.y, datum.r];
                })));
              }, [["Name", "Label", "X", "Y", "Radius"]]);
            }
            function makeBoxPlotExportData(exportData) {
              var _exportData$categorie;
              var series = exportData.series;
              var categories = (_exportData$categorie = exportData.categories) !== null && _exportData$categorie !== void 0 ? _exportData$categorie : [];
              return series.boxPlot.data.reduce(function(acc, _ref7) {
                var name = _ref7.name, data = _ref7.data, outliers = _ref7.outliers;
                var values = (data !== null && data !== void 0 ? data : []).map(function(rawData, index) {
                  var _find;
                  var outlierValue = (_find = (outliers !== null && outliers !== void 0 ? outliers : []).find(function(outlier) {
                    return outlier[0] === index;
                  })) === null || _find === void 0 ? void 0 : _find[1];
                  var value = outlierValue ? [].concat(downloader_toConsumableArray(rawData), [outlierValue]) : downloader_toConsumableArray(rawData);
                  return value.join();
                });
                return [].concat(downloader_toConsumableArray(acc), [[name].concat(downloader_toConsumableArray(values))]);
              }, [[""].concat(downloader_toConsumableArray(categories))]);
            }
            function makePieExportData(exportData) {
              var _exportData$categorie2;
              var series = exportData.series;
              var categories = (_exportData$categorie2 = exportData.categories) !== null && _exportData$categorie2 !== void 0 ? _exportData$categorie2 : [];
              return series.pie.data.reduce(function(acc, _ref8) {
                var name = _ref8.name, data = _ref8.data;
                var values = Array.isArray(data) ? (data !== null && data !== void 0 ? data : []).reduce(function(accNestedPieValue, value) {
                  var _value$data;
                  return [].concat(downloader_toConsumableArray(accNestedPieValue), [[value.name, (_value$data = value.data) !== null && _value$data !== void 0 ? _value$data : ""]]);
                }, []) : [[name, data !== null && data !== void 0 ? data : ""]];
                return [].concat(downloader_toConsumableArray(acc), downloader_toConsumableArray(values));
              }, categories.length ? [[""].concat(downloader_toConsumableArray(categories))] : []);
            }
            function makeCoordinateExportDataValues(type, categories, data) {
              return categories.map(function(category2, index) {
                if (type === "area" && Array.isArray(data[index])) {
                  return data[index].join();
                }
                var foundItem = data.find(function(value) {
                  return category2 === String(getCoordinateXValue(value));
                });
                return foundItem ? getCoordinateYValue(foundItem) : "";
              });
            }
            function makeExportData(exportData) {
              var series = exportData.series;
              var categories = exportData.categories;
              return Object.keys(series).reduce(function(acc, type) {
                var result = series[type].data.map(function(_ref9) {
                  var name = _ref9.name, data = _ref9.data;
                  var values = !isNumber(getFirstValidValue(data)) && includes(["line", "area", "scatter"], type) ? makeCoordinateExportDataValues(type, categories, data) : data.map(function(value) {
                    return Array.isArray(value) ? value.join() : value;
                  });
                  return [name].concat(downloader_toConsumableArray(values));
                });
                return [].concat(downloader_toConsumableArray(acc), downloader_toConsumableArray(result));
              }, series.gauge ? [] : [[""].concat(downloader_toConsumableArray(categories))]);
            }
            function get2DArrayFromRawData(exportData) {
              var result;
              var series = exportData.series;
              if (series.bullet) {
                result = makeBulletExportData(exportData);
              } else if (series.heatmap) {
                result = makeHeatmapExportData(exportData);
              } else if (series.bubble) {
                result = makeBubbleExportData(exportData);
              } else if (series.boxPlot) {
                result = makeBoxPlotExportData(exportData);
              } else if (series.pie) {
                result = makePieExportData(exportData);
              } else if (series.treemap) {
                result = makeTreemapExportData(exportData);
              } else {
                result = makeExportData(exportData);
              }
              return result;
            }
            function getTableElementStringForXLS(chartData2DArray) {
              var tableElementString = "<table>";
              chartData2DArray.forEach(function(row, rowIndex) {
                var cellTagName = rowIndex === 0 ? "th" : "td";
                tableElementString += "<tr>";
                row.forEach(function(cell, cellIndex) {
                  var cellNumberClass = rowIndex !== 0 || cellIndex === 0 ? ' class="number"' : "";
                  var cellString = "<".concat(cellTagName).concat(cellNumberClass, ">").concat(cell, "</").concat(cellTagName, ">");
                  tableElementString += cellString;
                });
                tableElementString += "</tr>";
              });
              tableElementString += "</table>";
              return tableElementString;
            }
            function makeXLSBodyWithRawData(chartData2DArray) {
              return oneLineTrim(_templateObject || (_templateObject = _taggedTemplateLiteral(['<html xmlns:o="urn:schemas-microsoft-com:office:office"\n        xmlns:x="urn:schemas-microsoft-com:office:excel"\n        xmlns="http://www.w3.org/TR/REC-html40">\n        <head>\n            <!--[if gte mso 9]>\n                <xml>\n                    <x:ExcelWorkbook>\n                        <x:ExcelWorksheets>\n                            <x:ExcelWorksheet>\n                                <x:Name>Ark1</x:Name>\n                                <x:WorksheetOptions>\n                                    <x:DisplayGridlines/>\n                                </x:WorksheetOptions>\n                            </x:ExcelWorksheet>\n                        </x:ExcelWorksheets>\n                        </x:ExcelWorkbook>\n                </xml>\n            <![endif]-->\n            <meta name=ProgId content=Excel.Sheet>\n            <meta charset=UTF-8>\n        </head>\n        <body>\n            ', "\n        </body>\n        </html>"])), getTableElementStringForXLS(chartData2DArray));
            }
            function makeCSVBodyWithRawData(chartData2DArray) {
              var option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
              var _option$lineDelimiter = option.lineDelimiter, lineDelimiter = _option$lineDelimiter === void 0 ? "\n" : _option$lineDelimiter, _option$itemDelimiter = option.itemDelimiter, itemDelimiter = _option$itemDelimiter === void 0 ? "," : _option$itemDelimiter;
              var lastRowIndex = chartData2DArray.length - 1;
              var csvText = "";
              chartData2DArray.forEach(function(row, rowIndex) {
                var lastCellIndex = row.length - 1;
                row.forEach(function(cell, cellIndex) {
                  var cellContent = isNumber(cell) ? cell : '"'.concat(cell, '"');
                  csvText += cellContent;
                  if (cellIndex < lastCellIndex) {
                    csvText += itemDelimiter;
                  }
                });
                if (rowIndex < lastRowIndex) {
                  csvText += lineDelimiter;
                }
              });
              return csvText;
            }
            function execDownload(fileName, extension, content, contentType) {
              var downloadMethod = getDownloadMethod();
              if (!utils_isString(content) || !downloadMethod) {
                return;
              }
              downloadMethod(fileName, extension, content, contentType);
            }
            function downloadSpreadSheet(fileName, extension, data) {
              var chartData2DArray = get2DArrayFromRawData(data);
              var contentType = DATA_URI_HEADERS[extension].replace(/(data:|;base64,|,%EF%BB%BF)/g, "");
              var content = "";
              if (extension === "csv") {
                content = encodeURIComponent(makeCSVBodyWithRawData(chartData2DArray));
              } else {
                content = makeXLSBodyWithRawData(chartData2DArray);
              }
              if (isNeedDataEncoding()) {
                if (extension !== "csv") {
                  content = window.btoa(unescape(encodeURIComponent(content)));
                }
                content = DATA_URI_HEADERS[extension] + content;
              }
              execDownload(fileName, extension, content, contentType);
            }
            ;
            function exportMenu_typeof(obj) {
              "@babel/helpers - typeof";
              if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                exportMenu_typeof = function _typeof2(obj2) {
                  return typeof obj2;
                };
              } else {
                exportMenu_typeof = function _typeof2(obj2) {
                  return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                };
              }
              return exportMenu_typeof(obj);
            }
            function exportMenu_classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function exportMenu_defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            function exportMenu_createClass(Constructor, protoProps, staticProps) {
              if (protoProps)
                exportMenu_defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                exportMenu_defineProperties(Constructor, staticProps);
              return Constructor;
            }
            function exportMenu_inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function");
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
              if (superClass)
                exportMenu_setPrototypeOf(subClass, superClass);
            }
            function exportMenu_setPrototypeOf(o, p) {
              exportMenu_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
                o2.__proto__ = p2;
                return o2;
              };
              return exportMenu_setPrototypeOf(o, p);
            }
            function exportMenu_createSuper(Derived) {
              var hasNativeReflectConstruct = exportMenu_isNativeReflectConstruct();
              return function _createSuperInternal() {
                var Super = exportMenu_getPrototypeOf(Derived), result;
                if (hasNativeReflectConstruct) {
                  var NewTarget = exportMenu_getPrototypeOf(this).constructor;
                  result = Reflect.construct(Super, arguments, NewTarget);
                } else {
                  result = Super.apply(this, arguments);
                }
                return exportMenu_possibleConstructorReturn(this, result);
              };
            }
            function exportMenu_possibleConstructorReturn(self2, call) {
              if (call && (exportMenu_typeof(call) === "object" || typeof call === "function")) {
                return call;
              }
              return exportMenu_assertThisInitialized(self2);
            }
            function exportMenu_assertThisInitialized(self2) {
              if (self2 === void 0) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return self2;
            }
            function exportMenu_isNativeReflectConstruct() {
              if (typeof Reflect === "undefined" || !Reflect.construct)
                return false;
              if (Reflect.construct.sham)
                return false;
              if (typeof Proxy === "function")
                return true;
              try {
                Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                }));
                return true;
              } catch (e) {
                return false;
              }
            }
            function exportMenu_getPrototypeOf(o) {
              exportMenu_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
                return o2.__proto__ || Object.getPrototypeOf(o2);
              };
              return exportMenu_getPrototypeOf(o);
            }
            function exportMenu_defineProperty(obj, key, value) {
              if (key in obj) {
                Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
              } else {
                obj[key] = value;
              }
              return obj;
            }
            var EXPORT_MENU_WIDTH = 140;
            var exportExtensions = {
              IMAGES: ["png", "jpeg"],
              SPREAD_SHEETS: ["xls", "csv"]
            };
            var BUTTON_RECT_SIZE = 24;
            var ExportMenu = function(_Component) {
              exportMenu_inherits(ExportMenu2, _Component);
              var _super = exportMenu_createSuper(ExportMenu2);
              function ExportMenu2() {
                var _this;
                exportMenu_classCallCheck(this, ExportMenu2);
                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }
                _this = _super.call.apply(_super, [this].concat(args));
                exportMenu_defineProperty(exportMenu_assertThisInitialized(_this), "responders", void 0);
                exportMenu_defineProperty(exportMenu_assertThisInitialized(_this), "models", {
                  exportMenuButton: []
                });
                exportMenu_defineProperty(exportMenu_assertThisInitialized(_this), "opened", false);
                exportMenu_defineProperty(exportMenu_assertThisInitialized(_this), "fileName", void 0);
                exportMenu_defineProperty(exportMenu_assertThisInitialized(_this), "data", void 0);
                exportMenu_defineProperty(exportMenu_assertThisInitialized(_this), "chartEl", void 0);
                exportMenu_defineProperty(exportMenu_assertThisInitialized(_this), "exportMenuEl", void 0);
                exportMenu_defineProperty(exportMenu_assertThisInitialized(_this), "theme", void 0);
                exportMenu_defineProperty(exportMenu_assertThisInitialized(_this), "chartBackgroundColor", void 0);
                exportMenu_defineProperty(exportMenu_assertThisInitialized(_this), "chartWidth", 0);
                exportMenu_defineProperty(exportMenu_assertThisInitialized(_this), "toggleExportMenu", function() {
                  _this.opened = !_this.opened;
                  _this.models.exportMenuButton[0].opened = _this.opened;
                  _this.eventBus.emit("needDraw");
                  if (_this.opened) {
                    _this.applyPanelWrapperStyle();
                    _this.chartEl.appendChild(_this.exportMenuEl);
                  } else {
                    _this.chartEl.removeChild(_this.exportMenuEl);
                  }
                });
                exportMenu_defineProperty(exportMenu_assertThisInitialized(_this), "getCanvasExportBtnRemoved", function() {
                  var canvas = _this.chartEl.getElementsByTagName("canvas")[0];
                  var ctx2 = canvas.getContext("2d");
                  var _this$rect = _this.rect, x = _this$rect.x, y = _this$rect.y, h = _this$rect.height, w = _this$rect.width;
                  ctx2.clearRect(x, y, w, h);
                  ctx2.fillStyle = _this.chartBackgroundColor;
                  ctx2.fillRect(x, y, w, h);
                  return canvas;
                });
                exportMenu_defineProperty(exportMenu_assertThisInitialized(_this), "onClickExportButton", function(ev) {
                  var id = ev.target.id;
                  var isImageExtension2 = exportExtensions.IMAGES.includes(id);
                  var isSpreadSheetExtension = exportExtensions.SPREAD_SHEETS.includes(id);
                  if (isImageExtension2) {
                    var canvas = _this.getCanvasExportBtnRemoved();
                    execDownload(_this.fileName, id, canvas.toDataURL("image/".concat(id), 1));
                  } else if (isSpreadSheetExtension) {
                    downloadSpreadSheet(_this.fileName, id, _this.data);
                  }
                  if (isImageExtension2 || isSpreadSheetExtension) {
                    _this.toggleExportMenu();
                  }
                });
                return _this;
              }
              exportMenu_createClass(ExportMenu2, [{
                key: "applyExportButtonPanelStyle",
                value: function applyExportButtonPanelStyle() {
                  var exportMenuTitle = this.exportMenuEl.querySelector(".toastui-chart-export-menu-title");
                  var menuBtnWrapper = this.exportMenuEl.querySelector(".toastui-chart-export-menu-btn-wrapper");
                  exportMenuTitle.setAttribute("style", this.makePanelStyle("header"));
                  menuBtnWrapper.setAttribute("style", this.makePanelStyle("body"));
                }
              }, {
                key: "makeExportMenuButton",
                value: function makeExportMenuButton() {
                  var el = document.createElement("div");
                  el.onclick = this.onClickExportButton;
                  el.innerHTML = '\n        <div class="toastui-chart-export-menu">\n          <p class="toastui-chart-export-menu-title">Export to</p>\n          <div class="toastui-chart-export-menu-btn-wrapper">\n            <button class="toastui-chart-export-menu-btn" id="xls">xls</button>\n            <button class="toastui-chart-export-menu-btn" id="csv">csv</button>\n            <button class="toastui-chart-export-menu-btn" id="png">png</button>\n            <button class="toastui-chart-export-menu-btn" id="jpeg">jpeg</button>\n          </div>\n        </div>\n      ';
                  return el;
                }
              }, {
                key: "initialize",
                value: function initialize(_ref) {
                  var chartEl = _ref.chartEl;
                  this.chartEl = chartEl;
                  this.type = "exportMenu";
                  this.name = "exportMenu";
                  this.exportMenuEl = this.makeExportMenuButton();
                }
              }, {
                key: "onClick",
                value: function onClick(_ref2) {
                  var responders = _ref2.responders;
                  if (responders.length) {
                    this.toggleExportMenu();
                  }
                }
              }, {
                key: "getFileName",
                value: function getFileName(title) {
                  var _title$text;
                  return utils_isString(title) ? title : (_title$text = title === null || title === void 0 ? void 0 : title.text) !== null && _title$text !== void 0 ? _title$text : "toast-ui-chart";
                }
              }, {
                key: "render",
                value: function render(_ref3) {
                  var _options$exportMenu;
                  var options2 = _ref3.options, layout2 = _ref3.layout, chart = _ref3.chart, series = _ref3.series, rawCategories = _ref3.rawCategories, theme2 = _ref3.theme;
                  this.isShow = isExportMenuVisible(options2);
                  this.chartWidth = chart.width;
                  if (!this.isShow) {
                    return;
                  }
                  this.chartBackgroundColor = theme2.chart.backgroundColor;
                  this.theme = theme2.exportMenu;
                  this.data = {
                    series,
                    categories: rawCategories
                  };
                  this.fileName = this.getFileName((options2 === null || options2 === void 0 ? void 0 : (_options$exportMenu = options2.exportMenu) === null || _options$exportMenu === void 0 ? void 0 : _options$exportMenu.filename) || chart.title);
                  this.applyExportButtonPanelStyle();
                  this.rect = layout2.exportMenu;
                  this.models.exportMenuButton = [{
                    type: "exportMenuButton",
                    x: 0,
                    y: 0,
                    opened: this.opened,
                    theme: this.theme.button
                  }];
                  this.responders = [{
                    type: "rect",
                    width: BUTTON_RECT_SIZE,
                    height: BUTTON_RECT_SIZE,
                    x: 0,
                    y: 0
                  }];
                }
              }, {
                key: "applyPanelWrapperStyle",
                value: function applyPanelWrapperStyle() {
                  var exportMenu = this.exportMenuEl.querySelector(".toastui-chart-export-menu");
                  var x = this.chartWidth - EXPORT_MENU_WIDTH - padding.X;
                  var y = padding.Y + BUTTON_RECT_SIZE + 5;
                  var _this$theme$panel = this.theme.panel, borderRadius = _this$theme$panel.borderRadius, borderWidth = _this$theme$panel.borderWidth, borderColor = _this$theme$panel.borderColor;
                  var style = "\n      transform: ".concat(getTranslateString(x, y), ";\n      border: ").concat(borderWidth, "px solid ").concat(borderColor, ";\n      border-radius: ").concat(borderRadius, "px;");
                  exportMenu.setAttribute("style", style);
                }
              }, {
                key: "makePanelStyle",
                value: function makePanelStyle(type) {
                  var sectionTheme = this.theme.panel[type];
                  var direction = type === "header" ? "top" : "bottom";
                  var _ref4 = this.theme.panel, borderRadius = _ref4.borderRadius, borderWidth = _ref4.borderWidth;
                  var borderRadiusPx = "".concat(borderRadius - borderWidth, "px");
                  return ["".concat(getFontStyleString(sectionTheme)), "border-".concat(direction, "-left-radius: ").concat(borderRadiusPx, ";"), "border-".concat(direction, "-right-radius: ").concat(borderRadiusPx, ";"), "background-color: ".concat(sectionTheme.backgroundColor, ";")].join("");
                }
              }]);
              return ExportMenu2;
            }(Component);
            ;
            function dataLabel_ownKeys(object, enumerableOnly) {
              var keys = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object);
                if (enumerableOnly) {
                  symbols = symbols.filter(function(sym) {
                    return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                  });
                }
                keys.push.apply(keys, symbols);
              }
              return keys;
            }
            function dataLabel_objectSpread(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i] != null ? arguments[i] : {};
                if (i % 2) {
                  dataLabel_ownKeys(Object(source), true).forEach(function(key) {
                    dataLabel_defineProperty(target, key, source[key]);
                  });
                } else if (Object.getOwnPropertyDescriptors) {
                  Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                } else {
                  dataLabel_ownKeys(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  });
                }
              }
              return target;
            }
            function dataLabel_defineProperty(obj, key, value) {
              if (key in obj) {
                Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
              } else {
                obj[key] = value;
              }
              return obj;
            }
            function dataLabel(ctx2, model) {
              var x = model.x, y = model.y, text = model.text, textAlign = model.textAlign, textBaseline = model.textBaseline, opacity = model.opacity, callout = model.callout, theme2 = model.theme, radian = model.radian;
              var color = theme2.color, textBubble = theme2.textBubble;
              var font = getFont(theme2);
              var textStyle = {
                textAlign,
                textBaseline,
                font,
                fillStyle: color
              };
              var textStrokeStyle = getTextStrokeStyle(theme2);
              if (callout) {
                var _callout$theme = callout.theme, lineWidth = _callout$theme.lineWidth, lineColor = _callout$theme.lineColor;
                line(ctx2, dataLabel_objectSpread(dataLabel_objectSpread({
                  type: "line"
                }, pick(callout, "x", "y", "x2", "y2")), {}, {
                  strokeStyle: lineColor,
                  lineWidth
                }));
              }
              if (textBubble !== null && textBubble !== void 0 && textBubble.visible) {
                drawBubbleLabel(ctx2, model);
                return;
              }
              label(ctx2, {
                type: "label",
                x,
                y,
                text,
                style: [textStyle],
                stroke: [textStrokeStyle],
                opacity,
                radian
              });
            }
            function drawBubbleLabel(ctx2, model) {
              var text = model.text, theme2 = model.theme, _model$radian = model.radian, radian = _model$radian === void 0 ? 0 : _model$radian;
              var _ref = theme2, color = _ref.color, textStrokeColor = _ref.textStrokeColor;
              var font = getFont(theme2);
              var bubbleRect = getBubbleRect(model);
              var x = bubbleRect.x, y = bubbleRect.y, width = bubbleRect.width, height = bubbleRect.height;
              bubbleLabel(ctx2, {
                type: "bubbleLabel",
                radian,
                rotationPosition: {
                  x: model.x,
                  y: model.y
                },
                bubble: bubbleRect,
                label: {
                  x: x + width / 2,
                  y: y + height / 2,
                  text,
                  style: [{
                    font,
                    fillStyle: color,
                    textAlign: "center",
                    textBaseline: "middle"
                  }],
                  strokeStyle: textStrokeColor
                }
              });
            }
            function getBubbleArrowPoints(direction, _ref2, arrowPointTheme) {
              var x = _ref2.x, y = _ref2.y;
              var width = arrowPointTheme.width;
              var height = arrowPointTheme.height;
              var points = [];
              if (direction === "top") {
                points = [{
                  x: x - width / 2,
                  y: y + height
                }, {
                  x,
                  y
                }, {
                  x: x + width / 2,
                  y: y + height
                }];
              } else if (direction === "bottom") {
                points = [{
                  x: x + width / 2,
                  y: y - height
                }, {
                  x,
                  y
                }, {
                  x: x - width / 2,
                  y: y - height
                }];
              } else if (direction === "right") {
                points = [{
                  x: x - height,
                  y: y - width / 2
                }, {
                  x,
                  y
                }, {
                  x: x - height,
                  y: y + width / 2
                }];
              } else if (direction === "left") {
                points = [{
                  x: x + height,
                  y: y + width / 2
                }, {
                  x,
                  y
                }, {
                  x: x + height,
                  y: y - width / 2
                }];
              }
              return points;
            }
            function getBubbleRect(model) {
              var text = model.text, theme2 = model.theme, textAlign = model.textAlign, textBaseline = model.textBaseline;
              var font = getFont(theme2);
              var _ref3 = theme2.textBubble, arrow = _ref3.arrow, paddingX = _ref3.paddingX, paddingY = _ref3.paddingY, borderRadius = _ref3.borderRadius, borderColor = _ref3.borderColor, borderWidth = _ref3.borderWidth, backgroundColor = _ref3.backgroundColor, shadowBlur = _ref3.shadowBlur, shadowOffsetX = _ref3.shadowOffsetX, shadowOffsetY = _ref3.shadowOffsetY, shadowColor = _ref3.shadowColor;
              var labelWidth = getTextWidth(text, font);
              var width = labelWidth + paddingX * 2;
              var height = getTextHeight(text, font) + paddingY * 2;
              var x = model.x, y = model.y;
              if (textAlign === "center") {
                x -= width / 2;
              } else if (includes(["right", "end"], textAlign)) {
                x -= width;
              }
              if (textBaseline === "middle") {
                y -= height / 2;
              } else if (textBaseline === "bottom") {
                y -= height;
              }
              var rect2 = {
                x,
                y,
                width,
                height
              };
              return dataLabel_objectSpread(dataLabel_objectSpread({}, rect2), {}, {
                radius: borderRadius,
                lineWidth: borderWidth,
                fill: backgroundColor,
                strokeStyle: borderColor,
                style: [{
                  shadowBlur,
                  shadowOffsetX,
                  shadowOffsetY,
                  shadowColor
                }]
              }, getArrowInfo(rect2, textAlign, textBaseline, arrow));
            }
            function getArrowInfo(rect2, textAlign, textBaseline, theme2) {
              var _theme$direction;
              if (!(theme2 !== null && theme2 !== void 0 && theme2.visible)) {
                return null;
              }
              var arrowHeight = theme2.height;
              var width = rect2.width, height = rect2.height;
              var direction = (_theme$direction = theme2.direction) !== null && _theme$direction !== void 0 ? _theme$direction : getArrowDirection(textAlign, textBaseline);
              var boxX = rect2.x, boxY = rect2.y;
              var pointX = rect2.x, pointY = rect2.y;
              if (direction === "top") {
                boxY += arrowHeight;
              } else if (direction === "bottom") {
                boxY -= arrowHeight;
                pointY += height;
              } else if (direction === "right") {
                boxX -= arrowHeight;
                pointX += width;
              } else if (direction === "left") {
                boxX += arrowHeight;
              }
              if (textAlign === "center") {
                pointX = rect2.x + width / 2;
              } else if (textBaseline === "middle") {
                pointY = rect2.y + height / 2;
              }
              return {
                direction,
                points: getBubbleArrowPoints(direction, {
                  x: pointX,
                  y: pointY
                }, theme2),
                x: boxX,
                y: boxY
              };
            }
            function getArrowDirection(textAlign, textBaseline) {
              var direction = "top";
              if (textAlign === "center" && textBaseline === "top") {
                direction = "top";
              } else if (textAlign === "center" && textBaseline === "bottom") {
                direction = "bottom";
              } else if (textBaseline === "middle" && textAlign === "right") {
                direction = "right";
              } else if (textBaseline === "middle" && textAlign === "left") {
                direction = "left";
              }
              return direction;
            }
            function getTextStrokeStyle(theme2) {
              var textStrokeColor = theme2.textStrokeColor;
              var textStrokeStyle = pick(theme2, "lineWidth", "shadowColor", "shadowBlur");
              if (textStrokeColor) {
                textStrokeStyle.strokeStyle = textStrokeColor;
              }
              return textStrokeStyle;
            }
            ;
            function spectrumLegend_ownKeys(object, enumerableOnly) {
              var keys = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object);
                if (enumerableOnly) {
                  symbols = symbols.filter(function(sym) {
                    return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                  });
                }
                keys.push.apply(keys, symbols);
              }
              return keys;
            }
            function spectrumLegend_objectSpread(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i] != null ? arguments[i] : {};
                if (i % 2) {
                  spectrumLegend_ownKeys(Object(source), true).forEach(function(key) {
                    spectrumLegend_defineProperty(target, key, source[key]);
                  });
                } else if (Object.getOwnPropertyDescriptors) {
                  Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                } else {
                  spectrumLegend_ownKeys(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  });
                }
              }
              return target;
            }
            function spectrumLegend_defineProperty(obj, key, value) {
              if (key in obj) {
                Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
              } else {
                obj[key] = value;
              }
              return obj;
            }
            var SPECTRUM_LEGEND_LABEL_HEIGHT = 12;
            var spectrumLegendBar = {
              HEIGHT: 6,
              PADDING: 5
            };
            var spectrumLegendTooltip = {
              HEIGHT: 28,
              POINT_WIDTH: 8,
              POINT_HEIGHT: 6,
              PADDING: 6
            };
            function getBarStartPoint(model) {
              var align = model.align, modelX = model.x, modelY = model.y, labels = model.labels, width = model.width;
              var PADDING = spectrumLegendBar.PADDING;
              var x, y;
              if (align === "top") {
                x = modelX;
                y = modelY + SPECTRUM_LEGEND_LABEL_HEIGHT + PADDING;
              } else if (align === "bottom") {
                x = modelX;
                y = modelY + spectrumLegendTooltip.HEIGHT;
              } else if (align === "left") {
                x = modelX + getMaxLengthLabelWidth(labels) + PADDING;
                y = modelY + SPECTRUM_LEGEND_LABEL_HEIGHT / 2;
              } else {
                x = modelX + width - (getMaxLengthLabelWidth(labels) + padding.X + PADDING * 2 + spectrumLegendBar.HEIGHT);
                y = modelY + SPECTRUM_LEGEND_LABEL_HEIGHT / 2;
              }
              return {
                x,
                y
              };
            }
            function getLabelsStartPoint(model) {
              var align = model.align, modelX = model.x, modelY = model.y, labels = model.labels, width = model.width;
              var x, y;
              if (align === "top") {
                x = modelX;
                y = modelY;
              } else if (align === "bottom") {
                x = modelX;
                y = modelY + spectrumLegendTooltip.HEIGHT + spectrumLegendBar.HEIGHT + spectrumLegendBar.PADDING;
              } else if (align === "left") {
                x = modelX + getMaxLengthLabelWidth(labels);
                y = modelY;
              } else {
                x = modelX + width - getMaxLengthLabelWidth(labels) - padding.X;
                y = modelY;
              }
              return {
                x,
                y
              };
            }
            function getBarSize(width, height, verticalAlign) {
              var HEIGHT = spectrumLegendBar.HEIGHT;
              var barWidth = verticalAlign ? width : HEIGHT;
              var barHeight = verticalAlign ? HEIGHT : height - SPECTRUM_LEGEND_LABEL_HEIGHT;
              return {
                barWidth,
                barHeight
              };
            }
            function drawLabels(ctx2, model) {
              var labels = model.labels, align = model.align, x = model.x, y = model.y, width = model.width, height = model.height, verticalAlign = model.verticalAlign;
              var _getBarSize = getBarSize(width, height, verticalAlign), barWidth = _getBarSize.barWidth, barHeight = _getBarSize.barHeight;
              var labelSize = labels.length - 1;
              var textBaseStyleMap = {
                left: {
                  textAlign: "right",
                  textBaseline: "top"
                },
                right: {
                  textAlign: "left",
                  textBaseline: "top"
                },
                top: {
                  textAlign: "center",
                  textBaseline: "top"
                },
                bottom: {
                  textAlign: "center",
                  textBaseline: "top"
                }
              };
              labels.forEach(function(text, idx) {
                var startX = verticalAlign ? x + barWidth / labelSize * idx : x;
                var startY = verticalAlign ? y : y + barHeight / labelSize * idx;
                label(ctx2, {
                  type: "label",
                  x: startX,
                  y: startY,
                  text,
                  style: ["default", textBaseStyleMap[align]]
                });
              });
            }
            function drawBar(ctx2, model) {
              var width = model.width, height = model.height, startColor = model.startColor, endColor = model.endColor, x = model.x, y = model.y, verticalAlign = model.verticalAlign;
              var _getBarSize2 = getBarSize(width, height, verticalAlign), barWidth = _getBarSize2.barWidth, barHeight = _getBarSize2.barHeight;
              var gradient = verticalAlign ? ctx2.createLinearGradient(x, y, x + barWidth, y) : ctx2.createLinearGradient(x, y, x, y + barHeight);
              gradient.addColorStop(0, startColor);
              gradient.addColorStop(1, endColor);
              ctx2.fillStyle = gradient;
              ctx2.fillRect(x, y, barWidth, barHeight);
            }
            function getTooltipArrowPoint(model) {
              var align = model.align, colorRatio = model.colorRatio, width = model.width, height = model.height, x = model.x, y = model.y, labels = model.labels, verticalAlign = model.verticalAlign;
              var _getBarSize3 = getBarSize(width, height, verticalAlign), barWidth = _getBarSize3.barWidth, barHeight = _getBarSize3.barHeight;
              var PADDING = spectrumLegendBar.PADDING, HEIGHT = spectrumLegendBar.HEIGHT;
              if (align === "top") {
                return {
                  x: x + barWidth * colorRatio,
                  y: y + SPECTRUM_LEGEND_LABEL_HEIGHT + HEIGHT + PADDING * 2
                };
              }
              if (align === "bottom") {
                return {
                  x: x + barWidth * colorRatio,
                  y: y + SPECTRUM_LEGEND_LABEL_HEIGHT + PADDING * 2
                };
              }
              if (align === "left") {
                return {
                  x: x + getMaxLengthLabelWidth(labels) + HEIGHT + PADDING * 2,
                  y: y + barHeight * colorRatio + PADDING
                };
              }
              if (align === "right") {
                return {
                  x: x + width - (getMaxLengthLabelWidth(labels) + padding.X + PADDING * 3 + HEIGHT),
                  y: y + barHeight * colorRatio + PADDING
                };
              }
            }
            function spectrumLegend(ctx2, model) {
              var labelsStartPoint = getLabelsStartPoint(model);
              var barStartPoint = getBarStartPoint(model);
              drawLabels(ctx2, spectrumLegend_objectSpread(spectrumLegend_objectSpread({}, model), labelsStartPoint));
              drawBar(ctx2, spectrumLegend_objectSpread(spectrumLegend_objectSpread({}, model), barStartPoint));
            }
            function spectrumTooltip(ctx2, model) {
              var _ref = getTooltipArrowPoint(model), x = _ref.x, y = _ref.y;
              var PADDING = spectrumLegendTooltip.PADDING, POINT_HEIGHT = spectrumLegendTooltip.POINT_HEIGHT, POINT_WIDTH = spectrumLegendTooltip.POINT_WIDTH;
              var align = model.align, text = model.text, color = model.color;
              var labelWidth = getTextWidth(text);
              var width = labelWidth + PADDING * 2;
              var height = SPECTRUM_LEGEND_LABEL_HEIGHT + PADDING * 2;
              var direction = align;
              var boxStartX = x;
              var boxStartY = y;
              if (align === "top") {
                boxStartY += POINT_HEIGHT;
              } else if (align === "right") {
                boxStartX -= width / 2 + POINT_HEIGHT;
                boxStartY -= height / 2;
              } else if (align === "left") {
                boxStartX += width / 2 + POINT_HEIGHT;
                boxStartY -= height / 2;
              } else if (align === "bottom") {
                boxStartY -= height + POINT_HEIGHT;
              }
              var points = getBubbleArrowPoints(align, {
                x,
                y
              }, {
                visible: true,
                width: POINT_WIDTH,
                height: POINT_HEIGHT
              });
              bubbleLabel(ctx2, {
                type: "bubbleLabel",
                bubble: {
                  x: boxStartX - width / 2,
                  y: boxStartY,
                  width,
                  height,
                  points,
                  direction,
                  fill: color
                },
                label: {
                  text,
                  x: boxStartX,
                  y: boxStartY + height / 2,
                  style: [{
                    font: "normal 11px Arial",
                    fillStyle: "#333333",
                    textAlign: "center",
                    textBaseline: "middle"
                  }]
                }
              });
            }
            ;
            function layout_ownKeys(object, enumerableOnly) {
              var keys = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object);
                if (enumerableOnly) {
                  symbols = symbols.filter(function(sym) {
                    return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                  });
                }
                keys.push.apply(keys, symbols);
              }
              return keys;
            }
            function layout_objectSpread(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i] != null ? arguments[i] : {};
                if (i % 2) {
                  layout_ownKeys(Object(source), true).forEach(function(key) {
                    layout_defineProperty(target, key, source[key]);
                  });
                } else if (Object.getOwnPropertyDescriptors) {
                  Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                } else {
                  layout_ownKeys(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  });
                }
              }
              return target;
            }
            function layout_defineProperty(obj, key, value) {
              if (key in obj) {
                Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
              } else {
                obj[key] = value;
              }
              return obj;
            }
            var padding = {
              X: 10,
              Y: 15
            };
            var X_AXIS_HEIGHT = 20;
            var Y_AXIS_MIN_WIDTH = 40;
            function isVerticalAlign(align) {
              return align === "top" || align === "bottom";
            }
            function getValidRectSize(size, width, height) {
              var _size$height, _size$width;
              return {
                height: (_size$height = size === null || size === void 0 ? void 0 : size.height) !== null && _size$height !== void 0 ? _size$height : height,
                width: (_size$width = size === null || size === void 0 ? void 0 : size.width) !== null && _size$width !== void 0 ? _size$width : width
              };
            }
            function getDefaultXAxisHeight(size) {
              var _size$xAxis;
              return (_size$xAxis = size.xAxis) !== null && _size$xAxis !== void 0 && _size$xAxis.height && !size.yAxis ? size.xAxis.height : X_AXIS_HEIGHT;
            }
            function getDefaultYAxisXPoint(yAxisRectParam) {
              var yAxisTitle = yAxisRectParam.yAxisTitle, isRightSide = yAxisRectParam.isRightSide, visibleSecondaryYAxis = yAxisRectParam.visibleSecondaryYAxis;
              var yAxisWidth = getDefaultYAxisWidth(yAxisRectParam);
              return isRightSide && visibleSecondaryYAxis ? Math.max(yAxisTitle.x + yAxisTitle.width - yAxisWidth, 0) : yAxisTitle.x;
            }
            function getYAxisXPoint(yAxisRectParam) {
              var chartSize = yAxisRectParam.chartSize, legend2 = yAxisRectParam.legend, circleLegend2 = yAxisRectParam.circleLegend, hasCenterYAxis = yAxisRectParam.hasCenterYAxis, maxLabelWidth = yAxisRectParam.maxLabelWidth;
              var width = chartSize.width;
              var align = legend2.align;
              var yAxisWidth = getDefaultYAxisWidth(yAxisRectParam);
              var x = getDefaultYAxisXPoint(yAxisRectParam);
              if (hasCenterYAxis) {
                yAxisWidth = maxLabelWidth + (TICK_SIZE + padding.X) * 2;
                x = (width - legend2.width - yAxisWidth + padding.X * 2) / 2;
              }
              if (legend2.visible && align === "left") {
                x = getDefaultYAxisXPoint(yAxisRectParam);
              }
              if (circleLegend2.visible && align === "left") {
                x = Math.max(circleLegend2.width + padding.X, x);
              }
              return x;
            }
            function getYAxisYPoint(_ref) {
              var yAxisTitle = _ref.yAxisTitle;
              return yAxisTitle.y + yAxisTitle.height;
            }
            function getDefaultYAxisWidth(_ref2) {
              var _size$width2, _size;
              var maxLabelWidth = _ref2.maxLabelWidth, size = _ref2.size, isRightSide = _ref2.isRightSide;
              return (_size$width2 = size === null || size === void 0 ? void 0 : (_size = size[isRightSide ? "secondaryYAxis" : "yAxis"]) === null || _size === void 0 ? void 0 : _size.width) !== null && _size$width2 !== void 0 ? _size$width2 : maxLabelWidth;
            }
            function getYAxisWidth(yAxisRectParam) {
              var hasCenterYAxis = yAxisRectParam.hasCenterYAxis, hasXYAxis = yAxisRectParam.hasXYAxis, maxLabelWidth = yAxisRectParam.maxLabelWidth, _yAxisRectParam$visib = yAxisRectParam.visibleSecondaryYAxis, visibleSecondaryYAxis = _yAxisRectParam$visib === void 0 ? false : _yAxisRectParam$visib, _yAxisRectParam$isRig = yAxisRectParam.isRightSide, isRightSide = _yAxisRectParam$isRig === void 0 ? false : _yAxisRectParam$isRig;
              var yAxisWidth = getDefaultYAxisWidth(yAxisRectParam);
              if (hasCenterYAxis && !isRightSide) {
                yAxisWidth = maxLabelWidth + (TICK_SIZE + padding.X) * 2;
              } else if (!hasXYAxis || isRightSide && !visibleSecondaryYAxis) {
                yAxisWidth = 0;
              }
              return yAxisWidth;
            }
            function getYAxisHeight(_ref3) {
              var _size$yAxis, _size$plot;
              var chartSize = _ref3.chartSize, legend2 = _ref3.legend, yAxisTitle = _ref3.yAxisTitle, hasXYAxis = _ref3.hasXYAxis, size = _ref3.size, xAxisTitleHeight = _ref3.xAxisTitleHeight;
              var height = chartSize.height;
              var align = legend2.align, legendHeight = legend2.height;
              var xAxisHeight = getDefaultXAxisHeight(size);
              var y = yAxisTitle.y + yAxisTitle.height;
              var yAxisHeight = height - y - xAxisHeight - xAxisTitleHeight;
              if (!hasXYAxis) {
                yAxisHeight = height - y;
              }
              if (legend2.visible) {
                var topArea = Math.max(y, legendHeight);
                if (align === "top") {
                  yAxisHeight = height - topArea - (hasXYAxis ? X_AXIS_HEIGHT + xAxisTitleHeight : 0);
                } else if (align === "bottom") {
                  yAxisHeight = height - y - X_AXIS_HEIGHT - xAxisTitleHeight - legendHeight;
                }
              }
              if (!(size !== null && size !== void 0 && (_size$yAxis = size.yAxis) !== null && _size$yAxis !== void 0 && _size$yAxis.height) && size !== null && size !== void 0 && (_size$plot = size.plot) !== null && _size$plot !== void 0 && _size$plot.height) {
                yAxisHeight = size.plot.height;
              }
              return yAxisHeight;
            }
            function getYAxisRect(yAxisRectParam) {
              var size = yAxisRectParam.size, _yAxisRectParam$isRig2 = yAxisRectParam.isRightSide, isRightSide = _yAxisRectParam$isRig2 === void 0 ? false : _yAxisRectParam$isRig2;
              var x = getYAxisXPoint(yAxisRectParam);
              var y = getYAxisYPoint(yAxisRectParam);
              var yAxisWidth = getYAxisWidth(yAxisRectParam);
              var yAxisHeight = getYAxisHeight(yAxisRectParam);
              return layout_objectSpread({
                x,
                y
              }, getValidRectSize(isRightSide ? size === null || size === void 0 ? void 0 : size.secondaryYAxis : size === null || size === void 0 ? void 0 : size.yAxis, yAxisWidth, yAxisHeight));
            }
            function getXAxisWidth(_ref4) {
              var chartSize = _ref4.chartSize, yAxis = _ref4.yAxis, hasCenterYAxis = _ref4.hasCenterYAxis, legend2 = _ref4.legend, circleLegend2 = _ref4.circleLegend, secondaryYAxis = _ref4.secondaryYAxis, xAxisData = _ref4.xAxisData;
              var width = chartSize.width;
              var align = legend2.align, legendWidth = legend2.width;
              var legendVerticalAlign = isVerticalAlign(align);
              var xAxisWidth;
              if (legendVerticalAlign) {
                xAxisWidth = width - (yAxis.x + yAxis.width + padding.X);
                if (circleLegend2.visible) {
                  xAxisWidth -= circleLegend2.width;
                }
              } else {
                xAxisWidth = width - (yAxis.width + Math.max(legendWidth, circleLegend2.visible ? circleLegend2.width : 0));
              }
              if (hasCenterYAxis) {
                xAxisWidth = width - (legendVerticalAlign ? 0 : legendWidth) - padding.X * 2;
              }
              if (secondaryYAxis.width) {
                xAxisWidth -= secondaryYAxis.width;
              }
              if (xAxisData !== null && xAxisData !== void 0 && xAxisData.maxLabelWidth) {
                xAxisWidth -= xAxisData.maxLabelWidth * 0.5;
              }
              return xAxisWidth;
            }
            function getXAxisHeight(xAxisData) {
              var _xAxisData$maxHeight;
              var hasXYAxis = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
              if (!hasXYAxis) {
                return 0;
              }
              return (_xAxisData$maxHeight = xAxisData === null || xAxisData === void 0 ? void 0 : xAxisData.maxHeight) !== null && _xAxisData$maxHeight !== void 0 ? _xAxisData$maxHeight : X_AXIS_HEIGHT;
            }
            function getXAxisRect(xAxisRectParam) {
              var hasXYAxis = xAxisRectParam.hasXYAxis, hasCenterYAxis = xAxisRectParam.hasCenterYAxis, yAxis = xAxisRectParam.yAxis, size = xAxisRectParam.size, xAxisData = xAxisRectParam.xAxisData;
              var x = hasCenterYAxis ? padding.X * 2 : yAxis.x + yAxis.width;
              var y = yAxis.y + yAxis.height;
              var xAxisWidth = getXAxisWidth(xAxisRectParam);
              var xAxisHeight = getXAxisHeight(xAxisData, hasXYAxis);
              return layout_objectSpread({
                x,
                y
              }, getValidRectSize(size === null || size === void 0 ? void 0 : size.xAxis, xAxisWidth, xAxisHeight));
            }
            function getLegendRect(legendRectParams) {
              var legend2 = legendRectParams.legend, xAxis = legendRectParams.xAxis, yAxis = legendRectParams.yAxis, chartSize = legendRectParams.chartSize, title = legendRectParams.title, hasXYAxis = legendRectParams.hasXYAxis, secondaryYAxis = legendRectParams.secondaryYAxis, xAxisTitleHeight = legendRectParams.xAxisTitleHeight;
              if (!legend2.visible) {
                return {
                  x: 0,
                  y: 0,
                  width: 0,
                  height: 0
                };
              }
              var align = legend2.align, legendWidth = legend2.width, legendHeight = legend2.height;
              var width = chartSize.width;
              var verticalAlign = isVerticalAlign(align);
              var x = xAxis.x + xAxis.width + secondaryYAxis.width + padding.X;
              var y = Math.max(yAxis.y, BUTTON_RECT_SIZE);
              if (verticalAlign) {
                x = (width - legendWidth) / 2;
                if (align === "top") {
                  y = title.y + title.height;
                } else {
                  y = yAxis.y + yAxis.height + (hasXYAxis ? xAxis.height + xAxisTitleHeight : padding.Y);
                }
              } else if (align === "left") {
                x = padding.X;
              }
              return {
                width: legendWidth,
                height: legendHeight,
                x,
                y
              };
            }
            function getCircleLegendRect(xAxis, yAxis, align, width) {
              return {
                width,
                height: yAxis.height,
                x: align === "left" ? padding.X : xAxis.x + xAxis.width + padding.X,
                y: yAxis.y
              };
            }
            function getPlotRect(xAxis, yAxis, size) {
              return layout_objectSpread({
                x: xAxis.x,
                y: yAxis.y
              }, getValidRectSize(size, xAxis.width, yAxis.height));
            }
            function getTitleRect(chartSize, exportMenu, visible, titleHeight) {
              var point = {
                x: padding.X,
                y: padding.Y
              };
              var marginBottom = 5;
              var width = visible ? chartSize.width - exportMenu.width : 0;
              var height = visible ? Math.max(titleHeight + marginBottom, exportMenu.height) : exportMenu.height;
              return layout_objectSpread({
                width,
                height
              }, point);
            }
            function getTopLegendAreaHeight(useSpectrumLegend, legendHeight) {
              return useSpectrumLegend ? SPECTRUM_LEGEND_LABEL_HEIGHT + spectrumLegendBar.PADDING * 2 + spectrumLegendTooltip.POINT_HEIGHT + spectrumLegendTooltip.HEIGHT + padding.Y : legendHeight + padding.Y;
            }
            function getYAxisTitleRect(_ref5) {
              var chartSize = _ref5.chartSize, visible = _ref5.visible, title = _ref5.title, _ref5$legend = _ref5.legend, legendAlign = _ref5$legend.align, legendWidth = _ref5$legend.width, legendHeight = _ref5$legend.height, legendVisible = _ref5$legend.visible, useSpectrumLegend = _ref5$legend.useSpectrumLegend, hasCenterYAxis = _ref5.hasCenterYAxis, visibleSecondaryYAxis = _ref5.visibleSecondaryYAxis, _ref5$isRightSide = _ref5.isRightSide, isRightSide = _ref5$isRightSide === void 0 ? false : _ref5$isRightSide, yAxisTitleHeight = _ref5.yAxisTitleHeight;
              var marginBottom = 5;
              var height = visible ? yAxisTitleHeight + marginBottom : 0;
              var verticalLegendAlign = isVerticalAlign(legendAlign);
              var width = (chartSize.width - (verticalLegendAlign ? padding.X * 2 : legendWidth)) / (visibleSecondaryYAxis ? 2 : 1);
              var point = {
                x: isRightSide ? title.x + width : title.x,
                y: title.y + title.height
              };
              if (legendVisible) {
                if (legendAlign === "left") {
                  point.x += legendWidth;
                } else if (legendAlign === "top") {
                  point.y += getTopLegendAreaHeight(useSpectrumLegend, legendHeight);
                }
              }
              if (hasCenterYAxis) {
                point.x = (width + padding.X * 2) / 2;
              }
              return layout_objectSpread({
                height,
                width
              }, point);
            }
            function getXAxisTitleRect(visible, xAxis, xAxisTitleHeight) {
              var point = {
                x: xAxis.x,
                y: xAxis.y + xAxis.height
              };
              var height = visible ? xAxisTitleHeight : 0;
              var width = visible ? xAxis.width : 0;
              return layout_objectSpread({
                height,
                width
              }, point);
            }
            function getExportMenuRect(chartSize, visible) {
              var marginY = 5;
              var x = visible ? padding.X + chartSize.width - BUTTON_RECT_SIZE : padding.X + chartSize.width;
              var y = padding.Y;
              var height = visible ? BUTTON_RECT_SIZE + marginY : 0;
              var width = visible ? BUTTON_RECT_SIZE : 0;
              return {
                x,
                y,
                height,
                width
              };
            }
            function getResetButtonRect(exportMenu, useResetButton) {
              var marginY = 5;
              var x = useResetButton ? exportMenu.x - BUTTON_RECT_SIZE - padding.X : 0;
              var y = useResetButton ? exportMenu.y : 0;
              var height = useResetButton ? BUTTON_RECT_SIZE + marginY : 0;
              var width = useResetButton ? BUTTON_RECT_SIZE : 0;
              return {
                x,
                y,
                height,
                width
              };
            }
            function isUsingResetButton(options2) {
              var _options$series;
              return !!((_options$series = options2.series) !== null && _options$series !== void 0 && _options$series.zoomable);
            }
            function isExportMenuVisible(options2) {
              var _options$exportMenu;
              var visible = (_options$exportMenu = options2.exportMenu) === null || _options$exportMenu === void 0 ? void 0 : _options$exportMenu.visible;
              return isUndefined(visible) ? true : visible;
            }
            function getYAxisMaxLabelWidth(maxLabelLength) {
              return maxLabelLength ? maxLabelLength + padding.X : Y_AXIS_MIN_WIDTH;
            }
            function pickOptionSize(option) {
              if (!option || isUndefined(option.width) && isUndefined(option.height)) {
                return null;
              }
              return pick(option, "width", "height");
            }
            function validOffsetValue(axis, plot2, sizeKey) {
              var axisSize = axis[sizeKey];
              var plotSize = plot2[sizeKey];
              if (isNumber(axisSize) && isNumber(plotSize)) {
                return Math.max(axisSize, plotSize);
              }
            }
            function getOptionSize(options2) {
              var xAxis = pickOptionSize(options2.xAxis);
              var yAxisOptions = getYAxisOption(options2);
              var yAxis = pickOptionSize(yAxisOptions.yAxis);
              var secondaryYAxis = pickOptionSize(yAxisOptions.secondaryYAxis);
              var plot2 = pickOptionSize(options2.plot);
              if (plot2) {
                if (xAxis) {
                  xAxis.width = plot2.width = validOffsetValue(xAxis, plot2, "width");
                }
                if (yAxis) {
                  yAxis.height = plot2.height = validOffsetValue(yAxis, plot2, "height");
                }
                if (secondaryYAxis) {
                  secondaryYAxis.height = plot2.height = validOffsetValue(secondaryYAxis, plot2, "height");
                }
              }
              return {
                xAxis,
                yAxis,
                plot: plot2,
                secondaryYAxis
              };
            }
            function getAxisTitleHeight(axisTheme) {
              var offsetY = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
              var fontSize = Array.isArray(axisTheme) ? Math.max(axisTheme[0].title.fontSize, axisTheme[1].title.fontSize) : axisTheme.title.fontSize;
              return fontSize + offsetY;
            }
            function adjustAxisSize(_ref6, layout2, legendState) {
              var width = _ref6.width, height = _ref6.height;
              if (width < 0 || height < 0) {
                return;
              }
              var title = layout2.title, yAxisTitle = layout2.yAxisTitle, yAxis = layout2.yAxis, xAxis = layout2.xAxis, xAxisTitle = layout2.xAxisTitle, legend2 = layout2.legend, secondaryYAxis = layout2.secondaryYAxis;
              var align = legendState.align;
              var hasVerticalLegend = isVerticalAlign(align);
              var legendHeight = hasVerticalLegend ? legend2.height : 0;
              var diffHeight = xAxis.height + xAxisTitle.height + yAxis.height + yAxisTitle.height + title.height + legendHeight - height;
              if (diffHeight > 0) {
                yAxis.height -= diffHeight;
                xAxis.y -= diffHeight;
                xAxisTitle.y -= diffHeight;
                if (hasVerticalLegend) {
                  legend2.y -= diffHeight;
                }
              }
              secondaryYAxis.x = xAxis.x + xAxis.width;
              secondaryYAxis.height = yAxis.height;
            }
            function getCircularAxisTitleRect(plot2, axisTheme, circularAxis) {
              var _title$offsetY;
              if (!circularAxis) {
                return layout_objectSpread({}, plot2);
              }
              var x = plot2.x, y = plot2.y;
              var centerX = circularAxis.centerX, centerY = circularAxis.centerY, axisSize = circularAxis.axisSize, title = circularAxis.title, outer = circularAxis.radius.outer;
              var offsetY = (_title$offsetY = title === null || title === void 0 ? void 0 : title.offsetY) !== null && _title$offsetY !== void 0 ? _title$offsetY : 0;
              return {
                x: centerX + x - axisSize / 2,
                y: centerY + y - outer / 2,
                width: axisSize,
                height: axisTheme.title.fontSize + offsetY
              };
            }
            function hasXYAxes(series) {
              return !(series.pie || series.radar || series.treemap || series.radialBar || series.gauge);
            }
            function getYAxisOptions(options2, hasXYAxis) {
              return hasXYAxis ? getYAxisOption(options2) : {
                yAxis: null,
                secondaryYAxis: null
              };
            }
            var layout = {
              name: "layout",
              state: function state() {
                return {
                  layout: {}
                };
              },
              action: {
                setLayout: function setLayout(_ref7) {
                  var _getAxisTitleHeight, _axes$yAxis, _axes$yAxis$title, _getAxisTitleHeight2, _axes$xAxis, _axes$xAxis$title, _options$chart, _axes$secondaryYAxis, _options$xAxis;
                  var state = _ref7.state;
                  var legendState = state.legend, theme2 = state.theme, circleLegendState = state.circleLegend, series = state.series, options2 = state.options, chart = state.chart, axes2 = state.axes, radialAxes2 = state.radialAxes;
                  var width = chart.width, height = chart.height;
                  var chartSize = {
                    height: height - padding.Y * 2,
                    width: width - padding.X * 2
                  };
                  var hasCenterYAxis = series.bar ? isCenterYAxis(options2) : false;
                  var hasXYAxis = hasXYAxes(series);
                  var optionSize = getOptionSize(options2);
                  var _getYAxisOptions = getYAxisOptions(options2, hasXYAxis), yAxisOption = _getYAxisOptions.yAxis, secondaryYAxisOption = _getYAxisOptions.secondaryYAxis;
                  var visibleSecondaryYAxis = !!secondaryYAxisOption;
                  var titleHeight = theme2.title.fontSize;
                  var yAxisTitleHeight = (_getAxisTitleHeight = getAxisTitleHeight(theme2.yAxis, axes2 === null || axes2 === void 0 ? void 0 : (_axes$yAxis = axes2.yAxis) === null || _axes$yAxis === void 0 ? void 0 : (_axes$yAxis$title = _axes$yAxis.title) === null || _axes$yAxis$title === void 0 ? void 0 : _axes$yAxis$title.offsetY)) !== null && _getAxisTitleHeight !== void 0 ? _getAxisTitleHeight : 0;
                  var xAxisTitleHeight = (_getAxisTitleHeight2 = getAxisTitleHeight(theme2.xAxis, axes2 === null || axes2 === void 0 ? void 0 : (_axes$xAxis = axes2.xAxis) === null || _axes$xAxis === void 0 ? void 0 : (_axes$xAxis$title = _axes$xAxis.title) === null || _axes$xAxis$title === void 0 ? void 0 : _axes$xAxis$title.offsetY)) !== null && _getAxisTitleHeight2 !== void 0 ? _getAxisTitleHeight2 : 0;
                  var exportMenu = getExportMenuRect(chartSize, isExportMenuVisible(options2));
                  var resetButton2 = getResetButtonRect(exportMenu, isUsingResetButton(options2));
                  var btnAreaRect = exportMenu.height ? exportMenu : resetButton2;
                  var title = getTitleRect(chartSize, btnAreaRect, !!((_options$chart = options2.chart) !== null && _options$chart !== void 0 && _options$chart.title), titleHeight);
                  var yAxisTitleVisible = !!(yAxisOption !== null && yAxisOption !== void 0 && yAxisOption.title) || !!(secondaryYAxisOption !== null && secondaryYAxisOption !== void 0 && secondaryYAxisOption.title);
                  var yAxisTitle = getYAxisTitleRect({
                    chartSize,
                    visible: yAxisTitleVisible,
                    title,
                    legend: legendState,
                    hasCenterYAxis,
                    visibleSecondaryYAxis,
                    yAxisTitleHeight
                  });
                  var yAxis = getYAxisRect({
                    chartSize,
                    legend: legendState,
                    circleLegend: circleLegendState,
                    yAxisTitle,
                    hasCenterYAxis,
                    hasXYAxis,
                    maxLabelWidth: getYAxisMaxLabelWidth(axes2 === null || axes2 === void 0 ? void 0 : axes2.yAxis.maxLabelWidth),
                    size: optionSize,
                    xAxisTitleHeight
                  });
                  var secondaryYAxisTitle = getYAxisTitleRect({
                    chartSize,
                    visible: yAxisTitleVisible,
                    title,
                    legend: legendState,
                    hasCenterYAxis,
                    isRightSide: true,
                    visibleSecondaryYAxis,
                    yAxisTitleHeight
                  });
                  var secondaryYAxis = getYAxisRect({
                    chartSize,
                    legend: legendState,
                    circleLegend: circleLegendState,
                    yAxisTitle: secondaryYAxisTitle,
                    hasCenterYAxis,
                    hasXYAxis,
                    maxLabelWidth: getYAxisMaxLabelWidth(axes2 === null || axes2 === void 0 ? void 0 : (_axes$secondaryYAxis = axes2.secondaryYAxis) === null || _axes$secondaryYAxis === void 0 ? void 0 : _axes$secondaryYAxis.maxLabelWidth),
                    size: optionSize,
                    isRightSide: true,
                    visibleSecondaryYAxis,
                    xAxisTitleHeight
                  });
                  var xAxis = getXAxisRect({
                    chartSize,
                    yAxis,
                    secondaryYAxis,
                    legend: legendState,
                    circleLegend: circleLegendState,
                    hasCenterYAxis,
                    hasXYAxis,
                    size: optionSize,
                    xAxisData: axes2 === null || axes2 === void 0 ? void 0 : axes2.xAxis
                  });
                  var xAxisTitle = getXAxisTitleRect(!!((_options$xAxis = options2.xAxis) !== null && _options$xAxis !== void 0 && _options$xAxis.title), xAxis, xAxisTitleHeight);
                  var legend2 = getLegendRect({
                    chartSize,
                    xAxis,
                    yAxis,
                    secondaryYAxis,
                    title,
                    legend: legendState,
                    hasXYAxis,
                    xAxisTitleHeight
                  });
                  adjustAxisSize(chartSize, {
                    title,
                    yAxisTitle,
                    yAxis,
                    xAxis,
                    xAxisTitle,
                    legend: legend2,
                    secondaryYAxis
                  }, legendState);
                  var circleLegend2 = getCircleLegendRect(xAxis, yAxis, legendState.align, circleLegendState.width);
                  var plot2 = getPlotRect(xAxis, yAxis, optionSize.plot);
                  var circularAxisTitle = getCircularAxisTitleRect(plot2, theme2.circularAxis, radialAxes2 === null || radialAxes2 === void 0 ? void 0 : radialAxes2.circularAxis);
                  store_extend(state.layout, {
                    chart: {
                      x: 0,
                      y: 0,
                      width,
                      height
                    },
                    title,
                    plot: plot2,
                    legend: legend2,
                    circleLegend: circleLegend2,
                    xAxis,
                    xAxisTitle,
                    yAxis,
                    yAxisTitle,
                    exportMenu,
                    resetButton: resetButton2,
                    secondaryYAxisTitle,
                    secondaryYAxis,
                    circularAxisTitle
                  });
                }
              },
              observe: {
                updateLayoutObserve: function updateLayoutObserve() {
                  this.dispatch("setLayout");
                }
              }
            };
            var store_layout = layout;
            ;
            function isRangeValue(value) {
              return Array.isArray(value) && value.length === 2;
            }
            function isRangeData(data) {
              return Array.isArray(data) && isRangeValue(getFirstValidValue(data));
            }
            function isZooming(categories, zoomRange) {
              return !!(zoomRange && (zoomRange[0] !== 0 || zoomRange[1] !== categories.length - 1));
            }
            function getDataInRange(data, range2) {
              if (!range2) {
                return data;
              }
              return data.slice(range2[0], range2[1] + 1);
            }
            ;
            function category_ownKeys(object, enumerableOnly) {
              var keys = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object);
                if (enumerableOnly) {
                  symbols = symbols.filter(function(sym) {
                    return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                  });
                }
                keys.push.apply(keys, symbols);
              }
              return keys;
            }
            function category_objectSpread(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i] != null ? arguments[i] : {};
                if (i % 2) {
                  category_ownKeys(Object(source), true).forEach(function(key) {
                    category_defineProperty(target, key, source[key]);
                  });
                } else if (Object.getOwnPropertyDescriptors) {
                  Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                } else {
                  category_ownKeys(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  });
                }
              }
              return target;
            }
            function category_defineProperty(obj, key, value) {
              if (key in obj) {
                Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
              } else {
                obj[key] = value;
              }
              return obj;
            }
            function makeRawCategories(series, categories) {
              if (categories) {
                return categories;
              }
              var firstValues = /* @__PURE__ */ new Set();
              Object.keys(series).forEach(function(key) {
                var _series$key$data;
                if (key === "pie" || key === "gauge") {
                  return;
                }
                ((_series$key$data = series[key].data) !== null && _series$key$data !== void 0 ? _series$key$data : series[key]).forEach(function(_ref) {
                  var data = _ref.data, name = _ref.name, visible = _ref.visible;
                  if (Array.isArray(data)) {
                    data.forEach(function(datum) {
                      if (!isNull(datum)) {
                        var rawXValue = getCoordinateXValue(datum);
                        firstValues.add(isNumber(rawXValue) ? rawXValue : rawXValue.toString());
                      }
                    });
                  } else if (key === "bullet" && isUndefined(visible) || visible) {
                    firstValues.add(name);
                  }
                });
              });
              return Array.from(firstValues).sort(sortCategories).map(function(category2) {
                return String(category2);
              });
            }
            var category = {
              name: "category",
              state: function state(_ref2) {
                var categories = _ref2.categories, series = _ref2.series;
                return {
                  categories: makeRawCategories(series, categories)
                };
              },
              action: {
                setCategory: function setCategory(_ref3) {
                  var state = _ref3.state, computed2 = _ref3.computed;
                  var viewRange = computed2.viewRange;
                  var categories = state.rawCategories;
                  if (viewRange) {
                    if (Array.isArray(categories)) {
                      categories = getDataInRange(categories, viewRange);
                    } else {
                      categories = category_objectSpread(category_objectSpread({}, categories), {}, {
                        x: getDataInRange(categories.x, viewRange)
                      });
                    }
                  }
                  state.categories = categories;
                  this.notify(state, "categories");
                },
                initCategory: function initCategory(_ref4) {
                  var initStoreState = _ref4.initStoreState, state = _ref4.state;
                  var zoomRange = state.zoomRange;
                  var categories = makeRawCategories(initStoreState.series);
                  if (zoomRange && Array.isArray(categories)) {
                    categories = getDataInRange(categories, zoomRange);
                  }
                  state.categories = categories;
                  this.notify(state, "categories");
                },
                removeCategoryByName: function removeCategoryByName(_ref5, name) {
                  var state = _ref5.state;
                  var index = state.categories.findIndex(function(seriesName) {
                    return seriesName === name;
                  });
                  state.categories.splice(index, 1);
                  this.notify(state, "axes");
                }
              },
              observe: {
                updateCategory: function updateCategory() {
                  this.dispatch("setCategory");
                }
              }
            };
            var store_category = category;
            ;
            function seriesData_toConsumableArray(arr) {
              return seriesData_arrayWithoutHoles(arr) || seriesData_iterableToArray(arr) || seriesData_unsupportedIterableToArray(arr) || seriesData_nonIterableSpread();
            }
            function seriesData_nonIterableSpread() {
              throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            function seriesData_iterableToArray(iter) {
              if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
                return Array.from(iter);
            }
            function seriesData_arrayWithoutHoles(arr) {
              if (Array.isArray(arr))
                return seriesData_arrayLikeToArray(arr);
            }
            function seriesData_ownKeys(object, enumerableOnly) {
              var keys = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object);
                if (enumerableOnly) {
                  symbols = symbols.filter(function(sym) {
                    return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                  });
                }
                keys.push.apply(keys, symbols);
              }
              return keys;
            }
            function seriesData_objectSpread(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i] != null ? arguments[i] : {};
                if (i % 2) {
                  seriesData_ownKeys(Object(source), true).forEach(function(key) {
                    seriesData_defineProperty(target, key, source[key]);
                  });
                } else if (Object.getOwnPropertyDescriptors) {
                  Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                } else {
                  seriesData_ownKeys(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  });
                }
              }
              return target;
            }
            function seriesData_defineProperty(obj, key, value) {
              if (key in obj) {
                Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
              } else {
                obj[key] = value;
              }
              return obj;
            }
            function seriesData_slicedToArray(arr, i) {
              return seriesData_arrayWithHoles(arr) || seriesData_iterableToArrayLimit(arr, i) || seriesData_unsupportedIterableToArray(arr, i) || seriesData_nonIterableRest();
            }
            function seriesData_nonIterableRest() {
              throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            function seriesData_unsupportedIterableToArray(o, minLen) {
              if (!o)
                return;
              if (typeof o === "string")
                return seriesData_arrayLikeToArray(o, minLen);
              var n = Object.prototype.toString.call(o).slice(8, -1);
              if (n === "Object" && o.constructor)
                n = o.constructor.name;
              if (n === "Map" || n === "Set")
                return Array.from(o);
              if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                return seriesData_arrayLikeToArray(o, minLen);
            }
            function seriesData_arrayLikeToArray(arr, len) {
              if (len == null || len > arr.length)
                len = arr.length;
              for (var i = 0, arr2 = new Array(len); i < len; i++) {
                arr2[i] = arr[i];
              }
              return arr2;
            }
            function seriesData_iterableToArrayLimit(arr, i) {
              var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]);
              if (_i == null)
                return;
              var _arr = [];
              var _n = true;
              var _d = false;
              var _s, _e;
              try {
                for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
                  _arr.push(_s.value);
                  if (i && _arr.length === i)
                    break;
                }
              } catch (err) {
                _d = true;
                _e = err;
              } finally {
                try {
                  if (!_n && _i["return"] != null)
                    _i["return"]();
                } finally {
                  if (_d)
                    throw _e;
                }
              }
              return _arr;
            }
            function seriesData_arrayWithHoles(arr) {
              if (Array.isArray(arr))
                return arr;
            }
            function initRange(series, categories) {
              var rawCategoriesLength;
              if (categories) {
                rawCategoriesLength = Array.isArray(categories) ? categories.length : categories.x.length;
              } else {
                rawCategoriesLength = Object.keys(makeRawCategories(series, categories)).length;
              }
              return [0, rawCategoriesLength - 1];
            }
            function initSelectionRange(series, options2, categories) {
              var _options$series;
              if (!(series.line || series.area || series.column) || !((_options$series = options2.series) !== null && _options$series !== void 0 && _options$series.rangeSelectable)) {
                return;
              }
              return initRange(series, categories);
            }
            function initZoomRange(series, options2, categories) {
              var _options$series2;
              if (!(series.line || series.area) || !((_options$series2 = options2.series) !== null && _options$series2 !== void 0 && _options$series2.zoomable)) {
                return;
              }
              return initRange(series, categories);
            }
            function initShiftRange(series, options2, categories) {
              var _options$series3;
              if (!(series.line || series.area || series.column || series.heatmap) || !((_options$series3 = options2.series) !== null && _options$series3 !== void 0 && _options$series3.shift)) {
                return;
              }
              return initRange(series, categories);
            }
            function getCoordinateDataRange(data, rawCategories, zoomRange) {
              var _zoomRange = seriesData_slicedToArray(zoomRange, 2), zoomStart = _zoomRange[0], zoomEnd = _zoomRange[1];
              var start, end;
              range(zoomStart, zoomEnd + 1).forEach(function(i) {
                var idx = data.findIndex(function(datum) {
                  return getCoordinateXValue(datum).toString() === rawCategories[i];
                });
                if (idx !== -1) {
                  if (isUndefined(start)) {
                    start = idx;
                  }
                  if (!isUndefined(start)) {
                    var _end;
                    end = Math.max(idx, (_end = end) !== null && _end !== void 0 ? _end : 0);
                  }
                }
              });
              return [start, end];
            }
            function getSeriesColors(colors, colorIndex, size, isColorByCategories) {
              return isColorByCategories ? colors.slice(0, size + 1) : colors[colorIndex % colors.length];
            }
            function getSeriesDataInRange(data, rawCategories, chartType, zoomRange) {
              if (!zoomRange) {
                return data;
              }
              var _zoomRange2 = seriesData_slicedToArray(zoomRange, 2), startIdx = _zoomRange2[0], endIdx = _zoomRange2[1];
              var firstValidValue = getFirstValidValue(data);
              var isCoordinateChart = chartType !== "area" && !isUndefined(firstValidValue) && !isNumber(firstValidValue);
              if (isCoordinateChart) {
                var _getCoordinateDataRan = getCoordinateDataRange(data, rawCategories, zoomRange);
                var _getCoordinateDataRan2 = seriesData_slicedToArray(_getCoordinateDataRan, 2);
                startIdx = _getCoordinateDataRan2[0];
                endIdx = _getCoordinateDataRan2[1];
              } else {
                startIdx = startIdx > 1 ? startIdx - 1 : startIdx;
                endIdx = endIdx < rawCategories.length - 1 ? endIdx + 1 : endIdx;
              }
              return data.slice(startIdx, endIdx + 1);
            }
            function isCoordinateTypeSeries(series, chartType) {
              return isCoordinateSeries(series) && (isUndefined(chartType) || chartType === "line" || chartType === "scatter");
            }
            function isSeriesAlreadyExist(series, seriesName, data) {
              return series[seriesName].some(function(_ref) {
                var label2 = _ref.label;
                return label2 === data.name;
              });
            }
            function isTreemapSeriesAlreadyExist(series, data) {
              return series.treemap.some(function(_ref2) {
                var label2 = _ref2.label;
                return label2 === data.label;
              });
            }
            function isHeatmapSeriesAlreadyExist(categories, category2) {
              return includes(categories.y, category2);
            }
            function initDisabledSeries(series) {
              var nestedPieChart = hasNestedPieSeries(series);
              var disabledSeries = [];
              if (nestedPieChart) {
                series.pie.forEach(function(_ref3) {
                  var data = _ref3.data;
                  data.forEach(function(datum) {
                    if (isBoolean(datum.visible) && !datum.visible) {
                      disabledSeries.push(datum.name);
                    }
                  });
                });
              } else {
                Object.keys(series).forEach(function(type) {
                  series[type].forEach(function(_ref4) {
                    var name = _ref4.name, visible = _ref4.visible;
                    if (isBoolean(visible) && !visible) {
                      disabledSeries.push(name);
                    }
                  });
                });
              }
              return disabledSeries;
            }
            var seriesData = {
              name: "seriesData",
              state: function state(_ref5) {
                var series = _ref5.series, categories = _ref5.categories, options2 = _ref5.options;
                return {
                  rawCategories: makeRawCategories(series, categories),
                  series: seriesData_objectSpread({}, series),
                  selectionRange: initSelectionRange(series, options2, categories),
                  zoomRange: initZoomRange(series, options2, categories),
                  shiftRange: initShiftRange(series, options2, categories),
                  disabledSeries: initDisabledSeries(series)
                };
              },
              action: {
                setSeriesData: function setSeriesData(_ref6) {
                  var state = _ref6.state, initStoreState = _ref6.initStoreState;
                  var rawSeries = deepCopy(initStoreState.series);
                  var disabledSeries = state.disabledSeries, theme2 = state.theme, zoomRange = state.zoomRange, rawCategories = state.rawCategories;
                  var newSeriesData = {};
                  var colorIndex = 0;
                  Object.keys(rawSeries).forEach(function(seriesName) {
                    var _originSeriesData$0$d, _originSeriesData$, _originSeriesData$$da;
                    var _seriesName = theme2.series[seriesName], colors = _seriesName.colors, iconTypes = _seriesName.iconTypes;
                    var originSeriesData = rawSeries[seriesName].map(function(series) {
                      var isColorByCategories = !!series.colorByCategories;
                      var size = isColorByCategories ? rawCategories.length : 1;
                      var color = colors ? getSeriesColors(colors, colorIndex, size, isColorByCategories) : "";
                      colorIndex += size;
                      return seriesData_objectSpread(seriesData_objectSpread({}, series), {}, {
                        rawData: series.data,
                        data: getSeriesDataInRange(series.data, rawCategories, seriesName, zoomRange),
                        color
                      });
                    });
                    if (seriesName === "scatter") {
                      originSeriesData = originSeriesData.map(function(series, idx) {
                        return seriesData_objectSpread(seriesData_objectSpread({}, series), {}, {
                          iconType: iconTypes ? iconTypes[idx] : "circle"
                        });
                      });
                    }
                    var seriesCount = originSeriesData.length;
                    var seriesGroupCount = (_originSeriesData$0$d = (_originSeriesData$ = originSeriesData[0]) === null || _originSeriesData$ === void 0 ? void 0 : (_originSeriesData$$da = _originSeriesData$.data) === null || _originSeriesData$$da === void 0 ? void 0 : _originSeriesData$$da.length) !== null && _originSeriesData$0$d !== void 0 ? _originSeriesData$0$d : 0;
                    var data = originSeriesData.filter(function(_ref7) {
                      var name = _ref7.name;
                      return !disabledSeries.includes(name);
                    });
                    newSeriesData[seriesName] = {
                      seriesCount,
                      seriesGroupCount,
                      data,
                      colors
                    };
                  });
                  store_extend(state.series, newSeriesData);
                },
                disableSeries: function disableSeries(_ref8, name) {
                  var state = _ref8.state;
                  state.disabledSeries.push(name);
                  this.notify(state, "disabledSeries");
                  if (state.series.bullet) {
                    this.dispatch("removeCategoryByName", name);
                  }
                },
                enableSeries: function enableSeries(_ref9, name) {
                  var state = _ref9.state;
                  var index = state.disabledSeries.findIndex(function(disabled) {
                    return disabled === name;
                  });
                  state.disabledSeries.splice(index, 1);
                  this.notify(state, "disabledSeries");
                  if (state.series.bullet) {
                    state.categories = state.series.bullet.data.map(function(_ref10) {
                      var seriesName = _ref10.name;
                      return seriesName;
                    });
                    this.notify(state, "axes");
                  }
                },
                selection: function selection(_ref11, rangeCategories) {
                  var state = _ref11.state;
                  var rawCategories = state.rawCategories;
                  state.selectionRange = rangeCategories.map(function(rangeCategory) {
                    return rawCategories.findIndex(function(category2) {
                      return category2 === rangeCategory;
                    });
                  });
                  this.notify(state, "selectionRange");
                },
                zoom: function zoom(_ref12, rangeCategories) {
                  var state = _ref12.state;
                  var rawCategories = state.rawCategories;
                  state.zoomRange = rangeCategories.map(function(rangeCategory) {
                    return rawCategories.findIndex(function(category2) {
                      return category2 === rangeCategory;
                    });
                  });
                  this.notify(state, "zoomRange");
                },
                resetZoom: function resetZoom(_ref13) {
                  var state = _ref13.state, initStoreState = _ref13.initStoreState;
                  var series = initStoreState.series, options2 = initStoreState.options;
                  var rawCategories = state.rawCategories;
                  state.zoomRange = initZoomRange(series, options2, rawCategories);
                  this.notify(state, "zoomRange");
                },
                addData: function addData(_ref14, _ref15) {
                  var state = _ref14.state, initStoreState = _ref14.initStoreState;
                  var data = _ref15.data, category2 = _ref15.category, chartType = _ref15.chartType;
                  var series = initStoreState.series;
                  var coordinateChart = isCoordinateTypeSeries(state.series, chartType);
                  var categories = initStoreState.categories;
                  categories = series.heatmap ? categories.x : categories;
                  if (category2 && Array.isArray(categories)) {
                    var isExist2 = categories.some(function(c) {
                      return c === category2;
                    });
                    if (!isExist2) {
                      categories.push(category2);
                      if (Array.isArray(state.shiftRange)) {
                        var _state$shiftRange = seriesData_slicedToArray(state.shiftRange, 2), start = _state$shiftRange[0], end = _state$shiftRange[1];
                        state.shiftRange = [start + 1, end + 1];
                      }
                    }
                  }
                  if (chartType) {
                    series[chartType].forEach(function(datum, idx) {
                      datum.data.push(data[idx]);
                    });
                  } else {
                    var _Object$keys = Object.keys(initStoreState.series), _Object$keys2 = seriesData_slicedToArray(_Object$keys, 1), seriesName = _Object$keys2[0];
                    series[seriesName].forEach(function(datum, idx) {
                      datum.data.push(data[idx]);
                    });
                  }
                  this.notify(state, "series");
                  this.notify(state, "rawCategories");
                  if (Array.isArray(state.zoomRange)) {
                    this.dispatch("resetZoom");
                  }
                  if (coordinateChart) {
                    this.dispatch("initCategory");
                  }
                },
                addSeries: function addSeries(_ref16, _ref17) {
                  var state = _ref16.state, initStoreState = _ref16.initStoreState;
                  var data = _ref17.data, chartType = _ref17.chartType, category2 = _ref17.category;
                  var series = initStoreState.series, categories = initStoreState.categories;
                  var coordinateChart = isCoordinateTypeSeries(state.series, chartType);
                  var seriesName = chartType || Object.keys(series)[0];
                  var isExist2 = isSeriesAlreadyExist(series, seriesName, data);
                  if (!isExist2) {
                    series[seriesName].push(data);
                    if (Array.isArray(categories) && category2) {
                      categories.push(category2);
                    }
                  }
                  this.dispatch("initThemeState");
                  this.dispatch("initLegendState");
                  this.notify(state, "series");
                  if (coordinateChart || seriesName === "bullet") {
                    this.dispatch("initCategory");
                  }
                },
                addHeatmapSeries: function addHeatmapSeries(_ref18, _ref19) {
                  var state = _ref18.state, initStoreState = _ref18.initStoreState;
                  var data = _ref19.data, category2 = _ref19.category;
                  var series = initStoreState.series, categories = initStoreState.categories;
                  var isExist2 = isHeatmapSeriesAlreadyExist(categories, category2);
                  if (!isExist2) {
                    series.heatmap.push({
                      data,
                      yCategory: category2
                    });
                  }
                  if (!isExist2 && category2) {
                    categories.y.push(category2);
                    this.notify(state, "rawCategories");
                  }
                  this.notify(state, "series");
                  this.dispatch("initThemeState");
                  this.dispatch("initLegendState");
                },
                addTreemapSeries: function addTreemapSeries(_ref20, _ref21) {
                  var state = _ref20.state, initStoreState = _ref20.initStoreState;
                  var data = _ref21.data;
                  var series = initStoreState.series;
                  var isExist2 = isTreemapSeriesAlreadyExist(series, data);
                  if (!isExist2) {
                    series.treemap.push(data);
                  }
                  this.notify(state, "series");
                  this.notify(state, "treemapSeries");
                  this.dispatch("initThemeState");
                  this.dispatch("initLegendState");
                },
                setData: function setData(_ref22, _ref23) {
                  var state = _ref22.state, initStoreState = _ref22.initStoreState;
                  var series = _ref23.series, categories = _ref23.categories;
                  initStoreState.series = series;
                  var isNestedPieChart = hasNestedPieSeries(series);
                  if (!isNestedPieChart) {
                    state.rawCategories = makeRawCategories(series, categories);
                  }
                  this.dispatch("initThemeState");
                  this.dispatch("initLegendState");
                },
                addOutlier: function addOutlier(_ref24, _ref25) {
                  var _seriesRawData$outlie;
                  var state = _ref24.state, initStoreState = _ref24.initStoreState;
                  var seriesIndex = _ref25.seriesIndex, outliers = _ref25.outliers;
                  var series = initStoreState.series;
                  var seriesRawData = series.boxPlot[seriesIndex];
                  if (!seriesRawData) {
                    throw new Error(message.SERIES_INDEX_ERROR);
                  }
                  seriesRawData.outliers = [].concat(seriesData_toConsumableArray((_seriesRawData$outlie = seriesRawData.outliers) !== null && _seriesRawData$outlie !== void 0 ? _seriesRawData$outlie : []), seriesData_toConsumableArray(outliers));
                  this.notify(state, "series");
                }
              },
              observe: {
                updateSeriesData: function updateSeriesData() {
                  this.dispatch("setSeriesData");
                }
              },
              computed: {
                isLineTypeSeriesZooming: function isLineTypeSeriesZooming(_ref26) {
                  var zoomRange = _ref26.zoomRange, rawCategories = _ref26.rawCategories;
                  return isZooming(rawCategories, zoomRange);
                },
                viewRange: function viewRange(_ref27) {
                  var zoomRange = _ref27.zoomRange, shiftRange = _ref27.shiftRange;
                  return zoomRange || shiftRange;
                }
              }
            };
            var store_seriesData = seriesData;
            var es_array_flat_map = __webpack_require__(4870);
            var es_array_unscopables_flat_map = __webpack_require__(3985);
            var es_object_values = __webpack_require__(7890);
            ;
            function polygon(ctx2, polygonModel) {
              var strokeStyle = polygonModel.color, points = polygonModel.points, lineWidth = polygonModel.lineWidth, fillColor = polygonModel.fillColor, _polygonModel$dashSeg = polygonModel.dashSegments, dashSegments = _polygonModel$dashSeg === void 0 ? [] : _polygonModel$dashSeg;
              if (!points.length) {
                return;
              }
              ctx2.beginPath();
              if (dashSegments) {
                setLineDash(ctx2, dashSegments);
              }
              points.forEach(function(_ref, idx) {
                var x = _ref.x, y = _ref.y;
                if (idx === 0) {
                  ctx2.moveTo(x, y);
                  return;
                }
                ctx2.lineTo(x, y);
              });
              ctx2.lineTo(points[0].x, points[0].y);
              if (fillColor) {
                fillStyle(ctx2, fillColor);
              }
              strokeWithOptions(ctx2, {
                lineWidth,
                strokeStyle
              });
              ctx2.closePath();
            }
            ;
            function scatterSeries_ownKeys(object, enumerableOnly) {
              var keys = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object);
                if (enumerableOnly) {
                  symbols = symbols.filter(function(sym) {
                    return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                  });
                }
                keys.push.apply(keys, symbols);
              }
              return keys;
            }
            function scatterSeries_objectSpread(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i] != null ? arguments[i] : {};
                if (i % 2) {
                  scatterSeries_ownKeys(Object(source), true).forEach(function(key) {
                    scatterSeries_defineProperty(target, key, source[key]);
                  });
                } else if (Object.getOwnPropertyDescriptors) {
                  Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                } else {
                  scatterSeries_ownKeys(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  });
                }
              }
              return target;
            }
            function scatterSeries_defineProperty(obj, key, value) {
              if (key in obj) {
                Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
              } else {
                obj[key] = value;
              }
              return obj;
            }
            function regularPolygon(ctx2, model) {
              var numberOfSides = model.numberOfSides, size = model.size, x = model.x, y = model.y, borderColor = model.borderColor, borderWidth = model.borderWidth, fillColor = model.fillColor;
              var s = size / 2;
              var shift = numberOfSides % 2 ? Math.PI / 180 * (10 + (numberOfSides - 3) / 2) * numberOfSides : 0;
              var step = 2 * Math.PI / numberOfSides;
              ctx2.beginPath();
              for (var i = 0; i <= numberOfSides; i += 1) {
                var curStep = i * step + shift;
                ctx2.lineTo(x + s * Math.cos(curStep), y + s * Math.sin(curStep));
              }
              ctx2.strokeStyle = borderColor;
              ctx2.lineWidth = borderWidth;
              fillStyle(ctx2, fillColor);
              ctx2.stroke();
              ctx2.closePath();
            }
            function star(ctx2, model) {
              var x = model.x, y = model.y, borderColor = model.borderColor, borderWidth = model.borderWidth, size = model.size, fillColor = model.fillColor;
              ctx2.lineWidth = borderWidth;
              ctx2.strokeStyle = borderColor;
              ctx2.fillStyle = fillColor;
              ctx2.save();
              ctx2.beginPath();
              ctx2.translate(x, y);
              ctx2.moveTo(0, -size);
              for (var i = 0; i < 5; i += 1) {
                ctx2.rotate(Math.PI / 5);
                ctx2.lineTo(0, -size / 2);
                ctx2.rotate(Math.PI / 5);
                ctx2.lineTo(0, -size);
              }
              ctx2.fill();
              ctx2.stroke();
              ctx2.restore();
              ctx2.closePath();
            }
            function cross(ctx2, model) {
              var x = model.x, y = model.y, borderColor = model.borderColor, borderWidth = model.borderWidth, size = model.size, fillColor = model.fillColor;
              var quarter = size / 4;
              var half = size / 2;
              var xPointsOffset = [-half, -half, -quarter, -quarter, quarter, quarter, half, half, quarter, quarter, -quarter, -quarter];
              var yPointsOffset = [];
              for (var idx = 0, len = xPointsOffset.length; idx < len; idx += 1) {
                var startIdx = 9;
                yPointsOffset.push(xPointsOffset[(startIdx + idx) % len]);
              }
              polygon(ctx2, {
                type: "polygon",
                lineWidth: borderWidth,
                color: borderColor,
                points: xPointsOffset.map(function(val, idx2) {
                  return {
                    x: x + val,
                    y: y + yPointsOffset[idx2]
                  };
                }),
                fillColor
              });
            }
            function getNumberOfSidesByIconType(iconType) {
              switch (iconType) {
                case "triangle":
                  return 3;
                case "diamond":
                  return 4;
                case "pentagon":
                  return 5;
                case "hexagon":
                  return 6;
              }
            }
            function scatterSeries(ctx2, model) {
              var x = model.x, y = model.y, borderColor = model.borderColor, borderWidth = model.borderWidth, fillColor = model.fillColor, iconType = model.iconType, size = model.size;
              var commonModel = {
                x,
                y,
                fillColor,
                borderColor,
                borderWidth,
                size
              };
              ctx2.beginPath();
              switch (iconType) {
                case "rect":
                  pathRect(ctx2, {
                    type: "pathRect",
                    x: x - size / 2,
                    y: y - size / 2,
                    width: size,
                    height: size,
                    stroke: borderColor,
                    lineWidth: borderWidth,
                    fill: fillColor
                  });
                  break;
                case "triangle":
                case "pentagon":
                case "diamond":
                case "hexagon":
                  regularPolygon(ctx2, scatterSeries_objectSpread({
                    type: "regularPolygon",
                    numberOfSides: getNumberOfSidesByIconType(iconType)
                  }, commonModel));
                  break;
                case "star":
                  star(ctx2, scatterSeries_objectSpread(scatterSeries_objectSpread({
                    type: "star"
                  }, commonModel), {}, {
                    size: size / 2
                  }));
                  break;
                case "cross":
                  cross(ctx2, scatterSeries_objectSpread({
                    type: "cross"
                  }, commonModel));
                  break;
                default:
                  circle(ctx2, {
                    type: "circle",
                    x,
                    y,
                    radius: size / 2,
                    style: [{
                      strokeStyle: borderColor,
                      lineWidth: borderWidth
                    }],
                    color: fillColor
                  });
              }
              ctx2.stroke();
              ctx2.closePath();
            }
            ;
            var LEGEND_ITEM_MARGIN_X = 40;
            var LEGEND_MARGIN_X = 5;
            var LEGEND_CHECKBOX_SIZE = 12;
            var LEGEND_ICON_SIZE = 12;
            var ICON_BORDER_WIDTH = 1.5;
            var INACTIVE_OPACITY = 0.3;
            var RECT_SIZE = 10;
            var LINE_ICON_PADDING = 2;
            var CIRCLE_ICON_RADIUS = 6;
            function getLegendItemHeight(fontSize) {
              return fontSize + padding.Y;
            }
            function drawLineIcon(ctx2, x, y, color) {
              var xCurveOffset = [2, 2, 6, 6, 10, 10];
              var yCurveOffset = [8, 0, 0, 8, 8, 0];
              xCurveOffset.forEach(function(xOffset, idx) {
                if (idx === 5) {
                  return;
                }
                line(ctx2, {
                  type: "line",
                  x: x + xOffset,
                  y: y + yCurveOffset[idx],
                  x2: x + xCurveOffset[idx + 1],
                  y2: y + yCurveOffset[idx + 1],
                  lineWidth: 2,
                  strokeStyle: color
                });
              });
            }
            function drawCheckIcon(ctx2, x, y, active) {
              var color = "#555555";
              var strokeStyle = active ? color : getRGBA(color, INACTIVE_OPACITY);
              line(ctx2, {
                type: "line",
                x: x + 2,
                y: y + 5,
                x2: x + 5,
                y2: y + 8,
                strokeStyle,
                lineWidth: 2
              });
              line(ctx2, {
                type: "line",
                x: x + 5,
                y: y + 9,
                x2: x + 10,
                y2: y + 3,
                strokeStyle,
                lineWidth: 2
              });
            }
            function drawCheckbox(ctx2, x, y, renderOptions) {
              var active = renderOptions.active, checked = renderOptions.checked;
              var borderColor = active ? "#bbb" : getRGBA("#bbbbbb", INACTIVE_OPACITY);
              rect(ctx2, {
                type: "rect",
                x,
                y,
                width: LEGEND_CHECKBOX_SIZE,
                height: LEGEND_CHECKBOX_SIZE,
                color: "#fff",
                borderColor,
                thickness: 1
              });
              if (checked) {
                drawCheckIcon(ctx2, x, y, active);
              }
            }
            function drawIcon(ctx2, x, y, renderOptions) {
              var iconType = renderOptions.iconType, active = renderOptions.active, color = renderOptions.color, showCheckbox2 = renderOptions.showCheckbox;
              var iconX = x + (showCheckbox2 ? LEGEND_CHECKBOX_SIZE + LEGEND_MARGIN_X : 0);
              var iconColor = active ? color : getRGBA(color, INACTIVE_OPACITY);
              if (iconType === "rect") {
                rect(ctx2, {
                  type: "rect",
                  x: iconX,
                  y: y + (LEGEND_CHECKBOX_SIZE - RECT_SIZE) / 2,
                  width: RECT_SIZE,
                  height: RECT_SIZE,
                  color: iconColor
                });
              } else if (iconType === "line") {
                drawLineIcon(ctx2, iconX, y + LINE_ICON_PADDING, iconColor);
              } else if (iconType === "circle") {
                circle(ctx2, {
                  type: "circle",
                  x: iconX + CIRCLE_ICON_RADIUS,
                  y: y + CIRCLE_ICON_RADIUS,
                  radius: CIRCLE_ICON_RADIUS,
                  color: iconColor,
                  style: ["default"]
                });
              }
            }
            function drawScatterIcon(ctx2, x, y, renderOptions) {
              var iconType = renderOptions.iconType, active = renderOptions.active, color = renderOptions.color, showCheckbox2 = renderOptions.showCheckbox;
              var iconX = x + (showCheckbox2 ? LEGEND_CHECKBOX_SIZE + LEGEND_MARGIN_X : 0);
              var iconColor = active ? color : getRGBA(color, INACTIVE_OPACITY);
              scatterSeries(ctx2, {
                type: "scatterSeries",
                iconType,
                x: iconX + CIRCLE_ICON_RADIUS,
                y: y + CIRCLE_ICON_RADIUS,
                borderColor: iconColor,
                size: CIRCLE_ICON_RADIUS * 2,
                fillColor: "rgba(255, 255, 255, 0)",
                borderWidth: ICON_BORDER_WIDTH
              });
            }
            function drawLabel(ctx2, x, y, text, renderOptions) {
              var active = renderOptions.active, showCheckbox2 = renderOptions.showCheckbox, font = renderOptions.font, fontColor = renderOptions.fontColor;
              var fillStyle2 = active ? fontColor : getRGBA(fontColor, INACTIVE_OPACITY);
              label(ctx2, {
                type: "label",
                x: x + LEGEND_ICON_SIZE + LEGEND_MARGIN_X + (showCheckbox2 ? LEGEND_CHECKBOX_SIZE + LEGEND_MARGIN_X : 0),
                y,
                text,
                style: ["default", {
                  font,
                  textBaseline: "top",
                  fillStyle: fillStyle2
                }]
              });
            }
            function legend(ctx2, model) {
              var data = model.data, showCheckbox2 = model.showCheckbox, align = model.align, fontSize = model.fontSize, fontFamily = model.fontFamily, fontWeight = model.fontWeight;
              var font = getTitleFontString({
                fontSize,
                fontFamily,
                fontWeight
              });
              var fontColor = model.color;
              data.forEach(function(datum) {
                var x = datum.x, y = datum.y, checked = datum.checked, active = datum.active, color = datum.color, iconType = datum.iconType, useScatterChartIcon = datum.useScatterChartIcon, legendLabel = datum.viewLabel;
                var iconY = y - 1 + (getTextHeight(legendLabel, font) - 11) / 4;
                var renderOptions = {
                  iconType,
                  checked,
                  active,
                  color,
                  showCheckbox: showCheckbox2,
                  align,
                  font,
                  fontColor
                };
                if (showCheckbox2) {
                  drawCheckbox(ctx2, x, iconY, renderOptions);
                }
                if (useScatterChartIcon && iconType !== "line") {
                  drawScatterIcon(ctx2, x, iconY, renderOptions);
                } else {
                  drawIcon(ctx2, x, iconY, renderOptions);
                }
                drawLabel(ctx2, x, y, legendLabel, renderOptions);
              });
            }
            ;
            function theme_ownKeys(object, enumerableOnly) {
              var keys = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object);
                if (enumerableOnly) {
                  symbols = symbols.filter(function(sym) {
                    return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                  });
                }
                keys.push.apply(keys, symbols);
              }
              return keys;
            }
            function theme_objectSpread(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i] != null ? arguments[i] : {};
                if (i % 2) {
                  theme_ownKeys(Object(source), true).forEach(function(key) {
                    theme_defineProperty(target, key, source[key]);
                  });
                } else if (Object.getOwnPropertyDescriptors) {
                  Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                } else {
                  theme_ownKeys(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  });
                }
              }
              return target;
            }
            function theme_defineProperty(obj, key, value) {
              if (key in obj) {
                Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
              } else {
                obj[key] = value;
              }
              return obj;
            }
            var DEFAULT_LINE_SERIES_WIDTH = 2;
            var DEFAULT_LINE_SERIES_DOT_RADIUS = 3;
            var DEFAULT_AREA_OPACITY = 0.3;
            var DEFAULT_AREA_SELECTED_SERIES_OPACITY = DEFAULT_AREA_OPACITY;
            var DEFAULT_AREA_UNSELECTED_SERIES_OPACITY = 0.06;
            var radarDefault = {
              LINE_WIDTH: 2,
              DOT_RADIUS: 3,
              HOVER_DOT_RADIUS: 4,
              SELECTED_SERIES_OPACITY: 0.3,
              UNSELECTED_SERIES_OPACITY: 0.05
            };
            var boxDefault = {
              HOVER_THICKNESS: 4,
              BOX_HOVER: {
                shadowColor: "rgba(0, 0, 0, 0.3)",
                shadowOffsetX: 2,
                shadowOffsetY: 2,
                shadowBlur: 6
              }
            };
            var boxplotDefault = {
              OUTLIER_RADIUS: 4,
              OUTLIER_BORDER_WIDTH: 2,
              LINE_TYPE: {
                whisker: {
                  lineWidth: 1
                },
                maximum: {
                  lineWidth: 1
                },
                minimum: {
                  lineWidth: 1
                },
                median: {
                  lineWidth: 1,
                  color: "#ffffff"
                }
              }
            };
            var DEFAULT_BULLET_RANGE_OPACITY = [0.5, 0.3, 0.1];
            var DEFAULT_PIE_LINE_WIDTH = 3;
            function makeDefaultDataLabelsTheme() {
              var globalFontFamily = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "Arial";
              return {
                fontFamily: globalFontFamily,
                fontSize: 11,
                fontWeight: 400,
                color: "#333333",
                useSeriesColor: false
              };
            }
            var DEFAULT_BUBBLE_ARROW = {
              width: 8,
              height: 6
            };
            var defaultSeriesTheme = {
              colors: ["#00a9ff", "#ffb840", "#ff5a46", "#00bd9f", "#785fff", "#f28b8c", "#989486", "#516f7d", "#28e6eb", "#28695f", "#96c85a", "#45ba3f", "#295ba0", "#2a4175", "#289399", "#66c8d3", "#617178", "#8a9a9a", "#bebebe", "#374b5a", "#64eba0", "#ffe155", "#ff9141", "#af4beb", "#ff73fa", "#ff55b2", "#2869f5", "#3296ff", "#8cc3ff", "#2828b9", "#fa8787", "#e13782", "#7d5aaa", "#643c91", "#d25f5f", "#fabe6e", "#c3a9eb", "#b9c8f5", "#73a0cd", "#0f5a8c"],
              startColor: "#ffe98a",
              endColor: "#d74177",
              lineWidth: DEFAULT_LINE_SERIES_WIDTH,
              dashSegments: [],
              borderWidth: 0,
              borderColor: "#ffffff",
              select: {
                dot: {
                  radius: DEFAULT_LINE_SERIES_DOT_RADIUS,
                  borderWidth: DEFAULT_LINE_SERIES_DOT_RADIUS + 2
                },
                areaOpacity: DEFAULT_AREA_SELECTED_SERIES_OPACITY,
                restSeries: {
                  areaOpacity: DEFAULT_AREA_UNSELECTED_SERIES_OPACITY
                }
              },
              hover: {
                dot: {
                  radius: DEFAULT_LINE_SERIES_DOT_RADIUS,
                  borderWidth: DEFAULT_LINE_SERIES_DOT_RADIUS + 2
                }
              },
              dot: {
                radius: DEFAULT_LINE_SERIES_DOT_RADIUS
              },
              areaOpacity: DEFAULT_AREA_OPACITY
            };
            function makeAxisTitleTheme() {
              var globalFontFamily = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "Arial";
              return {
                fontSize: 11,
                fontFamily: globalFontFamily,
                fontWeight: 700,
                color: "#bbbbbb"
              };
            }
            function makeCommonTextTheme() {
              var globalFontFamily = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "Arial";
              return {
                fontSize: 11,
                fontFamily: globalFontFamily,
                fontWeight: "normal",
                color: "#333333"
              };
            }
            function makeDefaultTheme(series) {
              var globalFontFamily = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "Arial";
              var axisTitleTheme = makeAxisTitleTheme(globalFontFamily);
              var commonTextTheme = makeCommonTextTheme(globalFontFamily);
              var hasRadarSeries = !!(series !== null && series !== void 0 && series.radar);
              var hasGaugeSeries = !!(series !== null && series !== void 0 && series.gauge);
              return {
                chart: {
                  fontFamily: globalFontFamily,
                  backgroundColor: "#ffffff"
                },
                noData: {
                  fontSize: 18,
                  fontFamily: globalFontFamily,
                  fontWeight: "normal",
                  color: "#333333"
                },
                title: {
                  fontSize: 18,
                  fontFamily: globalFontFamily,
                  fontWeight: 100,
                  color: "#333333"
                },
                yAxis: {
                  title: theme_objectSpread({}, axisTitleTheme),
                  label: theme_objectSpread({}, commonTextTheme),
                  width: 1,
                  color: "#333333"
                },
                xAxis: {
                  title: theme_objectSpread({}, axisTitleTheme),
                  label: theme_objectSpread({}, commonTextTheme),
                  width: 1,
                  color: "#333333"
                },
                verticalAxis: {
                  label: theme_objectSpread(theme_objectSpread({}, commonTextTheme), {}, {
                    textBubble: {
                      visible: hasRadarSeries,
                      backgroundColor: hasRadarSeries ? "#f3f3f3" : "rgba(0, 0, 0, 0)",
                      borderRadius: 7,
                      paddingX: 7,
                      paddingY: 2,
                      borderColor: "rgba(0, 0, 0, 0)",
                      borderWidth: 1
                    }
                  })
                },
                circularAxis: {
                  title: theme_objectSpread({}, axisTitleTheme),
                  label: theme_objectSpread({}, commonTextTheme),
                  lineWidth: 1,
                  strokeStyle: hasGaugeSeries ? "rgba(0, 0, 0, 0.5)" : "rgba(0, 0, 0, 0.05)",
                  dotColor: "rgba(0, 0, 0, 0.5)",
                  tick: {
                    lineWidth: 1,
                    strokeStyle: "rgba(0, 0, 0, 0.5)"
                  }
                },
                legend: {
                  label: {
                    color: "#333333",
                    fontSize: 11,
                    fontWeight: "normal",
                    fontFamily: globalFontFamily
                  }
                },
                tooltip: {
                  background: "rgba(85, 85, 85, 0.95)",
                  borderColor: "rgba(255, 255, 255, 0)",
                  borderWidth: 0,
                  borderRadius: 3,
                  borderStyle: "solid",
                  body: {
                    fontSize: 12,
                    fontFamily: "".concat(globalFontFamily, ", sans-serif"),
                    fontWeight: "normal",
                    color: "#ffffff"
                  },
                  header: {
                    fontSize: 13,
                    fontFamily: "".concat(globalFontFamily, ", sans-serif"),
                    fontWeight: "bold",
                    color: "#ffffff"
                  }
                },
                plot: {
                  lineColor: "rgba(0, 0, 0, 0.05)",
                  backgroundColor: "rgba(255, 255, 255, 0)"
                },
                exportMenu: {
                  button: theme_objectSpread(theme_objectSpread({}, makeBorderTheme(5, "#f4f4f4")), {}, {
                    backgroundColor: "#f4f4f4",
                    xIcon: {
                      color: "#555555",
                      lineWidth: 2
                    },
                    dotIcon: {
                      color: "#555555",
                      width: 2,
                      height: 2,
                      gap: 2
                    }
                  }),
                  panel: theme_objectSpread(theme_objectSpread({}, makeBorderTheme(0, "#bab9ba")), {}, {
                    header: theme_objectSpread(theme_objectSpread({}, commonTextTheme), {}, {
                      backgroundColor: "#f4f4f4"
                    }),
                    body: theme_objectSpread(theme_objectSpread({}, commonTextTheme), {}, {
                      backgroundColor: "#ffffff"
                    })
                  })
                }
              };
            }
            function makeBorderTheme(borderRadius, borderColor) {
              var borderWidth = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
              return {
                borderWidth,
                borderRadius,
                borderColor
              };
            }
            function makeDefaultTextBubbleTheme() {
              var visible = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
              var borderRadius = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 7;
              var paddingX = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 5;
              var paddingY = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;
              var backgroundColor = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : "#ffffff";
              return {
                visible,
                paddingX,
                paddingY,
                borderRadius,
                backgroundColor,
                shadowColor: "rgba(0, 0, 0, 0.3)",
                shadowOffsetY: 2,
                shadowBlur: 4
              };
            }
            function getLineTypeSeriesTheme(globalFontFamily) {
              var defaultDataLabelTheme = makeDefaultDataLabelsTheme(globalFontFamily);
              return {
                lineWidth: defaultSeriesTheme.lineWidth,
                dashSegments: defaultSeriesTheme.dashSegments,
                select: {
                  dot: defaultSeriesTheme.select.dot
                },
                hover: {
                  dot: defaultSeriesTheme.hover.dot
                },
                dot: defaultSeriesTheme.dot,
                dataLabels: theme_objectSpread(theme_objectSpread({}, defaultDataLabelTheme), {}, {
                  textBubble: theme_objectSpread(theme_objectSpread({}, makeDefaultTextBubbleTheme()), {}, {
                    arrow: theme_objectSpread({
                      visible: false,
                      direction: "bottom"
                    }, DEFAULT_BUBBLE_ARROW)
                  })
                })
              };
            }
            function getTreemapHeatmapSeriesTheme(globalFontFamily) {
              var defaultDataLabelTheme = makeDefaultDataLabelsTheme(globalFontFamily);
              return {
                startColor: defaultSeriesTheme.startColor,
                endColor: defaultSeriesTheme.endColor,
                borderWidth: 0,
                borderColor: "#ffffff",
                hover: {
                  borderWidth: boxDefault.HOVER_THICKNESS,
                  borderColor: "#ffffff"
                },
                select: {
                  borderWidth: boxDefault.HOVER_THICKNESS,
                  borderColor: "#ffffff"
                },
                dataLabels: theme_objectSpread(theme_objectSpread({}, defaultDataLabelTheme), {}, {
                  color: "#ffffff",
                  textBubble: theme_objectSpread({}, makeDefaultTextBubbleTheme(false, 1, 5, 1, "rgba(255, 255, 255, 0.5)"))
                })
              };
            }
            function getBarColumnSeriesTheme(globalFontFamily) {
              var defaultDataLabelTheme = makeDefaultDataLabelsTheme(globalFontFamily);
              return {
                areaOpacity: 1,
                hover: theme_objectSpread(theme_objectSpread({}, boxDefault.BOX_HOVER), {}, {
                  borderWidth: boxDefault.HOVER_THICKNESS,
                  borderColor: "#ffffff",
                  groupedRect: {
                    color: "#000000",
                    opacity: 0.05
                  }
                }),
                select: theme_objectSpread(theme_objectSpread({}, boxDefault.BOX_HOVER), {}, {
                  borderWidth: boxDefault.HOVER_THICKNESS,
                  borderColor: "#ffffff",
                  groupedRect: {
                    color: "#000000",
                    opacity: 0.2
                  },
                  restSeries: {
                    areaOpacity: 0.2
                  },
                  areaOpacity: 1
                }),
                connector: {
                  color: "rgba(51, 85, 139, 0.3)",
                  lineWidth: 1,
                  dashSegments: []
                },
                dataLabels: theme_objectSpread(theme_objectSpread({}, defaultDataLabelTheme), {}, {
                  textBubble: theme_objectSpread(theme_objectSpread({}, makeDefaultTextBubbleTheme(false, 1, 4, 3)), {}, {
                    arrow: theme_objectSpread({
                      visible: false
                    }, DEFAULT_BUBBLE_ARROW)
                  }),
                  stackTotal: theme_objectSpread(theme_objectSpread({}, defaultDataLabelTheme), {}, {
                    textBubble: theme_objectSpread(theme_objectSpread({}, makeDefaultTextBubbleTheme(true, 1, 4, 3)), {}, {
                      arrow: theme_objectSpread({
                        visible: true
                      }, DEFAULT_BUBBLE_ARROW)
                    })
                  })
                })
              };
            }
            var transparentColor = "rgba(255, 255, 255, 0)";
            var defaultThemeMakers = {
              line: function line2(globalFontFamily) {
                return theme_objectSpread({}, getLineTypeSeriesTheme(globalFontFamily));
              },
              area: function area(globalFontFamily) {
                var lineTypeSeriesTheme = getLineTypeSeriesTheme(globalFontFamily);
                return theme_objectSpread(theme_objectSpread({}, lineTypeSeriesTheme), {}, {
                  select: theme_objectSpread(theme_objectSpread({}, lineTypeSeriesTheme.select), {}, {
                    areaOpacity: DEFAULT_AREA_SELECTED_SERIES_OPACITY,
                    restSeries: defaultSeriesTheme.select.restSeries
                  }),
                  areaOpacity: DEFAULT_AREA_OPACITY
                });
              },
              treemap: function treemap(globalFontFamily) {
                return getTreemapHeatmapSeriesTheme(globalFontFamily);
              },
              heatmap: function heatmap(globalFontFamily) {
                return getTreemapHeatmapSeriesTheme(globalFontFamily);
              },
              scatter: function scatter() {
                return {
                  size: 12,
                  borderWidth: 1.5,
                  fillColor: transparentColor,
                  select: {
                    fillColor: "rgba(255, 255, 255, 1)",
                    borderWidth: 2.5,
                    size: 12
                  },
                  hover: {
                    fillColor: "rgba(255, 255, 255, 1)",
                    borderWidth: 2.5,
                    size: 12
                  }
                };
              },
              bubble: function bubble() {
                return {
                  borderWidth: 0,
                  borderColor: transparentColor,
                  select: {},
                  hover: {
                    shadowColor: "rgba(0, 0, 0, 0.3)",
                    shadowBlur: 2,
                    shadowOffsetY: 2,
                    lineWidth: 2
                  }
                };
              },
              radar: function radar() {
                return {
                  areaOpacity: radarDefault.SELECTED_SERIES_OPACITY,
                  hover: {
                    dot: {
                      radius: radarDefault.HOVER_DOT_RADIUS,
                      borderWidth: radarDefault.HOVER_DOT_RADIUS + 1
                    }
                  },
                  select: {
                    dot: {
                      radius: radarDefault.HOVER_DOT_RADIUS,
                      borderWidth: radarDefault.HOVER_DOT_RADIUS + 1
                    },
                    restSeries: {
                      areaOpacity: radarDefault.UNSELECTED_SERIES_OPACITY
                    },
                    areaOpacity: radarDefault.SELECTED_SERIES_OPACITY
                  },
                  dot: {
                    radius: radarDefault.DOT_RADIUS
                  }
                };
              },
              bar: function bar(globalFontFamily) {
                return theme_objectSpread({}, getBarColumnSeriesTheme(globalFontFamily));
              },
              column: function column(globalFontFamily) {
                return theme_objectSpread({}, getBarColumnSeriesTheme(globalFontFamily));
              },
              bullet: function bullet(globalFontFamily) {
                var defaultDataLabelTheme = makeDefaultDataLabelsTheme(globalFontFamily);
                return {
                  areaOpacity: 1,
                  barWidthRatios: {
                    rangeRatio: 1,
                    bulletRatio: 0.5,
                    markerRatio: 0.8
                  },
                  markerLineWidth: 1,
                  borderWidth: 0,
                  borderColor: "rgba(255, 255, 255, 0)",
                  hover: theme_objectSpread(theme_objectSpread({}, boxDefault.BOX_HOVER), {}, {
                    borderWidth: boxDefault.HOVER_THICKNESS,
                    borderColor: "#ffffff",
                    groupedRect: {
                      color: "#000000",
                      opacity: 0.05
                    }
                  }),
                  select: theme_objectSpread(theme_objectSpread({}, boxDefault.BOX_HOVER), {}, {
                    borderWidth: boxDefault.HOVER_THICKNESS,
                    borderColor: "#ffffff",
                    groupedRect: {
                      color: "#000000",
                      opacity: 0.2
                    },
                    restSeries: {
                      areaOpacity: 0.2
                    },
                    areaOpacity: 1
                  }),
                  dataLabels: theme_objectSpread(theme_objectSpread({}, defaultDataLabelTheme), {}, {
                    textBubble: theme_objectSpread(theme_objectSpread({}, makeDefaultTextBubbleTheme()), {}, {
                      arrow: theme_objectSpread({
                        visible: false
                      }, DEFAULT_BUBBLE_ARROW)
                    }),
                    marker: theme_objectSpread(theme_objectSpread({}, defaultDataLabelTheme), {}, {
                      fontSize: 9,
                      useSeriesColor: true,
                      textBubble: theme_objectSpread(theme_objectSpread({}, makeDefaultTextBubbleTheme(true)), {}, {
                        backgroundColor: "rgba(255, 255, 255, 0.8)",
                        shadowColor: "rgba(0, 0, 0, 0.0)",
                        shadowOffsetX: 0,
                        shadowOffsetY: 0,
                        shadowBlur: 0,
                        arrow: theme_objectSpread({
                          visible: false
                        }, DEFAULT_BUBBLE_ARROW)
                      })
                    })
                  })
                };
              },
              boxPlot: function boxPlot2() {
                return {
                  areaOpacity: 1,
                  barWidthRatios: {
                    barRatio: 1,
                    minMaxBarRatio: 0.5
                  },
                  markerLineWidth: 1,
                  dot: {
                    color: "#ffffff",
                    radius: boxplotDefault.OUTLIER_RADIUS,
                    borderWidth: boxplotDefault.OUTLIER_BORDER_WIDTH,
                    useSeriesColor: false
                  },
                  rect: {
                    borderWidth: 0
                  },
                  line: theme_objectSpread({}, boxplotDefault.LINE_TYPE),
                  hover: theme_objectSpread(theme_objectSpread({}, boxDefault.BOX_HOVER), {}, {
                    rect: {
                      borderWidth: boxDefault.HOVER_THICKNESS,
                      borderColor: "#ffffff"
                    },
                    dot: {
                      radius: boxplotDefault.OUTLIER_RADIUS,
                      borderWidth: 0,
                      useSeriesColor: true
                    },
                    line: theme_objectSpread({}, boxplotDefault.LINE_TYPE)
                  }),
                  select: theme_objectSpread(theme_objectSpread({}, boxDefault.BOX_HOVER), {}, {
                    rect: {
                      borderWidth: boxDefault.HOVER_THICKNESS,
                      borderColor: "#ffffff"
                    },
                    dot: {
                      radius: boxplotDefault.OUTLIER_RADIUS,
                      borderWidth: 0,
                      useSeriesColor: true
                    },
                    line: theme_objectSpread({}, boxplotDefault.LINE_TYPE),
                    restSeries: {
                      areaOpacity: 0.2
                    },
                    areaOpacity: 1
                  })
                };
              },
              pie: function pie(globalFontFamily, _ref) {
                var _ref$hasOuterAnchor = _ref.hasOuterAnchor, hasOuterAnchor = _ref$hasOuterAnchor === void 0 ? false : _ref$hasOuterAnchor, _ref$hasOuterAnchorPi = _ref.hasOuterAnchorPieSeriesName, hasOuterAnchorPieSeriesName = _ref$hasOuterAnchorPi === void 0 ? false : _ref$hasOuterAnchorPi;
                var isNestedPieChart = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                var defaultDataLabelTheme = makeDefaultDataLabelsTheme(globalFontFamily);
                return {
                  areaOpacity: 1,
                  strokeStyle: isNestedPieChart ? "#ffffff" : "rgba(255, 255, 255, 0)",
                  lineWidth: isNestedPieChart ? 1 : 0,
                  hover: {
                    lineWidth: DEFAULT_PIE_LINE_WIDTH,
                    strokeStyle: "#ffffff",
                    shadowColor: "#cccccc",
                    shadowBlur: 5,
                    shadowOffsetX: 0,
                    shadowOffsetY: 0
                  },
                  select: {
                    lineWidth: DEFAULT_PIE_LINE_WIDTH,
                    strokeStyle: "#ffffff",
                    shadowColor: "#cccccc",
                    shadowBlur: 5,
                    shadowOffsetX: 0,
                    shadowOffsetY: 0,
                    restSeries: {
                      areaOpacity: 0.3
                    },
                    areaOpacity: 1
                  },
                  dataLabels: {
                    fontFamily: globalFontFamily,
                    fontSize: 16,
                    fontWeight: 600,
                    color: hasOuterAnchor ? "#333333" : "#ffffff",
                    useSeriesColor: hasOuterAnchor,
                    textBubble: theme_objectSpread({}, makeDefaultTextBubbleTheme(false, 0)),
                    callout: {
                      lineWidth: 1,
                      useSeriesColor: true,
                      lineColor: "#e9e9e9"
                    },
                    pieSeriesName: theme_objectSpread(theme_objectSpread({}, defaultDataLabelTheme), {}, {
                      useSeriesColor: hasOuterAnchorPieSeriesName,
                      color: hasOuterAnchorPieSeriesName ? "#333333" : "#ffffff",
                      textBubble: theme_objectSpread({}, makeDefaultTextBubbleTheme(false, 0))
                    })
                  }
                };
              },
              radialBar: function radialBar(globalFontFamily) {
                return {
                  areaOpacity: 1,
                  strokeStyle: "rgba(255, 255, 255, 0)",
                  lineWidth: 0,
                  hover: {
                    lineWidth: DEFAULT_PIE_LINE_WIDTH,
                    strokeStyle: "#fff",
                    shadowColor: "#cccccc",
                    shadowBlur: 5,
                    shadowOffsetX: 0,
                    shadowOffsetY: 0,
                    groupedSector: {
                      color: "#000000",
                      opacity: 0.05
                    }
                  },
                  select: {
                    lineWidth: DEFAULT_PIE_LINE_WIDTH,
                    strokeStyle: "#fff",
                    shadowColor: "#cccccc",
                    shadowBlur: 5,
                    shadowOffsetX: 0,
                    shadowOffsetY: 0,
                    restSeries: {
                      areaOpacity: 0.3
                    },
                    areaOpacity: 1,
                    groupedSector: {
                      color: "#000000",
                      opacity: 0.2
                    }
                  },
                  dataLabels: {
                    fontFamily: globalFontFamily,
                    fontSize: 11,
                    fontWeight: 400,
                    color: "#333333",
                    useSeriesColor: false,
                    textBubble: theme_objectSpread({}, makeDefaultTextBubbleTheme(false, 0))
                  }
                };
              },
              gauge: function gauge(globalFontFamily) {
                return {
                  areaOpacity: 1,
                  hover: {
                    clockHand: {
                      baseLine: 5
                    },
                    pin: {
                      radius: 5,
                      borderWidth: 5
                    },
                    solid: {
                      lineWidth: DEFAULT_PIE_LINE_WIDTH,
                      strokeStyle: "#ffffff",
                      shadowColor: "#cccccc",
                      shadowBlur: 5,
                      shadowOffsetX: 0,
                      shadowOffsetY: 0
                    }
                  },
                  select: {
                    clockHand: {
                      baseLine: 5
                    },
                    pin: {
                      radius: 6,
                      borderWidth: 4
                    },
                    solid: {
                      lineWidth: DEFAULT_PIE_LINE_WIDTH,
                      strokeStyle: "#ffffff",
                      shadowColor: "#cccccc",
                      shadowBlur: 5,
                      shadowOffsetX: 0,
                      shadowOffsetY: 0,
                      restSeries: {
                        areaOpacity: 0.3
                      },
                      areaOpacity: 1
                    },
                    areaOpacity: 1,
                    restSeries: {
                      areaOpacity: 0.3
                    }
                  },
                  clockHand: {
                    baseLine: 4
                  },
                  pin: {
                    radius: 5,
                    borderWidth: 5
                  },
                  solid: {
                    lineWidth: 0,
                    backgroundSolid: {
                      color: "rgba(0, 0, 0, 0.1)"
                    }
                  },
                  dataLabels: {
                    fontFamily: globalFontFamily,
                    fontSize: 11,
                    fontWeight: 400,
                    color: "#333333",
                    useSeriesColor: false,
                    textBubble: theme_objectSpread(theme_objectSpread({}, makeDefaultTextBubbleTheme(true, 4, 4, 3)), {}, {
                      shadowColor: "rgba(0, 0, 0, 0)",
                      shadowOffsetY: 0,
                      shadowBlur: 0,
                      borderColor: "#ccc",
                      borderWidth: 1
                    })
                  }
                };
              }
            };
            function getSeriesTheme(globalFontFamily, seriesName, paramForPieSeries) {
              var isNestedPieChart = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
              if (seriesName === "pie") {
                return defaultThemeMakers[seriesName](globalFontFamily, paramForPieSeries, isNestedPieChart);
              }
              if (includes(["bubble", "radar", "boxPlot"], seriesName)) {
                return defaultThemeMakers[seriesName]();
              }
              return defaultThemeMakers[seriesName](globalFontFamily);
            }
            function getDefaultTheme(series, pieSeriesOuterAnchors) {
              var globalFontFamily = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "Arial";
              var isNestedPieChart = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
              var result = Object.keys(series).reduce(function(acc, seriesName) {
                return theme_objectSpread(theme_objectSpread({}, acc), {}, {
                  series: theme_objectSpread(theme_objectSpread({}, acc.series), {}, theme_defineProperty({}, seriesName, getSeriesTheme(globalFontFamily, seriesName, pieSeriesOuterAnchors)))
                });
              }, makeDefaultTheme(series, globalFontFamily));
              if (isNestedPieChart) {
                var aliasNames = getNestedPieChartAliasNames(series);
                result.series.pie = aliasNames.reduce(function(acc, cur) {
                  return theme_objectSpread(theme_objectSpread({}, acc), {}, theme_defineProperty({}, cur, getSeriesTheme(globalFontFamily, "pie", pieSeriesOuterAnchors[cur], isNestedPieChart)));
                }, {});
              }
              return result;
            }
            ;
            function isAvailableShowTooltipInfo(info, eventDetectType, targetChartType) {
              var index = info.index, seriesIndex = info.seriesIndex, chartType = info.chartType;
              return isNumber(index) && (eventDetectType === "grouped" || isNumber(seriesIndex)) && (isUndefined(chartType) || chartType === targetChartType);
            }
            function isAvailableSelectSeries(info, targetChartType) {
              var index = info.index, seriesIndex = info.seriesIndex, chartType = info.chartType;
              return isNumber(index) && isNumber(seriesIndex) && (isUndefined(chartType) || chartType === targetChartType);
            }
            function isNoData(series) {
              return Object.keys(series).reduce(function(acc, chartType) {
                return !series[chartType].data.length && acc;
              }, true);
            }
            ;
            function legend_ownKeys(object, enumerableOnly) {
              var keys = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object);
                if (enumerableOnly) {
                  symbols = symbols.filter(function(sym) {
                    return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                  });
                }
                keys.push.apply(keys, symbols);
              }
              return keys;
            }
            function legend_objectSpread(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i] != null ? arguments[i] : {};
                if (i % 2) {
                  legend_ownKeys(Object(source), true).forEach(function(key) {
                    legend_defineProperty(target, key, source[key]);
                  });
                } else if (Object.getOwnPropertyDescriptors) {
                  Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                } else {
                  legend_ownKeys(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  });
                }
              }
              return target;
            }
            function legend_defineProperty(obj, key, value) {
              if (key in obj) {
                Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
              } else {
                obj[key] = value;
              }
              return obj;
            }
            function getActiveSeriesMap(legend2) {
              return legend2.data.reduce(function(acc, _ref) {
                var active = _ref.active, label2 = _ref.label;
                return legend_objectSpread(legend_objectSpread({}, acc), {}, legend_defineProperty({}, label2, active));
              }, {});
            }
            function showCircleLegend(options2) {
              var _options$circleLegend, _options$circleLegend2;
              return (_options$circleLegend = options2 === null || options2 === void 0 ? void 0 : (_options$circleLegend2 = options2.circleLegend) === null || _options$circleLegend2 === void 0 ? void 0 : _options$circleLegend2.visible) !== null && _options$circleLegend !== void 0 ? _options$circleLegend : true;
            }
            function showLegend(options2, series) {
              var _options$series, _options$legend, _options$legend2;
              if (series.gauge || series.treemap && !((_options$series = options2.series) !== null && _options$series !== void 0 && _options$series.useColorValue)) {
                return false;
              }
              return isUndefined((_options$legend = options2.legend) === null || _options$legend === void 0 ? void 0 : _options$legend.visible) ? true : !!((_options$legend2 = options2.legend) !== null && _options$legend2 !== void 0 && _options$legend2.visible);
            }
            function showCheckbox(options2) {
              var _options$legend3, _options$legend4;
              return isUndefined((_options$legend3 = options2.legend) === null || _options$legend3 === void 0 ? void 0 : _options$legend3.showCheckbox) ? true : !!((_options$legend4 = options2.legend) !== null && _options$legend4 !== void 0 && _options$legend4.showCheckbox);
            }
            function useRectIcon(type) {
              return includes(["bar", "column", "area", "pie", "boxPlot", "bullet", "radialBar"], type);
            }
            function useCircleIcon(type) {
              return includes(["bubble", "scatter"], type);
            }
            function useLineIcon(type) {
              return includes(["line", "radar"], type);
            }
            function getIconType(type) {
              var iconType = "spectrum";
              if (useCircleIcon(type)) {
                iconType = "circle";
              } else if (useRectIcon(type)) {
                iconType = "rect";
              } else if (useLineIcon(type)) {
                iconType = "line";
              }
              return iconType;
            }
            function getLegendAlign(options2) {
              var _options$legend$align, _options$legend5;
              return (_options$legend$align = (_options$legend5 = options2.legend) === null || _options$legend5 === void 0 ? void 0 : _options$legend5.align) !== null && _options$legend$align !== void 0 ? _options$legend$align : "right";
            }
            ;
            function legend_slicedToArray(arr, i) {
              return legend_arrayWithHoles(arr) || legend_iterableToArrayLimit(arr, i) || legend_unsupportedIterableToArray(arr, i) || legend_nonIterableRest();
            }
            function legend_nonIterableRest() {
              throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            function legend_iterableToArrayLimit(arr, i) {
              var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]);
              if (_i == null)
                return;
              var _arr = [];
              var _n = true;
              var _d = false;
              var _s, _e;
              try {
                for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
                  _arr.push(_s.value);
                  if (i && _arr.length === i)
                    break;
                }
              } catch (err) {
                _d = true;
                _e = err;
              } finally {
                try {
                  if (!_n && _i["return"] != null)
                    _i["return"]();
                } finally {
                  if (_d)
                    throw _e;
                }
              }
              return _arr;
            }
            function legend_arrayWithHoles(arr) {
              if (Array.isArray(arr))
                return arr;
            }
            function store_legend_ownKeys(object, enumerableOnly) {
              var keys = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object);
                if (enumerableOnly) {
                  symbols = symbols.filter(function(sym) {
                    return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                  });
                }
                keys.push.apply(keys, symbols);
              }
              return keys;
            }
            function store_legend_objectSpread(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i] != null ? arguments[i] : {};
                if (i % 2) {
                  store_legend_ownKeys(Object(source), true).forEach(function(key) {
                    store_legend_defineProperty(target, key, source[key]);
                  });
                } else if (Object.getOwnPropertyDescriptors) {
                  Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                } else {
                  store_legend_ownKeys(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  });
                }
              }
              return target;
            }
            function store_legend_defineProperty(obj, key, value) {
              if (key in obj) {
                Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
              } else {
                obj[key] = value;
              }
              return obj;
            }
            function legend_toConsumableArray(arr) {
              return legend_arrayWithoutHoles(arr) || legend_iterableToArray(arr) || legend_unsupportedIterableToArray(arr) || legend_nonIterableSpread();
            }
            function legend_nonIterableSpread() {
              throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            function legend_unsupportedIterableToArray(o, minLen) {
              if (!o)
                return;
              if (typeof o === "string")
                return legend_arrayLikeToArray(o, minLen);
              var n = Object.prototype.toString.call(o).slice(8, -1);
              if (n === "Object" && o.constructor)
                n = o.constructor.name;
              if (n === "Map" || n === "Set")
                return Array.from(o);
              if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                return legend_arrayLikeToArray(o, minLen);
            }
            function legend_iterableToArray(iter) {
              if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
                return Array.from(iter);
            }
            function legend_arrayWithoutHoles(arr) {
              if (Array.isArray(arr))
                return legend_arrayLikeToArray(arr);
            }
            function legend_arrayLikeToArray(arr, len) {
              if (len == null || len > arr.length)
                len = arr.length;
              for (var i = 0, arr2 = new Array(len); i < len; i++) {
                arr2[i] = arr[i];
              }
              return arr2;
            }
            var INITIAL_LEGEND_WIDTH = 100;
            var INITIAL_CIRCLE_LEGEND_WIDTH = 150;
            var COMPONENT_HEIGHT_EXCEPT_Y_AXIS = 100;
            var ELLIPSIS_DOT_TEXT = "...";
            var WIDEST_TEXT = "W";
            var NUMBER_OF_BOTH_SIDES = 2;
            function recalculateLegendWhenHeightOverflows(params, legendHeight) {
              var legendWidths = params.legendWidths, itemHeight = params.itemHeight;
              var totalHeight = legendWidths.length * itemHeight;
              var columnCount = Math.ceil(totalHeight / legendHeight);
              var rowCount = legendWidths.length / columnCount;
              var legendWidth = 0;
              range(0, columnCount).forEach(function(count) {
                legendWidth += Math.max.apply(Math, legend_toConsumableArray(legendWidths.slice(count * rowCount, (count + 1) * rowCount)));
              });
              legendWidth += LEGEND_ITEM_MARGIN_X * (columnCount - 1);
              return {
                legendWidth,
                legendHeight: rowCount * itemHeight + padding.Y,
                columnCount,
                rowCount
              };
            }
            function recalculateLegendWhenWidthOverflows(params, prevLegendWidth) {
              var legendWidths = params.legendWidths, itemHeight = params.itemHeight;
              var columnCount = 0;
              var legendWidth = 0;
              var _legendWidths$reduce = legendWidths.reduce(function(acc, width) {
                var widthWithMargin = LEGEND_ITEM_MARGIN_X + width;
                if (acc.totalWidth + width > prevLegendWidth) {
                  acc.totalWidth = widthWithMargin;
                  acc.rowCount += 1;
                  acc.columnCount = 1;
                  columnCount = Math.max(columnCount, acc.columnCount);
                } else {
                  acc.totalWidth += widthWithMargin;
                  acc.columnCount += 1;
                }
                legendWidth = Math.max(legendWidth, acc.totalWidth);
                return acc;
              }, {
                totalWidth: 0,
                rowCount: 1,
                columnCount: 0
              }), rowCount = _legendWidths$reduce.rowCount;
              return {
                legendHeight: itemHeight * rowCount,
                rowCount,
                columnCount,
                legendWidth
              };
            }
            function calculateLegendSize(params) {
              if (!params.visible) {
                return {
                  legendWidth: 0,
                  legendHeight: 0,
                  rowCount: 0,
                  columnCount: 0
                };
              }
              var chart = params.chart, verticalAlign = params.verticalAlign, legendWidths = params.legendWidths;
              var _calculateLegendWidth = calculateLegendWidth(params), legendWidth = _calculateLegendWidth.legendWidth, widthOverflow = _calculateLegendWidth.isOverflow;
              var _calculateLegendHeigh = calculateLegendHeight(params), legendHeight = _calculateLegendHeigh.legendHeight, heightOverflow = _calculateLegendHeigh.isOverflow;
              var columnCount = verticalAlign ? legendWidths.length : 1;
              var rowCount = verticalAlign ? Math.ceil(legendWidth / chart.width) : legendWidths.length;
              if (widthOverflow) {
                return recalculateLegendWhenWidthOverflows(params, legendWidth / rowCount);
              }
              if (heightOverflow) {
                return recalculateLegendWhenHeightOverflows(params, legendHeight);
              }
              return {
                legendWidth,
                legendHeight,
                columnCount,
                rowCount
              };
            }
            function calculateLegendHeight(params) {
              var verticalAlign = params.verticalAlign, itemHeight = params.itemHeight, legendWidths = params.legendWidths;
              var _getDefaultLegendSize = getDefaultLegendSize(params), chartHeight = _getDefaultLegendSize.height;
              var legendHeight;
              var isOverflow = false;
              if (verticalAlign) {
                legendHeight = chartHeight;
              } else {
                var totalHeight = legendWidths.length * itemHeight;
                isOverflow = chartHeight < totalHeight;
                legendHeight = isOverflow ? chartHeight : totalHeight;
              }
              return {
                legendHeight,
                isOverflow
              };
            }
            function getSpectrumLegendWidth(legendWidths, chartWidth, verticalAlign) {
              if (verticalAlign) {
                var labelAreaWidth = sum(legendWidths);
                return Math.max(chartWidth / 4, labelAreaWidth);
              }
              var spectrumAreaWidth = (spectrumLegendTooltip.PADDING + spectrumLegendBar.PADDING + padding.X) * NUMBER_OF_BOTH_SIDES + spectrumLegendTooltip.POINT_HEIGHT + spectrumLegendBar.HEIGHT;
              return Math.max.apply(Math, legend_toConsumableArray(legendWidths)) + spectrumAreaWidth;
            }
            function getSpectrumLegendHeight(itemHeight, chartHeight, verticalAlign) {
              return verticalAlign ? SPECTRUM_LEGEND_LABEL_HEIGHT + spectrumLegendBar.PADDING * NUMBER_OF_BOTH_SIDES + spectrumLegendTooltip.POINT_HEIGHT + spectrumLegendTooltip.HEIGHT + padding.Y : chartHeight * 3 / 4;
            }
            function getNormalLegendWidth(params) {
              var initialWidth = params.initialWidth, legendWidths = params.legendWidths, checkbox = params.checkbox, verticalAlign = params.verticalAlign;
              var isOverflow = false;
              var legendWidth;
              if (verticalAlign) {
                var _getDefaultLegendSize2 = getDefaultLegendSize(params), chartWidth = _getDefaultLegendSize2.width;
                var totalWidth = sum(legendWidths) + LEGEND_ITEM_MARGIN_X * (legendWidths.length - 1);
                isOverflow = totalWidth > chartWidth;
                legendWidth = totalWidth;
              } else {
                var labelAreaWidth = Math.max.apply(Math, legend_toConsumableArray(legendWidths));
                legendWidth = (checkbox ? LEGEND_CHECKBOX_SIZE + LEGEND_MARGIN_X : 0) + LEGEND_ICON_SIZE + LEGEND_MARGIN_X + Math.max(labelAreaWidth, initialWidth);
              }
              return {
                legendWidth,
                isOverflow
              };
            }
            function calculateLegendWidth(params) {
              var options2 = params.options, visible = params.visible;
              var legendOptions = options2 === null || options2 === void 0 ? void 0 : options2.legend;
              if (!visible) {
                return {
                  legendWidth: 0,
                  isOverflow: false
                };
              }
              if (legendOptions !== null && legendOptions !== void 0 && legendOptions.width) {
                return {
                  legendWidth: legendOptions.width,
                  isOverflow: false
                };
              }
              return getNormalLegendWidth(params);
            }
            function getDefaultLegendSize(params) {
              var verticalAlign = params.verticalAlign, chart = params.chart, itemHeight = params.itemHeight, initialWidth = params.initialWidth, circleLegendVisible = params.circleLegendVisible;
              var restAreaHeight = COMPONENT_HEIGHT_EXCEPT_Y_AXIS + (circleLegendVisible ? INITIAL_CIRCLE_LEGEND_WIDTH : 0);
              return verticalAlign ? {
                width: chart.width - padding.X * NUMBER_OF_BOTH_SIDES,
                height: itemHeight
              } : {
                width: initialWidth,
                height: chart.height - restAreaHeight
              };
            }
            function getNestedPieLegendLabelsInfo(series, legendInfo) {
              var result = [];
              var maxTextLengthWithEllipsis = getMaxTextLengthWithEllipsis(legendInfo);
              series.pie.forEach(function(_ref) {
                var data = _ref.data;
                data.forEach(function(_ref2) {
                  var name = _ref2.name, parentName = _ref2.parentName, visible = _ref2.visible;
                  if (!parentName) {
                    var _getViewLabelInfo = getViewLabelInfo(legendInfo, name, maxTextLengthWithEllipsis), width = _getViewLabelInfo.width, viewLabel = _getViewLabelInfo.viewLabel;
                    result.push({
                      label: name,
                      type: "pie",
                      checked: visible !== null && visible !== void 0 ? visible : true,
                      viewLabel,
                      width
                    });
                  }
                });
              });
              return result;
            }
            function getMaxTextLengthWithEllipsis(legendInfo) {
              var _legendOptions$item;
              var legendOptions = legendInfo.legendOptions, font = legendInfo.font, checkboxVisible = legendInfo.checkboxVisible;
              var width = legendOptions === null || legendOptions === void 0 ? void 0 : (_legendOptions$item = legendOptions.item) === null || _legendOptions$item === void 0 ? void 0 : _legendOptions$item.width;
              if (isUndefined(width)) {
                return;
              }
              var checkboxWidth = checkboxVisible ? LEGEND_CHECKBOX_SIZE + LEGEND_MARGIN_X : 0;
              var iconWidth = LEGEND_ICON_SIZE + LEGEND_MARGIN_X;
              var ellipsisDotWidth = getTextWidth(ELLIPSIS_DOT_TEXT, font);
              var widestTextWidth = getTextWidth(WIDEST_TEXT, font);
              var maxTextCount = Math.floor((width - ellipsisDotWidth - checkboxWidth - iconWidth) / widestTextWidth);
              return maxTextCount > 0 ? maxTextCount : 0;
            }
            function getViewLabelInfo(legendInfo, label2, maxTextLength) {
              var _legendOptions$item2;
              var checkboxVisible = legendInfo.checkboxVisible, useSpectrumLegend = legendInfo.useSpectrumLegend, font = legendInfo.font, legendOptions = legendInfo.legendOptions;
              var viewLabel = label2;
              var itemWidth = legendOptions === null || legendOptions === void 0 ? void 0 : (_legendOptions$item2 = legendOptions.item) === null || _legendOptions$item2 === void 0 ? void 0 : _legendOptions$item2.width;
              var itemWidthWithFullText = getItemWidth(viewLabel, checkboxVisible, useSpectrumLegend, font);
              if (isNumber(itemWidth) && isNumber(maxTextLength) && itemWidth < itemWidthWithFullText) {
                viewLabel = "".concat(label2.slice(0, maxTextLength)).concat(ELLIPSIS_DOT_TEXT);
              }
              return {
                viewLabel,
                width: itemWidth !== null && itemWidth !== void 0 ? itemWidth : itemWidthWithFullText
              };
            }
            function getLegendLabelsInfo(series, legendInfo, categories) {
              var maxTextLengthWithEllipsis = getMaxTextLengthWithEllipsis(legendInfo);
              var colorIndex = 0;
              return Object.keys(series).flatMap(function(type) {
                var labelInfo = series[type].map(function(_ref3) {
                  var name = _ref3.name, colorValue = _ref3.colorValue, visible = _ref3.visible, colorByCategories = _ref3.colorByCategories;
                  var label2 = colorValue ? colorValue : name;
                  var currentColorIndex = colorIndex;
                  var _getViewLabelInfo2 = getViewLabelInfo(legendInfo, label2, maxTextLengthWithEllipsis), width = _getViewLabelInfo2.width, viewLabel = _getViewLabelInfo2.viewLabel;
                  colorIndex += colorByCategories ? categories.length : 1;
                  return {
                    label: label2,
                    type,
                    colorByCategories: !!colorByCategories,
                    colorIndex: currentColorIndex,
                    checked: visible !== null && visible !== void 0 ? visible : true,
                    viewLabel,
                    width
                  };
                });
                colorIndex += series[type].length - 1;
                return labelInfo;
              });
            }
            function getItemWidth(label2, checkboxVisible, useSpectrumLegend, font) {
              return (useSpectrumLegend ? 0 : (checkboxVisible ? LEGEND_CHECKBOX_SIZE + LEGEND_MARGIN_X : 0) + LEGEND_ICON_SIZE + LEGEND_MARGIN_X) + getTextWidth(label2, font);
            }
            function getLegendDataAppliedTheme(data, series) {
              var colors = Object.values(series).reduce(function(acc, cur) {
                return cur && cur.colors ? [].concat(legend_toConsumableArray(acc), legend_toConsumableArray(cur.colors)) : acc;
              }, []);
              var hasColorByCategories = data.some(function(legend2) {
                return legend2.colorByCategories;
              });
              return data.map(function(datum, idx) {
                var colorByCategories = datum.colorByCategories, colorIndex = datum.colorIndex;
                var index = hasColorByCategories ? colorIndex || idx : idx;
                return store_legend_objectSpread(store_legend_objectSpread({}, datum), {}, {
                  color: colorByCategories ? "#aaa" : colors[index % colors.length]
                });
              });
            }
            function getLegendState(options2, series, categories) {
              var _useColorValue, _options$series, _options$theme, _options$theme$chart, _options$theme2, _options$theme2$legen;
              var useSpectrumLegend = (_useColorValue = options2 === null || options2 === void 0 ? void 0 : (_options$series = options2.series) === null || _options$series === void 0 ? void 0 : _options$series.useColorValue) !== null && _useColorValue !== void 0 ? _useColorValue : !!series.heatmap;
              var useScatterChartIcon = !!(series !== null && series !== void 0 && series.scatter);
              var checkboxVisible = useSpectrumLegend ? false : showCheckbox(options2);
              var defaultTheme = makeDefaultTheme(series, options2 === null || options2 === void 0 ? void 0 : (_options$theme = options2.theme) === null || _options$theme === void 0 ? void 0 : (_options$theme$chart = _options$theme.chart) === null || _options$theme$chart === void 0 ? void 0 : _options$theme$chart.fontFamily);
              var font = getTitleFontString(deepMergedCopy(defaultTheme.legend.label, store_legend_objectSpread({}, (_options$theme2 = options2.theme) === null || _options$theme2 === void 0 ? void 0 : (_options$theme2$legen = _options$theme2.legend) === null || _options$theme2$legen === void 0 ? void 0 : _options$theme2$legen.label)));
              var legendInfo = {
                checkboxVisible,
                font,
                useSpectrumLegend,
                legendOptions: options2.legend
              };
              var legendLabelsInfo = hasNestedPieSeries(series) ? getNestedPieLegendLabelsInfo(series, legendInfo) : getLegendLabelsInfo(series, legendInfo, categories);
              var data = legendLabelsInfo.map(function(_ref4) {
                var label2 = _ref4.label, type = _ref4.type, checked = _ref4.checked, width = _ref4.width, viewLabel = _ref4.viewLabel, colorByCategories = _ref4.colorByCategories, colorIndex = _ref4.colorIndex;
                return {
                  label: label2,
                  active: true,
                  checked,
                  width,
                  iconType: getIconType(type),
                  chartType: type,
                  rowIndex: 0,
                  columnIndex: 0,
                  viewLabel,
                  colorByCategories,
                  colorIndex
                };
              });
              return {
                useSpectrumLegend,
                useScatterChartIcon,
                data
              };
            }
            function getNextColumnRowIndex(params) {
              var verticalAlign = params.verticalAlign, columnCount = params.columnCount, rowCount = params.rowCount, legendCount = params.legendCount;
              var rowIndex = params.rowIndex, columnIndex = params.columnIndex;
              if (verticalAlign) {
                var maxLen = legendCount / rowCount;
                if (maxLen - 1 > columnIndex) {
                  columnIndex += 1;
                } else {
                  rowIndex += 1;
                  columnIndex = 0;
                }
              } else {
                var _maxLen = legendCount / columnCount;
                if (_maxLen - 1 > rowIndex) {
                  rowIndex += 1;
                } else {
                  columnIndex += 1;
                  rowIndex = 0;
                }
              }
              return [rowIndex, columnIndex];
            }
            function setIndexToLegendData(legendData, rowCount, columnCount, legendCount, verticalAlign) {
              var columnIndex = 0;
              var rowIndex = 0;
              legendData.forEach(function(datum) {
                datum.rowIndex = rowIndex;
                datum.columnIndex = columnIndex;
                var _getNextColumnRowInde = getNextColumnRowIndex({
                  rowCount,
                  columnCount,
                  verticalAlign,
                  legendCount,
                  rowIndex,
                  columnIndex
                });
                var _getNextColumnRowInde2 = legend_slicedToArray(_getNextColumnRowInde, 2);
                rowIndex = _getNextColumnRowInde2[0];
                columnIndex = _getNextColumnRowInde2[1];
              });
            }
            var legend_legend = {
              name: "legend",
              state: function state(_ref5) {
                var options2 = _ref5.options, series = _ref5.series, categories = _ref5.categories;
                return {
                  legend: getLegendState(options2, series, categories),
                  circleLegend: {}
                };
              },
              action: {
                initLegendState: function initLegendState(_ref6) {
                  var state = _ref6.state, initStoreState = _ref6.initStoreState;
                  store_extend(state.legend, getLegendState(initStoreState.options, initStoreState.series, initStoreState.categories));
                },
                setLegendLayout: function setLegendLayout(_ref7) {
                  var state = _ref7.state;
                  if (state.legend.useSpectrumLegend) {
                    this.dispatch("setSpectrumLegendLayout");
                  } else {
                    this.dispatch("setNormalLegendLayout");
                  }
                },
                setSpectrumLegendLayout: function setSpectrumLegendLayout(_ref8) {
                  var state = _ref8.state;
                  var legendData = state.legend.data, series = state.series, options2 = state.options, chart = state.chart, theme2 = state.theme;
                  var align = getLegendAlign(options2);
                  var visible = showLegend(options2, series);
                  var verticalAlign = isVerticalAlign(align);
                  var legendWidths = legendData.map(function(_ref9) {
                    var width2 = _ref9.width;
                    return width2;
                  });
                  var itemHeight = getLegendItemHeight(theme2.legend.label.fontSize);
                  var width = getSpectrumLegendWidth(legendWidths, chart.width, verticalAlign);
                  var height = getSpectrumLegendHeight(itemHeight, chart.height, verticalAlign);
                  store_extend(state.legend, {
                    visible,
                    align,
                    width,
                    height
                  });
                },
                setNormalLegendLayout: function setNormalLegendLayout(_ref10) {
                  var state = _ref10.state, initStoreState = _ref10.initStoreState;
                  var legendData = state.legend.data, series = state.series, options2 = state.options, chart = state.chart, theme2 = state.theme;
                  var align = getLegendAlign(options2);
                  var visible = showLegend(options2, series);
                  var checkbox = showCheckbox(options2);
                  var initialWidth = Math.min(chart.width / 5, INITIAL_LEGEND_WIDTH);
                  var verticalAlign = isVerticalAlign(align);
                  var isNestedPieChart = hasNestedPieSeries(initStoreState.series);
                  var isScatterChart = !!series.scatter;
                  var isBubbleChart = !!series.bubble;
                  var circleLegendVisible = isBubbleChart ? showCircleLegend(options2) : false;
                  var legendWidths = legendData.map(function(_ref11) {
                    var width = _ref11.width;
                    return width;
                  });
                  var itemHeight = getLegendItemHeight(theme2.legend.label.fontSize);
                  var _calculateLegendSize = calculateLegendSize({
                    initialWidth,
                    legendWidths,
                    options: options2,
                    verticalAlign,
                    visible,
                    checkbox,
                    chart,
                    itemHeight,
                    circleLegendVisible
                  }), legendWidth = _calculateLegendSize.legendWidth, legendHeight = _calculateLegendSize.legendHeight, rowCount = _calculateLegendSize.rowCount, columnCount = _calculateLegendSize.columnCount;
                  setIndexToLegendData(legendData, rowCount, columnCount, legendWidths.length, verticalAlign);
                  store_extend(state.legend, {
                    visible,
                    align,
                    showCheckbox: checkbox,
                    width: legendWidth,
                    height: legendHeight
                  });
                  if (isBubbleChart && circleLegendVisible) {
                    this.dispatch("updateCircleLegendLayout", {
                      legendWidth
                    });
                  }
                  if (!isNestedPieChart && !isNoData(series)) {
                    this.dispatch("updateLegendColor");
                  }
                  if (isScatterChart) {
                    this.dispatch("updateLegendIcon");
                  }
                },
                updateCircleLegendLayout: function updateCircleLegendLayout(_ref12, _ref13) {
                  var state = _ref12.state;
                  var legendWidth = _ref13.legendWidth;
                  var width = legendWidth === 0 ? INITIAL_CIRCLE_LEGEND_WIDTH : Math.min(legendWidth, INITIAL_CIRCLE_LEGEND_WIDTH);
                  var radius = Math.max((width - LEGEND_MARGIN_X) / 2, 0);
                  store_extend(state.circleLegend, {
                    visible: true,
                    width,
                    radius
                  });
                },
                setLegendActiveState: function setLegendActiveState(_ref14, _ref15) {
                  var state = _ref14.state;
                  var name = _ref15.name, active = _ref15.active;
                  var data = state.legend.data;
                  var model = data.find(function(_ref16) {
                    var label2 = _ref16.label;
                    return label2 === name;
                  });
                  model.active = active;
                  this.notify(state, "legend");
                },
                setAllLegendActiveState: function setAllLegendActiveState(_ref17, active) {
                  var state = _ref17.state;
                  state.legend.data.forEach(function(datum) {
                    datum.active = active;
                  });
                  this.notify(state, "legend");
                },
                setLegendCheckedState: function setLegendCheckedState(_ref18, _ref19) {
                  var state = _ref18.state;
                  var name = _ref19.name, checked = _ref19.checked;
                  var model = state.legend.data.find(function(_ref20) {
                    var label2 = _ref20.label;
                    return label2 === name;
                  });
                  model.checked = checked;
                  this.notify(state, "legend");
                },
                updateLegendColor: function updateLegendColor(_ref21) {
                  var state = _ref21.state;
                  var legendData = state.legend, series = state.series;
                  var data = getLegendDataAppliedTheme(legendData.data, series);
                  store_extend(state.legend, {
                    data
                  });
                },
                updateLegendIcon: function updateLegendIcon(_ref22) {
                  var state = _ref22.state;
                  var legendData = state.legend, series = state.series;
                  var data = legendData.data.reduce(function(acc, cur) {
                    var _series$scatter;
                    if (cur.chartType === "scatter" && (_series$scatter = series.scatter) !== null && _series$scatter !== void 0 && _series$scatter.data) {
                      var model = series.scatter.data.find(function(_ref23) {
                        var name = _ref23.name;
                        return name === cur.label;
                      });
                      var iconType = model ? model.iconType : cur.iconType;
                      return [].concat(legend_toConsumableArray(acc), [store_legend_objectSpread(store_legend_objectSpread({}, cur), {}, {
                        iconType
                      })]);
                    }
                    return [].concat(legend_toConsumableArray(acc), [cur]);
                  }, []);
                  store_extend(state.legend, {
                    data
                  });
                },
                updateNestedPieChartLegend: function updateNestedPieChartLegend(_ref24) {
                  var state = _ref24.state;
                  var legendData = state.legend, nestedPieSeries = state.nestedPieSeries;
                  store_extend(state.legend, {
                    data: getLegendDataAppliedTheme(legendData.data, nestedPieSeries)
                  });
                }
              },
              observe: {
                updateLegendLayout: function updateLegendLayout() {
                  this.dispatch("setLegendLayout");
                }
              }
            };
            var store_legend = legend_legend;
            ;
            function getOptionsBySize(size, options2) {
              var _options$responsive;
              var rules = (_options$responsive = options2.responsive) === null || _options$responsive === void 0 ? void 0 : _options$responsive.rules;
              return Array.isArray(rules) ? rules.reduce(function(acc, cur) {
                return cur.condition(size) ? deepMergedCopy(acc, cur.options) : acc;
              }, options2) : options2;
            }
            function getSize(usingContainerSize, containerSize, chartSize) {
              var usingContainerWidth = usingContainerSize.width, usingContainerHeight = usingContainerSize.height;
              return {
                width: usingContainerWidth ? containerSize.width : chartSize === null || chartSize === void 0 ? void 0 : chartSize.width,
                height: usingContainerHeight ? containerSize.height : chartSize === null || chartSize === void 0 ? void 0 : chartSize.height
              };
            }
            var optionsData = {
              name: "options",
              state: function state(_ref) {
                var options2 = _ref.options;
                return {
                  originalOptions: deepCopy(options2),
                  options: options2
                };
              },
              action: {
                setOptions: function setOptions(_ref2) {
                  var state = _ref2.state;
                  var _state$chart = state.chart, width = _state$chart.width, height = _state$chart.height;
                  if (width < 0 || height < 0) {
                    return;
                  }
                  state.options = getOptionsBySize({
                    width,
                    height
                  }, state.originalOptions);
                },
                initOptions: function initOptions(_ref3, _ref4) {
                  var initStoreState = _ref3.initStoreState, state = _ref3.state;
                  var options2 = _ref4.options, containerSize = _ref4.containerSize;
                  initStoreState.options = options2;
                  state.originalOptions = deepCopy(options2);
                  var usingContainerSize = state.usingContainerSize, originalOptions = state.originalOptions;
                  var size = getSize(usingContainerSize, containerSize, {
                    width: originalOptions.chart.width,
                    height: originalOptions.chart.height
                  });
                  this.dispatch("setChartSize", size);
                },
                updateOptions: function updateOptions(_ref5, _ref6) {
                  var _originalOptions$char, _originalOptions$char2;
                  var state = _ref5.state, initStoreState = _ref5.initStoreState;
                  var options2 = _ref6.options, containerSize = _ref6.containerSize;
                  initStoreState.options = deepMergedCopy(initStoreState.options, options2);
                  state.originalOptions = deepMergedCopy(state.originalOptions, options2);
                  var usingContainerSize = state.usingContainerSize, originalOptions = state.originalOptions;
                  var size = getSize(usingContainerSize, containerSize, {
                    width: (_originalOptions$char = originalOptions.chart) === null || _originalOptions$char === void 0 ? void 0 : _originalOptions$char.width,
                    height: (_originalOptions$char2 = originalOptions.chart) === null || _originalOptions$char2 === void 0 ? void 0 : _originalOptions$char2.height
                  });
                  this.dispatch("setChartSize", size);
                  this.dispatch("initThemeState");
                }
              },
              observe: {
                updateOptions: function updateOptions() {
                  this.dispatch("setOptions");
                }
              }
            };
            var options = optionsData;
            ;
            function theme_toConsumableArray(arr) {
              return theme_arrayWithoutHoles(arr) || theme_iterableToArray(arr) || theme_unsupportedIterableToArray(arr) || theme_nonIterableSpread();
            }
            function theme_nonIterableSpread() {
              throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            function theme_unsupportedIterableToArray(o, minLen) {
              if (!o)
                return;
              if (typeof o === "string")
                return theme_arrayLikeToArray(o, minLen);
              var n = Object.prototype.toString.call(o).slice(8, -1);
              if (n === "Object" && o.constructor)
                n = o.constructor.name;
              if (n === "Map" || n === "Set")
                return Array.from(o);
              if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                return theme_arrayLikeToArray(o, minLen);
            }
            function theme_iterableToArray(iter) {
              if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
                return Array.from(iter);
            }
            function theme_arrayWithoutHoles(arr) {
              if (Array.isArray(arr))
                return theme_arrayLikeToArray(arr);
            }
            function theme_arrayLikeToArray(arr, len) {
              if (len == null || len > arr.length)
                len = arr.length;
              for (var i = 0, arr2 = new Array(len); i < len; i++) {
                arr2[i] = arr[i];
              }
              return arr2;
            }
            function store_theme_ownKeys(object, enumerableOnly) {
              var keys = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object);
                if (enumerableOnly) {
                  symbols = symbols.filter(function(sym) {
                    return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                  });
                }
                keys.push.apply(keys, symbols);
              }
              return keys;
            }
            function store_theme_objectSpread(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i] != null ? arguments[i] : {};
                if (i % 2) {
                  store_theme_ownKeys(Object(source), true).forEach(function(key) {
                    store_theme_defineProperty(target, key, source[key]);
                  });
                } else if (Object.getOwnPropertyDescriptors) {
                  Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                } else {
                  store_theme_ownKeys(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  });
                }
              }
              return target;
            }
            function store_theme_defineProperty(obj, key, value) {
              if (key in obj) {
                Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
              } else {
                obj[key] = value;
              }
              return obj;
            }
            function getCommonSeriesOptions(options2, series, isNestedPieChart) {
              var theme2 = options2 === null || options2 === void 0 ? void 0 : options2.theme;
              if (!(theme2 !== null && theme2 !== void 0 && theme2.series)) {
                return {};
              }
              var seriesNames = isNestedPieChart ? getNestedPieChartAliasNames(series) : Object.keys(series);
              return seriesNames.reduce(function(acc, seriesName) {
                delete acc[seriesName];
                return acc;
              }, store_theme_objectSpread({}, theme2.series));
            }
            function getThemeAppliedSecondaryYAxis(options2) {
              var _options$theme, _options$theme$chart;
              var theme2 = store_theme_objectSpread({}, options2.theme);
              if (!Array.isArray(theme2.yAxis)) {
                return theme2;
              }
              var axisTitleTheme = makeAxisTitleTheme(options2 === null || options2 === void 0 ? void 0 : (_options$theme = options2.theme) === null || _options$theme === void 0 ? void 0 : (_options$theme$chart = _options$theme.chart) === null || _options$theme$chart === void 0 ? void 0 : _options$theme$chart.fontFamily);
              var yAxis = theme2.yAxis.map(function(yAxisTheme) {
                return deepMergedCopy({
                  title: store_theme_objectSpread({}, axisTitleTheme)
                }, store_theme_objectSpread({}, yAxisTheme));
              });
              return store_theme_objectSpread(store_theme_objectSpread({}, theme2), {}, {
                yAxis
              });
            }
            function getThemeOptionsWithSeriesName(options2, series, commonSeriesOptions, isNestedPieChart) {
              var theme2 = getThemeAppliedSecondaryYAxis(options2);
              if (!(theme2 !== null && theme2 !== void 0 && theme2.series)) {
                return store_theme_objectSpread({}, theme2);
              }
              var seriesTheme = store_theme_objectSpread(store_theme_objectSpread({}, theme2), {}, {
                series: {}
              });
              var seriesNames = Object.keys(series);
              var isComboChart = seriesNames.length > 1;
              if (isNestedPieChart) {
                var aliasNames = getNestedPieChartAliasNames(series);
                seriesTheme.series = {
                  pie: aliasNames.reduce(function(acc, aliasName) {
                    var _theme$series;
                    return store_theme_objectSpread(store_theme_objectSpread({}, acc), {}, store_theme_defineProperty({}, aliasName, deepMergedCopy((_theme$series = theme2.series) === null || _theme$series === void 0 ? void 0 : _theme$series[aliasName], omit(commonSeriesOptions, "colors"))));
                  }, {})
                };
              } else if (isComboChart) {
                seriesTheme.series = store_theme_objectSpread({}, seriesNames.reduce(function(acc, seriesName) {
                  var _theme$series2;
                  return store_theme_objectSpread(store_theme_objectSpread({}, acc), {}, store_theme_defineProperty({}, seriesName, deepMergedCopy((_theme$series2 = theme2.series) === null || _theme$series2 === void 0 ? void 0 : _theme$series2[seriesName], omit(commonSeriesOptions, "colors"))));
                }, {}));
              } else {
                seriesTheme.series = store_theme_defineProperty({}, seriesNames[0], theme2.series);
              }
              return seriesTheme;
            }
            function setColors(theme2, series, commonSeriesOptions, isNestedPieChart, categories) {
              var _ref;
              var index = 0;
              var commonColorsOption = [].concat(theme_toConsumableArray((_ref = commonSeriesOptions === null || commonSeriesOptions === void 0 ? void 0 : commonSeriesOptions.colors) !== null && _ref !== void 0 ? _ref : []), theme_toConsumableArray(defaultSeriesTheme.colors));
              var themeNames = isNestedPieChart ? getNestedPieChartAliasNames(series) : Object.keys(series);
              themeNames.forEach(function(name, idx) {
                var _target$name;
                var themeSeries = series[name] || [];
                var filteredSeries = themeSeries.filter(function(chartSeries) {
                  return chartSeries.colorByCategories;
                });
                var hasColorByCategories = filteredSeries.length > 0;
                var size;
                if (isNestedPieChart) {
                  size = series.pie[idx].data.length;
                } else if (hasColorByCategories) {
                  var rejectedSeries = themeSeries.filter(function(chartSeries) {
                    return !chartSeries.colorByCategories;
                  });
                  size = rejectedSeries.length + categories.length;
                } else {
                  size = series[name].length;
                }
                var target = isNestedPieChart ? theme2.series.pie : theme2.series;
                if (!((_target$name = target[name]) !== null && _target$name !== void 0 && _target$name.colors)) {
                  target[name] = store_theme_objectSpread(store_theme_objectSpread({}, target[name]), {}, {
                    colors: commonColorsOption.slice(index, index + size)
                  });
                  index += size;
                }
              });
            }
            function setPlot(theme2) {
              ["vertical", "horizontal"].reduce(function(acc, cur) {
                if (!acc[cur]) {
                  acc[cur] = {
                    lineColor: acc.lineColor
                  };
                }
                return acc;
              }, theme2.plot);
            }
            function checkAnchorPieSeriesOption(options2, series, alias) {
              var _options$series, _options$series$alias, _options$series$alias2, _options$series2, _options$series2$alia, _options$series2$alia2, _options$series2$alia3;
              return {
                hasOuterAnchor: !!series.pie && (options2 === null || options2 === void 0 ? void 0 : (_options$series = options2.series) === null || _options$series === void 0 ? void 0 : (_options$series$alias = _options$series[alias]) === null || _options$series$alias === void 0 ? void 0 : (_options$series$alias2 = _options$series$alias.dataLabels) === null || _options$series$alias2 === void 0 ? void 0 : _options$series$alias2.anchor) === "outer",
                hasOuterAnchorPieSeriesName: !!series.pie && (options2 === null || options2 === void 0 ? void 0 : (_options$series2 = options2.series) === null || _options$series2 === void 0 ? void 0 : (_options$series2$alia = _options$series2[alias]) === null || _options$series2$alia === void 0 ? void 0 : (_options$series2$alia2 = _options$series2$alia.dataLabels) === null || _options$series2$alia2 === void 0 ? void 0 : (_options$series2$alia3 = _options$series2$alia2.pieSeriesName) === null || _options$series2$alia3 === void 0 ? void 0 : _options$series2$alia3.anchor) === "outer"
              };
            }
            function getTheme(options2, series, categories) {
              var _options$theme2, _options$theme2$chart;
              var isNestedPieChart = hasNestedPieSeries(series);
              var commonSeriesOptions = getCommonSeriesOptions(options2, series, isNestedPieChart);
              var pieSeriesOuterAnchors = {
                hasOuterAnchor: hasOuterDataLabel(options2, series),
                hasOuterAnchorPieSeriesName: hasOuterPieSeriesName(options2, series)
              };
              if (isNestedPieChart) {
                var aliasNames = getNestedPieChartAliasNames(series);
                pieSeriesOuterAnchors = aliasNames.reduce(function(acc, cur) {
                  return store_theme_objectSpread(store_theme_objectSpread({}, acc), {}, store_theme_defineProperty({}, cur, checkAnchorPieSeriesOption(options2, series, cur)));
                }, {});
              }
              var globalFontFamily = options2 === null || options2 === void 0 ? void 0 : (_options$theme2 = options2.theme) === null || _options$theme2 === void 0 ? void 0 : (_options$theme2$chart = _options$theme2.chart) === null || _options$theme2$chart === void 0 ? void 0 : _options$theme2$chart.fontFamily;
              var theme2 = deepMergedCopy(getDefaultTheme(series, pieSeriesOuterAnchors, globalFontFamily, isNestedPieChart), getThemeOptionsWithSeriesName(options2, series, commonSeriesOptions, isNestedPieChart));
              if (!series.heatmap) {
                setColors(theme2, series, commonSeriesOptions, isNestedPieChart, categories);
              }
              setPlot(theme2);
              return theme2;
            }
            var theme = {
              name: "theme",
              state: function state(_ref2) {
                var options2 = _ref2.options, series = _ref2.series, categories = _ref2.categories;
                return {
                  theme: getTheme(options2, series, categories)
                };
              },
              action: {
                initThemeState: function initThemeState(_ref3) {
                  var state = _ref3.state, initStoreState = _ref3.initStoreState;
                  state.theme = getTheme(state.options, initStoreState.series, initStoreState.categories);
                }
              },
              observe: {
                updateTheme: function updateTheme() {
                  this.dispatch("initThemeState");
                }
              }
            };
            var store_theme = theme;
            ;
            function eventEmitter_classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function eventEmitter_defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            function eventEmitter_createClass(Constructor, protoProps, staticProps) {
              if (protoProps)
                eventEmitter_defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                eventEmitter_defineProperties(Constructor, staticProps);
              return Constructor;
            }
            function eventEmitter_defineProperty(obj, key, value) {
              if (key in obj) {
                Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
              } else {
                obj[key] = value;
              }
              return obj;
            }
            var EventEmitter = function() {
              function EventEmitter2() {
                eventEmitter_classCallCheck(this, EventEmitter2);
                eventEmitter_defineProperty(this, "handlers", []);
              }
              eventEmitter_createClass(EventEmitter2, [{
                key: "on",
                value: function on(type, handler) {
                  if (!this.handlers[type]) {
                    this.handlers[type] = [];
                  }
                  this.handlers[type].push(handler);
                }
              }, {
                key: "emit",
                value: function emit(type) {
                  var _this$handlers$type;
                  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                    args[_key - 1] = arguments[_key];
                  }
                  (_this$handlers$type = this.handlers[type]) === null || _this$handlers$type === void 0 ? void 0 : _this$handlers$type.forEach(function(handler) {
                    return handler.apply(void 0, args);
                  });
                }
              }]);
              return EventEmitter2;
            }();
            ;
            function componentManager_classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function componentManager_defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            function componentManager_createClass(Constructor, protoProps, staticProps) {
              if (protoProps)
                componentManager_defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                componentManager_defineProperties(Constructor, staticProps);
              return Constructor;
            }
            function componentManager_defineProperty(obj, key, value) {
              if (key in obj) {
                Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
              } else {
                obj[key] = value;
              }
              return obj;
            }
            var ComponentManager = function() {
              function ComponentManager2(_ref) {
                var store = _ref.store, eventBus = _ref.eventBus;
                componentManager_classCallCheck(this, ComponentManager2);
                componentManager_defineProperty(this, "components", []);
                componentManager_defineProperty(this, "store", void 0);
                componentManager_defineProperty(this, "eventBus", void 0);
                this.store = store;
                this.eventBus = eventBus;
              }
              componentManager_createClass(ComponentManager2, [{
                key: "add",
                value: function add2(ComponentCtor, initialParam) {
                  var _this = this;
                  var component = new ComponentCtor({
                    store: this.store,
                    eventBus: this.eventBus
                  });
                  if (component.initialize) {
                    component.initialize(initialParam);
                  }
                  var proc = function proc2() {
                    component.render(arguments.length <= 0 ? void 0 : arguments[0], arguments.length <= 1 ? void 0 : arguments[1]);
                    component.sync();
                    _this.eventBus.emit("needLoop");
                  };
                  this.store.observe(function() {
                    proc.apply(void 0, arguments);
                  });
                  proc = debounce(proc);
                  this.components.push(component);
                }
              }, {
                key: "remove",
                value: function remove(ComponentCtor) {
                  this.components = this.components.filter(function(component) {
                    return !(component instanceof ComponentCtor);
                  });
                }
              }, {
                key: "clear",
                value: function clear() {
                  this.components = [];
                  this.eventBus.emit("needDraw");
                }
              }, {
                key: "invoke",
                value: function invoke(method, params) {
                  this.components.forEach(function(component) {
                    var fn = component[method];
                    if (fn) {
                      fn.call(component, params);
                    }
                  });
                }
              }, {
                key: "forEach",
                value: function forEach2(iteratee) {
                  this.components.forEach(iteratee);
                }
              }]);
              return ComponentManager2;
            }();
            ;
            function painter_classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function painter_defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            function painter_createClass(Constructor, protoProps, staticProps) {
              if (protoProps)
                painter_defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                painter_defineProperties(Constructor, staticProps);
              return Constructor;
            }
            function painter_defineProperty(obj, key, value) {
              if (key in obj) {
                Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
              } else {
                obj[key] = value;
              }
              return obj;
            }
            var Painter = function() {
              function Painter2(chart) {
                painter_classCallCheck(this, Painter2);
                painter_defineProperty(this, "width", 0);
                painter_defineProperty(this, "height", 0);
                painter_defineProperty(this, "brushes", {});
                painter_defineProperty(this, "chart", void 0);
                painter_defineProperty(this, "canvas", void 0);
                painter_defineProperty(this, "ctx", void 0);
                this.chart = chart;
              }
              painter_createClass(Painter2, [{
                key: "showUnsupportedCanvasFeatureError",
                value: function showUnsupportedCanvasFeatureError() {
                  if (!this.ctx.setLineDash) {
                    console.warn(message.DASH_SEGMENTS_UNAVAILABLE_ERROR);
                  }
                }
              }, {
                key: "setup",
                value: function setup() {
                  var _this$chart$store$sta = this.chart.store.state.chart, height = _this$chart$store$sta.height, width = _this$chart$store$sta.width;
                  if (!this.canvas) {
                    var canvas = document.createElement("canvas");
                    this.canvas = canvas;
                    this.chart.el.appendChild(canvas);
                    canvas.addEventListener("click", this.chart);
                    canvas.addEventListener("mousemove", this.chart);
                    canvas.addEventListener("mousedown", this.chart);
                    canvas.addEventListener("mouseup", this.chart);
                    canvas.addEventListener("mouseout", this.chart);
                    var _ctx = canvas.getContext("2d");
                    if (_ctx) {
                      this.ctx = _ctx;
                    }
                  }
                  this.setSize(width, height);
                  this.showUnsupportedCanvasFeatureError();
                }
              }, {
                key: "setSize",
                value: function setSize(width, height) {
                  this.canvas.style.width = "".concat(width, "px");
                  this.canvas.style.height = "".concat(height, "px");
                  var ratio = 1;
                  if ("deviceXDPI" in window.screen) {
                    ratio = window.screen.deviceXDPI / window.screen.logicalXDPI;
                  } else if (window.hasOwnProperty("devicePixelRatio")) {
                    ratio = window.devicePixelRatio;
                  }
                  this.width = width * ratio || 0;
                  this.height = height * ratio || 0;
                  this.scaleCanvasRatio(ratio);
                }
              }, {
                key: "scaleCanvasRatio",
                value: function scaleCanvasRatio(ratio) {
                  this.canvas.width = this.width;
                  this.canvas.height = this.height;
                  this.ctx.scale(ratio, ratio);
                }
              }, {
                key: "add",
                value: function add2(name, brush) {
                  this.brushes[name] = brush;
                }
              }, {
                key: "addGroups",
                value: function addGroups(groups) {
                  var _this = this;
                  groups.forEach(function(group) {
                    Object.keys(group).forEach(function(key) {
                      _this.add(key, group[key]);
                    });
                  });
                }
              }, {
                key: "paint",
                value: function paint(name, brushModel) {
                  if (this.brushes[name]) {
                    this.brushes[name](this.ctx, brushModel);
                  } else {
                    throw new Error(message.noBrushError(name));
                  }
                }
              }, {
                key: "paintForEach",
                value: function paintForEach(brushModels) {
                  var _this2 = this;
                  brushModels.forEach(function(m) {
                    return _this2.paint(m.type, m);
                  });
                }
              }, {
                key: "beforeFrame",
                value: function beforeFrame() {
                  this.ctx.clearRect(0, 0, this.width, this.height);
                  this.ctx.fillStyle = "transparent";
                  this.ctx.fillRect(0, 0, this.width, this.height);
                }
              }, {
                key: "beforeDraw",
                value: function beforeDraw(transX, transY) {
                  this.ctx.save();
                  this.ctx.translate(transX, transY);
                }
              }, {
                key: "afterDraw",
                value: function afterDraw() {
                  this.ctx.restore();
                }
              }]);
              return Painter2;
            }();
            ;
            function animator_classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function animator_defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            function animator_createClass(Constructor, protoProps, staticProps) {
              if (protoProps)
                animator_defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                animator_defineProperties(Constructor, staticProps);
              return Constructor;
            }
            function animator_defineProperty(obj, key, value) {
              if (key in obj) {
                Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
              } else {
                obj[key] = value;
              }
              return obj;
            }
            var Animator = function() {
              function Animator2() {
                animator_classCallCheck(this, Animator2);
                animator_defineProperty(this, "anims", []);
                animator_defineProperty(this, "state", "IDLE");
                animator_defineProperty(this, "requestId", null);
                animator_defineProperty(this, "firstRendering", true);
              }
              animator_createClass(Animator2, [{
                key: "add",
                value: function add2(_ref) {
                  var _this = this;
                  var chart = _ref.chart, duration = _ref.duration, requester = _ref.requester, _ref$onCompleted = _ref.onCompleted, onCompleted = _ref$onCompleted === void 0 ? function() {
                  } : _ref$onCompleted, _ref$onFrame = _ref.onFrame, onFrame = _ref$onFrame === void 0 ? function(delta) {
                    if (!_this.firstRendering) {
                      chart.update(delta);
                    }
                    if (_this.firstRendering) {
                      chart.initUpdate(delta);
                      if (delta === 1) {
                        _this.firstRendering = false;
                      }
                    }
                  } : _ref$onFrame;
                  if (this.anims.length) {
                    this.reset();
                  }
                  if (this.state === "IDLE") {
                    this.anims.push({
                      chart,
                      requester,
                      duration,
                      onFrame,
                      onCompleted,
                      start: null,
                      current: null,
                      completed: false
                    });
                    this.start();
                  }
                }
              }, {
                key: "reset",
                value: function reset() {
                  this.anims.forEach(function(anim) {
                    anim.current = 1;
                    anim.onFrame(anim.current);
                    anim.completed = true;
                  });
                  this.anims = [];
                  this.cancelAnimFrame();
                  this.state = "IDLE";
                  this.requestId = null;
                }
              }, {
                key: "start",
                value: function start() {
                  if (this.anims.length) {
                    this.state = "RUNNING";
                    this.runFrame();
                  }
                }
              }, {
                key: "runFrame",
                value: function runFrame() {
                  var _this2 = this;
                  this.requestId = window.requestAnimationFrame(function(timestamp) {
                    _this2.runAnims(timestamp);
                  });
                }
              }, {
                key: "runAnims",
                value: function runAnims(timestamp) {
                  this.next(timestamp);
                  if (this.anims.length) {
                    this.runFrame();
                  } else {
                    this.state = "IDLE";
                    this.requestId = null;
                  }
                }
              }, {
                key: "next",
                value: function next(timestamp) {
                  var _this3 = this;
                  this.anims.forEach(function(anim) {
                    if (isNull(anim.start)) {
                      anim.start = timestamp;
                    }
                    Object.defineProperty(anim.chart, "___animId___", {
                      value: timestamp,
                      enumerable: false,
                      writable: false,
                      configurable: true
                    });
                    anim.current = anim.duration ? Math.min((timestamp - anim.start) / anim.duration, 1) : 1;
                    anim.onFrame(anim.current);
                    anim.completed = anim.current === 1;
                  });
                  this.anims.forEach(function(anim) {
                    if (anim.chart.___animId___ === timestamp) {
                      anim.chart.draw();
                      delete anim.chart.___animId___;
                    }
                    if (anim.completed) {
                      _this3.cancelAnimFrame();
                      anim.onCompleted();
                      anim.chart.eventBus.emit("animationCompleted", anim.requester);
                    }
                  });
                  this.anims = this.anims.filter(function(anim) {
                    return !anim.completed;
                  });
                }
              }, {
                key: "cancelAnimFrame",
                value: function cancelAnimFrame() {
                  if (this.requestId) {
                    window.cancelAnimationFrame(this.requestId);
                  }
                }
              }]);
              return Animator2;
            }();
            ;
            function responderDetectors_slicedToArray(arr, i) {
              return responderDetectors_arrayWithHoles(arr) || responderDetectors_iterableToArrayLimit(arr, i) || responderDetectors_unsupportedIterableToArray(arr, i) || responderDetectors_nonIterableRest();
            }
            function responderDetectors_nonIterableRest() {
              throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            function responderDetectors_unsupportedIterableToArray(o, minLen) {
              if (!o)
                return;
              if (typeof o === "string")
                return responderDetectors_arrayLikeToArray(o, minLen);
              var n = Object.prototype.toString.call(o).slice(8, -1);
              if (n === "Object" && o.constructor)
                n = o.constructor.name;
              if (n === "Map" || n === "Set")
                return Array.from(o);
              if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                return responderDetectors_arrayLikeToArray(o, minLen);
            }
            function responderDetectors_arrayLikeToArray(arr, len) {
              if (len == null || len > arr.length)
                len = arr.length;
              for (var i = 0, arr2 = new Array(len); i < len; i++) {
                arr2[i] = arr[i];
              }
              return arr2;
            }
            function responderDetectors_iterableToArrayLimit(arr, i) {
              var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]);
              if (_i == null)
                return;
              var _arr = [];
              var _n = true;
              var _d = false;
              var _s, _e;
              try {
                for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
                  _arr.push(_s.value);
                  if (i && _arr.length === i)
                    break;
                }
              } catch (err) {
                _d = true;
                _e = err;
              } finally {
                try {
                  if (!_n && _i["return"] != null)
                    _i["return"]();
                } finally {
                  if (_d)
                    throw _e;
                }
              }
              return _arr;
            }
            function responderDetectors_arrayWithHoles(arr) {
              if (Array.isArray(arr))
                return arr;
            }
            function withinRotationRect(_ref) {
              var slope = _ref.slope, yIntercept = _ref.yIntercept, mouseX = _ref.mouseX, mouseY = _ref.mouseY, modelXPositions = _ref.modelXPositions, compX = _ref.compX, compY = _ref.compY, _ref$detectionSize = _ref.detectionSize, detectionSize = _ref$detectionSize === void 0 ? 0 : _ref$detectionSize;
              var _modelXPositions = responderDetectors_slicedToArray(modelXPositions, 2), x1 = _modelXPositions[0], x2 = _modelXPositions[1];
              var posY = slope * (mouseX - compX) + yIntercept;
              var withinRadius = x1 > x2 && mouseX >= compX + x2 && mouseX <= compX + x1 || x1 < x2 && mouseX <= compX + x2 && mouseX >= compX + x1;
              var withinDetectionSize = posY - detectionSize + compY <= mouseY && mouseY <= posY + detectionSize + compY;
              return withinRadius && withinDetectionSize;
            }
            var responderDetectors = {
              circle: function circle2(mousePosition, model, componentRect) {
                var x = mousePosition.x, y = mousePosition.y;
                var modelX = model.x, modelY = model.y, radius = model.radius, detectionSize = model.detectionSize;
                var compX = componentRect.x, compY = componentRect.y;
                var radiusAdjustment = isUndefined(detectionSize) ? 10 : detectionSize;
                return Math.pow(x - (modelX + compX), 2) + Math.pow(y - (modelY + compY), 2) < Math.pow(radius + radiusAdjustment, 2);
              },
              rect: function rect2(mousePosition, model) {
                var componentRect = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
                  x: 0,
                  y: 0,
                  width: 0,
                  height: 0
                };
                var x = mousePosition.x, y = mousePosition.y;
                var modelX = model.x, modelY = model.y, width = model.width, height = model.height;
                var compX = componentRect.x, compY = componentRect.y;
                return x >= modelX + compX && x <= modelX + compX + width && y >= modelY + compY && y <= modelY + compY + height;
              },
              sector: function sector2(mousePosition, model) {
                var componentRect = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
                  x: 0,
                  y: 0,
                  width: 0,
                  height: 0
                };
                var x = mousePosition.x, y = mousePosition.y;
                var modelX = model.x, modelY = model.y, _model$radius = model.radius, outer = _model$radius.outer, inner = _model$radius.inner, _model$degree = model.degree, start = _model$degree.start, end = _model$degree.end, drawingStartAngle = model.drawingStartAngle, clockwise = model.clockwise;
                var compX = componentRect.x, compY = componentRect.y;
                var xPos = x - (modelX + compX);
                var yPos = y - (modelY + compY);
                var insideOuterRadius = Math.pow(xPos, 2) + Math.pow(yPos, 2) < Math.pow(outer, 2);
                var outsideInnerRadius = Math.pow(xPos, 2) + Math.pow(yPos, 2) > Math.pow(inner, 2);
                var withinRadius = insideOuterRadius && outsideInnerRadius;
                var detectionDegree = calculateRadianToDegree(Math.atan2(yPos, xPos), drawingStartAngle);
                return withinRadius && withinRadian(clockwise, start, end, detectionDegree);
              },
              line: function line2(mousePosition, model) {
                var componentRect = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
                  x: 0,
                  y: 0,
                  width: 0,
                  height: 0
                };
                var x = mousePosition.x, y = mousePosition.y;
                var compX = componentRect.x, compY = componentRect.y;
                var modelX = model.x, modelY = model.y, x2 = model.x2, y2 = model.y2, _model$detectionSize = model.detectionSize, detectionSize = _model$detectionSize === void 0 ? 3 : _model$detectionSize;
                var numerator = y2 - modelY;
                var denominator = x2 - modelX;
                var withinLine = false;
                if (numerator === 0) {
                  var minX = Math.min(modelX, x2);
                  var maxX = Math.max(modelX, x2);
                  withinLine = x - compX >= minX && x - compX <= maxX && y >= modelY + compY - detectionSize && y <= modelY + compY + detectionSize;
                } else if (denominator === 0) {
                  var minY = Math.min(modelY, y2);
                  var maxY = Math.max(modelY, y2);
                  withinLine = y - compY >= minY && y - compY <= maxY && x >= modelX + compX - detectionSize && x <= modelX + compX + detectionSize;
                } else {
                  var slope = numerator / denominator;
                  var xPos = x - (modelX + compX);
                  var yPos = y - (modelY + compY);
                  withinLine = slope * xPos === yPos;
                }
                return withinLine;
              },
              boxPlot: function boxPlot2(mousePosition, model) {
                var componentRect = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
                  x: 0,
                  y: 0,
                  width: 0,
                  height: 0
                };
                return ["rect", "median", "minimum", "maximum", "upperWhisker", "lowerWhisker"].some(function(prop) {
                  if (!model[prop]) {
                    return false;
                  }
                  return prop === "rect" ? responderDetectors.rect(mousePosition, model[prop], componentRect) : responderDetectors.line(mousePosition, model[prop], componentRect);
                });
              },
              clockHand: function clockHand2(mousePosition, model) {
                var componentRect = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
                  x: 0,
                  y: 0,
                  width: 0,
                  height: 0
                };
                var x = mousePosition.x, y = mousePosition.y;
                var compX = componentRect.x, compY = componentRect.y;
                var centerX = model.x, centerY = model.y, x2 = model.x2, y2 = model.y2, _model$detectionSize2 = model.detectionSize, detectionSize = _model$detectionSize2 === void 0 ? 5 : _model$detectionSize2;
                var numerator = y2 - centerY;
                var denominator = x2 - centerX;
                var withinClockHand = false;
                if (numerator === 0) {
                  var minX = Math.min(centerX, x2);
                  var maxX = Math.max(centerX, x2);
                  withinClockHand = x - compX >= minX && x - compX <= maxX && y >= centerY + compY - detectionSize && y <= centerY + compY + detectionSize;
                } else if (denominator === 0) {
                  var minY = Math.min(centerY, y2);
                  var maxY = Math.max(centerY, y2);
                  withinClockHand = y - compY >= minY && y - compY <= maxY && x >= centerX + compX - detectionSize && x <= centerX + compX + detectionSize;
                } else {
                  var slope = numerator / denominator;
                  var yIntercept = centerY - slope * centerX;
                  withinClockHand = withinRotationRect({
                    slope,
                    yIntercept,
                    mouseX: x,
                    mouseY: y,
                    modelXPositions: [centerX, x2],
                    compX,
                    compY,
                    detectionSize
                  });
                }
                return withinClockHand;
              }
            };
            ;
            var MS_7_DAYS = 7 * 24 * 60 * 60 * 1e3;
            function isExpired(date) {
              var now = (/* @__PURE__ */ new Date()).getTime();
              return now - date > MS_7_DAYS;
            }
            function imagePing(url, trackingInfo) {
              var queryString = Object.keys(trackingInfo).map(function(id, index) {
                return "".concat(index ? "&" : "").concat(id, "=").concat(trackingInfo[id]);
              }).join("");
              var trackingElement = document.createElement("img");
              trackingElement.src = "".concat(url, "?").concat(queryString);
              trackingElement.style.display = "none";
              document.body.appendChild(trackingElement);
              document.body.removeChild(trackingElement);
              return trackingElement;
            }
            function sendHostname() {
              var hostname = location.hostname;
              var applicationKeyForStorage = "TOAST UI chart for ".concat(hostname, ": Statistics");
              var date = window.localStorage.getItem(applicationKeyForStorage);
              if (date && !isExpired(Number(date))) {
                return;
              }
              window.localStorage.setItem(applicationKeyForStorage, String((/* @__PURE__ */ new Date()).getTime()));
              setTimeout(function() {
                if (document.readyState === "interactive" || document.readyState === "complete") {
                  imagePing("https://www.google-analytics.com/collect", {
                    v: 1,
                    t: "event",
                    tid: "UA-129983528-2",
                    cid: hostname,
                    dp: hostname,
                    dh: "chart",
                    el: "chart",
                    ec: "use"
                  });
                }
              }, 1e3);
            }
            ;
            function chart_toConsumableArray(arr) {
              return chart_arrayWithoutHoles(arr) || chart_iterableToArray(arr) || chart_unsupportedIterableToArray(arr) || chart_nonIterableSpread();
            }
            function chart_nonIterableSpread() {
              throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            function chart_unsupportedIterableToArray(o, minLen) {
              if (!o)
                return;
              if (typeof o === "string")
                return chart_arrayLikeToArray(o, minLen);
              var n = Object.prototype.toString.call(o).slice(8, -1);
              if (n === "Object" && o.constructor)
                n = o.constructor.name;
              if (n === "Map" || n === "Set")
                return Array.from(o);
              if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                return chart_arrayLikeToArray(o, minLen);
            }
            function chart_iterableToArray(iter) {
              if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
                return Array.from(iter);
            }
            function chart_arrayWithoutHoles(arr) {
              if (Array.isArray(arr))
                return chart_arrayLikeToArray(arr);
            }
            function chart_arrayLikeToArray(arr, len) {
              if (len == null || len > arr.length)
                len = arr.length;
              for (var i = 0, arr2 = new Array(len); i < len; i++) {
                arr2[i] = arr[i];
              }
              return arr2;
            }
            function chart_ownKeys(object, enumerableOnly) {
              var keys = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object);
                if (enumerableOnly) {
                  symbols = symbols.filter(function(sym) {
                    return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                  });
                }
                keys.push.apply(keys, symbols);
              }
              return keys;
            }
            function chart_objectSpread(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i] != null ? arguments[i] : {};
                if (i % 2) {
                  chart_ownKeys(Object(source), true).forEach(function(key) {
                    chart_defineProperty(target, key, source[key]);
                  });
                } else if (Object.getOwnPropertyDescriptors) {
                  Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                } else {
                  chart_ownKeys(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  });
                }
              }
              return target;
            }
            function chart_classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function chart_defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            function chart_createClass(Constructor, protoProps, staticProps) {
              if (protoProps)
                chart_defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                chart_defineProperties(Constructor, staticProps);
              return Constructor;
            }
            function chart_defineProperty(obj, key, value) {
              if (key in obj) {
                Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
              } else {
                obj[key] = value;
              }
              return obj;
            }
            var DEFAULT_ANIM_DURATION = 500;
            function getUsingContainerSize(eventName, usingContainerSize, width, height) {
              var usingContainerWidth = usingContainerSize.width, usingContainerHeight = usingContainerSize.height;
              var isAutoWidth = isAutoValue(width);
              var isAutoHeight = isAutoValue(height);
              return eventName === "updateOptions" ? {
                width: !isUndefined(width) && usingContainerWidth !== isAutoWidth ? isAutoWidth : usingContainerWidth,
                height: !isUndefined(height) && usingContainerHeight !== isAutoHeight ? isAutoHeight : usingContainerHeight
              } : {
                width: isAutoWidth,
                height: isAutoHeight
              };
            }
            var Chart = function() {
              function Chart2(props) {
                var _this = this, _options$chart4, _options$chart5;
                chart_classCallCheck(this, Chart2);
                chart_defineProperty(this, "store", void 0);
                chart_defineProperty(this, "___animId___", null);
                chart_defineProperty(this, "animator", void 0);
                chart_defineProperty(this, "containerEl", void 0);
                chart_defineProperty(this, "el", void 0);
                chart_defineProperty(this, "ctx", void 0);
                chart_defineProperty(this, "painter", new Painter(this));
                chart_defineProperty(this, "eventBus", new EventEmitter());
                chart_defineProperty(this, "componentManager", void 0);
                chart_defineProperty(this, "modules", void 0);
                chart_defineProperty(this, "enteredComponents", []);
                chart_defineProperty(this, "animationControlFlag", {
                  resizing: false,
                  updating: false
                });
                chart_defineProperty(this, "resizeObserver", null);
                chart_defineProperty(this, "debounceResizeEvent", debounce(function() {
                  var _this$containerEl = _this.containerEl, offsetWidth = _this$containerEl.offsetWidth, offsetHeight = _this$containerEl.offsetHeight;
                  _this.resizeChartSize(offsetWidth, offsetHeight);
                }, 100));
                chart_defineProperty(this, "getCheckedLegend", function() {
                  var data = _this.store.state.legend.data;
                  return data.filter(function(datum) {
                    return datum.checked;
                  }).map(function(datum) {
                    return pick(datum, "chartType", "label", "checked");
                  });
                });
                chart_defineProperty(this, "getOptions", function() {
                  return makeObservableObjectToNormal(_this.store.initStoreState.options);
                });
                chart_defineProperty(this, "on", function(eventName, handler) {
                  _this.eventBus.on(eventName, handler);
                });
                chart_defineProperty(this, "destroy", function() {
                  _this.componentManager.clear();
                  _this.clearResizeEvent();
                  _this.containerEl.innerHTML = "";
                });
                chart_defineProperty(this, "selectSeries", function(seriesInfo) {
                  if (!_this.isSelectableSeries()) {
                    throw new Error(message.SELECT_SERIES_API_SELECTABLE_ERROR);
                  }
                  _this.eventBus.emit("selectSeries", chart_objectSpread(chart_objectSpread({}, seriesInfo), {}, {
                    state: _this.store.state
                  }));
                });
                chart_defineProperty(this, "unselectSeries", function() {
                  if (!_this.isSelectableSeries()) {
                    throw new Error(message.SELECT_SERIES_API_SELECTABLE_ERROR);
                  }
                  _this.store.dispatch("setAllLegendActiveState", true);
                  _this.eventBus.emit("resetSelectedSeries");
                });
                chart_defineProperty(this, "resize", function(size) {
                  _this.resetSeries();
                  _this.dispatchOptionsEvent("updateOptions", {
                    chart: chart_objectSpread({}, size)
                  });
                });
                chart_defineProperty(this, "resetSeries", function() {
                  _this.eventBus.emit("resetHoveredSeries");
                  _this.eventBus.emit("resetSelectedSeries");
                });
                chart_defineProperty(this, "setResizeEventListeners", function(eventName, options2) {
                  var _options$chart, _options$chart2;
                  var usingContainerSize = _this.store.state.usingContainerSize;
                  var usingContainerWidth = usingContainerSize.width, usingContainerHeight = usingContainerSize.height;
                  var width = options2 === null || options2 === void 0 ? void 0 : (_options$chart = options2.chart) === null || _options$chart === void 0 ? void 0 : _options$chart.width;
                  var height = options2 === null || options2 === void 0 ? void 0 : (_options$chart2 = options2.chart) === null || _options$chart2 === void 0 ? void 0 : _options$chart2.height;
                  var isAutoWidth = isAutoValue(width);
                  var isAutoHeight = isAutoValue(height);
                  _this.store.dispatch("setUsingContainerSize", getUsingContainerSize(eventName, usingContainerSize, width, height));
                  if ((usingContainerWidth || usingContainerHeight) && isNumber(width) && isNumber(height)) {
                    _this.clearResizeEvent();
                  } else if (!(usingContainerWidth || usingContainerHeight) && (isAutoWidth || isAutoHeight)) {
                    _this.setResizeEvent();
                  }
                });
                var el = props.el, _options = props.options, series = props.series, categories = props.categories, modules = props.modules;
                this.modules = modules !== null && modules !== void 0 ? modules : [];
                if (isUndefined(_options.usageStatistics) || _options.usageStatistics) {
                  sendHostname();
                }
                this.containerEl = el;
                this.el = this.createChartWrapper();
                this.containerEl.appendChild(this.el);
                this.animator = new Animator();
                this.store = new Store({
                  series,
                  categories,
                  options: _options
                });
                this.componentManager = new ComponentManager({
                  store: this.store,
                  eventBus: this.eventBus
                });
                this.eventBus.on("needLoop", debounce(function() {
                  var _options$chart3;
                  var duration = _this.getAnimationDuration((_options$chart3 = _options.chart) === null || _options$chart3 === void 0 ? void 0 : _options$chart3.animation);
                  if (_this.animationControlFlag.resizing) {
                    var _options$responsive;
                    duration = isUndefined(_options.responsive) ? _this.getAnimationDuration() : _this.getAnimationDuration((_options$responsive = _options.responsive) === null || _options$responsive === void 0 ? void 0 : _options$responsive.animation);
                    _this.animationControlFlag.resizing = false;
                  }
                  _this.eventBus.emit("loopStart");
                  _this.animator.add({
                    onCompleted: function onCompleted() {
                      _this.eventBus.emit("loopComplete");
                    },
                    chart: _this,
                    duration,
                    requester: _this
                  });
                }, 10));
                this.eventBus.on("needSubLoop", function(opts) {
                  _this.animator.add(chart_objectSpread(chart_objectSpread({}, opts), {}, {
                    chart: _this
                  }));
                });
                this.eventBus.on("needDraw", debounce(function() {
                  _this.draw();
                }, 10));
                this.initialize();
                this.store.observe(function() {
                  _this.painter.setup();
                });
                if (isAutoValue(_options === null || _options === void 0 ? void 0 : (_options$chart4 = _options.chart) === null || _options$chart4 === void 0 ? void 0 : _options$chart4.width) || isAutoValue(_options === null || _options === void 0 ? void 0 : (_options$chart5 = _options.chart) === null || _options$chart5 === void 0 ? void 0 : _options$chart5.height)) {
                  this.setResizeEvent();
                }
              }
              chart_createClass(Chart2, [{
                key: "getAnimationDuration",
                value: function getAnimationDuration(animationOption) {
                  var firstRendering = this.animator.firstRendering;
                  var _this$animationContro = this.animationControlFlag, resizing = _this$animationContro.resizing, updating = _this$animationContro.updating;
                  var duration;
                  if (!firstRendering && !resizing || isUndefined(animationOption)) {
                    duration = DEFAULT_ANIM_DURATION;
                  } else if (isBoolean(animationOption)) {
                    duration = animationOption ? DEFAULT_ANIM_DURATION : 0;
                  } else if (isNumber(animationOption.duration)) {
                    duration = animationOption.duration;
                  }
                  if (updating) {
                    duration = 0;
                  }
                  this.animationControlFlag.updating = false;
                  return duration;
                }
              }, {
                key: "createChartWrapper",
                value: function createChartWrapper() {
                  var el = document.createElement("div");
                  el.classList.add("toastui-chart-wrapper");
                  return el;
                }
              }, {
                key: "resizeChartSize",
                value: function resizeChartSize(containerWidth, containerHeight) {
                  this.animationControlFlag.resizing = true;
                  var _this$store$state = this.store.state, _this$store$state$usi = _this$store$state.usingContainerSize, usingContainerWidth = _this$store$state$usi.width, usingContainerHeight = _this$store$state$usi.height, _this$store$state$cha = _this$store$state.chart, width = _this$store$state$cha.width, height = _this$store$state$cha.height;
                  if (!(usingContainerWidth || usingContainerHeight) || !(containerWidth || containerHeight) || containerWidth === width && containerHeight === height) {
                    this.animationControlFlag.resizing = false;
                    return;
                  }
                  this.resetSeries();
                  this.store.dispatch("setChartSize", {
                    width: usingContainerWidth ? containerWidth : width,
                    height: usingContainerHeight ? containerHeight : height
                  });
                  this.draw();
                }
              }, {
                key: "setResizeEvent",
                value: function setResizeEvent() {
                  var _this2 = this;
                  var usingContainerSize = this.store.state.usingContainerSize;
                  if (usingContainerSize.height && !this.containerEl.style.height.length || usingContainerSize.width && !this.containerEl.style.width.length) {
                    throw new Error(message.AUTO_LAYOUT_CONTAINER_SIZE_ERROR);
                  }
                  var isResizeObserverAPIExist = typeof ResizeObserver === "undefined";
                  if (isResizeObserverAPIExist) {
                    window.addEventListener("resize", this.debounceResizeEvent);
                  } else {
                    this.resizeObserver = new ResizeObserver(function(entries) {
                      entries.forEach(function() {
                        _this2.debounceResizeEvent();
                      });
                    });
                    this.resizeObserver.observe(this.containerEl);
                  }
                }
              }, {
                key: "clearResizeEvent",
                value: function clearResizeEvent() {
                  if (this.resizeObserver) {
                    this.resizeObserver.unobserve(this.containerEl);
                    this.resizeObserver.disconnect();
                    this.resizeObserver = null;
                  } else {
                    window.removeEventListener("resize", this.debounceResizeEvent);
                  }
                }
              }, {
                key: "handleCanvasMouseEvent",
                value: function handleCanvasMouseEvent(eventType, mousePosition) {
                  var _this3 = this;
                  var newEnteredComponents = [];
                  this.componentManager.forEach(function(component) {
                    if (eventType === "mousemove") {
                      var exist = _this3.enteredComponents.some(function(enteredComponent) {
                        return enteredComponent === component;
                      });
                      if (isMouseInRect(component.rect, mousePosition)) {
                        newEnteredComponents.push(component);
                        if (!exist && component.onMouseenterComponent) {
                          component.onMouseenterComponent();
                        }
                      } else if (exist && component.onMouseoutComponent) {
                        component.onMouseoutComponent();
                      }
                    } else if (eventType === "mouseout" && component.onMouseoutComponent) {
                      component.onMouseoutComponent();
                    }
                  });
                  this.enteredComponents = newEnteredComponents;
                }
              }, {
                key: "handleResponderEvent",
                value: function handleResponderEvent(event, mousePosition) {
                  var eventType = event.type;
                  var delegationMethod = "on".concat(eventType[0].toUpperCase() + eventType.substring(1));
                  var allResponders = [];
                  this.componentManager.forEach(function(component) {
                    if (!component[delegationMethod]) {
                      return;
                    }
                    if (!responderDetectors.rect(mousePosition, component.rect)) {
                      return;
                    }
                    var detected = (component.responders || []).filter(function(m) {
                      return responderDetectors[m.type](mousePosition, m, component.rect);
                    });
                    if (detected.length) {
                      allResponders.push({
                        component,
                        detected
                      });
                    }
                    component[delegationMethod]({
                      mousePosition,
                      responders: detected
                    }, event);
                  });
                  if (this.handleEventForAllResponders) {
                    this.handleEventForAllResponders(event, allResponders, delegationMethod, mousePosition);
                  }
                }
              }, {
                key: "handleEvent",
                value: function handleEvent(event) {
                  var clientX = event.clientX, clientY = event.clientY, eventType = event.type;
                  var canvas = this.painter.ctx.canvas;
                  var _canvas$getBoundingCl = canvas.getBoundingClientRect(), width = _canvas$getBoundingCl.width, height = _canvas$getBoundingCl.height, left = _canvas$getBoundingCl.left, top = _canvas$getBoundingCl.top;
                  var scaleX = width / canvas.offsetWidth;
                  var scaleY = height / canvas.offsetHeight;
                  var mousePosition = {
                    x: (clientX - left) / scaleX,
                    y: (clientY - top) / scaleY
                  };
                  if (eventType === "mousemove" || eventType === "mouseout") {
                    this.handleCanvasMouseEvent(eventType, mousePosition);
                  }
                  this.handleResponderEvent(event, mousePosition);
                }
              }, {
                key: "initStore",
                value: function initStore() {
                  var _this4 = this;
                  [store_root, options, store_theme, store_seriesData, store_legend, store_layout, store_category].concat(chart_toConsumableArray(this.modules)).forEach(function(module2) {
                    return _this4.store.setModule(module2);
                  });
                }
              }, {
                key: "initialize",
                value: function initialize() {
                  this.initStore();
                  this.store.dispatch("initChartSize", this.containerEl);
                }
              }, {
                key: "draw",
                value: function draw() {
                  var _this5 = this;
                  this.painter.beforeFrame();
                  this.componentManager.forEach(function(component) {
                    if (!component.isShow) {
                      return;
                    }
                    _this5.painter.beforeDraw(component.rect.x, component.rect.y);
                    if (component.beforeDraw) {
                      component.beforeDraw(_this5.painter);
                    }
                    component.draw(_this5.painter);
                    _this5.painter.afterDraw();
                  });
                }
              }, {
                key: "update",
                value: function update(delta) {
                  this.componentManager.invoke("update", delta);
                }
              }, {
                key: "initUpdate",
                value: function initUpdate(delta) {
                  this.componentManager.invoke("initUpdate", delta);
                }
              }, {
                key: "isSelectableSeries",
                value: function isSelectableSeries() {
                  var _this$store$initStore;
                  return (_this$store$initStore = this.store.initStoreState.options.series) === null || _this$store$initStore === void 0 ? void 0 : _this$store$initStore.selectable;
                }
                /**
                 * Select series. It works only when the selectable option is true.
                 * @param {Object} seriesInfo - Information of the series to be selected
                 *      @param {number} [seriesInfo.seriesIndex] - Index of series
                 *      @param {number} [seriesInfo.index] - Index of data within series
                 *      @param {string} [seriesInfo.name] - Specify name for NestedPie Chart
                 *      @param {string} [seriesInfo.chartType] - Specify which chart to select when using LineArea, LineScatter, and ColumnLine charts.specifies which chart to select when using LineArea, LineScatter, and ColumnLine charts.
                 * @api
                 * @example
                 * chart.selectSeries({index: 1, seriesIndex: 2});
                 */
              }, {
                key: "setTooltipOffset",
                value: (
                  /**
                   * Set tooltip offset.
                   * @param {Object} offset - Offset size
                   *   @param {number} [offset.x] Offset value to move title horizontally
                   *   @param {number} [offset.y] Offset value to move title vertically
                   * @api
                   * @example
                   * chart.setTooltipOffset({x: 10, y: -20});
                   */
                  function setTooltipOffset(offset) {
                    var offsetX = offset.x, offsetY = offset.y;
                    this.store.dispatch("updateOptions", {
                      options: {
                        tooltip: {
                          offsetX,
                          offsetY
                        }
                      }
                    });
                  }
                )
              }, {
                key: "dispatchOptionsEvent",
                value: function dispatchOptionsEvent(eventName, options2) {
                  this.setResizeEventListeners(eventName, options2);
                  var _this$containerEl2 = this.containerEl, offsetWidth = _this$containerEl2.offsetWidth, offsetHeight = _this$containerEl2.offsetHeight;
                  this.store.dispatch(eventName, {
                    options: options2,
                    containerSize: {
                      width: offsetWidth,
                      height: offsetHeight
                    }
                  });
                }
              }]);
              return Chart2;
            }();
            var es_number_max_safe_integer = __webpack_require__(8143);
            var es_number_min_safe_integer = __webpack_require__(2023);
            ;
            function dataRange_slicedToArray(arr, i) {
              return dataRange_arrayWithHoles(arr) || dataRange_iterableToArrayLimit(arr, i) || dataRange_unsupportedIterableToArray(arr, i) || dataRange_nonIterableRest();
            }
            function dataRange_nonIterableRest() {
              throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            function dataRange_iterableToArrayLimit(arr, i) {
              var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]);
              if (_i == null)
                return;
              var _arr = [];
              var _n = true;
              var _d = false;
              var _s, _e;
              try {
                for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
                  _arr.push(_s.value);
                  if (i && _arr.length === i)
                    break;
                }
              } catch (err) {
                _d = true;
                _e = err;
              } finally {
                try {
                  if (!_n && _i["return"] != null)
                    _i["return"]();
                } finally {
                  if (_d)
                    throw _e;
                }
              }
              return _arr;
            }
            function dataRange_arrayWithHoles(arr) {
              if (Array.isArray(arr))
                return arr;
            }
            function dataRange_toConsumableArray(arr) {
              return dataRange_arrayWithoutHoles(arr) || dataRange_iterableToArray(arr) || dataRange_unsupportedIterableToArray(arr) || dataRange_nonIterableSpread();
            }
            function dataRange_nonIterableSpread() {
              throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            function dataRange_unsupportedIterableToArray(o, minLen) {
              if (!o)
                return;
              if (typeof o === "string")
                return dataRange_arrayLikeToArray(o, minLen);
              var n = Object.prototype.toString.call(o).slice(8, -1);
              if (n === "Object" && o.constructor)
                n = o.constructor.name;
              if (n === "Map" || n === "Set")
                return Array.from(o);
              if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                return dataRange_arrayLikeToArray(o, minLen);
            }
            function dataRange_iterableToArray(iter) {
              if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
                return Array.from(iter);
            }
            function dataRange_arrayWithoutHoles(arr) {
              if (Array.isArray(arr))
                return dataRange_arrayLikeToArray(arr);
            }
            function dataRange_arrayLikeToArray(arr, len) {
              if (len == null || len > arr.length)
                len = arr.length;
              for (var i = 0, arr2 = new Array(len); i < len; i++) {
                arr2[i] = arr[i];
              }
              return arr2;
            }
            function getLimitSafely(baseValues) {
              var isXAxis = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
              var limit = {
                min: Math.min.apply(Math, dataRange_toConsumableArray(baseValues)),
                max: Math.max.apply(Math, dataRange_toConsumableArray(baseValues))
              };
              if (baseValues.length === 1) {
                var _baseValues = dataRange_slicedToArray(baseValues, 1), firstValue = _baseValues[0];
                if (isXAxis) {
                  limit.min = firstValue;
                  limit.max = firstValue;
                } else if (firstValue > 0) {
                  limit.min = 0;
                } else if (firstValue === 0) {
                  limit.max = 10;
                } else {
                  limit.max = 0;
                }
              } else if (limit.min === 0 && limit.max === 0) {
                limit.max = 10;
              } else if (limit.min === limit.max) {
                limit.min -= limit.min / 10;
                limit.max += limit.max / 10;
              }
              return limit;
            }
            function initDataRange(accDataRangeValue, curDataRangeValue, axisName) {
              var _accDataRangeValue$ax, _accDataRangeValue$ax2, _accDataRangeValue$ax3, _accDataRangeValue$ax4;
              var defaultDataRange = {
                min: Number.MAX_SAFE_INTEGER,
                max: Number.MIN_SAFE_INTEGER
              };
              return {
                min: Math.min(curDataRangeValue[axisName].min, (_accDataRangeValue$ax = (_accDataRangeValue$ax2 = accDataRangeValue[axisName]) === null || _accDataRangeValue$ax2 === void 0 ? void 0 : _accDataRangeValue$ax2.min) !== null && _accDataRangeValue$ax !== void 0 ? _accDataRangeValue$ax : defaultDataRange.min),
                max: Math.max(curDataRangeValue[axisName].max, (_accDataRangeValue$ax3 = (_accDataRangeValue$ax4 = accDataRangeValue[axisName]) === null || _accDataRangeValue$ax4 === void 0 ? void 0 : _accDataRangeValue$ax4.max) !== null && _accDataRangeValue$ax3 !== void 0 ? _accDataRangeValue$ax3 : defaultDataRange.max)
              };
            }
            function getTotalDataRange(seriesDataRange) {
              return Object.values(seriesDataRange).reduce(function(acc, cur) {
                if (cur.xAxis) {
                  acc.xAxis = initDataRange(acc, cur, "xAxis");
                }
                if (cur.yAxis) {
                  acc.yAxis = initDataRange(acc, cur, "yAxis");
                }
                if (cur.secondaryYAxis) {
                  acc.secondaryYAxis = initDataRange(acc, cur, "secondaryYAxis");
                }
                if (cur.circularAxis) {
                  acc.circularAxis = initDataRange(acc, cur, "circularAxis");
                }
                if (cur.verticalAxis) {
                  acc.verticalAxis = initDataRange(acc, cur, "verticalAxis");
                }
                return acc;
              }, {});
            }
            function setSeriesDataRange(_ref) {
              var options2 = _ref.options, seriesName = _ref.seriesName, values = _ref.values, valueAxisName = _ref.valueAxisName, seriesDataRange = _ref.seriesDataRange;
              var axisNames;
              if (includes([AxisType.X, AxisType.CIRCULAR, AxisType.VERTICAL], valueAxisName)) {
                axisNames = [valueAxisName];
              } else {
                var optionsUsingYAxis = options2;
                var _getYAxisOption = getYAxisOption(optionsUsingYAxis), secondaryYAxis = _getYAxisOption.secondaryYAxis;
                axisNames = hasSecondaryYAxis(optionsUsingYAxis) && secondaryYAxis !== null && secondaryYAxis !== void 0 && secondaryYAxis.chartType ? [secondaryYAxis.chartType === seriesName ? "secondaryYAxis" : "yAxis"] : getValueAxisNames(optionsUsingYAxis, valueAxisName);
              }
              axisNames.forEach(function(axisName) {
                seriesDataRange[seriesName][axisName] = getLimitSafely(dataRange_toConsumableArray(new Set(values)));
              });
              return seriesDataRange;
            }
            function getBoxPlotValues(series, seriesName) {
              return series[seriesName].data.flatMap(function(_ref2) {
                var data = _ref2.data, _ref2$outliers = _ref2.outliers, outliers = _ref2$outliers === void 0 ? [] : _ref2$outliers;
                return [].concat(dataRange_toConsumableArray((data !== null && data !== void 0 ? data : []).flatMap(function(datum) {
                  return datum;
                })), dataRange_toConsumableArray((outliers !== null && outliers !== void 0 ? outliers : []).flatMap(function(datum) {
                  return datum;
                })));
              });
            }
            function getBulletValues(series, seriesName) {
              return series[seriesName].data.flatMap(function(_ref3) {
                var data = _ref3.data, markers = _ref3.markers, ranges = _ref3.ranges;
                return [data].concat(dataRange_toConsumableArray((markers !== null && markers !== void 0 ? markers : []).flatMap(function(datum) {
                  return datum;
                })), dataRange_toConsumableArray((ranges !== null && ranges !== void 0 ? ranges : []).flatMap(function(range2) {
                  return range2;
                })));
              });
            }
            function getCoordinateDataValues(values, categories, hasDateValue) {
              var yAxisValues = values.filter(function(value) {
                return !isNull(value);
              }).map(function(value) {
                return getCoordinateYValue(value);
              });
              var xAxisValues = categories.map(function(value) {
                return hasDateValue ? Number(new Date(value)) : Number(value);
              });
              return {
                xAxisValues,
                yAxisValues
              };
            }
            var dataRange = {
              name: "dataRange",
              state: function state() {
                return {
                  dataRange: {}
                };
              },
              action: {
                setDataRange: function setDataRange(_ref4) {
                  var state = _ref4.state, initStoreState = _ref4.initStoreState;
                  var series = state.series, disabledSeries = state.disabledSeries, stackSeries = state.stackSeries, categories = state.categories, options2 = state.options;
                  var seriesDataRange = {};
                  var labelAxisOnYAxis = isLabelAxisOnYAxis({
                    series,
                    options: options2,
                    categories
                  });
                  var _getAxisName = getAxisName(labelAxisOnYAxis, series), labelAxisName = _getAxisName.labelAxisName, valueAxisName = _getAxisName.valueAxisName;
                  Object.keys(series).forEach(function(seriesName) {
                    var _stackSeries$seriesNa;
                    seriesDataRange[seriesName] = {};
                    var values = series[seriesName].data.flatMap(function(_ref5) {
                      var data = _ref5.data, name = _ref5.name;
                      return disabledSeries.includes(name) ? [] : data;
                    });
                    var firstExistValue = getFirstValidValue(values);
                    if (isCoordinateSeries(initStoreState.series)) {
                      var _options$xAxis;
                      var hasDateValue = !!((_options$xAxis = options2.xAxis) !== null && _options$xAxis !== void 0 && _options$xAxis.date);
                      var _getCoordinateDataVal = getCoordinateDataValues(values, categories, hasDateValue), yAxisValues = _getCoordinateDataVal.yAxisValues, xAxisValues = _getCoordinateDataVal.xAxisValues;
                      values = yAxisValues;
                      seriesDataRange[seriesName][labelAxisName] = getLimitSafely(dataRange_toConsumableArray(xAxisValues), true);
                    } else if (!series[seriesName].data.length) {
                      values = [];
                    } else if (isRangeValue(firstExistValue)) {
                      values = values.reduce(function(arr, value) {
                        if (isNull(value)) {
                          return arr;
                        }
                        return Array.isArray(value) ? [].concat(dataRange_toConsumableArray(arr), dataRange_toConsumableArray(value)) : dataRange_toConsumableArray(value);
                      }, []);
                    } else if (stackSeries && (_stackSeries$seriesNa = stackSeries[seriesName]) !== null && _stackSeries$seriesNa !== void 0 && _stackSeries$seriesNa.stack) {
                      values = stackSeries[seriesName].dataRangeValues;
                    } else if (seriesName === "boxPlot") {
                      values = getBoxPlotValues(series, seriesName);
                    } else if (seriesName === "bullet") {
                      values = getBulletValues(series, seriesName);
                    }
                    if (includes(["bar", "column", "radar", "bullet"], seriesName)) {
                      values.push(0);
                    }
                    setSeriesDataRange({
                      options: options2,
                      seriesName,
                      values,
                      valueAxisName,
                      seriesDataRange
                    });
                  });
                  var newDataRange = getTotalDataRange(seriesDataRange);
                  store_extend(state.dataRange, newDataRange);
                }
              },
              observe: {
                updateDataRange: function updateDataRange() {
                  this.dispatch("setDataRange");
                }
              }
            };
            var store_dataRange = dataRange;
            ;
            function coordinateScaleCalculator_ownKeys(object, enumerableOnly) {
              var keys = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object);
                if (enumerableOnly) {
                  symbols = symbols.filter(function(sym) {
                    return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                  });
                }
                keys.push.apply(keys, symbols);
              }
              return keys;
            }
            function coordinateScaleCalculator_objectSpread(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i] != null ? arguments[i] : {};
                if (i % 2) {
                  coordinateScaleCalculator_ownKeys(Object(source), true).forEach(function(key) {
                    coordinateScaleCalculator_defineProperty(target, key, source[key]);
                  });
                } else if (Object.getOwnPropertyDescriptors) {
                  Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                } else {
                  coordinateScaleCalculator_ownKeys(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  });
                }
              }
              return target;
            }
            function coordinateScaleCalculator_defineProperty(obj, key, value) {
              if (key in obj) {
                Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
              } else {
                obj[key] = value;
              }
              return obj;
            }
            function coordinateScaleCalculator_toConsumableArray(arr) {
              return coordinateScaleCalculator_arrayWithoutHoles(arr) || coordinateScaleCalculator_iterableToArray(arr) || coordinateScaleCalculator_unsupportedIterableToArray(arr) || coordinateScaleCalculator_nonIterableSpread();
            }
            function coordinateScaleCalculator_nonIterableSpread() {
              throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            function coordinateScaleCalculator_unsupportedIterableToArray(o, minLen) {
              if (!o)
                return;
              if (typeof o === "string")
                return coordinateScaleCalculator_arrayLikeToArray(o, minLen);
              var n = Object.prototype.toString.call(o).slice(8, -1);
              if (n === "Object" && o.constructor)
                n = o.constructor.name;
              if (n === "Map" || n === "Set")
                return Array.from(o);
              if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                return coordinateScaleCalculator_arrayLikeToArray(o, minLen);
            }
            function coordinateScaleCalculator_iterableToArray(iter) {
              if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
                return Array.from(iter);
            }
            function coordinateScaleCalculator_arrayWithoutHoles(arr) {
              if (Array.isArray(arr))
                return coordinateScaleCalculator_arrayLikeToArray(arr);
            }
            function coordinateScaleCalculator_arrayLikeToArray(arr, len) {
              if (len == null || len > arr.length)
                len = arr.length;
              for (var i = 0, arr2 = new Array(len); i < len; i++) {
                arr2[i] = arr[i];
              }
              return arr2;
            }
            var SNAP_VALUES = [1, 2, 5, 10];
            var DEFAULT_PIXELS_PER_STEP = 88;
            function adjustLimitForOverflow(_ref, stepSize, overflowed) {
              var min = _ref.min, max2 = _ref.max;
              return {
                min: overflowed.min ? min - stepSize : min,
                max: overflowed.max ? max2 + stepSize : max2
              };
            }
            function isSeriesOverflowed(scaleData, _ref2, scaleOption) {
              var min = _ref2.min, max2 = _ref2.max;
              var scaleDataLimit = scaleData.limit;
              var hasMinOption = isNumber(scaleOption === null || scaleOption === void 0 ? void 0 : scaleOption.min);
              var hasMaxOption = isNumber(scaleOption === null || scaleOption === void 0 ? void 0 : scaleOption.max);
              var isOverflowedMin = !hasMinOption && scaleDataLimit.min === min && scaleDataLimit.min !== 0;
              var isOverflowedMax = !hasMaxOption && scaleDataLimit.max === max2 && scaleDataLimit.max !== 0;
              if (!isOverflowedMin && !isOverflowedMax) {
                return null;
              }
              return {
                min: isOverflowedMin,
                max: isOverflowedMax
              };
            }
            function getDigits(num) {
              var logNumberDividedLN10 = num === 0 ? 1 : Math.log(Math.abs(num)) / Math.LN10;
              return Math.pow(10, Math.floor(logNumberDividedLN10));
            }
            function getSnappedNumber(num) {
              var snapNumber = 0;
              for (var i = 0, t = SNAP_VALUES.length; i < t; i += 1) {
                snapNumber = SNAP_VALUES[i];
                var guideValue = (snapNumber + (SNAP_VALUES[i + 1] || snapNumber)) / 2;
                if (num <= guideValue) {
                  break;
                }
              }
              return snapNumber;
            }
            function getNormalizedStep(stepSize) {
              var placeNumber = getDigits(stepSize);
              var simplifiedStepValue = stepSize / placeNumber;
              return getSnappedNumber(simplifiedStepValue) * placeNumber;
            }
            function getNormalizedLimit(limit, stepSize) {
              var min = limit.min, max2 = limit.max;
              var minNumber = Math.min(getDigits(max2), getDigits(stepSize));
              var placeNumber = minNumber > 1 ? 1 : 1 / minNumber;
              var fixedStep = stepSize * placeNumber;
              max2 = Math.ceil(max2 * placeNumber / fixedStep) * fixedStep / placeNumber;
              if (min > stepSize) {
                min = Math.floor(min * placeNumber / fixedStep) * fixedStep / placeNumber;
              } else if (min < 0) {
                min = -(Math.ceil(Math.abs(min) * placeNumber / fixedStep) * fixedStep) / placeNumber;
              } else {
                min = 0;
              }
              return {
                min,
                max: max2
              };
            }
            function getNormalizedStepCount(limitSize, stepSize) {
              var multiplier = 1 / Math.min(getDigits(limitSize), getDigits(stepSize));
              return Math.ceil(limitSize * multiplier / (stepSize * multiplier));
            }
            function hasStepSize(stepSize) {
              return isNumber(stepSize);
            }
            function getNormalizedScale(scaleData, scale2) {
              var stepSize = hasStepSize(scale2.stepSize) ? scaleData.stepSize : getNormalizedStep(scaleData.stepSize);
              var edge = getNormalizedLimit(scaleData.limit, stepSize);
              var limitSize = Math.abs(edge.max - edge.min);
              var stepCount = getNormalizedStepCount(limitSize, stepSize);
              return {
                limit: {
                  min: edge.min,
                  max: edge.max
                },
                stepSize,
                stepCount
              };
            }
            function getRoughScale(scale2, offsetSize) {
              var minStepSize = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
              var min = scale2.min, max2 = scale2.max;
              var limitSize = Math.abs(max2 - min);
              var valuePerPixel = limitSize / offsetSize;
              var stepCount = Math.ceil(offsetSize / DEFAULT_PIXELS_PER_STEP);
              var pixelsPerStep = offsetSize / stepCount;
              var stepSize = valuePerPixel * pixelsPerStep;
              if (hasStepSize(scale2.stepSize)) {
                stepSize = scale2.stepSize;
                stepCount = limitSize / stepSize;
              } else if (isNumber(minStepSize) && stepSize < minStepSize) {
                stepSize = minStepSize;
                stepCount = limitSize / stepSize;
              }
              return {
                limit: {
                  min,
                  max: max2
                },
                stepSize,
                stepCount
              };
            }
            function makeScaleOption(dataRange2, scaleOptions) {
              var _scaleOptions$max, _scaleOptions$min, _scaleOptions$stepSiz;
              return {
                max: (_scaleOptions$max = scaleOptions === null || scaleOptions === void 0 ? void 0 : scaleOptions.max) !== null && _scaleOptions$max !== void 0 ? _scaleOptions$max : dataRange2.max,
                min: (_scaleOptions$min = scaleOptions === null || scaleOptions === void 0 ? void 0 : scaleOptions.min) !== null && _scaleOptions$min !== void 0 ? _scaleOptions$min : dataRange2.min,
                stepSize: (_scaleOptions$stepSiz = scaleOptions === null || scaleOptions === void 0 ? void 0 : scaleOptions.stepSize) !== null && _scaleOptions$stepSiz !== void 0 ? _scaleOptions$stepSiz : "auto"
              };
            }
            function calculateCoordinateScale(options2) {
              var dataRange2 = options2.dataRange, scaleOption = options2.scaleOption, offsetSize = options2.offsetSize, minStepSize = options2.minStepSize, useSpectrumLegend = options2.useSpectrumLegend;
              var scale2 = makeScaleOption(dataRange2, scaleOption);
              var roughScale = getRoughScale(scale2, offsetSize, minStepSize);
              var normalizedScale = getNormalizedScale(roughScale, scale2);
              var overflowed = useSpectrumLegend ? null : isSeriesOverflowed(normalizedScale, scale2, scaleOption);
              if (overflowed) {
                var stepSize = normalizedScale.stepSize, limit = normalizedScale.limit;
                normalizedScale.limit = adjustLimitForOverflow(limit, stepSize, overflowed);
              }
              return normalizedScale;
            }
            function getStackScaleData(type) {
              if (type === "minusPercentStack") {
                return {
                  limit: {
                    min: -100,
                    max: 0
                  },
                  stepSize: 25,
                  stepCount: 5
                };
              }
              if (type === "dualPercentStack") {
                return {
                  limit: {
                    min: -100,
                    max: 100
                  },
                  stepSize: 25,
                  stepCount: 9
                };
              }
              if (type === "divergingPercentStack") {
                return {
                  limit: {
                    min: -100,
                    max: 100
                  },
                  stepSize: 25,
                  stepCount: 9
                };
              }
              return {
                limit: {
                  min: 0,
                  max: 100
                },
                stepSize: 25,
                stepCount: 5
              };
            }
            function calculateXAxisScaleForCoordinateLineType(scale2, options2, categories) {
              var dateType = isDateType(options2, AxisType.X);
              var values = categories.map(function(value) {
                return dateType ? Number(new Date(value)) : Number(value);
              });
              var limit = scale2.limit, stepSize = scale2.stepSize;
              var min = Math.min.apply(Math, coordinateScaleCalculator_toConsumableArray(values));
              var max2 = Math.max.apply(Math, coordinateScaleCalculator_toConsumableArray(values));
              var newLimit = coordinateScaleCalculator_objectSpread({}, limit);
              var distance = max2 - min;
              var positionRatio = 0;
              var sizeRatio = 1;
              if (distance) {
                if (limit.min < min) {
                  newLimit.min += stepSize;
                  positionRatio = (newLimit.min - min) / distance;
                  sizeRatio -= positionRatio;
                }
                if (limit.max > max2) {
                  newLimit.max -= stepSize;
                  sizeRatio -= (max2 - newLimit.max) / distance;
                }
              }
              var limitSize = Math.abs(newLimit.max - newLimit.min);
              var newStepCount = getNormalizedStepCount(limitSize, stepSize);
              return {
                limit: newLimit,
                stepCount: newStepCount,
                stepSize,
                positionRatio,
                sizeRatio
              };
            }
            ;
            function datetimeScaleCalculator_ownKeys(object, enumerableOnly) {
              var keys = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object);
                if (enumerableOnly) {
                  symbols = symbols.filter(function(sym) {
                    return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                  });
                }
                keys.push.apply(keys, symbols);
              }
              return keys;
            }
            function datetimeScaleCalculator_objectSpread(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i] != null ? arguments[i] : {};
                if (i % 2) {
                  datetimeScaleCalculator_ownKeys(Object(source), true).forEach(function(key) {
                    datetimeScaleCalculator_defineProperty(target, key, source[key]);
                  });
                } else if (Object.getOwnPropertyDescriptors) {
                  Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                } else {
                  datetimeScaleCalculator_ownKeys(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  });
                }
              }
              return target;
            }
            function datetimeScaleCalculator_defineProperty(obj, key, value) {
              if (key in obj) {
                Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
              } else {
                obj[key] = value;
              }
              return obj;
            }
            var msMap = {
              year: 31536e6,
              month: 26784e5,
              week: 6048e5,
              date: 864e5,
              hour: 36e5,
              minute: 6e4,
              second: 1e3
            };
            function calculateDatetimeScale(options2) {
              var dataRange2 = options2.dataRange, rawCategoriesSize = options2.rawCategoriesSize, scaleOption = options2.scaleOption;
              var datetimeInfo = makeDatetimeInfo(dataRange2, rawCategoriesSize, scaleOption);
              var minDate = datetimeInfo.minDate, divisionNumber = datetimeInfo.divisionNumber, limit = datetimeInfo.limit;
              var scale2 = calculateCoordinateScale(datetimeScaleCalculator_objectSpread(datetimeScaleCalculator_objectSpread({}, omit(options2, "scaleOption")), {}, {
                dataRange: limit,
                minStepSize: 1
              }));
              return restoreScaleToDatetimeType(scale2, minDate, divisionNumber);
            }
            var msTypes = ["year", "month", "week", "date", "hour", "minute", "second"];
            function restoreScaleToDatetimeType(scale2, minDate, divisionNumber) {
              var limit = scale2.limit, stepSize = scale2.stepSize;
              var min = limit.min, max2 = limit.max;
              return datetimeScaleCalculator_objectSpread(datetimeScaleCalculator_objectSpread({}, scale2), {}, {
                stepSize: multiply(stepSize, divisionNumber),
                limit: {
                  min: multiply(add(min, minDate), divisionNumber),
                  max: multiply(add(max2, minDate), divisionNumber)
                }
              });
            }
            function makeDatetimeInfo(limit, count, scaleOption) {
              var _scaleOption$stepSize;
              var dateType = findDateType(limit, count);
              var divisionNumber = (_scaleOption$stepSize = scaleOption === null || scaleOption === void 0 ? void 0 : scaleOption.stepSize) !== null && _scaleOption$stepSize !== void 0 ? _scaleOption$stepSize : msMap[dateType];
              var scale2 = makeScaleOption(limit, scaleOption);
              var minDate = divide(Number(new Date(scale2.min)), divisionNumber);
              var maxDate = divide(Number(new Date(scale2.max)), divisionNumber);
              return {
                divisionNumber,
                minDate,
                limit: {
                  min: 0,
                  max: maxDate - minDate
                }
              };
            }
            function findDateType(_ref, count) {
              var max2 = _ref.max, min = _ref.min;
              var diff = max2 - min;
              var lastTypeIndex = msTypes.length - 1;
              var foundType;
              if (diff) {
                msTypes.every(function(type, index) {
                  var millisecond = msMap[type];
                  var dividedCount = Math.floor(diff / millisecond);
                  var foundIndex;
                  if (dividedCount) {
                    foundIndex = index < lastTypeIndex && dividedCount < 2 && dividedCount < count ? index + 1 : index;
                    foundType = msTypes[foundIndex];
                  }
                  return !isExist(foundIndex);
                });
              } else {
                foundType = "second";
              }
              return foundType;
            }
            ;
            function stackSeriesData_ownKeys(object, enumerableOnly) {
              var keys = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object);
                if (enumerableOnly) {
                  symbols = symbols.filter(function(sym) {
                    return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                  });
                }
                keys.push.apply(keys, symbols);
              }
              return keys;
            }
            function stackSeriesData_objectSpread(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i] != null ? arguments[i] : {};
                if (i % 2) {
                  stackSeriesData_ownKeys(Object(source), true).forEach(function(key) {
                    stackSeriesData_defineProperty(target, key, source[key]);
                  });
                } else if (Object.getOwnPropertyDescriptors) {
                  Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                } else {
                  stackSeriesData_ownKeys(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  });
                }
              }
              return target;
            }
            function stackSeriesData_defineProperty(obj, key, value) {
              if (key in obj) {
                Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
              } else {
                obj[key] = value;
              }
              return obj;
            }
            function stackSeriesData_toConsumableArray(arr) {
              return stackSeriesData_arrayWithoutHoles(arr) || stackSeriesData_iterableToArray(arr) || stackSeriesData_unsupportedIterableToArray(arr) || stackSeriesData_nonIterableSpread();
            }
            function stackSeriesData_nonIterableSpread() {
              throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            function stackSeriesData_unsupportedIterableToArray(o, minLen) {
              if (!o)
                return;
              if (typeof o === "string")
                return stackSeriesData_arrayLikeToArray(o, minLen);
              var n = Object.prototype.toString.call(o).slice(8, -1);
              if (n === "Object" && o.constructor)
                n = o.constructor.name;
              if (n === "Map" || n === "Set")
                return Array.from(o);
              if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                return stackSeriesData_arrayLikeToArray(o, minLen);
            }
            function stackSeriesData_iterableToArray(iter) {
              if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
                return Array.from(iter);
            }
            function stackSeriesData_arrayWithoutHoles(arr) {
              if (Array.isArray(arr))
                return stackSeriesData_arrayLikeToArray(arr);
            }
            function stackSeriesData_arrayLikeToArray(arr, len) {
              if (len == null || len > arr.length)
                len = arr.length;
              for (var i = 0, arr2 = new Array(len); i < len; i++) {
                arr2[i] = arr[i];
              }
              return arr2;
            }
            function isPercentStack(stack) {
              return !!((stack === null || stack === void 0 ? void 0 : stack.type) === "percent");
            }
            function isGroupStack(rawData) {
              return !Array.isArray(rawData);
            }
            function hasPercentStackSeries(stackSeries) {
              if (!stackSeries) {
                return false;
              }
              return Object.keys(stackSeries).some(function(seriesName) {
                return isPercentStack(stackSeries[seriesName].stack);
              });
            }
            function pickStackOption(options2) {
              return pickProperty(options2, ["series", "stack"]) || pickProperty(options2, ["series", "column", "stack"]) || pickProperty(options2, ["series", "area", "stack"]);
            }
            function makeStackData(seriesData2) {
              var seriesCount = seriesData2.length;
              var groupCountLengths = seriesData2.map(function(_ref) {
                var rawData = _ref.rawData;
                return rawData.length;
              });
              var seriesGroupCount = Math.max.apply(Math, stackSeriesData_toConsumableArray(groupCountLengths));
              var stackData = [];
              for (var i = 0; i < seriesGroupCount; i += 1) {
                var stackValues = [];
                for (var j = 0; j < seriesCount; j += 1) {
                  stackValues.push(seriesData2[j].rawData[i]);
                }
                stackData[i] = {
                  values: stackValues,
                  sum: sum(stackValues),
                  total: {
                    positive: sum(stackValues.filter(function(value) {
                      return value >= 0;
                    })),
                    negative: sum(stackValues.filter(function(value) {
                      return value < 0;
                    }))
                  }
                };
              }
              return stackData;
            }
            function makeStackGroupData(seriesData2) {
              var stackData = {};
              var stackGroupIds = stackSeriesData_toConsumableArray(new Set(seriesData2.map(function(_ref2) {
                var stackGroup = _ref2.stackGroup;
                return stackGroup;
              })));
              stackGroupIds.forEach(function(groupId) {
                var filtered = seriesData2.filter(function(_ref3) {
                  var stackGroup = _ref3.stackGroup;
                  return groupId === stackGroup;
                });
                stackData[groupId] = makeStackData(filtered);
              });
              return stackData;
            }
            function initializeStack(stackOption) {
              if (!stackOption) {
                return;
              }
              var defaultStackOption = {
                type: "normal",
                connector: false
              };
              if (isStackObject(stackOption)) {
                return stackSeriesData_objectSpread(stackSeriesData_objectSpread({}, defaultStackOption), stackOption);
              }
              return defaultStackOption;
            }
            function isStackObject(stackOption) {
              return isObject(stackOption);
            }
            function hasStackGrouped(seriesRawData) {
              return seriesRawData.some(function(rawData) {
                return rawData.hasOwnProperty("stackGroup");
              });
            }
            function getStackDataRangeValues(stackData) {
              var values = [];
              if (Array.isArray(stackData)) {
                values = [0].concat(stackSeriesData_toConsumableArray(getSumValues(stackData)));
              } else {
                for (var groupId in stackData) {
                  if (Object.prototype.hasOwnProperty.call(stackData, groupId)) {
                    values = [0].concat(stackSeriesData_toConsumableArray(values), stackSeriesData_toConsumableArray(getSumValues(stackData[groupId])));
                  }
                }
              }
              return values;
            }
            function getSumValues(stackData) {
              var positiveSum = stackData.map(function(_ref4) {
                var total = _ref4.total;
                return total.positive;
              });
              var negativeSum = stackData.map(function(_ref5) {
                var total = _ref5.total;
                return total.negative;
              });
              return [].concat(stackSeriesData_toConsumableArray(negativeSum), stackSeriesData_toConsumableArray(positiveSum));
            }
            function getStackDataValues(stackData) {
              if (!isGroupStack(stackData)) {
                return stackData;
              }
              var stackDataValues = [];
              if (isGroupStack(stackData)) {
                Object.keys(stackData).forEach(function(groupId) {
                  stackDataValues = [].concat(stackSeriesData_toConsumableArray(stackDataValues), stackSeriesData_toConsumableArray(stackData[groupId]));
                });
              }
              return stackDataValues;
            }
            function checkIfNegativeAndPositiveValues(stackData) {
              return {
                hasNegative: stackData.map(function(_ref6) {
                  var total = _ref6.total;
                  return total.negative;
                }).some(function(total) {
                  return total < 0;
                }),
                hasPositive: stackData.map(function(_ref7) {
                  var total = _ref7.total;
                  return total.positive;
                }).some(function(total) {
                  return total >= 0;
                })
              };
            }
            function getScaleType(stackData, stackType, diverging) {
              var _checkIfNegativeAndPo = checkIfNegativeAndPositiveValues(stackData), hasPositive = _checkIfNegativeAndPo.hasPositive, hasNegative2 = _checkIfNegativeAndPo.hasNegative;
              if (stackType === "percent") {
                if (diverging) {
                  return "divergingPercentStack";
                }
                if (hasNegative2 && hasPositive) {
                  return "dualPercentStack";
                }
                if (!hasNegative2 && hasPositive) {
                  return "percentStack";
                }
                if (hasNegative2 && !hasPositive) {
                  return "minusPercentStack";
                }
              }
            }
            function initStackSeries(series, options2) {
              var stackSeries = {};
              Object.keys(series).forEach(function(seriesName) {
                var chartType = seriesName;
                var stackOption = pickStackOption(options2);
                if (stackOption) {
                  if (!stackSeries[chartType]) {
                    stackSeries[chartType] = {};
                  }
                  stackSeries[chartType].stack = initializeStack(stackOption);
                } else if (seriesName === "radialBar") {
                  stackSeries[seriesName] = {
                    stack: true
                  };
                }
              });
              return stackSeries;
            }
            var stackSeriesData = {
              name: "stackSeriesData",
              state: function state(_ref8) {
                var series = _ref8.series, options2 = _ref8.options;
                return {
                  stackSeries: initStackSeries(series, options2)
                };
              },
              action: {
                setStackSeriesData: function setStackSeriesData(_ref9) {
                  var state = _ref9.state;
                  var series = state.series, stackSeries = state.stackSeries, options2 = state.options;
                  var stackOption = pickStackOption(options2);
                  var newStackSeries = {};
                  Object.keys(series).forEach(function(seriesName) {
                    var _options$series;
                    var seriesData2 = series[seriesName];
                    var data = seriesData2.data, seriesCount = seriesData2.seriesCount, seriesGroupCount = seriesData2.seriesGroupCount;
                    var isRadialBar = seriesName === "radialBar";
                    if (stackOption) {
                      if (!stackSeries[seriesName]) {
                        stackSeries[seriesName] = {};
                      }
                      stackSeries[seriesName].stack = initializeStack(stackOption);
                    } else if (!isRadialBar) {
                      stackSeries[seriesName] = null;
                      delete stackSeries[seriesName];
                    }
                    var _ref10 = stackSeries[seriesName] || {}, stack = _ref10.stack;
                    var diverging = !!((_options$series = options2.series) !== null && _options$series !== void 0 && _options$series.diverging);
                    if (stack) {
                      var _stack$type;
                      var stackData = hasStackGrouped(data) ? makeStackGroupData(data) : makeStackData(data);
                      var stackType = (_stack$type = stack.type) !== null && _stack$type !== void 0 ? _stack$type : "normal";
                      var dataRangeValues = getStackDataRangeValues(stackData);
                      newStackSeries[seriesName] = {
                        data,
                        seriesCount,
                        seriesGroupCount,
                        stackData,
                        dataRangeValues,
                        scaleType: getScaleType(getStackDataValues(stackData), stackType, diverging)
                      };
                      state.stackSeries[seriesName].stackData = stackData;
                    }
                    store_extend(state.stackSeries, newStackSeries);
                  });
                }
              },
              observe: {
                updateStackSeriesData: function updateStackSeriesData() {
                  this.dispatch("setStackSeriesData");
                }
              }
            };
            var store_stackSeriesData = stackSeriesData;
            ;
            var MIN_OFFSET_SIZE = 1;
            function getLabelScaleData(state, labelAxisOnYAxis, scaleOptions, labelAxisName) {
              var _options$xAxis, _xAxis;
              var dataRange2 = state.dataRange, layout2 = state.layout, series = state.series, options2 = state.options;
              var categories = state.categories;
              var rawCategories = state.rawCategories;
              var _getSizeKey = getSizeKey(labelAxisOnYAxis), labelSizeKey = _getSizeKey.labelSizeKey;
              var dateTypeLabel = isExist((_options$xAxis = options2.xAxis) === null || _options$xAxis === void 0 ? void 0 : _options$xAxis.date);
              var labelOptions = {
                dataRange: dataRange2[labelAxisName],
                offsetSize: Math.max(layout2.plot[labelSizeKey], MIN_OFFSET_SIZE),
                scaleOption: scaleOptions[labelAxisName],
                rawCategoriesSize: rawCategories.length
              };
              var result;
              if (dataRange2[labelAxisName]) {
                result = dateTypeLabel ? calculateDatetimeScale(labelOptions) : calculateCoordinateScale(labelOptions);
              }
              if (series.line && categories && !((_xAxis = options2.xAxis) !== null && _xAxis !== void 0 && _xAxis.pointOnColumn)) {
                result = calculateXAxisScaleForCoordinateLineType(result, options2, categories);
              }
              return result;
            }
            function getValueScaleData(state, labelAxisOnYAxis, scaleOptions, valueAxisName, isCoordinateTypeChart) {
              var dataRange2 = state.dataRange, layout2 = state.layout, series = state.series, stackSeries = state.stackSeries;
              var _getSizeKey2 = getSizeKey(labelAxisOnYAxis), valueSizeKey = _getSizeKey2.valueSizeKey;
              var result;
              if (hasPercentStackSeries(stackSeries)) {
                Object.keys(series).forEach(function(seriesName) {
                  result = getStackScaleData(stackSeries[seriesName].scaleType);
                });
              } else if (isCoordinateTypeChart) {
                var valueOptions = {
                  dataRange: dataRange2[valueAxisName],
                  offsetSize: Math.max(layout2.plot[valueSizeKey], MIN_OFFSET_SIZE),
                  scaleOption: scaleOptions[valueAxisName]
                };
                result = calculateCoordinateScale(valueOptions);
              } else {
                result = calculateCoordinateScale({
                  dataRange: dataRange2[valueAxisName],
                  offsetSize: Math.max(layout2.plot[valueSizeKey], MIN_OFFSET_SIZE),
                  scaleOption: scaleOptions[valueAxisName]
                });
              }
              return result;
            }
            function getScaleOptions(options2, series, valueAxisName) {
              var scaleOptions = {};
              if (isSeriesUsingRadialAxes(series)) {
                var _options$valueAxisNam;
                scaleOptions[valueAxisName] = options2 === null || options2 === void 0 ? void 0 : (_options$valueAxisNam = options2[valueAxisName]) === null || _options$valueAxisNam === void 0 ? void 0 : _options$valueAxisNam.scale;
              } else {
                var _options$xAxis2;
                var _getYAxisOption = getYAxisOption(options2), yAxis = _getYAxisOption.yAxis, secondaryYAxis = _getYAxisOption.secondaryYAxis;
                scaleOptions.xAxis = options2 === null || options2 === void 0 ? void 0 : (_options$xAxis2 = options2.xAxis) === null || _options$xAxis2 === void 0 ? void 0 : _options$xAxis2.scale;
                scaleOptions.yAxis = yAxis === null || yAxis === void 0 ? void 0 : yAxis.scale;
                if (secondaryYAxis) {
                  scaleOptions.secondaryYAxis = secondaryYAxis === null || secondaryYAxis === void 0 ? void 0 : secondaryYAxis.scale;
                }
              }
              return scaleOptions;
            }
            var scale = {
              name: "scale",
              state: function state() {
                return {
                  scale: {}
                };
              },
              action: {
                setScale: function setScale(_ref) {
                  var state = _ref.state, initStoreState = _ref.initStoreState;
                  var series = state.series, options2 = state.options, categories = state.categories;
                  var labelAxisOnYAxis = isLabelAxisOnYAxis({
                    series,
                    options: options2,
                    categories
                  });
                  var _getAxisName = getAxisName(labelAxisOnYAxis, series), labelAxisName = _getAxisName.labelAxisName, valueAxisName = _getAxisName.valueAxisName;
                  var scaleOptions = getScaleOptions(options2, series, valueAxisName);
                  var isCoordinateTypeChart = isCoordinateSeries(initStoreState.series);
                  var scaleData = {};
                  getValueAxisNames(options2, valueAxisName).forEach(function(axisName) {
                    scaleData[axisName] = getValueScaleData(state, labelAxisOnYAxis, scaleOptions, axisName, isCoordinateTypeChart);
                  });
                  if (isCoordinateTypeChart) {
                    scaleData[labelAxisName] = getLabelScaleData(state, labelAxisOnYAxis, scaleOptions, labelAxisName);
                  }
                  state.scale = scaleData;
                }
              },
              observe: {
                updateScale: function updateScale() {
                  this.dispatch("setScale");
                }
              }
            };
            var store_scale = scale;
            ;
            function isExistPlotId(plots, data) {
              return plots.some(function(_ref) {
                var bandId = _ref.id;
                return !isUndefined(bandId) && !isUndefined(data.id) && bandId === data.id;
              });
            }
            ;
            function plot_toConsumableArray(arr) {
              return plot_arrayWithoutHoles(arr) || plot_iterableToArray(arr) || plot_unsupportedIterableToArray(arr) || plot_nonIterableSpread();
            }
            function plot_nonIterableSpread() {
              throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            function plot_iterableToArray(iter) {
              if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
                return Array.from(iter);
            }
            function plot_arrayWithoutHoles(arr) {
              if (Array.isArray(arr))
                return plot_arrayLikeToArray(arr);
            }
            function plot_slicedToArray(arr, i) {
              return plot_arrayWithHoles(arr) || plot_iterableToArrayLimit(arr, i) || plot_unsupportedIterableToArray(arr, i) || plot_nonIterableRest();
            }
            function plot_nonIterableRest() {
              throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            function plot_unsupportedIterableToArray(o, minLen) {
              if (!o)
                return;
              if (typeof o === "string")
                return plot_arrayLikeToArray(o, minLen);
              var n = Object.prototype.toString.call(o).slice(8, -1);
              if (n === "Object" && o.constructor)
                n = o.constructor.name;
              if (n === "Map" || n === "Set")
                return Array.from(o);
              if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                return plot_arrayLikeToArray(o, minLen);
            }
            function plot_arrayLikeToArray(arr, len) {
              if (len == null || len > arr.length)
                len = arr.length;
              for (var i = 0, arr2 = new Array(len); i < len; i++) {
                arr2[i] = arr[i];
              }
              return arr2;
            }
            function plot_iterableToArrayLimit(arr, i) {
              var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]);
              if (_i == null)
                return;
              var _arr = [];
              var _n = true;
              var _d = false;
              var _s, _e;
              try {
                for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
                  _arr.push(_s.value);
                  if (i && _arr.length === i)
                    break;
                }
              } catch (err) {
                _d = true;
                _e = err;
              } finally {
                try {
                  if (!_n && _i["return"] != null)
                    _i["return"]();
                } finally {
                  if (_d)
                    throw _e;
                }
              }
              return _arr;
            }
            function plot_arrayWithHoles(arr) {
              if (Array.isArray(arr))
                return arr;
            }
            function getOverlappingRange(ranges) {
              var overlappingRanges = ranges.reduce(function(acc, _ref) {
                var range2 = _ref.range;
                var _acc = plot_slicedToArray(acc, 2), accStart = _acc[0], accEnd = _acc[1];
                var _ref2 = range2, _ref3 = plot_slicedToArray(_ref2, 2), start = _ref3[0], end = _ref3[1];
                return [Math.min(accStart, start), Math.max(accEnd, end)];
              }, [Number.MAX_SAFE_INTEGER, Number.MIN_SAFE_INTEGER]);
              return {
                range: overlappingRanges,
                color: ranges[0].color
              };
            }
            function getCategoryIndex(value, categories) {
              return categories.findIndex(function(category2) {
                return category2 === String(value);
              });
            }
            function getValidValue(value, categories) {
              var isDateType2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
              if (isDateType2) {
                return Number(new Date(value));
              }
              if (utils_isString(value)) {
                return getCategoryIndex(value, categories);
              }
              return value;
            }
            function makePlotLines(categories, isDateType2) {
              var plotLines = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
              return plotLines.map(function(_ref4) {
                var value = _ref4.value, color = _ref4.color, opacity = _ref4.opacity;
                return {
                  value: getValidValue(value, categories, isDateType2),
                  color: rgba(color, opacity)
                };
              });
            }
            function makePlotBands(categories, isDateType2) {
              var plotBands = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
              return plotBands.flatMap(function(_ref5) {
                var range2 = _ref5.range, _ref5$mergeOverlappin = _ref5.mergeOverlappingRanges, mergeOverlappingRanges = _ref5$mergeOverlappin === void 0 ? false : _ref5$mergeOverlappin, bgColor = _ref5.color, opacity = _ref5.opacity;
                var color = rgba(bgColor, opacity);
                var rangeArray = isRangeValue(range2[0]) ? range2 : [range2];
                var ranges = rangeArray.map(function(rangeData) {
                  return {
                    range: rangeData.map(function(value) {
                      return getValidValue(value, categories, isDateType2);
                    }),
                    color
                  };
                });
                return mergeOverlappingRanges ? getOverlappingRange(ranges) : ranges;
              });
            }
            var plot = {
              name: "plot",
              state: function state(_ref6) {
                var _plot$visible, _plot;
                var options2 = _ref6.options;
                return {
                  plot: {
                    visible: (_plot$visible = options2 === null || options2 === void 0 ? void 0 : (_plot = options2.plot) === null || _plot === void 0 ? void 0 : _plot.visible) !== null && _plot$visible !== void 0 ? _plot$visible : true,
                    lines: [],
                    bands: []
                  }
                };
              },
              action: {
                setPlot: function setPlot2(_ref7) {
                  var _options$xAxis, _lineAreaOptions$plot, _options$xAxis2, _lineAreaOptions$plot2;
                  var state = _ref7.state;
                  var series = state.series, options2 = state.options;
                  if (!(series.area || series.line)) {
                    return;
                  }
                  var rawCategories = state.rawCategories;
                  var lineAreaOptions = options2;
                  var lines = makePlotLines(rawCategories, !!(options2 !== null && options2 !== void 0 && (_options$xAxis = options2.xAxis) !== null && _options$xAxis !== void 0 && _options$xAxis.date), lineAreaOptions === null || lineAreaOptions === void 0 ? void 0 : (_lineAreaOptions$plot = lineAreaOptions.plot) === null || _lineAreaOptions$plot === void 0 ? void 0 : _lineAreaOptions$plot.lines);
                  var bands = makePlotBands(rawCategories, !!(options2 !== null && options2 !== void 0 && (_options$xAxis2 = options2.xAxis) !== null && _options$xAxis2 !== void 0 && _options$xAxis2.date), lineAreaOptions === null || lineAreaOptions === void 0 ? void 0 : (_lineAreaOptions$plot2 = lineAreaOptions.plot) === null || _lineAreaOptions$plot2 === void 0 ? void 0 : _lineAreaOptions$plot2.bands);
                  store_extend(state.plot, {
                    lines,
                    bands
                  });
                },
                addPlotLine: function addPlotLine(_ref8, _ref9) {
                  var _plot$lines, _state$options, _state$options$plot;
                  var state = _ref8.state;
                  var data = _ref9.data;
                  var lines = (_plot$lines = (_state$options = state.options) === null || _state$options === void 0 ? void 0 : (_state$options$plot = _state$options.plot) === null || _state$options$plot === void 0 ? void 0 : _state$options$plot.lines) !== null && _plot$lines !== void 0 ? _plot$lines : [];
                  if (!isExistPlotId(lines, data)) {
                    this.dispatch("updateOptions", {
                      options: {
                        plot: {
                          lines: [].concat(plot_toConsumableArray(lines), [data])
                        }
                      }
                    });
                  }
                },
                addPlotBand: function addPlotBand(_ref10, _ref11) {
                  var _plot$bands, _state$options2, _state$options2$plot;
                  var state = _ref10.state;
                  var data = _ref11.data;
                  var bands = (_plot$bands = (_state$options2 = state.options) === null || _state$options2 === void 0 ? void 0 : (_state$options2$plot = _state$options2.plot) === null || _state$options2$plot === void 0 ? void 0 : _state$options2$plot.bands) !== null && _plot$bands !== void 0 ? _plot$bands : [];
                  if (!isExistPlotId(bands, data)) {
                    this.dispatch("updateOptions", {
                      options: {
                        plot: {
                          bands: [].concat(plot_toConsumableArray(bands), [data])
                        }
                      }
                    });
                  }
                },
                removePlotLine: function removePlotLine(_ref12, _ref13) {
                  var _plot$lines2, _state$options3, _state$options3$plot;
                  var state = _ref12.state;
                  var id = _ref13.id;
                  var lines = ((_plot$lines2 = (_state$options3 = state.options) === null || _state$options3 === void 0 ? void 0 : (_state$options3$plot = _state$options3.plot) === null || _state$options3$plot === void 0 ? void 0 : _state$options3$plot.lines) !== null && _plot$lines2 !== void 0 ? _plot$lines2 : []).filter(function(_ref14) {
                    var lineId = _ref14.id;
                    return lineId !== id;
                  });
                  this.dispatch("updateOptions", {
                    options: {
                      plot: {
                        lines
                      }
                    }
                  });
                },
                removePlotBand: function removePlotBand(_ref15, _ref16) {
                  var _plot$bands2, _state$options4, _state$options4$plot;
                  var state = _ref15.state;
                  var id = _ref16.id;
                  var bands = ((_plot$bands2 = (_state$options4 = state.options) === null || _state$options4 === void 0 ? void 0 : (_state$options4$plot = _state$options4.plot) === null || _state$options4$plot === void 0 ? void 0 : _state$options4$plot.bands) !== null && _plot$bands2 !== void 0 ? _plot$bands2 : []).filter(function(_ref17) {
                    var bandId = _ref17.id;
                    return bandId !== id;
                  });
                  this.dispatch("updateOptions", {
                    options: {
                      plot: {
                        bands
                      }
                    }
                  });
                }
              },
              observe: {
                updatePlot: function updatePlot() {
                  this.dispatch("setPlot");
                }
              }
            };
            var store_plot = plot;
            ;
            function isBubblePointType(value) {
              return value.hasOwnProperty("r");
            }
            function getValueString(value) {
              var result = "";
              if (isRangeValue(value)) {
                result = "".concat(value[0], " ~ ").concat(value[1]);
              } else if (isObject(value) && !Array.isArray(value)) {
                result = "(".concat(value.x, ", ").concat(value.y, ")") + (isBubblePointType(value) ? ", r: ".concat(value.r) : "");
              } else {
                result = String(value);
              }
              return result;
            }
            ;
            function tooltipTemplate_slicedToArray(arr, i) {
              return tooltipTemplate_arrayWithHoles(arr) || tooltipTemplate_iterableToArrayLimit(arr, i) || tooltipTemplate_unsupportedIterableToArray(arr, i) || tooltipTemplate_nonIterableRest();
            }
            function tooltipTemplate_nonIterableRest() {
              throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            function tooltipTemplate_iterableToArrayLimit(arr, i) {
              var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]);
              if (_i == null)
                return;
              var _arr = [];
              var _n = true;
              var _d = false;
              var _s, _e;
              try {
                for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
                  _arr.push(_s.value);
                  if (i && _arr.length === i)
                    break;
                }
              } catch (err) {
                _d = true;
                _e = err;
              } finally {
                try {
                  if (!_n && _i["return"] != null)
                    _i["return"]();
                } finally {
                  if (_d)
                    throw _e;
                }
              }
              return _arr;
            }
            function tooltipTemplate_arrayWithHoles(arr) {
              if (Array.isArray(arr))
                return arr;
            }
            function tooltipTemplate_toConsumableArray(arr) {
              return tooltipTemplate_arrayWithoutHoles(arr) || tooltipTemplate_iterableToArray(arr) || tooltipTemplate_unsupportedIterableToArray(arr) || tooltipTemplate_nonIterableSpread();
            }
            function tooltipTemplate_nonIterableSpread() {
              throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            function tooltipTemplate_unsupportedIterableToArray(o, minLen) {
              if (!o)
                return;
              if (typeof o === "string")
                return tooltipTemplate_arrayLikeToArray(o, minLen);
              var n = Object.prototype.toString.call(o).slice(8, -1);
              if (n === "Object" && o.constructor)
                n = o.constructor.name;
              if (n === "Map" || n === "Set")
                return Array.from(o);
              if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                return tooltipTemplate_arrayLikeToArray(o, minLen);
            }
            function tooltipTemplate_iterableToArray(iter) {
              if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
                return Array.from(iter);
            }
            function tooltipTemplate_arrayWithoutHoles(arr) {
              if (Array.isArray(arr))
                return tooltipTemplate_arrayLikeToArray(arr);
            }
            function tooltipTemplate_arrayLikeToArray(arr, len) {
              if (len == null || len > arr.length)
                len = arr.length;
              for (var i = 0, arr2 = new Array(len); i < len; i++) {
                arr2[i] = arr[i];
              }
              return arr2;
            }
            function getSeriesNameTemplate(label2, color) {
              return '<span class="toastui-chart-series-name">\n    <i class="toastui-chart-icon" style="background: '.concat(color, '"></i>\n    <span class="toastui-chart-name">').concat(label2, "</span>\n  </span>");
            }
            function getTitleValueTemplate(title, value) {
              return '<div class="toastui-chart-tooltip-series">\n    <span class="toastui-chart-series-name">'.concat(title, '</span>\n    <span class="toastui-chart-series-value">').concat(value, "</span>\n  </div>");
            }
            function getColorValueTemplate(color, value) {
              return '<div class="toastui-chart-tooltip-series">\n    <i class="toastui-chart-icon" style="background: '.concat(color, '"></i>\n    <span class="toastui-chart-series-value">').concat(value, "</span>\n  </div>");
            }
            function makeBulletDataTemplate(data, titleType) {
              return data.filter(function(_ref) {
                var title = _ref.title;
                return title === titleType;
              }).sort(function(a, b) {
                if (isRangeValue(a.value) && isRangeValue(b.value)) {
                  return a.value[0] - b.value[0];
                }
                if (isNumber(a.value) && isNumber(b.value)) {
                  return a.value - b.value;
                }
                return 0;
              }).map(function(_ref2) {
                var formattedValue = _ref2.formattedValue, color = _ref2.color;
                return getColorValueTemplate(color, formattedValue);
              }).join("");
            }
            function getDefaultTemplate(model, _ref3, theme2) {
              var header = _ref3.header, body = _ref3.body;
              var borderColor = theme2.borderColor, borderWidth = theme2.borderWidth, background = theme2.background, borderRadius = theme2.borderRadius, borderStyle = theme2.borderStyle;
              var style = "border: ".concat(borderWidth, "px ").concat(borderStyle, " ").concat(borderColor, ";border-radius: ").concat(borderRadius, "px;background: ").concat(background, ";");
              return '<div class="toastui-chart-tooltip" style="'.concat(style, '">').concat(header).concat(body, "</div>");
            }
            function getHeaderTemplate(_ref4, theme2) {
              var category2 = _ref4.category;
              return category2 ? '<div class="toastui-chart-tooltip-category" style="'.concat(getFontStyleString(theme2.header), '">\n        ').concat(category2, "\n      </div>") : "";
            }
            function getDefaultBodyTemplate(_ref5, theme2) {
              var data = _ref5.data;
              return '\n    <div class="toastui-chart-tooltip-series-wrapper" style="'.concat(getFontStyleString(theme2.body), '">\n      ').concat(data.map(function(_ref6) {
                var label2 = _ref6.label, color = _ref6.color, formattedValue = _ref6.formattedValue;
                return '<div class="toastui-chart-tooltip-series">\n                '.concat(getSeriesNameTemplate(label2, color), '\n                <span class="toastui-chart-series-value">').concat(formattedValue, "</span>\n              </div>");
              }).join(""), "\n    </div>");
            }
            function getBoxPlotTemplate(_ref7, theme2) {
              var data = _ref7.data;
              var groupedData = data.reduce(function(acc, item, index) {
                if (!index) {
                  return item;
                }
                if (acc.category === item.category && acc.label === item.label) {
                  acc.value = [].concat(tooltipTemplate_toConsumableArray(acc.value), tooltipTemplate_toConsumableArray(item.value));
                }
                return acc;
              }, {});
              return '\n    <div class="toastui-chart-tooltip-series-wrapper" style="'.concat(getFontStyleString(theme2.body), '">\n      ').concat([groupedData].map(function(_ref8) {
                var label2 = _ref8.label, color = _ref8.color, values = _ref8.value;
                return '<div class="toastui-chart-tooltip-series">\n              '.concat(getSeriesNameTemplate(label2, color), "\n            </div>\n            <div>\n          ").concat(values.map(function(_ref9) {
                  var title = _ref9.title, formattedValue = _ref9.formattedValue;
                  return getTitleValueTemplate(title, formattedValue);
                }).join(""), "\n            </div>");
              }).join(""), "\n    </div>");
            }
            function getBulletTemplate(_ref10, theme2) {
              var data = _ref10.data;
              return data.length > 1 ? getBulletGroupedTemplate(data, theme2) : getBulletBasicTemplate(data, theme2);
            }
            function getBulletBasicTemplate(data, theme2) {
              return '\n    <div class="toastui-chart-tooltip-series-wrapper" style="'.concat(getFontStyleString(theme2.body), '">\n      ').concat(data.map(function(_ref11) {
                var label2 = _ref11.label, color = _ref11.color, values = _ref11.value;
                return '<div class="toastui-chart-tooltip-series">'.concat(getSeriesNameTemplate(label2, color), "</div>\n            ").concat(values.map(function(_ref12) {
                  var title = _ref12.title, formattedValue = _ref12.formattedValue;
                  return getTitleValueTemplate(title, formattedValue);
                }).join(""));
              }).join(""), "\n    </div>");
            }
            function getBulletGroupedTemplate(data, theme2) {
              var bulletData = data.map(function(_ref13) {
                var value = _ref13.value;
                return value[0];
              });
              var _map = ["Actual", "Range", "Marker"].map(function(titleType) {
                return makeBulletDataTemplate(bulletData, titleType);
              }), _map2 = tooltipTemplate_slicedToArray(_map, 3), actual = _map2[0], ranges = _map2[1], markers = _map2[2];
              return '<div class="toastui-chart-tooltip-category" style="'.concat(getFontStyleString(theme2.header), '">\n      ').concat(data[0].label, '\n    </div>\n    <div class="toastui-chart-tooltip-series-wrapper" style="').concat(getFontStyleString(theme2.body), '">\n      ').concat(actual ? '<div class="toastui-chart-tooltip-title">Actual</div>' : "", " ").concat(actual, "\n      ").concat(ranges ? '<div class="toastui-chart-tooltip-title">Ranges</div>' : "", " ").concat(ranges, "\n      ").concat(markers ? '<div class="toastui-chart-tooltip-title">Markers</div>' : "", " ").concat(markers, "\n    </div>");
            }
            function getPieTemplate(_ref14, theme2) {
              var data = _ref14.data;
              return '\n    <div class="toastui-chart-tooltip-series-wrapper" style="'.concat(getFontStyleString(theme2.body), '">\n      ').concat(data.map(function(_ref15) {
                var label2 = _ref15.label, color = _ref15.color, formattedValue = _ref15.formattedValue, percentValue = _ref15.percentValue;
                return '<div class="toastui-chart-tooltip-series">\n          '.concat(getSeriesNameTemplate(label2, color), '\n          <span class="toastui-chart-series-value">').concat(pieTooltipLabelFormatter(percentValue), "&nbsp;&nbsp;(").concat(formattedValue, ")</span>\n        </div>");
              }).join(""), "\n    </div>");
            }
            function getHeatmapTemplate(_ref16, theme2) {
              var data = _ref16.data;
              return "".concat(data.map(function(_ref17) {
                var label2 = _ref17.label, color = _ref17.color, formattedValue = _ref17.formattedValue;
                return '<div class="toastui-chart-tooltip-category" style="'.concat(getFontStyleString(theme2.header), '">\n          ').concat(label2, '\n        </div>\n        <div class="toastui-chart-tooltip-series-wrapper" style="').concat(getFontStyleString(theme2.body), '">\n          <div class="toastui-chart-tooltip-series">\n            ').concat(getSeriesNameTemplate(formattedValue, color), "\n          </div>\n        </div>");
              }).join(""));
            }
            var tooltipTemplates = {
              default: getDefaultTemplate,
              defaultHeader: getHeaderTemplate,
              defaultBody: getDefaultBodyTemplate,
              boxPlot: getBoxPlotTemplate,
              bullet: getBulletTemplate,
              pie: getPieTemplate,
              heatmap: getHeatmapTemplate
            };
            function getBodyTemplate(type) {
              return tooltipTemplates[type || "defaultBody"];
            }
            var es_regexp_constructor = __webpack_require__(7368);
            ;
            function findNodes(element, selector) {
              return element.querySelectorAll(selector);
            }
            function removeNode(node) {
              if (node.parentNode) {
                node.parentNode.removeChild(node);
              }
            }
            ;
            var HTML_ATTR_LIST_RX = new RegExp("^(abbr|align|alt|axis|bgcolor|border|cellpadding|cellspacing|class|clear|color|cols|compact|coords|dir|face|headers|height|hreflang|hspace|ismap|lang|language|nohref|nowrap|rel|rev|rows|rules|scope|scrolling|shape|size|span|start|summary|tabindex|target|title|type|valign|value|vspace|width|checked|mathvariant|encoding|id|name|background|cite|href|longdesc|src|usemap|xlink:href|data-+|checked|style)", "g");
            var SVG_ATTR_LIST_RX = new RegExp("^(accent-height|accumulate|additive|alphabetic|arabic-form|ascent|baseProfile|bbox|begin|by|calcMode|cap-height|class|color|color-rendering|content|cx|cy|d|dx|dy|descent|display|dur|end|fill|fill-rule|font-family|font-size|font-stretch|font-style|font-variant|font-weight|from|fx|fy|g1|g2|glyph-name|gradientUnits|hanging|height|horiz-adv-x|horiz-origin-x|ideographic|k|keyPoints|keySplines|keyTimes|lang|marker-end|marker-mid|marker-start|markerHeight|markerUnits|markerWidth|mathematical|max|min|offset|opacity|orient|origin|overline-position|overline-thickness|panose-1|path|pathLength|points|preserveAspectRatio|r|refX|refY|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|rotate|rx|ry|slope|stemh|stemv|stop-color|stop-opacity|strikethrough-position|strikethrough-thickness|stroke|stroke-dasharray|stroke-dashoffset|stroke-linecap|stroke-linejoin|stroke-miterlimit|stroke-opacity|stroke-width|systemLanguage|target|text-anchor|to|transform|type|u1|u2|underline-position|underline-thickness|unicode|unicode-range|units-per-em|values|version|viewBox|visibility|width|widths|x|x-height|x1|x2|xlink:actuate|xlink:arcrole|xlink:role|xlink:show|xlink:title|xlink:type|xml:base|xml:lang|xml:space|xmlns|xmlns:xlink|y|y1|y2|zoomAndPan)", "g");
            var DEFAULT_TAG_DENY_LIST = ["script", "iframe", "textarea", "form", "button", "select", "input", "meta", "style", "link", "title", "embed", "object"];
            var XSS_ATTR_RX = /href|src|background/gi;
            var XSS_VALUE_RX = /((java|vb|live)script|x):/gi;
            var ON_EVENT_RX = /^on\S+/;
            function sanitizeHTML(html) {
              var root2 = document.createElement("div");
              if (utils_isString(html)) {
                html = html.replace(/<!--[\s\S]*?-->/g, "");
                root2.innerHTML = html;
              } else {
                root2.appendChild(html);
              }
              removeUnnecessaryTags(root2);
              leaveOnlyWhitelistAttribute(root2);
              return root2.innerHTML;
            }
            function removeUnnecessaryTags(html) {
              var removedTags = findNodes(html, DEFAULT_TAG_DENY_LIST.join(","));
              removedTags.forEach(function(node) {
                removeNode(node);
              });
            }
            function isXSSAttribute(attrName, attrValue) {
              return attrName.match(XSS_ATTR_RX) && attrValue.match(XSS_VALUE_RX);
            }
            function removeBlacklistAttributes(node, blacklistAttrs) {
              blacklistAttrs.forEach(function(_ref) {
                var name = _ref.name;
                if (ON_EVENT_RX.test(name)) {
                  node[name] = null;
                }
                if (node.getAttribute(name)) {
                  node.removeAttribute(name);
                }
              });
            }
            function leaveOnlyWhitelistAttribute(html) {
              findNodes(html, "*").forEach(function(node) {
                var attributes = node.attributes;
                var blacklist = toArray(attributes).filter(function(attr) {
                  var name = attr.name, value = attr.value;
                  var htmlAttr = name.match(HTML_ATTR_LIST_RX);
                  var svgAttr = name.match(SVG_ATTR_LIST_RX);
                  var xssAttr = htmlAttr && isXSSAttribute(name, value);
                  return !htmlAttr && !svgAttr || xssAttr;
                });
                removeBlacklistAttributes(node, blacklist);
              });
            }
            ;
            function tooltip_typeof(obj) {
              "@babel/helpers - typeof";
              if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                tooltip_typeof = function _typeof2(obj2) {
                  return typeof obj2;
                };
              } else {
                tooltip_typeof = function _typeof2(obj2) {
                  return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                };
              }
              return tooltip_typeof(obj);
            }
            function tooltip_ownKeys(object, enumerableOnly) {
              var keys = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object);
                if (enumerableOnly) {
                  symbols = symbols.filter(function(sym) {
                    return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                  });
                }
                keys.push.apply(keys, symbols);
              }
              return keys;
            }
            function tooltip_objectSpread(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i] != null ? arguments[i] : {};
                if (i % 2) {
                  tooltip_ownKeys(Object(source), true).forEach(function(key) {
                    tooltip_defineProperty(target, key, source[key]);
                  });
                } else if (Object.getOwnPropertyDescriptors) {
                  Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                } else {
                  tooltip_ownKeys(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  });
                }
              }
              return target;
            }
            function tooltip_toConsumableArray(arr) {
              return tooltip_arrayWithoutHoles(arr) || tooltip_iterableToArray(arr) || tooltip_unsupportedIterableToArray(arr) || tooltip_nonIterableSpread();
            }
            function tooltip_nonIterableSpread() {
              throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            function tooltip_unsupportedIterableToArray(o, minLen) {
              if (!o)
                return;
              if (typeof o === "string")
                return tooltip_arrayLikeToArray(o, minLen);
              var n = Object.prototype.toString.call(o).slice(8, -1);
              if (n === "Object" && o.constructor)
                n = o.constructor.name;
              if (n === "Map" || n === "Set")
                return Array.from(o);
              if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                return tooltip_arrayLikeToArray(o, minLen);
            }
            function tooltip_iterableToArray(iter) {
              if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
                return Array.from(iter);
            }
            function tooltip_arrayWithoutHoles(arr) {
              if (Array.isArray(arr))
                return tooltip_arrayLikeToArray(arr);
            }
            function tooltip_arrayLikeToArray(arr, len) {
              if (len == null || len > arr.length)
                len = arr.length;
              for (var i = 0, arr2 = new Array(len); i < len; i++) {
                arr2[i] = arr[i];
              }
              return arr2;
            }
            function tooltip_classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function tooltip_defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            function tooltip_createClass(Constructor, protoProps, staticProps) {
              if (protoProps)
                tooltip_defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                tooltip_defineProperties(Constructor, staticProps);
              return Constructor;
            }
            function tooltip_inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function");
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
              if (superClass)
                tooltip_setPrototypeOf(subClass, superClass);
            }
            function tooltip_setPrototypeOf(o, p) {
              tooltip_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
                o2.__proto__ = p2;
                return o2;
              };
              return tooltip_setPrototypeOf(o, p);
            }
            function tooltip_createSuper(Derived) {
              var hasNativeReflectConstruct = tooltip_isNativeReflectConstruct();
              return function _createSuperInternal() {
                var Super = tooltip_getPrototypeOf(Derived), result;
                if (hasNativeReflectConstruct) {
                  var NewTarget = tooltip_getPrototypeOf(this).constructor;
                  result = Reflect.construct(Super, arguments, NewTarget);
                } else {
                  result = Super.apply(this, arguments);
                }
                return tooltip_possibleConstructorReturn(this, result);
              };
            }
            function tooltip_possibleConstructorReturn(self2, call) {
              if (call && (tooltip_typeof(call) === "object" || typeof call === "function")) {
                return call;
              }
              return tooltip_assertThisInitialized(self2);
            }
            function tooltip_assertThisInitialized(self2) {
              if (self2 === void 0) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return self2;
            }
            function tooltip_isNativeReflectConstruct() {
              if (typeof Reflect === "undefined" || !Reflect.construct)
                return false;
              if (Reflect.construct.sham)
                return false;
              if (typeof Proxy === "function")
                return true;
              try {
                Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                }));
                return true;
              } catch (e) {
                return false;
              }
            }
            function tooltip_getPrototypeOf(o) {
              tooltip_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
                return o2.__proto__ || Object.getPrototypeOf(o2);
              };
              return tooltip_getPrototypeOf(o);
            }
            function tooltip_defineProperty(obj, key, value) {
              if (key in obj) {
                Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
              } else {
                obj[key] = value;
              }
              return obj;
            }
            var DEFAULT_TOOLTIP_TRANSITION = "transform 0.2s ease";
            var Tooltip = function(_Component) {
              tooltip_inherits(Tooltip2, _Component);
              var _super = tooltip_createSuper(Tooltip2);
              function Tooltip2() {
                var _this;
                tooltip_classCallCheck(this, Tooltip2);
                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }
                _this = _super.call.apply(_super, [this].concat(args));
                tooltip_defineProperty(tooltip_assertThisInitialized(_this), "chartEl", void 0);
                tooltip_defineProperty(tooltip_assertThisInitialized(_this), "tooltipContainerEl", void 0);
                tooltip_defineProperty(tooltip_assertThisInitialized(_this), "templateFunc", void 0);
                tooltip_defineProperty(tooltip_assertThisInitialized(_this), "theme", void 0);
                tooltip_defineProperty(tooltip_assertThisInitialized(_this), "offsetX", void 0);
                tooltip_defineProperty(tooltip_assertThisInitialized(_this), "offsetY", void 0);
                tooltip_defineProperty(tooltip_assertThisInitialized(_this), "formatter", void 0);
                tooltip_defineProperty(tooltip_assertThisInitialized(_this), "tooltipInfoModels", {});
                tooltip_defineProperty(tooltip_assertThisInitialized(_this), "onSeriesPointHovered", function(_ref) {
                  var models = _ref.models, name = _ref.name;
                  _this.tooltipInfoModels[name] = models !== null && models !== void 0 && models.length ? tooltip_toConsumableArray(models) : [];
                  var isShow = !!_this.getTooltipInfoModels().length;
                  if (isShow) {
                    _this.renderTooltip();
                  } else {
                    _this.removeTooltip();
                  }
                });
                return _this;
              }
              tooltip_createClass(Tooltip2, [{
                key: "isTooltipContainerOverflow",
                value: function isTooltipContainerOverflow(x, y) {
                  var _this$tooltipContaine = this.tooltipContainerEl.getBoundingClientRect(), width = _this$tooltipContaine.width, height = _this$tooltipContaine.height;
                  var _this$rect = this.rect, rectX = _this$rect.x, rectY = _this$rect.y, rectWidth = _this$rect.width, rectHeight = _this$rect.height;
                  return {
                    overflowX: x > rectX + rectWidth || x + width > rectX + rectWidth,
                    overflowY: y > rectY + rectHeight || y + height > rectY + rectHeight
                  };
                }
              }, {
                key: "getPositionInRect",
                value: function getPositionInRect(model) {
                  var target = model.target;
                  var startX = this.rect.x + model.x;
                  var startY = this.rect.y + model.y;
                  var x = startX + target.radius + target.width + this.offsetX;
                  var y = startY + this.offsetY;
                  var _this$isTooltipContai = this.isTooltipContainerOverflow(x, y), overflowX = _this$isTooltipContai.overflowX, overflowY = _this$isTooltipContai.overflowY;
                  var _this$tooltipContaine2 = this.tooltipContainerEl.getBoundingClientRect(), width = _this$tooltipContaine2.width, height = _this$tooltipContaine2.height;
                  if (overflowX) {
                    x = startX - (width + target.radius + this.offsetX) > 0 ? startX - (width + target.radius + this.offsetX) : startX + this.offsetX;
                  }
                  if (overflowY) {
                    y = startY + target.height - (height + this.offsetY) > 0 ? startY + target.height - (height + this.offsetY) : y;
                  }
                  return {
                    x,
                    y
                  };
                }
              }, {
                key: "setTooltipPosition",
                value: function setTooltipPosition(model) {
                  var _this$getPositionInRe = this.getPositionInRect(model), x = _this$getPositionInRe.x, y = _this$getPositionInRe.y;
                  this.tooltipContainerEl.style.transform = getTranslateString(x, y);
                }
              }, {
                key: "getTooltipInfoModels",
                value: function getTooltipInfoModels() {
                  return Object.values(this.tooltipInfoModels).flatMap(function(item) {
                    return item;
                  });
                }
              }, {
                key: "renderTooltip",
                value: function renderTooltip() {
                  var _this2 = this;
                  var model = this.getTooltipInfoModels().reduce(function(acc, item) {
                    var data = item.data, x = item.x, y = item.y, radius = item.radius, width = item.width, height = item.height;
                    acc.x = acc.x ? (acc.x + x) / 2 : x;
                    acc.y = acc.y ? (acc.y + y) / 2 : y;
                    if (isNumber(radius)) {
                      acc.target.radius = radius;
                    }
                    if (width) {
                      acc.target.width = width;
                    }
                    if (height) {
                      acc.target.height = height;
                    }
                    acc.data.push(tooltip_objectSpread(tooltip_objectSpread({}, data), {}, {
                      value: Array.isArray(data.value) ? data.value.map(function(titleValue) {
                        return tooltip_objectSpread(tooltip_objectSpread({}, titleValue), {}, {
                          formattedValue: _this2.getFormattedValue(titleValue.value, data)
                        });
                      }) : data.value,
                      formattedValue: _this2.getFormattedValue(data.value, data)
                    }));
                    if (!acc.category && data.category) {
                      acc.category = data.category;
                    }
                    if (data.templateType) {
                      acc.templateType = data.templateType;
                    }
                    return acc;
                  }, {
                    type: "tooltip",
                    x: 0,
                    y: 0,
                    data: [],
                    target: {
                      radius: 0,
                      width: 0,
                      height: 0
                    }
                  });
                  this.tooltipContainerEl.innerHTML = sanitizeHTML(this.templateFunc(model, {
                    header: tooltipTemplates.defaultHeader(model, this.theme),
                    body: getBodyTemplate(model.templateType)(model, this.theme)
                  }, this.theme));
                  this.setTooltipPosition(model);
                }
              }, {
                key: "initialize",
                value: function initialize(_ref2) {
                  var chartEl = _ref2.chartEl;
                  this.type = "tooltip";
                  this.name = "tooltip";
                  this.chartEl = chartEl;
                  this.tooltipContainerEl = document.createElement("div");
                  this.tooltipContainerEl.classList.add("toastui-chart-tooltip-container");
                  var _this$chartEl$getBoun = this.chartEl.getBoundingClientRect(), width = _this$chartEl$getBoun.width, height = _this$chartEl$getBoun.height, top = _this$chartEl$getBoun.top, left = _this$chartEl$getBoun.left;
                  this.tooltipContainerEl.style.transform = getTranslateString(left + width / 2, top + height / 2);
                  this.chartEl.appendChild(this.tooltipContainerEl);
                  this.eventBus.on("seriesPointHovered", this.onSeriesPointHovered);
                }
              }, {
                key: "removeTooltip",
                value: function removeTooltip() {
                  this.tooltipContainerEl.innerHTML = "";
                }
              }, {
                key: "setTooltipTransition",
                value: function setTooltipTransition(options2) {
                  var _options$tooltip;
                  var transition = (_options$tooltip = options2.tooltip) === null || _options$tooltip === void 0 ? void 0 : _options$tooltip.transition;
                  if (isBoolean(transition) && transition) {
                    this.tooltipContainerEl.style.transition = DEFAULT_TOOLTIP_TRANSITION;
                  } else if (utils_isString(transition)) {
                    this.tooltipContainerEl.style.transition = transition;
                  }
                }
              }, {
                key: "render",
                value: function render(_ref3) {
                  var _options$tooltip$temp, _options$tooltip2, _options$tooltip$offs, _options$tooltip3, _options$tooltip$offs2, _options$tooltip4, _options$tooltip5;
                  var layout2 = _ref3.layout, options2 = _ref3.options, theme2 = _ref3.theme;
                  this.setTooltipTransition(options2);
                  this.rect = layout2.plot;
                  this.theme = theme2.tooltip;
                  this.templateFunc = (_options$tooltip$temp = options2 === null || options2 === void 0 ? void 0 : (_options$tooltip2 = options2.tooltip) === null || _options$tooltip2 === void 0 ? void 0 : _options$tooltip2.template) !== null && _options$tooltip$temp !== void 0 ? _options$tooltip$temp : tooltipTemplates.default;
                  this.offsetX = (_options$tooltip$offs = options2 === null || options2 === void 0 ? void 0 : (_options$tooltip3 = options2.tooltip) === null || _options$tooltip3 === void 0 ? void 0 : _options$tooltip3.offsetX) !== null && _options$tooltip$offs !== void 0 ? _options$tooltip$offs : 10;
                  this.offsetY = (_options$tooltip$offs2 = options2 === null || options2 === void 0 ? void 0 : (_options$tooltip4 = options2.tooltip) === null || _options$tooltip4 === void 0 ? void 0 : _options$tooltip4.offsetY) !== null && _options$tooltip$offs2 !== void 0 ? _options$tooltip$offs2 : 0;
                  this.formatter = options2 === null || options2 === void 0 ? void 0 : (_options$tooltip5 = options2.tooltip) === null || _options$tooltip5 === void 0 ? void 0 : _options$tooltip5.formatter;
                }
              }, {
                key: "getFormattedValue",
                value: function getFormattedValue(value, tooltipDataInfo) {
                  return this.formatter ? this.formatter(value, tooltipDataInfo) : getValueString(value);
                }
              }]);
              return Tooltip2;
            }(Component);
            ;
            function plot_typeof(obj) {
              "@babel/helpers - typeof";
              if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                plot_typeof = function _typeof2(obj2) {
                  return typeof obj2;
                };
              } else {
                plot_typeof = function _typeof2(obj2) {
                  return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                };
              }
              return plot_typeof(obj);
            }
            function plot_ownKeys(object, enumerableOnly) {
              var keys = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object);
                if (enumerableOnly) {
                  symbols = symbols.filter(function(sym) {
                    return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                  });
                }
                keys.push.apply(keys, symbols);
              }
              return keys;
            }
            function plot_objectSpread(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i] != null ? arguments[i] : {};
                if (i % 2) {
                  plot_ownKeys(Object(source), true).forEach(function(key) {
                    plot_defineProperty(target, key, source[key]);
                  });
                } else if (Object.getOwnPropertyDescriptors) {
                  Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                } else {
                  plot_ownKeys(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  });
                }
              }
              return target;
            }
            function component_plot_toConsumableArray(arr) {
              return component_plot_arrayWithoutHoles(arr) || component_plot_iterableToArray(arr) || component_plot_unsupportedIterableToArray(arr) || component_plot_nonIterableSpread();
            }
            function component_plot_nonIterableSpread() {
              throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            function component_plot_iterableToArray(iter) {
              if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
                return Array.from(iter);
            }
            function component_plot_arrayWithoutHoles(arr) {
              if (Array.isArray(arr))
                return component_plot_arrayLikeToArray(arr);
            }
            function component_plot_slicedToArray(arr, i) {
              return component_plot_arrayWithHoles(arr) || component_plot_iterableToArrayLimit(arr, i) || component_plot_unsupportedIterableToArray(arr, i) || component_plot_nonIterableRest();
            }
            function component_plot_nonIterableRest() {
              throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            function component_plot_unsupportedIterableToArray(o, minLen) {
              if (!o)
                return;
              if (typeof o === "string")
                return component_plot_arrayLikeToArray(o, minLen);
              var n = Object.prototype.toString.call(o).slice(8, -1);
              if (n === "Object" && o.constructor)
                n = o.constructor.name;
              if (n === "Map" || n === "Set")
                return Array.from(o);
              if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                return component_plot_arrayLikeToArray(o, minLen);
            }
            function component_plot_arrayLikeToArray(arr, len) {
              if (len == null || len > arr.length)
                len = arr.length;
              for (var i = 0, arr2 = new Array(len); i < len; i++) {
                arr2[i] = arr[i];
              }
              return arr2;
            }
            function component_plot_iterableToArrayLimit(arr, i) {
              var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]);
              if (_i == null)
                return;
              var _arr = [];
              var _n = true;
              var _d = false;
              var _s, _e;
              try {
                for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
                  _arr.push(_s.value);
                  if (i && _arr.length === i)
                    break;
                }
              } catch (err) {
                _d = true;
                _e = err;
              } finally {
                try {
                  if (!_n && _i["return"] != null)
                    _i["return"]();
                } finally {
                  if (_d)
                    throw _e;
                }
              }
              return _arr;
            }
            function component_plot_arrayWithHoles(arr) {
              if (Array.isArray(arr))
                return arr;
            }
            function plot_classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function plot_defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            function plot_createClass(Constructor, protoProps, staticProps) {
              if (protoProps)
                plot_defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                plot_defineProperties(Constructor, staticProps);
              return Constructor;
            }
            function plot_inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function");
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
              if (superClass)
                plot_setPrototypeOf(subClass, superClass);
            }
            function plot_setPrototypeOf(o, p) {
              plot_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
                o2.__proto__ = p2;
                return o2;
              };
              return plot_setPrototypeOf(o, p);
            }
            function plot_createSuper(Derived) {
              var hasNativeReflectConstruct = plot_isNativeReflectConstruct();
              return function _createSuperInternal() {
                var Super = plot_getPrototypeOf(Derived), result;
                if (hasNativeReflectConstruct) {
                  var NewTarget = plot_getPrototypeOf(this).constructor;
                  result = Reflect.construct(Super, arguments, NewTarget);
                } else {
                  result = Super.apply(this, arguments);
                }
                return plot_possibleConstructorReturn(this, result);
              };
            }
            function plot_possibleConstructorReturn(self2, call) {
              if (call && (plot_typeof(call) === "object" || typeof call === "function")) {
                return call;
              }
              return plot_assertThisInitialized(self2);
            }
            function plot_assertThisInitialized(self2) {
              if (self2 === void 0) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return self2;
            }
            function plot_isNativeReflectConstruct() {
              if (typeof Reflect === "undefined" || !Reflect.construct)
                return false;
              if (Reflect.construct.sham)
                return false;
              if (typeof Proxy === "function")
                return true;
              try {
                Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                }));
                return true;
              } catch (e) {
                return false;
              }
            }
            function plot_getPrototypeOf(o) {
              plot_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
                return o2.__proto__ || Object.getPrototypeOf(o2);
              };
              return plot_getPrototypeOf(o);
            }
            function plot_defineProperty(obj, key, value) {
              if (key in obj) {
                Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
              } else {
                obj[key] = value;
              }
              return obj;
            }
            function getValidIndex(index) {
              var startIndex = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
              return ~~index ? index - startIndex : index;
            }
            function validXPosition(_ref) {
              var axisData = _ref.axisData, offsetSize = _ref.offsetSize, value = _ref.value, _ref$startIndex = _ref.startIndex, startIndex = _ref$startIndex === void 0 ? 0 : _ref$startIndex;
              var dataIndex = getValidIndex(value, startIndex);
              var x = getXPosition(axisData, offsetSize, value, dataIndex);
              return x > 0 ? Math.min(offsetSize, x) : 0;
            }
            function getPlotAxisData(vertical, axes2) {
              return vertical ? axes2.xAxis : axes2.yAxis;
            }
            var Plot = function(_Component) {
              plot_inherits(Plot2, _Component);
              var _super = plot_createSuper(Plot2);
              function Plot2() {
                var _this;
                plot_classCallCheck(this, Plot2);
                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }
                _this = _super.call.apply(_super, [this].concat(args));
                plot_defineProperty(plot_assertThisInitialized(_this), "models", {
                  plot: [],
                  line: [],
                  band: []
                });
                plot_defineProperty(plot_assertThisInitialized(_this), "startIndex", 0);
                plot_defineProperty(plot_assertThisInitialized(_this), "theme", void 0);
                return _this;
              }
              plot_createClass(Plot2, [{
                key: "initialize",
                value: function initialize() {
                  this.type = "plot";
                }
              }, {
                key: "getPlotAxisSize",
                value: function getPlotAxisSize(vertical) {
                  return {
                    offsetSize: vertical ? this.rect.width : this.rect.height,
                    anchorSize: vertical ? this.rect.height : this.rect.width
                  };
                }
              }, {
                key: "renderLines",
                value: function renderLines(axes2, categories) {
                  var _this2 = this;
                  var lines = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
                  return lines.map(function(_ref2) {
                    var value = _ref2.value, color = _ref2.color;
                    var _this2$getPlotAxisSiz = _this2.getPlotAxisSize(true), offsetSize = _this2$getPlotAxisSiz.offsetSize;
                    var position = validXPosition({
                      axisData: getPlotAxisData(true, axes2),
                      offsetSize,
                      value,
                      categories,
                      startIndex: _this2.startIndex
                    });
                    return _this2.makeLineModel(true, position, {
                      color
                    });
                  });
                }
              }, {
                key: "renderBands",
                value: function renderBands(axes2, categories) {
                  var _this3 = this;
                  var bands = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
                  var _this$getPlotAxisSize = this.getPlotAxisSize(true), offsetSize = _this$getPlotAxisSize.offsetSize, anchorSize = _this$getPlotAxisSize.anchorSize;
                  return bands.map(function(_ref3) {
                    var range2 = _ref3.range, color = _ref3.color;
                    var _map = range2.map(function(value) {
                      return validXPosition({
                        axisData: getPlotAxisData(true, axes2),
                        offsetSize,
                        value,
                        categories,
                        startIndex: _this3.startIndex
                      });
                    }), _map2 = component_plot_slicedToArray(_map, 2), start = _map2[0], end = _map2[1];
                    return {
                      type: "rect",
                      x: crispPixel(start),
                      y: crispPixel(0),
                      width: end - start,
                      height: anchorSize,
                      color
                    };
                  });
                }
              }, {
                key: "renderPlotLineModels",
                value: function renderPlotLineModels(relativePositions, vertical) {
                  var _ref5, _this4 = this;
                  var options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
                  var size = options2.size, startPosition = options2.startPosition, axes2 = options2.axes;
                  var _ref4 = this.theme[vertical ? "vertical" : "horizontal"], color = _ref4.lineColor, lineWidth = _ref4.lineWidth, dashSegments = _ref4.dashSegments;
                  var tickInterval = ((_ref5 = vertical ? axes2 === null || axes2 === void 0 ? void 0 : axes2.xAxis : axes2 === null || axes2 === void 0 ? void 0 : axes2.yAxis) === null || _ref5 === void 0 ? void 0 : _ref5.tickInterval) || 1;
                  return relativePositions.filter(function(_, idx) {
                    return !(idx % tickInterval);
                  }).map(function(position) {
                    return _this4.makeLineModel(vertical, position, {
                      color,
                      lineWidth,
                      dashSegments
                    }, size !== null && size !== void 0 ? size : _this4.rect.width, startPosition !== null && startPosition !== void 0 ? startPosition : 0);
                  });
                }
              }, {
                key: "renderPlotsForCenterYAxis",
                value: function renderPlotsForCenterYAxis(axes2) {
                  var _ref6 = axes2.centerYAxis, xAxisHalfSize = _ref6.xAxisHalfSize, secondStartX = _ref6.secondStartX, yAxisHeight = _ref6.yAxisHeight;
                  var xAxisTickCount = axes2.xAxis.tickCount;
                  var verticalLines = [].concat(component_plot_toConsumableArray(this.renderPlotLineModels(makeTickPixelPositions(xAxisHalfSize, xAxisTickCount), true)), component_plot_toConsumableArray(this.renderPlotLineModels(makeTickPixelPositions(xAxisHalfSize, xAxisTickCount, secondStartX), true)));
                  var yAxisTickCount = axes2.yAxis.tickCount;
                  var yAxisTickPixelPositions = makeTickPixelPositions(yAxisHeight, yAxisTickCount);
                  var horizontalLines = [].concat(component_plot_toConsumableArray(this.renderPlotLineModels(yAxisTickPixelPositions, false, {
                    size: xAxisHalfSize
                  })), component_plot_toConsumableArray(this.renderPlotLineModels(yAxisTickPixelPositions, false, {
                    size: xAxisHalfSize,
                    startPosition: secondStartX
                  })));
                  return [].concat(component_plot_toConsumableArray(verticalLines), component_plot_toConsumableArray(horizontalLines));
                }
              }, {
                key: "renderPlots",
                value: function renderPlots(axes2, scale2) {
                  var vertical = true;
                  return axes2.centerYAxis ? this.renderPlotsForCenterYAxis(axes2) : [].concat(component_plot_toConsumableArray(this.renderPlotLineModels(this.getHorizontalTickPixelPositions(axes2), !vertical, {
                    axes: axes2
                  })), component_plot_toConsumableArray(this.renderPlotLineModels(this.getVerticalTickPixelPositions(axes2, scale2), vertical, {
                    axes: axes2
                  })));
                }
              }, {
                key: "getVerticalTickPixelPositions",
                value: function getVerticalTickPixelPositions(axes2, scale2) {
                  var _this$getPlotAxisSize2 = this.getPlotAxisSize(true), offsetSize = _this$getPlotAxisSize2.offsetSize;
                  var axisData = getPlotAxisData(true, axes2);
                  if (axisData !== null && axisData !== void 0 && axisData.labelRange) {
                    var _scale$xAxis$sizeRati, _scale$xAxis, _scale$xAxis$position, _scale$xAxis2;
                    var sizeRatio = (_scale$xAxis$sizeRati = scale2 === null || scale2 === void 0 ? void 0 : (_scale$xAxis = scale2.xAxis) === null || _scale$xAxis === void 0 ? void 0 : _scale$xAxis.sizeRatio) !== null && _scale$xAxis$sizeRati !== void 0 ? _scale$xAxis$sizeRati : 1;
                    var positionRatio = (_scale$xAxis$position = scale2 === null || scale2 === void 0 ? void 0 : (_scale$xAxis2 = scale2.xAxis) === null || _scale$xAxis2 === void 0 ? void 0 : _scale$xAxis2.positionRatio) !== null && _scale$xAxis$position !== void 0 ? _scale$xAxis$position : 0;
                    var axisSizeAppliedRatio = offsetSize * sizeRatio;
                    var additional = offsetSize * positionRatio;
                    return makeTickPixelPositions(axisSizeAppliedRatio, axisData.tickCount, additional);
                  }
                  return makeTickPixelPositions(offsetSize, axisData.tickCount);
                }
              }, {
                key: "getHorizontalTickPixelPositions",
                value: function getHorizontalTickPixelPositions(axes2) {
                  var _this$getPlotAxisSize3 = this.getPlotAxisSize(false), offsetSize = _this$getPlotAxisSize3.offsetSize;
                  var axisData = getPlotAxisData(false, axes2);
                  return makeTickPixelPositions(offsetSize, axisData.tickCount);
                }
              }, {
                key: "renderPlotBackgroundRect",
                value: function renderPlotBackgroundRect() {
                  return plot_objectSpread(plot_objectSpread({
                    type: "rect",
                    x: 0,
                    y: 0
                  }, pick(this.rect, "width", "height")), {}, {
                    color: this.theme.backgroundColor
                  });
                }
              }, {
                key: "render",
                value: function render(state) {
                  var _zoomRange$, _ref7;
                  var layout2 = state.layout, axes2 = state.axes, plot2 = state.plot, zoomRange = state.zoomRange, theme2 = state.theme, scale2 = state.scale;
                  if (!plot2) {
                    return;
                  }
                  this.rect = layout2.plot;
                  this.startIndex = (_zoomRange$ = zoomRange === null || zoomRange === void 0 ? void 0 : zoomRange[0]) !== null && _zoomRange$ !== void 0 ? _zoomRange$ : 0;
                  this.theme = theme2.plot;
                  var categories = (_ref7 = state.categories) !== null && _ref7 !== void 0 ? _ref7 : [];
                  var lines = plot2.lines, bands = plot2.bands, visible = plot2.visible;
                  this.models.line = this.renderLines(axes2, categories, lines);
                  this.models.band = this.renderBands(axes2, categories, bands);
                  if (visible) {
                    this.models.plot = [this.renderPlotBackgroundRect()].concat(component_plot_toConsumableArray(this.renderPlots(axes2, scale2)));
                  }
                }
              }, {
                key: "makeLineModel",
                value: function makeLineModel(vertical, position, _ref8, sizeWidth) {
                  var color = _ref8.color, _ref8$dashSegments = _ref8.dashSegments, dashSegments = _ref8$dashSegments === void 0 ? [] : _ref8$dashSegments, _ref8$lineWidth = _ref8.lineWidth, lineWidth = _ref8$lineWidth === void 0 ? 1 : _ref8$lineWidth;
                  var xPos = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0;
                  var x = vertical ? crispPixel(position) : crispPixel(xPos);
                  var y = vertical ? crispPixel(0) : crispPixel(position);
                  var width = vertical ? 0 : sizeWidth !== null && sizeWidth !== void 0 ? sizeWidth : this.rect.width;
                  var height = vertical ? this.rect.height : 0;
                  return {
                    type: "line",
                    x,
                    y,
                    x2: x + width,
                    y2: y + height,
                    strokeStyle: color,
                    lineWidth,
                    dashSegments
                  };
                }
              }, {
                key: "beforeDraw",
                value: function beforeDraw(painter) {
                  painter.ctx.strokeStyle = "rgba(0, 0, 0, 0.05)";
                  painter.ctx.lineWidth = 1;
                }
              }]);
              return Plot2;
            }(Component);
            ;
            function responders_ownKeys(object, enumerableOnly) {
              var keys = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object);
                if (enumerableOnly) {
                  symbols = symbols.filter(function(sym) {
                    return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                  });
                }
                keys.push.apply(keys, symbols);
              }
              return keys;
            }
            function responders_objectSpread(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i] != null ? arguments[i] : {};
                if (i % 2) {
                  responders_ownKeys(Object(source), true).forEach(function(key) {
                    responders_defineProperty(target, key, source[key]);
                  });
                } else if (Object.getOwnPropertyDescriptors) {
                  Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                } else {
                  responders_ownKeys(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  });
                }
              }
              return target;
            }
            function responders_defineProperty(obj, key, value) {
              if (key in obj) {
                Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
              } else {
                obj[key] = value;
              }
              return obj;
            }
            function responders_toConsumableArray(arr) {
              return responders_arrayWithoutHoles(arr) || responders_iterableToArray(arr) || responders_unsupportedIterableToArray(arr) || responders_nonIterableSpread();
            }
            function responders_nonIterableSpread() {
              throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            function responders_unsupportedIterableToArray(o, minLen) {
              if (!o)
                return;
              if (typeof o === "string")
                return responders_arrayLikeToArray(o, minLen);
              var n = Object.prototype.toString.call(o).slice(8, -1);
              if (n === "Object" && o.constructor)
                n = o.constructor.name;
              if (n === "Map" || n === "Set")
                return Array.from(o);
              if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                return responders_arrayLikeToArray(o, minLen);
            }
            function responders_iterableToArray(iter) {
              if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
                return Array.from(iter);
            }
            function responders_arrayWithoutHoles(arr) {
              if (Array.isArray(arr))
                return responders_arrayLikeToArray(arr);
            }
            function responders_arrayLikeToArray(arr, len) {
              if (len == null || len > arr.length)
                len = arr.length;
              for (var i = 0, arr2 = new Array(len); i < len; i++) {
                arr2[i] = arr[i];
              }
              return arr2;
            }
            function isSameSeriesResponder(_ref) {
              var models = _ref.models, comparisonModel = _ref.comparisonModel, name = _ref.name, eventDetectType = _ref.eventDetectType;
              switch (name) {
                case "heatmap":
                  return isClickSameNameResponder(models, comparisonModel);
                case "bullet":
                  return eventDetectType === "grouped" ? isClickSameGroupedRectResponder(models, comparisonModel) : isClickSameNameResponder(models, comparisonModel);
                case "radar":
                case "bubble":
                case "scatter":
                case "area":
                case "line":
                  return isClickSameCircleResponder(models, comparisonModel);
                case "pie":
                  return isClickSameDataResponder(models, comparisonModel);
                case "column":
                case "bar":
                  return eventDetectType === "grouped" ? isClickSameGroupedRectResponder(models, comparisonModel) : isClickSameDataResponder(models, comparisonModel);
                case "boxPlot":
                  return eventDetectType === "grouped" ? isClickSameDataResponder(models, comparisonModel) : isClickSameBoxPlotDataResponder(models, comparisonModel);
                case "treemap":
                  return isClickSameLabelResponder(models, comparisonModel);
                case "gauge":
                  return isClickSameNameResponder(models, comparisonModel);
                default:
                  return false;
              }
            }
            function getNearestResponder(responders, mousePosition, rect2) {
              var minDistance = Infinity;
              var result = [];
              responders.forEach(function(responder) {
                var x = responder.x, y = responder.y, radius = responder.radius;
                var responderPoint = {
                  x: x + rect2.x,
                  y: y + rect2.y
                };
                var distance = getDistance(responderPoint, mousePosition);
                if (minDistance > distance) {
                  minDistance = distance;
                  result = [responder];
                } else if (minDistance === distance) {
                  if (result.length && result[0].radius > radius) {
                    result = [responder];
                  } else {
                    result.push(responder);
                  }
                }
              });
              return result;
            }
            function makeRectResponderModel(rect2, axis, categories) {
              var vertical = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
              var pointOnColumn = axis.pointOnColumn, tickDistance = axis.tickDistance, rectResponderCount = axis.rectResponderCount;
              var width = rect2.width, height = rect2.height;
              var halfDetectAreaIndex = pointOnColumn ? [] : [0, rectResponderCount - 1];
              var halfSize = tickDistance / 2;
              return range(0, rectResponderCount).map(function(index) {
                var half = halfDetectAreaIndex.includes(index);
                var size = half ? halfSize : tickDistance;
                var startPos = 0;
                if (index !== 0) {
                  startPos += pointOnColumn ? tickDistance * index : halfSize + tickDistance * (index - 1);
                }
                return {
                  type: "rect",
                  y: vertical ? 0 : startPos,
                  height: vertical ? height : size,
                  x: vertical ? startPos : 0,
                  width: vertical ? size : width,
                  index,
                  label: categories[index]
                };
              });
            }
            function responders_makeRectResponderModelForCoordinateType(responderInfo, rect2) {
              var width = rect2.width, height = rect2.height;
              var startPos = 0;
              return responderInfo.sort(function(a, b) {
                return a.x - b.x;
              }).reduce(function(acc, model, index) {
                var x = model.x, label2 = model.label;
                var next = responderInfo[index + 1];
                var endPos = next ? (next.x + x) / 2 : width;
                var rectResponderModel = {
                  type: "rect",
                  x: startPos,
                  y: 0,
                  width: endPos - startPos,
                  height,
                  label: label2,
                  index
                };
                startPos = endPos;
                return [].concat(responders_toConsumableArray(acc), [rectResponderModel]);
              }, []);
            }
            function makeTooltipCircleMap(seriesCircleModel, tooltipDataArr) {
              var dataMap = tooltipDataArr.reduce(function(acc, cur) {
                var index = cur.index, seriesIndex = cur.seriesIndex;
                if (!acc[seriesIndex]) {
                  acc[seriesIndex] = [];
                }
                acc[seriesIndex][index] = cur;
                return acc;
              }, []);
              return seriesCircleModel.reduce(function(acc, model) {
                var seriesIndex = model.seriesIndex, index = model.index;
                var data = dataMap[seriesIndex][index];
                var category2 = data.category;
                if (!category2) {
                  return acc;
                }
                if (!acc[category2]) {
                  acc[category2] = [];
                }
                acc[category2].push(responders_objectSpread(responders_objectSpread({}, model), {}, {
                  data
                }));
                return acc;
              }, {});
            }
            function getDeepestNode(responders) {
              return responders.reduce(function(acc, responder) {
                if (!acc.length || responder.depth > acc[0].depth) {
                  return [responder];
                }
                return acc;
              }, []);
            }
            function isClickSameNameResponder(responders, selectedSeries) {
              return responders.length && (selectedSeries === null || selectedSeries === void 0 ? void 0 : selectedSeries.length) && responders[0].name === selectedSeries[0].name;
            }
            function isClickSameCircleResponder(responders, selectedSeries) {
              var same = false;
              if (responders.length && selectedSeries !== null && selectedSeries !== void 0 && selectedSeries.length && responders.length === selectedSeries.length) {
                same = responders.reduce(function(acc, cur, idx) {
                  return acc && cur.seriesIndex === selectedSeries[idx].seriesIndex && cur.index === selectedSeries[idx].index;
                }, true);
              }
              return same;
            }
            function isClickSameDataResponder(responders, selectedSeries) {
              var same = false;
              if (responders.length && selectedSeries !== null && selectedSeries !== void 0 && selectedSeries.length && responders.length === selectedSeries.length) {
                same = responders.reduce(function(acc, cur, idx) {
                  var _cur$data, _selectedSeries$idx$d, _cur$data2, _selectedSeries$idx$d2;
                  return acc && ((_cur$data = cur.data) === null || _cur$data === void 0 ? void 0 : _cur$data.label) === ((_selectedSeries$idx$d = selectedSeries[idx].data) === null || _selectedSeries$idx$d === void 0 ? void 0 : _selectedSeries$idx$d.label) && ((_cur$data2 = cur.data) === null || _cur$data2 === void 0 ? void 0 : _cur$data2.category) === ((_selectedSeries$idx$d2 = selectedSeries[idx].data) === null || _selectedSeries$idx$d2 === void 0 ? void 0 : _selectedSeries$idx$d2.category);
                }, true);
              }
              return same;
            }
            function isClickSameLabelResponder(responders, selectedSeries) {
              return responders.length && (selectedSeries === null || selectedSeries === void 0 ? void 0 : selectedSeries.length) && responders[0].label === selectedSeries[0].label;
            }
            function isClickSameGroupedRectResponder(responders, selectedSeries) {
              return responders.length && (selectedSeries === null || selectedSeries === void 0 ? void 0 : selectedSeries.length) && responders[0].index === selectedSeries[0].index;
            }
            function isClickSameBoxPlotDataResponder(responders, selectedSeries) {
              var same = false;
              if (responders.length && selectedSeries !== null && selectedSeries !== void 0 && selectedSeries.length) {
                var _selectedSeries$0$dat, _selectedSeries$0$dat2;
                var _responders$ = responders[0], type = _responders$.type, data = _responders$.data;
                same = type === selectedSeries[0].type && (data === null || data === void 0 ? void 0 : data.label) === ((_selectedSeries$0$dat = selectedSeries[0].data) === null || _selectedSeries$0$dat === void 0 ? void 0 : _selectedSeries$0$dat.label) && (data === null || data === void 0 ? void 0 : data.category) === ((_selectedSeries$0$dat2 = selectedSeries[0].data) === null || _selectedSeries$0$dat2 === void 0 ? void 0 : _selectedSeries$0$dat2.category);
              }
              return same;
            }
            function makeGroupedSectorResponderModel(radiusRanges, renderOptions, categories) {
              var centerX = renderOptions.centerX, centerY = renderOptions.centerY, _renderOptions$angleR = renderOptions.angleRange, start = _renderOptions$angleR.start, end = _renderOptions$angleR.end, clockwise = renderOptions.clockwise;
              return getRadiusRanges(radiusRanges, 0).map(function(radius, index) {
                return {
                  type: "sector",
                  x: centerX,
                  y: centerY,
                  degree: {
                    start,
                    end
                  },
                  radius,
                  name: categories[index],
                  clockwise,
                  index
                };
              });
            }
            ;
            function dataLabels_ownKeys(object, enumerableOnly) {
              var keys = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object);
                if (enumerableOnly) {
                  symbols = symbols.filter(function(sym) {
                    return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                  });
                }
                keys.push.apply(keys, symbols);
              }
              return keys;
            }
            function dataLabels_objectSpread(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i] != null ? arguments[i] : {};
                if (i % 2) {
                  dataLabels_ownKeys(Object(source), true).forEach(function(key) {
                    dataLabels_defineProperty(target, key, source[key]);
                  });
                } else if (Object.getOwnPropertyDescriptors) {
                  Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                } else {
                  dataLabels_ownKeys(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  });
                }
              }
              return target;
            }
            function dataLabels_defineProperty(obj, key, value) {
              if (key in obj) {
                Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
              } else {
                obj[key] = value;
              }
              return obj;
            }
            var RADIUS_PADDING = 30;
            var CALLOUT_LENGTH = 20;
            function getDefaultAnchor(type) {
              var withStack = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
              var anchor = "auto";
              switch (type) {
                case "point":
                  anchor = "center";
                  break;
                case "rect":
                  anchor = !withStack ? "auto" : "center";
                  break;
                case "sector":
                case "treemapSeriesName":
                  anchor = "center";
                  break;
                case "stackTotal":
                  anchor = "auto";
                  break;
              }
              return anchor;
            }
            function getAnchor(dataLabelOptions, type) {
              var withStack = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
              return type !== "stackTotal" && includes(["center", "start", "end", "auto", "outer"], dataLabelOptions.anchor) ? dataLabelOptions.anchor : getDefaultAnchor(type, withStack);
            }
            function getDefaultDataLabelsOptions(dataLabelOptions, type) {
              var _pieSeriesName;
              var withStack = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
              var anchor = getAnchor(dataLabelOptions, type, withStack);
              var _dataLabelOptions$off = dataLabelOptions.offsetX, offsetX = _dataLabelOptions$off === void 0 ? 0 : _dataLabelOptions$off, _dataLabelOptions$off2 = dataLabelOptions.offsetY, offsetY = _dataLabelOptions$off2 === void 0 ? 0 : _dataLabelOptions$off2;
              var formatter = isFunction(dataLabelOptions.formatter) ? dataLabelOptions.formatter : function(value) {
                return String(value) || "";
              };
              var options2 = {
                anchor,
                offsetX,
                offsetY,
                formatter
              };
              if (withStack) {
                var stackTotal = dataLabelOptions.stackTotal;
                options2.stackTotal = {
                  visible: isBoolean(stackTotal === null || stackTotal === void 0 ? void 0 : stackTotal.visible) ? stackTotal.visible : true,
                  formatter: isFunction(stackTotal === null || stackTotal === void 0 ? void 0 : stackTotal.formatter) ? stackTotal.formatter : formatter
                };
              }
              if (type === "sector" && (_pieSeriesName = dataLabelOptions.pieSeriesName) !== null && _pieSeriesName !== void 0 && _pieSeriesName.visible) {
                options2.pieSeriesName = dataLabels_objectSpread(dataLabels_objectSpread({}, {
                  anchor: "center"
                }), dataLabelOptions.pieSeriesName);
              }
              return options2;
            }
            function makePointLabelInfo(point, dataLabelOptions, rect2) {
              var width = rect2.width, height = rect2.height;
              var anchor = dataLabelOptions.anchor, _dataLabelOptions$off3 = dataLabelOptions.offsetX, offsetX = _dataLabelOptions$off3 === void 0 ? 0 : _dataLabelOptions$off3, _dataLabelOptions$off4 = dataLabelOptions.offsetY, offsetY = _dataLabelOptions$off4 === void 0 ? 0 : _dataLabelOptions$off4, formatter = dataLabelOptions.formatter;
              var name = point.name, theme2 = point.theme;
              var textBaseline = "middle";
              if (anchor === "end") {
                textBaseline = "bottom";
              } else if (anchor === "start") {
                textBaseline = "top";
              }
              var xWithOffset = point.x + offsetX;
              var yWithOffset = point.y + offsetY;
              var x = xWithOffset < 0 || xWithOffset > width ? point.x : xWithOffset;
              var y = yWithOffset < 0 || yWithOffset > height ? point.y : yWithOffset;
              return {
                type: "point",
                x,
                y,
                text: formatter(point.value, point.data),
                textAlign: "center",
                textBaseline,
                name,
                theme: theme2
              };
            }
            function isHorizontal(direction) {
              return includes(["left", "right"], direction);
            }
            function makeHorizontalRectPosition(rect2, anchor) {
              var x = rect2.x, y = rect2.y, width = rect2.width, height = rect2.height, direction = rect2.direction;
              var textBaseline = "middle";
              var posY = y + height / 2;
              var textAlign = "center";
              var posX;
              if (direction === "right") {
                switch (anchor) {
                  case "start":
                    textAlign = "left";
                    posX = x;
                    break;
                  case "end":
                    textAlign = "right";
                    posX = x + width;
                    break;
                  case "center":
                    textAlign = "center";
                    posX = x + width / 2;
                    break;
                  default:
                    textAlign = "left";
                    posX = x + width;
                }
              } else {
                switch (anchor) {
                  case "start":
                    textAlign = "right";
                    posX = x + width;
                    break;
                  case "end":
                    textAlign = "left";
                    posX = x;
                    break;
                  case "center":
                    textAlign = "center";
                    posX = x + width / 2;
                    break;
                  default:
                    textAlign = "right";
                    posX = x;
                }
              }
              return {
                x: posX,
                y: posY,
                textAlign,
                textBaseline
              };
            }
            function makeVerticalRectPosition(rect2, anchor) {
              var x = rect2.x, y = rect2.y, width = rect2.width, height = rect2.height, direction = rect2.direction;
              var textAlign = "center";
              var posX = x + width / 2;
              var textBaseline = "middle";
              var posY = 0;
              if (direction === "top") {
                switch (anchor) {
                  case "end":
                    textBaseline = "top";
                    posY = y;
                    break;
                  case "start":
                    textBaseline = "bottom";
                    posY = y + height;
                    break;
                  case "center":
                    textBaseline = "middle";
                    posY = y + height / 2;
                    break;
                  default:
                    textBaseline = "bottom";
                    posY = y;
                }
              } else {
                switch (anchor) {
                  case "end":
                    textBaseline = "bottom";
                    posY = y + height;
                    break;
                  case "start":
                    textBaseline = "top";
                    posY = y;
                    break;
                  case "center":
                    textBaseline = "middle";
                    posY = y + height / 2;
                    break;
                  default:
                    textBaseline = "top";
                    posY = y + height;
                    break;
                }
              }
              return {
                x: posX,
                y: posY,
                textAlign,
                textBaseline
              };
            }
            function adjustOverflowHorizontalRect(rect2, dataLabelOptions, position) {
              var width = rect2.width, value = rect2.value, direction = rect2.direction, plot2 = rect2.plot, theme2 = rect2.theme;
              var formatter = dataLabelOptions.formatter;
              var font = getFont(theme2);
              var text = utils_isString(value) ? value : formatter(value);
              var textWidth = getTextWidth(text, font);
              var x = position.x, textAlign = position.textAlign;
              var isOverflow = direction === "left" && x - textWidth < 0 || x + textWidth > plot2.size;
              if (isOverflow) {
                x = rect2.x + width;
                textAlign = "right";
                if (direction === "left" && width >= textWidth) {
                  x = rect2.x;
                  textAlign = "left";
                }
              }
              return {
                x,
                textAlign
              };
            }
            function adjustOverflowVerticalRect(rect2, dataLabelOptions, position) {
              var height = rect2.height, direction = rect2.direction, plot2 = rect2.plot, theme2 = rect2.theme, value = rect2.value;
              var font = getFont(theme2);
              var plotSize = plot2.size;
              var textHeight = getTextHeight("".concat(value), font);
              var y = position.y, textBaseline = position.textBaseline;
              var isOverflow = !(direction === "bottom") && y - textHeight < 0 || y + textHeight > plotSize;
              if (isOverflow) {
                y = rect2.y;
                textBaseline = "top";
                if (y + textHeight > plotSize) {
                  y = rect2.y;
                  textBaseline = "bottom";
                }
                if (direction === "bottom") {
                  y = rect2.y + height;
                  textBaseline = "bottom";
                }
              }
              return {
                y,
                textBaseline
              };
            }
            function makeHorizontalRectLabelInfo(rect2, dataLabelOptions) {
              var anchor = dataLabelOptions.anchor, _dataLabelOptions$off5 = dataLabelOptions.offsetX, offsetX = _dataLabelOptions$off5 === void 0 ? 0 : _dataLabelOptions$off5, _dataLabelOptions$off6 = dataLabelOptions.offsetY, offsetY = _dataLabelOptions$off6 === void 0 ? 0 : _dataLabelOptions$off6;
              var direction = rect2.direction, _rect$plot = rect2.plot, _rect$plot$x = _rect$plot.x, startOffsetX = _rect$plot$x === void 0 ? 0 : _rect$plot$x, _rect$plot$y = _rect$plot.y, startOffsetY = _rect$plot$y === void 0 ? 0 : _rect$plot$y;
              var position = makeHorizontalRectPosition(rect2, anchor);
              var posX = position.x, posY = position.y, textAlign = position.textAlign;
              if (anchor === "auto") {
                var adjustRect = adjustOverflowHorizontalRect(rect2, dataLabelOptions, {
                  x: posX,
                  textAlign
                });
                posX = adjustRect.x;
                textAlign = adjustRect.textAlign;
              }
              posY += offsetY;
              if (direction === "left") {
                posX = posX - offsetX;
              } else {
                posX = posX + offsetX;
              }
              var padding2 = 10;
              if (textAlign === "right") {
                posX -= padding2;
              } else if (textAlign === "left") {
                posX += padding2;
              }
              posX -= startOffsetX;
              posY -= startOffsetY;
              return {
                x: posX,
                y: posY,
                textAlign,
                textBaseline: position.textBaseline
              };
            }
            function makeVerticalRectLabelInfo(rect2, dataLabelOptions) {
              var anchor = dataLabelOptions.anchor, _dataLabelOptions$off7 = dataLabelOptions.offsetX, offsetX = _dataLabelOptions$off7 === void 0 ? 0 : _dataLabelOptions$off7, _dataLabelOptions$off8 = dataLabelOptions.offsetY, offsetY = _dataLabelOptions$off8 === void 0 ? 0 : _dataLabelOptions$off8;
              var direction = rect2.direction, _rect$plot2 = rect2.plot, _rect$plot2$x = _rect$plot2.x, startOffsetX = _rect$plot2$x === void 0 ? 0 : _rect$plot2$x, _rect$plot2$y = _rect$plot2.y, startOffsetY = _rect$plot2$y === void 0 ? 0 : _rect$plot2$y;
              var position = makeVerticalRectPosition(rect2, anchor);
              var posX = position.x, posY = position.y, textBaseline = position.textBaseline;
              if (anchor === "auto") {
                var adjustRect = adjustOverflowVerticalRect(rect2, dataLabelOptions, position);
                posY = adjustRect.y;
                textBaseline = adjustRect.textBaseline;
              }
              posX += offsetX;
              if (direction === "top") {
                posY = posY + offsetY;
              } else if (direction === "bottom") {
                posY = posY - offsetY;
              }
              var padding2 = 5;
              if (textBaseline === "bottom") {
                posY -= padding2;
              } else if (textBaseline === "top") {
                posY += padding2;
              }
              posX -= startOffsetX;
              posY -= startOffsetY;
              return {
                x: posX,
                y: posY,
                textAlign: position.textAlign,
                textBaseline
              };
            }
            function makeRectLabelInfo(rect2, dataLabelOptions) {
              var type = rect2.type, value = rect2.value, direction = rect2.direction, name = rect2.name, theme2 = rect2.theme;
              var horizontal = isHorizontal(direction);
              var labelPosition = horizontal ? makeHorizontalRectLabelInfo(rect2, dataLabelOptions) : makeVerticalRectLabelInfo(rect2, dataLabelOptions);
              var formatter = type === "stackTotal" ? dataLabelOptions.stackTotal.formatter : dataLabelOptions.formatter;
              return dataLabels_objectSpread(dataLabels_objectSpread({
                type
              }, labelPosition), {}, {
                text: utils_isString(value) ? value : formatter(value),
                name,
                seriesColor: rect2.color,
                theme: theme2
              });
            }
            function makeSectorLabelPosition(model, dataLabelOptions) {
              var anchor = dataLabelOptions.anchor;
              var position = getRadialAnchorPosition(makeAnchorPositionParam(anchor, dataLabels_objectSpread(dataLabels_objectSpread({}, model), {}, {
                radius: dataLabels_objectSpread(dataLabels_objectSpread({}, model.radius), {}, {
                  outer: anchor === "outer" ? model.radius.outer + RADIUS_PADDING : model.radius.outer
                })
              })));
              var textAlign = getRadialLabelAlign(model, anchor);
              return dataLabels_objectSpread(dataLabels_objectSpread({}, position), {}, {
                textAlign,
                textBaseline: hasSameAnchorPieDataLabel(dataLabelOptions) ? "bottom" : "middle"
              });
            }
            function makeSectorBarLabelPosition(model, dataLabelOptions) {
              var anchor = dataLabelOptions.anchor;
              var clockwise = model.clockwise, _model$degree = model.degree, start = _model$degree.start, end = _model$degree.end, _model$radius = model.radius, inner = _model$radius.inner, outer = _model$radius.outer;
              var startAngle = start;
              var endAngle = end;
              var textAlign = "center";
              var rotationDegree = (start + end) / 2;
              if (anchor === "start") {
                textAlign = clockwise ? "left" : "right";
                endAngle = startAngle;
                rotationDegree = start;
              } else if (anchor === "end") {
                textAlign = clockwise ? "right" : "left";
                startAngle = endAngle;
                rotationDegree = end;
              }
              var _getRadialAnchorPosit = getRadialAnchorPosition(makeAnchorPositionParam(anchor, dataLabels_objectSpread(dataLabels_objectSpread({}, model), {}, {
                degree: {
                  start: startAngle,
                  end: endAngle
                },
                radius: {
                  inner,
                  outer
                }
              }))), x = _getRadialAnchorPosit.x, y = _getRadialAnchorPosit.y;
              return {
                x,
                y,
                textAlign,
                textBaseline: "middle",
                radian: calculateDegreeToRadian(rotationDegree, 0)
              };
            }
            function makeSectorBarLabelInfo(model, dataLabelOptions) {
              var formatter = dataLabelOptions.formatter;
              var labelPosition = makeSectorBarLabelPosition(model, dataLabelOptions);
              var value = model.value, name = model.name, dataLabelTheme = model.theme;
              var theme2 = dataLabels_objectSpread(dataLabels_objectSpread({}, dataLabelTheme), {}, {
                color: dataLabelTheme.useSeriesColor ? model.color : dataLabelTheme.color
              });
              return dataLabels_objectSpread(dataLabels_objectSpread({
                type: "sector"
              }, labelPosition), {}, {
                text: formatter(value),
                name,
                theme: theme2
              });
            }
            function makeSectorLabelInfo(model, dataLabelOptions) {
              var formatter = dataLabelOptions.formatter;
              var labelPosition = makeSectorLabelPosition(model, dataLabelOptions);
              var value = model.value, name = model.name, dataLabelTheme = model.theme;
              var anchor = dataLabelOptions.anchor;
              var theme2 = dataLabels_objectSpread(dataLabels_objectSpread({}, dataLabelTheme), {}, {
                color: dataLabelTheme.useSeriesColor ? model.color : dataLabelTheme.color
              });
              return dataLabels_objectSpread(dataLabels_objectSpread({
                type: "sector"
              }, labelPosition), {}, {
                text: formatter(value),
                name,
                callout: hasSectorCallout(dataLabelOptions) ? getPieDataLabelCallout(model, anchor) : null,
                theme: theme2
              });
            }
            function makePieSeriesNameLabelInfo(model, dataLabelOptions) {
              var _dataLabelOptions$pie;
              var seriesNameAnchor = (_dataLabelOptions$pie = dataLabelOptions.pieSeriesName) === null || _dataLabelOptions$pie === void 0 ? void 0 : _dataLabelOptions$pie.anchor;
              var hasOuterAnchor = seriesNameAnchor === "outer";
              var position = getRadialAnchorPosition(makeAnchorPositionParam(seriesNameAnchor, dataLabels_objectSpread(dataLabels_objectSpread({}, model), {}, {
                radius: dataLabels_objectSpread(dataLabels_objectSpread({}, model.radius), {}, {
                  outer: hasOuterAnchor ? model.radius.outer + RADIUS_PADDING : model.radius.outer
                })
              })));
              var textAlign = getRadialLabelAlign(model, seriesNameAnchor);
              var pieSeriesNameTheme = model.theme.pieSeriesName;
              var theme2 = dataLabels_objectSpread(dataLabels_objectSpread({}, pieSeriesNameTheme), {}, {
                color: pieSeriesNameTheme.useSeriesColor ? model.color : pieSeriesNameTheme.color
              });
              return dataLabels_objectSpread(dataLabels_objectSpread({
                type: "pieSeriesName"
              }, position), {}, {
                text: model.name,
                callout: hasPieSeriesNameCallout(dataLabelOptions) ? getPieDataLabelCallout(model, seriesNameAnchor) : null,
                textAlign,
                textBaseline: hasSameAnchorPieDataLabel(dataLabelOptions) ? "top" : "middle",
                theme: theme2
              });
            }
            function getDataLabelsOptions(options2, name) {
              var _options$series, _options$series$name, _options$series2;
              return (options2 === null || options2 === void 0 ? void 0 : (_options$series = options2.series) === null || _options$series === void 0 ? void 0 : (_options$series$name = _options$series[name]) === null || _options$series$name === void 0 ? void 0 : _options$series$name.dataLabels) || (options2 === null || options2 === void 0 ? void 0 : (_options$series2 = options2.series) === null || _options$series2 === void 0 ? void 0 : _options$series2.dataLabels) || {};
            }
            function makeLineLabelInfo(model, dataLabelOptions) {
              var value = model.value, textAlign = model.textAlign, textBaseline = model.textBaseline;
              var formatter = dataLabelOptions.formatter;
              return dataLabels_objectSpread(dataLabels_objectSpread({}, model), {}, {
                x: model.x,
                y: (model.y + model.y2) / 2,
                textAlign: textAlign !== null && textAlign !== void 0 ? textAlign : "center",
                textBaseline: textBaseline !== null && textBaseline !== void 0 ? textBaseline : "middle",
                text: utils_isString(value) ? value : formatter(value)
              });
            }
            function hasSameAnchorPieDataLabel(dataLabelOptions) {
              var _dataLabelOptions$pie2;
              return dataLabelOptions.anchor === ((_dataLabelOptions$pie2 = dataLabelOptions.pieSeriesName) === null || _dataLabelOptions$pie2 === void 0 ? void 0 : _dataLabelOptions$pie2.anchor);
            }
            function hasSectorCallout(dataLabelOptions) {
              var _dataLabelOptions$pie3;
              return dataLabelOptions.anchor === "outer" || ((_dataLabelOptions$pie3 = dataLabelOptions.pieSeriesName) === null || _dataLabelOptions$pie3 === void 0 ? void 0 : _dataLabelOptions$pie3.anchor) !== "outer";
            }
            function hasPieSeriesNameCallout(dataLabelOptions) {
              var _dataLabelOptions$pie4;
              return dataLabelOptions.anchor !== "outer" || ((_dataLabelOptions$pie4 = dataLabelOptions.pieSeriesName) === null || _dataLabelOptions$pie4 === void 0 ? void 0 : _dataLabelOptions$pie4.anchor) === "outer";
            }
            function getPieDataLabelCallout(model, anchor) {
              if (anchor !== "outer") {
                return null;
              }
              var _getRadialAnchorPosit2 = getRadialAnchorPosition(makeAnchorPositionParam("outer", dataLabels_objectSpread(dataLabels_objectSpread({}, model), {}, {
                radius: dataLabels_objectSpread(dataLabels_objectSpread({}, model.radius), {}, {
                  outer: model.radius.outer + CALLOUT_LENGTH
                })
              }))), x = _getRadialAnchorPosit2.x, y = _getRadialAnchorPosit2.y;
              var _getRadialAnchorPosit3 = getRadialAnchorPosition(makeAnchorPositionParam("outer", dataLabels_objectSpread({}, model))), x2 = _getRadialAnchorPosit3.x, y2 = _getRadialAnchorPosit3.y;
              var callout = model.theme.callout;
              var theme2 = dataLabels_objectSpread(dataLabels_objectSpread({}, callout), {}, {
                lineColor: callout.useSeriesColor ? model.color : callout.lineColor
              });
              return {
                x,
                y,
                x2,
                y2,
                theme: theme2
              };
            }
            ;
            function lineSeries_typeof(obj) {
              "@babel/helpers - typeof";
              if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                lineSeries_typeof = function _typeof2(obj2) {
                  return typeof obj2;
                };
              } else {
                lineSeries_typeof = function _typeof2(obj2) {
                  return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                };
              }
              return lineSeries_typeof(obj);
            }
            function lineSeries_ownKeys(object, enumerableOnly) {
              var keys = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object);
                if (enumerableOnly) {
                  symbols = symbols.filter(function(sym) {
                    return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                  });
                }
                keys.push.apply(keys, symbols);
              }
              return keys;
            }
            function lineSeries_objectSpread(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i] != null ? arguments[i] : {};
                if (i % 2) {
                  lineSeries_ownKeys(Object(source), true).forEach(function(key) {
                    lineSeries_defineProperty(target, key, source[key]);
                  });
                } else if (Object.getOwnPropertyDescriptors) {
                  Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                } else {
                  lineSeries_ownKeys(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  });
                }
              }
              return target;
            }
            function lineSeries_classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function lineSeries_defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            function lineSeries_createClass(Constructor, protoProps, staticProps) {
              if (protoProps)
                lineSeries_defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                lineSeries_defineProperties(Constructor, staticProps);
              return Constructor;
            }
            function lineSeries_inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function");
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
              if (superClass)
                lineSeries_setPrototypeOf(subClass, superClass);
            }
            function lineSeries_setPrototypeOf(o, p) {
              lineSeries_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
                o2.__proto__ = p2;
                return o2;
              };
              return lineSeries_setPrototypeOf(o, p);
            }
            function lineSeries_createSuper(Derived) {
              var hasNativeReflectConstruct = lineSeries_isNativeReflectConstruct();
              return function _createSuperInternal() {
                var Super = lineSeries_getPrototypeOf(Derived), result;
                if (hasNativeReflectConstruct) {
                  var NewTarget = lineSeries_getPrototypeOf(this).constructor;
                  result = Reflect.construct(Super, arguments, NewTarget);
                } else {
                  result = Super.apply(this, arguments);
                }
                return lineSeries_possibleConstructorReturn(this, result);
              };
            }
            function lineSeries_possibleConstructorReturn(self2, call) {
              if (call && (lineSeries_typeof(call) === "object" || typeof call === "function")) {
                return call;
              }
              return lineSeries_assertThisInitialized(self2);
            }
            function lineSeries_assertThisInitialized(self2) {
              if (self2 === void 0) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return self2;
            }
            function lineSeries_isNativeReflectConstruct() {
              if (typeof Reflect === "undefined" || !Reflect.construct)
                return false;
              if (Reflect.construct.sham)
                return false;
              if (typeof Proxy === "function")
                return true;
              try {
                Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                }));
                return true;
              } catch (e) {
                return false;
              }
            }
            function lineSeries_getPrototypeOf(o) {
              lineSeries_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
                return o2.__proto__ || Object.getPrototypeOf(o2);
              };
              return lineSeries_getPrototypeOf(o);
            }
            function lineSeries_defineProperty(obj, key, value) {
              if (key in obj) {
                Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
              } else {
                obj[key] = value;
              }
              return obj;
            }
            var LineSeries = function(_Component) {
              lineSeries_inherits(LineSeries2, _Component);
              var _super = lineSeries_createSuper(LineSeries2);
              function LineSeries2() {
                var _this;
                lineSeries_classCallCheck(this, LineSeries2);
                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }
                _this = _super.call.apply(_super, [this].concat(args));
                lineSeries_defineProperty(lineSeries_assertThisInitialized(_this), "models", {
                  rect: [],
                  series: [],
                  dot: []
                });
                lineSeries_defineProperty(lineSeries_assertThisInitialized(_this), "drawModels", void 0);
                lineSeries_defineProperty(lineSeries_assertThisInitialized(_this), "responders", void 0);
                lineSeries_defineProperty(lineSeries_assertThisInitialized(_this), "theme", void 0);
                lineSeries_defineProperty(lineSeries_assertThisInitialized(_this), "activatedResponders", []);
                lineSeries_defineProperty(lineSeries_assertThisInitialized(_this), "eventDetectType", "nearest");
                lineSeries_defineProperty(lineSeries_assertThisInitialized(_this), "tooltipCircleMap", void 0);
                lineSeries_defineProperty(lineSeries_assertThisInitialized(_this), "startIndex", void 0);
                lineSeries_defineProperty(lineSeries_assertThisInitialized(_this), "yAxisName", "yAxis");
                lineSeries_defineProperty(lineSeries_assertThisInitialized(_this), "onMouseoutComponent", function() {
                  _this.eventBus.emit("seriesPointHovered", {
                    models: [],
                    name: _this.name
                  });
                  _this.eventBus.emit("renderHoveredSeries", {
                    models: [],
                    name: _this.name,
                    eventDetectType: _this.eventDetectType
                  });
                  _this.eventBus.emit("needDraw");
                });
                lineSeries_defineProperty(lineSeries_assertThisInitialized(_this), "selectSeries", function(info) {
                  var index = info.index, seriesIndex = info.seriesIndex;
                  if (!isAvailableSelectSeries(info, "line")) {
                    return;
                  }
                  var category2 = _this.getResponderCategoryByIndex(index);
                  if (!category2) {
                    throw new Error(message.SELECT_SERIES_API_INDEX_ERROR);
                  }
                  var model = _this.tooltipCircleMap[category2][seriesIndex];
                  if (!model) {
                    throw new Error(message.SELECT_SERIES_API_INDEX_ERROR);
                  }
                  var models = _this.getResponderSeriesWithTheme([model], "select");
                  _this.eventBus.emit("renderSelectedSeries", {
                    models,
                    name: _this.name
                  });
                  _this.eventBus.emit("needDraw");
                });
                lineSeries_defineProperty(lineSeries_assertThisInitialized(_this), "showTooltip", function(info) {
                  var index = info.index, seriesIndex = info.seriesIndex;
                  if (!isAvailableShowTooltipInfo(info, _this.eventDetectType, "line")) {
                    return;
                  }
                  var category2 = _this.getResponderCategoryByIndex(index);
                  if (!category2) {
                    return;
                  }
                  var models = _this.eventDetectType === "grouped" ? _this.tooltipCircleMap[category2] : [_this.tooltipCircleMap[category2][seriesIndex]];
                  if (!(models !== null && models !== void 0 && models.length)) {
                    return;
                  }
                  _this.onMousemoveNearType(models);
                  _this.eventBus.emit("seriesPointHovered", {
                    models: _this.activatedResponders,
                    name: _this.name
                  });
                  _this.eventBus.emit("needDraw");
                });
                return _this;
              }
              lineSeries_createClass(LineSeries2, [{
                key: "initialize",
                value: function initialize() {
                  this.type = "series";
                  this.name = "line";
                  this.eventBus.on("selectSeries", this.selectSeries);
                  this.eventBus.on("showTooltip", this.showTooltip);
                  this.eventBus.on("hideTooltip", this.onMouseoutComponent);
                }
              }, {
                key: "initUpdate",
                value: function initUpdate(delta) {
                  this.drawModels.rect[0].width = this.models.rect[0].width * delta;
                }
              }, {
                key: "setEventDetectType",
                value: function setEventDetectType(series, options2) {
                  var _options$series;
                  if (series.area || series.column) {
                    this.eventDetectType = "grouped";
                  }
                  if (options2 !== null && options2 !== void 0 && (_options$series = options2.series) !== null && _options$series !== void 0 && _options$series.eventDetectType) {
                    this.eventDetectType = options2.series.eventDetectType;
                  }
                  if (series.scatter) {
                    this.eventDetectType = "near";
                  }
                }
              }, {
                key: "render",
                value: function render(chartState, computed2) {
                  var _ref, _ref2, _options$series2, _viewRange$;
                  var viewRange = computed2.viewRange;
                  var layout2 = chartState.layout, series = chartState.series, scale2 = chartState.scale, axes2 = chartState.axes, legend2 = chartState.legend, theme2 = chartState.theme;
                  if (!series.line) {
                    throw new Error(message.noDataError(this.name));
                  }
                  var categories = (_ref = chartState.categories) !== null && _ref !== void 0 ? _ref : [];
                  var rawCategories = (_ref2 = chartState.rawCategories) !== null && _ref2 !== void 0 ? _ref2 : [];
                  var options2 = lineSeries_objectSpread({}, chartState.options);
                  if (options2 !== null && options2 !== void 0 && options2.series && "line" in options2.series) {
                    options2.series = lineSeries_objectSpread(lineSeries_objectSpread({}, options2.series), options2.series.line);
                  }
                  this.setEventDetectType(series, options2);
                  var labelAxisData = axes2.xAxis;
                  var seriesOptions = (_options$series2 = options2.series) !== null && _options$series2 !== void 0 ? _options$series2 : {};
                  var lineSeriesData = series.line.data;
                  this.theme = theme2.series.line;
                  this.rect = layout2.plot;
                  this.activeSeriesMap = getActiveSeriesMap(legend2);
                  this.startIndex = (_viewRange$ = viewRange === null || viewRange === void 0 ? void 0 : viewRange[0]) !== null && _viewRange$ !== void 0 ? _viewRange$ : 0;
                  this.selectable = this.getSelectableOption(options2);
                  this.yAxisName = getValueAxisName(options2, this.name, "yAxis");
                  var lineSeriesModel = this.renderLinePointsModel(lineSeriesData, scale2, labelAxisData, seriesOptions, categories);
                  var _this$renderCircleMod = this.renderCircleModel(lineSeriesModel, seriesOptions), dotSeriesModel = _this$renderCircleMod.dotSeriesModel, responderModel = _this$renderCircleMod.responderModel;
                  var tooltipDataArr = this.makeTooltipData(lineSeriesData, categories);
                  this.tooltipCircleMap = makeTooltipCircleMap(responderModel, tooltipDataArr);
                  this.models = {
                    rect: [this.renderClipRectAreaModel()],
                    series: lineSeriesModel,
                    dot: dotSeriesModel
                  };
                  if (!this.drawModels) {
                    this.drawModels = lineSeries_objectSpread(lineSeries_objectSpread({}, this.models), {}, {
                      rect: [this.renderClipRectAreaModel(true)]
                    });
                  }
                  if (getDataLabelsOptions(options2, this.name).visible) {
                    this.renderDataLabels(this.getDataLabels(lineSeriesModel));
                  }
                  var coordinateType = isCoordinateSeries(series);
                  this.responders = this.getResponders({
                    labelAxisData,
                    responderModel,
                    tooltipDataArr,
                    categories,
                    rawCategories,
                    coordinateType
                  });
                }
              }, {
                key: "getResponders",
                value: function getResponders(_ref3) {
                  var labelAxisData = _ref3.labelAxisData, responderModel = _ref3.responderModel, tooltipDataArr = _ref3.tooltipDataArr, categories = _ref3.categories, rawCategories = _ref3.rawCategories, coordinateType = _ref3.coordinateType;
                  if (this.eventDetectType === "near") {
                    return this.makeNearTypeResponderModel(responderModel, tooltipDataArr, rawCategories);
                  }
                  if (this.eventDetectType === "point") {
                    return this.makeNearTypeResponderModel(responderModel, tooltipDataArr, rawCategories, 0);
                  }
                  if (coordinateType) {
                    var rectResponderInfo = this.getRectResponderInfoForCoordinateType(responderModel, rawCategories);
                    return responders_makeRectResponderModelForCoordinateType(rectResponderInfo, this.rect);
                  }
                  return makeRectResponderModel(this.rect, labelAxisData, categories);
                }
              }, {
                key: "makeNearTypeResponderModel",
                value: function makeNearTypeResponderModel(seriesCircleModel, tooltipDataArr, categories, detectionSize) {
                  return seriesCircleModel.map(function(m, index) {
                    return lineSeries_objectSpread(lineSeries_objectSpread({}, m), {}, {
                      data: tooltipDataArr[index],
                      detectionSize,
                      label: categories[m.index]
                    });
                  });
                }
              }, {
                key: "makeTooltipData",
                value: function makeTooltipData(lineSeriesData, categories) {
                  var _this2 = this;
                  return lineSeriesData.flatMap(function(_ref4, seriesIndex) {
                    var rawData = _ref4.rawData, name = _ref4.name, color = _ref4.color;
                    return rawData.map(function(datum, index) {
                      return isNull(datum) ? {} : {
                        label: name,
                        color,
                        value: getCoordinateYValue(datum),
                        category: categories[getCoordinateDataIndex(datum, categories, index, _this2.startIndex)],
                        seriesIndex,
                        index
                      };
                    });
                  });
                }
              }, {
                key: "renderClipRectAreaModel",
                value: function renderClipRectAreaModel(isDrawModel) {
                  return {
                    type: "clipRectArea",
                    x: 0,
                    y: 0,
                    width: isDrawModel ? 0 : this.rect.width,
                    height: this.rect.height
                  };
                }
              }, {
                key: "renderLinePointsModel",
                value: function renderLinePointsModel(seriesRawData, scale2, axisData, options2, categories) {
                  var _this3 = this;
                  var spline = options2.spline;
                  var yAxisLimit = scale2[this.yAxisName].limit;
                  var _this$theme = this.theme, lineWidth = _this$theme.lineWidth, dashSegments = _this$theme.dashSegments;
                  return seriesRawData.map(function(_ref5, seriesIndex) {
                    var rawData = _ref5.rawData, name = _ref5.name, seriesColor = _ref5.color;
                    var points = [];
                    var active = _this3.activeSeriesMap[name];
                    rawData.forEach(function(datum, idx) {
                      if (isNull(datum)) {
                        return points.push(null);
                      }
                      var value = getCoordinateYValue(datum);
                      var yValueRatio = getValueRatio(value, yAxisLimit);
                      var y = (1 - yValueRatio) * _this3.rect.height;
                      var x = getXPosition(axisData, _this3.rect.width, getCoordinateXValue(datum), getCoordinateDataIndex(datum, categories, idx, _this3.startIndex));
                      points.push({
                        x,
                        y,
                        value
                      });
                    });
                    if (spline) {
                      setSplineControlPoint(points);
                    }
                    return {
                      type: "linePoints",
                      points,
                      seriesIndex,
                      name,
                      color: getRGBA(seriesColor, active ? 1 : 0.3),
                      lineWidth,
                      dashSegments
                    };
                  });
                }
              }, {
                key: "getRectResponderInfoForCoordinateType",
                value: function getRectResponderInfoForCoordinateType(circleModel, categories) {
                  var _this4 = this;
                  var duplicateCheckMap = {};
                  var modelInRange = circleModel.filter(function(_ref6) {
                    var x = _ref6.x;
                    return x >= 0 && x <= _this4.rect.width;
                  });
                  return modelInRange.reduce(function(acc, model) {
                    var index = model.index, x = model.x;
                    if (!duplicateCheckMap[x]) {
                      var label2 = categories[index];
                      duplicateCheckMap[x] = true;
                      acc.push({
                        x,
                        label: label2
                      });
                    }
                    return acc;
                  }, []);
                }
              }, {
                key: "renderCircleModel",
                value: function renderCircleModel(lineSeriesModel, options2) {
                  var _this5 = this;
                  var dotSeriesModel = [];
                  var responderModel = [];
                  var showDot = !!options2.showDot;
                  var _this$theme2 = this.theme, hover = _this$theme2.hover, dotTheme = _this$theme2.dot;
                  var hoverDotTheme = hover.dot;
                  lineSeriesModel.forEach(function(_ref7, seriesIndex) {
                    var color = _ref7.color, name = _ref7.name, points = _ref7.points;
                    var active = _this5.activeSeriesMap[name];
                    points.forEach(function(point, index) {
                      var _hoverDotTheme$color;
                      if (isNull(point)) {
                        return;
                      }
                      var x = point.x, y = point.y;
                      var model = {
                        type: "circle",
                        x,
                        y,
                        seriesIndex,
                        name,
                        index
                      };
                      if (showDot) {
                        var _dotTheme$borderColor;
                        dotSeriesModel.push(lineSeries_objectSpread(lineSeries_objectSpread({}, model), {}, {
                          radius: dotTheme.radius,
                          color: getRGBA(color, active ? 1 : 0.3),
                          style: [{
                            lineWidth: dotTheme.borderWidth,
                            strokeStyle: (_dotTheme$borderColor = dotTheme.borderColor) !== null && _dotTheme$borderColor !== void 0 ? _dotTheme$borderColor : color
                          }]
                        }));
                      }
                      responderModel.push(lineSeries_objectSpread(lineSeries_objectSpread({}, model), {}, {
                        radius: hoverDotTheme.radius,
                        color: (_hoverDotTheme$color = hoverDotTheme.color) !== null && _hoverDotTheme$color !== void 0 ? _hoverDotTheme$color : getRGBA(color, 1),
                        style: ["default"]
                      }));
                    });
                  });
                  return {
                    dotSeriesModel,
                    responderModel
                  };
                }
              }, {
                key: "getCircleModelsFromRectResponders",
                value: function getCircleModelsFromRectResponders(responders, mousePositions) {
                  var _this$tooltipCircleMa, _responders$;
                  if (!responders.length || !responders[0].label) {
                    return [];
                  }
                  var models = (_this$tooltipCircleMa = this.tooltipCircleMap[(_responders$ = responders[0]) === null || _responders$ === void 0 ? void 0 : _responders$.label]) !== null && _this$tooltipCircleMa !== void 0 ? _this$tooltipCircleMa : [];
                  return this.eventDetectType === "grouped" ? models : getNearestResponder(models, mousePositions, this.rect);
                }
              }, {
                key: "onMousemoveNearType",
                value: function onMousemoveNearType(responders) {
                  this.eventBus.emit("renderHoveredSeries", {
                    models: this.getResponderSeriesWithTheme(responders, "hover"),
                    name: this.name,
                    eventDetectType: this.eventDetectType
                  });
                  this.activatedResponders = responders;
                }
              }, {
                key: "onMousemoveNearestType",
                value: function onMousemoveNearestType(responders, mousePositions) {
                  var circleModels = this.getCircleModelsFromRectResponders(responders, mousePositions);
                  this.onMousemoveNearType(circleModels);
                }
              }, {
                key: "onMousemoveGroupedType",
                value: function onMousemoveGroupedType(responders) {
                  var circleModels = this.getCircleModelsFromRectResponders(responders);
                  this.onMousemoveNearType(circleModels);
                }
              }, {
                key: "onMousemove",
                value: function onMousemove(_ref8) {
                  var responders = _ref8.responders, mousePosition = _ref8.mousePosition;
                  if (this.eventDetectType === "nearest") {
                    this.onMousemoveNearestType(responders, mousePosition);
                  } else if (includes(["near", "point"], this.eventDetectType)) {
                    this.onMousemoveNearType(responders);
                  } else {
                    this.onMousemoveGroupedType(responders);
                  }
                  this.eventBus.emit("seriesPointHovered", {
                    models: this.activatedResponders,
                    name: this.name
                  });
                  this.eventBus.emit("needDraw");
                }
              }, {
                key: "getDataLabels",
                value: function getDataLabels(seriesModels) {
                  var dataLabelTheme = this.theme.dataLabels;
                  return seriesModels.flatMap(function(_ref9) {
                    var points = _ref9.points, name = _ref9.name, color = _ref9.color;
                    return points.map(function(point) {
                      return isNull(point) ? {} : lineSeries_objectSpread(lineSeries_objectSpread({
                        type: "point"
                      }, point), {}, {
                        name,
                        theme: lineSeries_objectSpread(lineSeries_objectSpread({}, dataLabelTheme), {}, {
                          color: dataLabelTheme.useSeriesColor ? color : dataLabelTheme.color
                        })
                      });
                    });
                  });
                }
              }, {
                key: "getResponderSeriesWithTheme",
                value: function getResponderSeriesWithTheme(models, type) {
                  var _ref10 = this.theme[type].dot, radius = _ref10.radius, color = _ref10.color, borderWidth = _ref10.borderWidth, borderColor = _ref10.borderColor;
                  return models.map(function(model) {
                    var modelColor = color !== null && color !== void 0 ? color : model.color;
                    return lineSeries_objectSpread(lineSeries_objectSpread({}, model), {}, {
                      radius,
                      color: modelColor,
                      style: [{
                        lineWidth: borderWidth,
                        strokeStyle: borderColor !== null && borderColor !== void 0 ? borderColor : getRGBA(modelColor, 0.5)
                      }]
                    });
                  });
                }
              }, {
                key: "onClick",
                value: function onClick(_ref11) {
                  var responders = _ref11.responders, mousePosition = _ref11.mousePosition;
                  if (this.selectable) {
                    var models;
                    if (this.eventDetectType === "near") {
                      models = responders;
                    } else {
                      models = this.getCircleModelsFromRectResponders(responders, mousePosition);
                    }
                    this.eventBus.emit("renderSelectedSeries", {
                      models: this.getResponderSeriesWithTheme(models, "select"),
                      name: this.name
                    });
                    this.eventBus.emit("needDraw");
                  }
                }
              }, {
                key: "getResponderCategoryByIndex",
                value: function getResponderCategoryByIndex(index) {
                  var _responder$data;
                  var responder = Object.values(this.tooltipCircleMap).flatMap(function(val) {
                    return val;
                  }).find(function(model) {
                    return model.index === index;
                  });
                  return responder === null || responder === void 0 ? void 0 : (_responder$data = responder.data) === null || _responder$data === void 0 ? void 0 : _responder$data.category;
                }
              }]);
              return LineSeries2;
            }(Component);
            ;
            function legend_typeof(obj) {
              "@babel/helpers - typeof";
              if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                legend_typeof = function _typeof2(obj2) {
                  return typeof obj2;
                };
              } else {
                legend_typeof = function _typeof2(obj2) {
                  return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                };
              }
              return legend_typeof(obj);
            }
            function component_legend_toConsumableArray(arr) {
              return component_legend_arrayWithoutHoles(arr) || component_legend_iterableToArray(arr) || component_legend_unsupportedIterableToArray(arr) || component_legend_nonIterableSpread();
            }
            function component_legend_nonIterableSpread() {
              throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            function component_legend_unsupportedIterableToArray(o, minLen) {
              if (!o)
                return;
              if (typeof o === "string")
                return component_legend_arrayLikeToArray(o, minLen);
              var n = Object.prototype.toString.call(o).slice(8, -1);
              if (n === "Object" && o.constructor)
                n = o.constructor.name;
              if (n === "Map" || n === "Set")
                return Array.from(o);
              if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                return component_legend_arrayLikeToArray(o, minLen);
            }
            function component_legend_iterableToArray(iter) {
              if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
                return Array.from(iter);
            }
            function component_legend_arrayWithoutHoles(arr) {
              if (Array.isArray(arr))
                return component_legend_arrayLikeToArray(arr);
            }
            function component_legend_arrayLikeToArray(arr, len) {
              if (len == null || len > arr.length)
                len = arr.length;
              for (var i = 0, arr2 = new Array(len); i < len; i++) {
                arr2[i] = arr[i];
              }
              return arr2;
            }
            function component_legend_ownKeys(object, enumerableOnly) {
              var keys = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object);
                if (enumerableOnly) {
                  symbols = symbols.filter(function(sym) {
                    return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                  });
                }
                keys.push.apply(keys, symbols);
              }
              return keys;
            }
            function component_legend_objectSpread(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i] != null ? arguments[i] : {};
                if (i % 2) {
                  component_legend_ownKeys(Object(source), true).forEach(function(key) {
                    component_legend_defineProperty(target, key, source[key]);
                  });
                } else if (Object.getOwnPropertyDescriptors) {
                  Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                } else {
                  component_legend_ownKeys(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  });
                }
              }
              return target;
            }
            function legend_classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function legend_defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            function legend_createClass(Constructor, protoProps, staticProps) {
              if (protoProps)
                legend_defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                legend_defineProperties(Constructor, staticProps);
              return Constructor;
            }
            function legend_inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function");
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
              if (superClass)
                legend_setPrototypeOf(subClass, superClass);
            }
            function legend_setPrototypeOf(o, p) {
              legend_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
                o2.__proto__ = p2;
                return o2;
              };
              return legend_setPrototypeOf(o, p);
            }
            function legend_createSuper(Derived) {
              var hasNativeReflectConstruct = legend_isNativeReflectConstruct();
              return function _createSuperInternal() {
                var Super = legend_getPrototypeOf(Derived), result;
                if (hasNativeReflectConstruct) {
                  var NewTarget = legend_getPrototypeOf(this).constructor;
                  result = Reflect.construct(Super, arguments, NewTarget);
                } else {
                  result = Super.apply(this, arguments);
                }
                return legend_possibleConstructorReturn(this, result);
              };
            }
            function legend_possibleConstructorReturn(self2, call) {
              if (call && (legend_typeof(call) === "object" || typeof call === "function")) {
                return call;
              }
              return legend_assertThisInitialized(self2);
            }
            function legend_assertThisInitialized(self2) {
              if (self2 === void 0) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return self2;
            }
            function legend_isNativeReflectConstruct() {
              if (typeof Reflect === "undefined" || !Reflect.construct)
                return false;
              if (Reflect.construct.sham)
                return false;
              if (typeof Proxy === "function")
                return true;
              try {
                Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                }));
                return true;
              } catch (e) {
                return false;
              }
            }
            function legend_getPrototypeOf(o) {
              legend_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
                return o2.__proto__ || Object.getPrototypeOf(o2);
              };
              return legend_getPrototypeOf(o);
            }
            function component_legend_defineProperty(obj, key, value) {
              if (key in obj) {
                Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
              } else {
                obj[key] = value;
              }
              return obj;
            }
            var Legend = function(_Component) {
              legend_inherits(Legend2, _Component);
              var _super = legend_createSuper(Legend2);
              function Legend2() {
                var _this;
                legend_classCallCheck(this, Legend2);
                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }
                _this = _super.call.apply(_super, [this].concat(args));
                component_legend_defineProperty(legend_assertThisInitialized(_this), "models", void 0);
                component_legend_defineProperty(legend_assertThisInitialized(_this), "responders", void 0);
                component_legend_defineProperty(legend_assertThisInitialized(_this), "theme", void 0);
                component_legend_defineProperty(legend_assertThisInitialized(_this), "activatedResponders", []);
                component_legend_defineProperty(legend_assertThisInitialized(_this), "seriesColorMap", {});
                component_legend_defineProperty(legend_assertThisInitialized(_this), "seriesIconTypeMap", {});
                component_legend_defineProperty(legend_assertThisInitialized(_this), "onClickCheckbox", function(responders) {
                  var _responders$ = responders[0], label2 = _responders$.label, checked = _responders$.checked;
                  _this.store.dispatch("setAllLegendActiveState", true);
                  _this.store.dispatch("setLegendCheckedState", {
                    name: label2,
                    checked: !checked
                  });
                  if (checked) {
                    _this.store.dispatch("disableSeries", label2);
                  } else {
                    _this.store.dispatch("enableSeries", label2);
                  }
                  _this.eventBus.emit("needDraw");
                });
                component_legend_defineProperty(legend_assertThisInitialized(_this), "onClickLabel", function(responders) {
                  var label2 = responders[0].label;
                  _this.eventBus.emit("resetSelectedSeries");
                  if (_this.activatedResponders.length && _this.activatedResponders[0].label === label2) {
                    _this.store.dispatch("setAllLegendActiveState", true);
                    _this.activatedResponders = [];
                  } else {
                    _this.store.dispatch("setAllLegendActiveState", false);
                    _this.store.dispatch("setLegendActiveState", {
                      name: label2,
                      active: true
                    });
                    _this.activatedResponders = responders;
                  }
                  _this.eventBus.emit("needDraw");
                });
                return _this;
              }
              legend_createClass(Legend2, [{
                key: "onClick",
                value: function onClick(_ref) {
                  var responders = _ref.responders;
                  if (responders.length) {
                    var data = responders[0].data;
                    if ((data === null || data === void 0 ? void 0 : data.name) === "checkbox") {
                      this.eventBus.emit("clickLegendCheckbox", makeObservableObjectToNormal(responders));
                    } else {
                      this.eventBus.emit("clickLegendLabel", makeObservableObjectToNormal(responders));
                    }
                  }
                }
              }, {
                key: "initialize",
                value: function initialize() {
                  this.type = "legend";
                  this.name = "legend";
                  this.eventBus.on("clickLegendCheckbox", this.onClickCheckbox);
                  this.eventBus.on("clickLegendLabel", this.onClickLabel);
                }
              }, {
                key: "initColorAndIconTypeMap",
                value: function initColorAndIconTypeMap(legendData) {
                  var _this2 = this;
                  this.seriesColorMap = {};
                  this.seriesIconTypeMap = {};
                  legendData.forEach(function(_ref2) {
                    var label2 = _ref2.label, color = _ref2.color, iconType = _ref2.iconType;
                    _this2.seriesColorMap[label2] = color;
                    _this2.seriesIconTypeMap[label2] = iconType;
                  });
                }
              }, {
                key: "getXPositionWhenVerticalAlign",
                value: function getXPositionWhenVerticalAlign(data) {
                  var _data$reduce = data.reduce(function(acc, datum) {
                    var rowIndex = datum.rowIndex, columnIndex = datum.columnIndex, width2 = datum.width;
                    if (isUndefined(acc.rowWidths[rowIndex])) {
                      acc.rowWidths[rowIndex] = 0;
                      acc.offset[rowIndex] = [0];
                    }
                    acc.rowWidths[rowIndex] += width2 + (columnIndex ? LEGEND_ITEM_MARGIN_X : 0);
                    acc.offset[rowIndex][columnIndex + 1] = acc.offset[rowIndex][columnIndex] + LEGEND_ITEM_MARGIN_X + width2;
                    return acc;
                  }, {
                    offset: [],
                    rowWidths: []
                  }), offset = _data$reduce.offset, rowWidths = _data$reduce.rowWidths;
                  var width = this.rect.width;
                  rowWidths.forEach(function(rowWidth, rowIndex) {
                    var xMargin = (width - rowWidth) / 2;
                    offset[rowIndex] = offset[rowIndex].map(function(xOffset) {
                      return xOffset + xMargin;
                    });
                  });
                  return offset;
                }
              }, {
                key: "getXPositionWhenHorizontalAlign",
                value: function getXPositionWhenHorizontalAlign(data) {
                  var maxWidths = data.reduce(function(acc, datum) {
                    var columnIndex = datum.columnIndex, width = datum.width;
                    if (isUndefined(acc[columnIndex])) {
                      acc[columnIndex] = 0;
                    }
                    acc[columnIndex] = Math.max(acc[columnIndex], width);
                    return acc;
                  }, []);
                  return data.reduce(function(acc, datum) {
                    var rowIndex = datum.rowIndex, columnIndex = datum.columnIndex;
                    if (isUndefined(acc[rowIndex])) {
                      acc[rowIndex] = [0];
                    }
                    acc[rowIndex][columnIndex + 1] = acc[rowIndex][columnIndex] + LEGEND_ITEM_MARGIN_X + maxWidths[columnIndex];
                    return acc;
                  }, []);
                }
              }, {
                key: "renderLegendModel",
                value: function renderLegendModel(legend2) {
                  var _this3 = this;
                  var data = legend2.data, showCheckbox2 = legend2.showCheckbox, align = legend2.align, useScatterChartIcon = legend2.useScatterChartIcon;
                  var verticalAlign = isVerticalAlign(align);
                  var itemHeight = getLegendItemHeight(this.theme.label.fontSize);
                  var xPosition = verticalAlign ? this.getXPositionWhenVerticalAlign(data) : this.getXPositionWhenHorizontalAlign(data);
                  return [component_legend_objectSpread({
                    type: "legend",
                    align,
                    showCheckbox: showCheckbox2,
                    data: data.map(function(datum) {
                      var _this3$seriesIconType;
                      var label2 = datum.label, iconType = datum.iconType, rowIndex = datum.rowIndex, columnIndex = datum.columnIndex;
                      return component_legend_objectSpread(component_legend_objectSpread({}, datum), {}, {
                        iconType: (_this3$seriesIconType = _this3.seriesIconTypeMap[label2]) !== null && _this3$seriesIconType !== void 0 ? _this3$seriesIconType : iconType,
                        color: _this3.seriesColorMap[label2],
                        x: xPosition[rowIndex][columnIndex],
                        y: padding.Y + itemHeight * rowIndex,
                        useScatterChartIcon
                      });
                    })
                  }, this.theme.label)];
                }
              }, {
                key: "makeCheckboxResponder",
                value: function makeCheckboxResponder(data, showCheckbox2) {
                  return showCheckbox2 ? data.map(function(m) {
                    return component_legend_objectSpread(component_legend_objectSpread({}, m), {}, {
                      type: "rect",
                      x: m.x,
                      y: m.y,
                      width: LEGEND_CHECKBOX_SIZE,
                      height: LEGEND_CHECKBOX_SIZE,
                      data: {
                        name: "checkbox"
                      }
                    });
                  }) : [];
                }
              }, {
                key: "makeLabelResponder",
                value: function makeLabelResponder(data, showCheckbox2) {
                  var font = getTitleFontString(this.theme.label);
                  return data.map(function(m) {
                    return component_legend_objectSpread(component_legend_objectSpread({}, m), {}, {
                      type: "rect",
                      x: m.x + (showCheckbox2 ? LEGEND_CHECKBOX_SIZE + LEGEND_MARGIN_X : 0) + LEGEND_ICON_SIZE + LEGEND_MARGIN_X,
                      y: m.y,
                      width: getTextWidth(m.label, font),
                      data: {
                        name: "label"
                      },
                      height: LEGEND_CHECKBOX_SIZE
                    });
                  });
                }
              }, {
                key: "render",
                value: function render(_ref3) {
                  var layout2 = _ref3.layout, legend2 = _ref3.legend, theme2 = _ref3.theme;
                  this.isShow = legend2.visible && !!legend2.data.length;
                  if (!this.isShow) {
                    return;
                  }
                  var showCheckbox2 = legend2.showCheckbox, legendData = legend2.data;
                  this.rect = layout2.legend;
                  this.theme = theme2.legend;
                  this.initColorAndIconTypeMap(legendData);
                  this.models = this.renderLegendModel(legend2);
                  var data = this.models[0].data;
                  var checkboxResponder = this.makeCheckboxResponder(data, showCheckbox2);
                  var labelResponder = this.makeLabelResponder(data, showCheckbox2);
                  this.responders = [].concat(component_legend_toConsumableArray(checkboxResponder), component_legend_toConsumableArray(labelResponder));
                }
              }]);
              return Legend2;
            }(Component);
            ;
            function dataLabels_typeof(obj) {
              "@babel/helpers - typeof";
              if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                dataLabels_typeof = function _typeof2(obj2) {
                  return typeof obj2;
                };
              } else {
                dataLabels_typeof = function _typeof2(obj2) {
                  return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                };
              }
              return dataLabels_typeof(obj);
            }
            function component_dataLabels_ownKeys(object, enumerableOnly) {
              var keys = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object);
                if (enumerableOnly) {
                  symbols = symbols.filter(function(sym) {
                    return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                  });
                }
                keys.push.apply(keys, symbols);
              }
              return keys;
            }
            function component_dataLabels_objectSpread(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i] != null ? arguments[i] : {};
                if (i % 2) {
                  component_dataLabels_ownKeys(Object(source), true).forEach(function(key) {
                    component_dataLabels_defineProperty(target, key, source[key]);
                  });
                } else if (Object.getOwnPropertyDescriptors) {
                  Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                } else {
                  component_dataLabels_ownKeys(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  });
                }
              }
              return target;
            }
            function dataLabels_toConsumableArray(arr) {
              return dataLabels_arrayWithoutHoles(arr) || dataLabels_iterableToArray(arr) || dataLabels_unsupportedIterableToArray(arr) || dataLabels_nonIterableSpread();
            }
            function dataLabels_nonIterableSpread() {
              throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            function dataLabels_unsupportedIterableToArray(o, minLen) {
              if (!o)
                return;
              if (typeof o === "string")
                return dataLabels_arrayLikeToArray(o, minLen);
              var n = Object.prototype.toString.call(o).slice(8, -1);
              if (n === "Object" && o.constructor)
                n = o.constructor.name;
              if (n === "Map" || n === "Set")
                return Array.from(o);
              if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                return dataLabels_arrayLikeToArray(o, minLen);
            }
            function dataLabels_iterableToArray(iter) {
              if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
                return Array.from(iter);
            }
            function dataLabels_arrayWithoutHoles(arr) {
              if (Array.isArray(arr))
                return dataLabels_arrayLikeToArray(arr);
            }
            function dataLabels_arrayLikeToArray(arr, len) {
              if (len == null || len > arr.length)
                len = arr.length;
              for (var i = 0, arr2 = new Array(len); i < len; i++) {
                arr2[i] = arr[i];
              }
              return arr2;
            }
            function dataLabels_classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function dataLabels_defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            function dataLabels_createClass(Constructor, protoProps, staticProps) {
              if (protoProps)
                dataLabels_defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                dataLabels_defineProperties(Constructor, staticProps);
              return Constructor;
            }
            function dataLabels_inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function");
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
              if (superClass)
                dataLabels_setPrototypeOf(subClass, superClass);
            }
            function dataLabels_setPrototypeOf(o, p) {
              dataLabels_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
                o2.__proto__ = p2;
                return o2;
              };
              return dataLabels_setPrototypeOf(o, p);
            }
            function dataLabels_createSuper(Derived) {
              var hasNativeReflectConstruct = dataLabels_isNativeReflectConstruct();
              return function _createSuperInternal() {
                var Super = dataLabels_getPrototypeOf(Derived), result;
                if (hasNativeReflectConstruct) {
                  var NewTarget = dataLabels_getPrototypeOf(this).constructor;
                  result = Reflect.construct(Super, arguments, NewTarget);
                } else {
                  result = Super.apply(this, arguments);
                }
                return dataLabels_possibleConstructorReturn(this, result);
              };
            }
            function dataLabels_possibleConstructorReturn(self2, call) {
              if (call && (dataLabels_typeof(call) === "object" || typeof call === "function")) {
                return call;
              }
              return dataLabels_assertThisInitialized(self2);
            }
            function dataLabels_assertThisInitialized(self2) {
              if (self2 === void 0) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return self2;
            }
            function dataLabels_isNativeReflectConstruct() {
              if (typeof Reflect === "undefined" || !Reflect.construct)
                return false;
              if (Reflect.construct.sham)
                return false;
              if (typeof Proxy === "function")
                return true;
              try {
                Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                }));
                return true;
              } catch (e) {
                return false;
              }
            }
            function dataLabels_getPrototypeOf(o) {
              dataLabels_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
                return o2.__proto__ || Object.getPrototypeOf(o2);
              };
              return dataLabels_getPrototypeOf(o);
            }
            function component_dataLabels_defineProperty(obj, key, value) {
              if (key in obj) {
                Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
              } else {
                obj[key] = value;
              }
              return obj;
            }
            function getLabelInfo(model, labelOptions, rect2, name) {
              var type = model.type;
              var dataLabel2 = [];
              if (type === "point") {
                dataLabel2.push(makePointLabelInfo(model, labelOptions, rect2));
              } else if (type === "sector") {
                if (name === "radialBar") {
                  dataLabel2.push(makeSectorBarLabelInfo(model, labelOptions));
                } else {
                  var _labelOptions$pieSeri;
                  dataLabel2.push(makeSectorLabelInfo(model, labelOptions));
                  if ((_labelOptions$pieSeri = labelOptions.pieSeriesName) !== null && _labelOptions$pieSeri !== void 0 && _labelOptions$pieSeri.visible) {
                    var seriesNameLabel = makePieSeriesNameLabelInfo(model, labelOptions);
                    dataLabel2.push(seriesNameLabel);
                  }
                }
              } else if (type === "line") {
                dataLabel2.push(makeLineLabelInfo(model, labelOptions));
              } else {
                dataLabel2.push(makeRectLabelInfo(model, labelOptions));
              }
              return dataLabel2;
            }
            var DataLabels = function(_Component) {
              dataLabels_inherits(DataLabels2, _Component);
              var _super = dataLabels_createSuper(DataLabels2);
              function DataLabels2() {
                var _this;
                dataLabels_classCallCheck(this, DataLabels2);
                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }
                _this = _super.call.apply(_super, [this].concat(args));
                component_dataLabels_defineProperty(dataLabels_assertThisInitialized(_this), "models", void 0);
                component_dataLabels_defineProperty(dataLabels_assertThisInitialized(_this), "drawModels", void 0);
                component_dataLabels_defineProperty(dataLabels_assertThisInitialized(_this), "options", void 0);
                component_dataLabels_defineProperty(dataLabels_assertThisInitialized(_this), "dataLabelsMap", {});
                component_dataLabels_defineProperty(dataLabels_assertThisInitialized(_this), "renderSeriesDataLabels", function(seriesDataLabel) {
                  _this.appendDataLabels(seriesDataLabel);
                  _this.models = _this.renderLabelModel();
                  if (!_this.drawModels) {
                    _this.drawModels = _this.getDrawModelsAppliedOpacity(0);
                  } else {
                    _this.sync();
                  }
                });
                return _this;
              }
              dataLabels_createClass(DataLabels2, [{
                key: "initialize",
                value: function initialize() {
                  this.type = "dataLabels";
                  this.name = "dataLabels";
                  this.eventBus.on("renderDataLabels", this.renderSeriesDataLabels);
                }
              }, {
                key: "initUpdate",
                value: function initUpdate(delta) {
                  if (!this.drawModels) {
                    return;
                  }
                  this.drawModels = this.getDrawModelsAppliedOpacity(delta);
                }
              }, {
                key: "render",
                value: function render(_ref) {
                  var layout2 = _ref.layout, options2 = _ref.options, series = _ref.series, nestedPieSeries = _ref.nestedPieSeries;
                  this.rect = layout2.plot;
                  this.options = options2;
                  this.isShow = this.visibleDataLabels(series, nestedPieSeries);
                }
              }, {
                key: "visibleDataLabels",
                value: function visibleDataLabels(series, nestedPieSeries) {
                  var _this$options$series, _this$options$series$, _this2 = this;
                  var visibleCommonSeriesDataLabels = !!((_this$options$series = this.options.series) !== null && _this$options$series !== void 0 && (_this$options$series$ = _this$options$series.dataLabels) !== null && _this$options$series$ !== void 0 && _this$options$series$.visible);
                  var visibleComboSeriesDataLabels = Object.keys(series).some(function(seriesName) {
                    var _this2$options$series, _this2$options$series2, _this2$options$series3;
                    return !!((_this2$options$series = _this2.options.series) !== null && _this2$options$series !== void 0 && (_this2$options$series2 = _this2$options$series[seriesName]) !== null && _this2$options$series2 !== void 0 && (_this2$options$series3 = _this2$options$series2.dataLabels) !== null && _this2$options$series3 !== void 0 && _this2$options$series3.visible);
                  });
                  var visibleNestedPieSeriesDataLabels = !!(nestedPieSeries && Object.keys(nestedPieSeries).some(function(alias) {
                    var _this2$options$series4, _this2$options$series5, _this2$options$series6;
                    return !!((_this2$options$series4 = _this2.options.series) !== null && _this2$options$series4 !== void 0 && (_this2$options$series5 = _this2$options$series4[alias]) !== null && _this2$options$series5 !== void 0 && (_this2$options$series6 = _this2$options$series5.dataLabels) !== null && _this2$options$series6 !== void 0 && _this2$options$series6.visible);
                  }));
                  return visibleCommonSeriesDataLabels || visibleComboSeriesDataLabels || visibleNestedPieSeriesDataLabels;
                }
              }, {
                key: "appendDataLabels",
                value: function appendDataLabels(_ref2) {
                  var _this3 = this;
                  var name = _ref2.name, data = _ref2.data;
                  var dataLabelOptions = getDataLabelsOptions(this.options, name);
                  var withStack = !!pickStackOption(this.options);
                  var labels = [];
                  data.forEach(function(model) {
                    var _labelOptions$stackTo;
                    var type = model.type, value = model.value;
                    var labelOptions = getDefaultDataLabelsOptions(dataLabelOptions, type, withStack);
                    var disableStackTotal = type === "stackTotal" && !((_labelOptions$stackTo = labelOptions.stackTotal) !== null && _labelOptions$stackTo !== void 0 && _labelOptions$stackTo.visible);
                    if (disableStackTotal || isUndefined(value)) {
                      return;
                    }
                    labels.splice.apply(labels, [labels.length, 0].concat(dataLabels_toConsumableArray(getLabelInfo(model, labelOptions, _this3.rect, name))));
                  });
                  this.dataLabelsMap[name] = {
                    data: labels,
                    options: dataLabelOptions
                  };
                }
              }, {
                key: "getDrawModelsAppliedOpacity",
                value: function getDrawModelsAppliedOpacity(opacity) {
                  var _this4 = this;
                  return Object.keys(this.models).reduce(function(acc, key) {
                    return component_dataLabels_objectSpread(component_dataLabels_objectSpread({}, acc), {}, component_dataLabels_defineProperty({}, key, _this4.models[key].map(function(m) {
                      return component_dataLabels_objectSpread(component_dataLabels_objectSpread({}, m), {}, {
                        opacity
                      });
                    })));
                  }, {
                    series: [],
                    total: []
                  });
                }
              }, {
                key: "renderLabelModel",
                value: function renderLabelModel() {
                  var _this5 = this;
                  return Object.keys(this.dataLabelsMap).map(function(seriesName) {
                    var data = _this5.dataLabelsMap[seriesName].data;
                    return _this5.makeLabelModel(data);
                  }).reduce(function(acc, cur) {
                    return {
                      series: [].concat(dataLabels_toConsumableArray(acc.series), dataLabels_toConsumableArray(cur.series)),
                      total: [].concat(dataLabels_toConsumableArray(acc.total), dataLabels_toConsumableArray(cur.total))
                    };
                  }, {
                    series: [],
                    total: []
                  });
                }
              }, {
                key: "makeLabelModel",
                value: function makeLabelModel(dataLabels) {
                  var _this6 = this;
                  return dataLabels.reduce(function(acc, dataLabel2) {
                    var _acc$modelName;
                    var type = dataLabel2.type, x = dataLabel2.x, y = dataLabel2.y, text = dataLabel2.text, textAlign = dataLabel2.textAlign, textBaseline = dataLabel2.textBaseline, name = dataLabel2.name, callout = dataLabel2.callout, theme2 = dataLabel2.theme, radian = dataLabel2.radian;
                    if (!isModelExistingInRect(_this6.rect, {
                      x,
                      y
                    })) {
                      return acc;
                    }
                    var modelName = type === "stackTotal" ? "total" : "series";
                    return component_dataLabels_objectSpread(component_dataLabels_objectSpread({}, acc), {}, component_dataLabels_defineProperty({}, modelName, [].concat(dataLabels_toConsumableArray((_acc$modelName = acc[modelName]) !== null && _acc$modelName !== void 0 ? _acc$modelName : []), [{
                      type: "dataLabel",
                      dataLabelType: type,
                      text,
                      x,
                      y,
                      textAlign,
                      textBaseline,
                      opacity: 1,
                      name,
                      callout,
                      theme: theme2,
                      radian
                    }])));
                  }, {
                    series: [],
                    total: []
                  });
                }
              }]);
              return DataLabels2;
            }(Component);
            ;
            function axisTitle_typeof(obj) {
              "@babel/helpers - typeof";
              if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                axisTitle_typeof = function _typeof2(obj2) {
                  return typeof obj2;
                };
              } else {
                axisTitle_typeof = function _typeof2(obj2) {
                  return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                };
              }
              return axisTitle_typeof(obj);
            }
            function axisTitle_slicedToArray(arr, i) {
              return axisTitle_arrayWithHoles(arr) || axisTitle_iterableToArrayLimit(arr, i) || axisTitle_unsupportedIterableToArray(arr, i) || axisTitle_nonIterableRest();
            }
            function axisTitle_nonIterableRest() {
              throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            function axisTitle_unsupportedIterableToArray(o, minLen) {
              if (!o)
                return;
              if (typeof o === "string")
                return axisTitle_arrayLikeToArray(o, minLen);
              var n = Object.prototype.toString.call(o).slice(8, -1);
              if (n === "Object" && o.constructor)
                n = o.constructor.name;
              if (n === "Map" || n === "Set")
                return Array.from(o);
              if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                return axisTitle_arrayLikeToArray(o, minLen);
            }
            function axisTitle_arrayLikeToArray(arr, len) {
              if (len == null || len > arr.length)
                len = arr.length;
              for (var i = 0, arr2 = new Array(len); i < len; i++) {
                arr2[i] = arr[i];
              }
              return arr2;
            }
            function axisTitle_iterableToArrayLimit(arr, i) {
              var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]);
              if (_i == null)
                return;
              var _arr = [];
              var _n = true;
              var _d = false;
              var _s, _e;
              try {
                for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
                  _arr.push(_s.value);
                  if (i && _arr.length === i)
                    break;
                }
              } catch (err) {
                _d = true;
                _e = err;
              } finally {
                try {
                  if (!_n && _i["return"] != null)
                    _i["return"]();
                } finally {
                  if (_d)
                    throw _e;
                }
              }
              return _arr;
            }
            function axisTitle_arrayWithHoles(arr) {
              if (Array.isArray(arr))
                return arr;
            }
            function axisTitle_classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function axisTitle_defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            function axisTitle_createClass(Constructor, protoProps, staticProps) {
              if (protoProps)
                axisTitle_defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                axisTitle_defineProperties(Constructor, staticProps);
              return Constructor;
            }
            function axisTitle_inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function");
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
              if (superClass)
                axisTitle_setPrototypeOf(subClass, superClass);
            }
            function axisTitle_setPrototypeOf(o, p) {
              axisTitle_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
                o2.__proto__ = p2;
                return o2;
              };
              return axisTitle_setPrototypeOf(o, p);
            }
            function axisTitle_createSuper(Derived) {
              var hasNativeReflectConstruct = axisTitle_isNativeReflectConstruct();
              return function _createSuperInternal() {
                var Super = axisTitle_getPrototypeOf(Derived), result;
                if (hasNativeReflectConstruct) {
                  var NewTarget = axisTitle_getPrototypeOf(this).constructor;
                  result = Reflect.construct(Super, arguments, NewTarget);
                } else {
                  result = Super.apply(this, arguments);
                }
                return axisTitle_possibleConstructorReturn(this, result);
              };
            }
            function axisTitle_possibleConstructorReturn(self2, call) {
              if (call && (axisTitle_typeof(call) === "object" || typeof call === "function")) {
                return call;
              }
              return axisTitle_assertThisInitialized(self2);
            }
            function axisTitle_assertThisInitialized(self2) {
              if (self2 === void 0) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return self2;
            }
            function axisTitle_isNativeReflectConstruct() {
              if (typeof Reflect === "undefined" || !Reflect.construct)
                return false;
              if (Reflect.construct.sham)
                return false;
              if (typeof Proxy === "function")
                return true;
              try {
                Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                }));
                return true;
              } catch (e) {
                return false;
              }
            }
            function axisTitle_getPrototypeOf(o) {
              axisTitle_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
                return o2.__proto__ || Object.getPrototypeOf(o2);
              };
              return axisTitle_getPrototypeOf(o);
            }
            function axisTitle_defineProperty(obj, key, value) {
              if (key in obj) {
                Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
              } else {
                obj[key] = value;
              }
              return obj;
            }
            var AxisTitle = function(_Component) {
              axisTitle_inherits(AxisTitle2, _Component);
              var _super = axisTitle_createSuper(AxisTitle2);
              function AxisTitle2() {
                var _this;
                axisTitle_classCallCheck(this, AxisTitle2);
                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }
                _this = _super.call.apply(_super, [this].concat(args));
                axisTitle_defineProperty(axisTitle_assertThisInitialized(_this), "models", void 0);
                axisTitle_defineProperty(axisTitle_assertThisInitialized(_this), "isYAxis", void 0);
                axisTitle_defineProperty(axisTitle_assertThisInitialized(_this), "isCircularAxis", void 0);
                axisTitle_defineProperty(axisTitle_assertThisInitialized(_this), "theme", void 0);
                return _this;
              }
              axisTitle_createClass(AxisTitle2, [{
                key: "initialize",
                value: function initialize(_ref) {
                  var name = _ref.name;
                  this.type = "axisTitle";
                  this.name = name;
                  this.isYAxis = includes([AxisType.Y, AxisType.SECONDARY_Y], name);
                  this.isCircularAxis = this.name === AxisType.CIRCULAR;
                }
              }, {
                key: "getTitlePosition",
                value: function getTitlePosition(offsetX, offsetY) {
                  if (this.isCircularAxis) {
                    return [this.rect.width / 2 + offsetX, this.rect.height / 2 + offsetY];
                  }
                  return this.isYAxis ? [this.name === AxisType.Y ? offsetX : this.rect.width + offsetX, offsetY] : [this.rect.width + offsetX, offsetY];
                }
              }, {
                key: "renderAxisTitle",
                value: function renderAxisTitle(option, textAlign) {
                  var text = option.text, offsetX = option.offsetX, offsetY = option.offsetY;
                  var _this$getTitlePositio = this.getTitlePosition(offsetX, offsetY), _this$getTitlePositio2 = axisTitle_slicedToArray(_this$getTitlePositio, 2), x = _this$getTitlePositio2[0], y = _this$getTitlePositio2[1];
                  var font = getTitleFontString(this.theme);
                  var fillStyle2 = this.theme.color;
                  return [{
                    type: "label",
                    text,
                    x,
                    y,
                    style: ["axisTitle", {
                      textAlign,
                      fillStyle: fillStyle2,
                      font
                    }]
                  }];
                }
              }, {
                key: "getTextAlign",
                value: function getTextAlign() {
                  var hasCenterYAxis = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
                  if (this.name === AxisType.Y) {
                    return hasCenterYAxis ? "center" : "left";
                  }
                  if (this.isCircularAxis) {
                    return "center";
                  }
                  return "right";
                }
              }, {
                key: "getCircularAxisTitleRect",
                value: function getCircularAxisTitleRect2(option, plotRect, circularAxisData) {
                  var x = plotRect.x, y = plotRect.y;
                  var centerX = circularAxisData.centerX, centerY = circularAxisData.centerY, axisSize = circularAxisData.axisSize, outerRadius = circularAxisData.radius.outer;
                  var offsetY = option.offsetY;
                  return {
                    x: centerX + x - axisSize / 2,
                    y: centerY + y - outerRadius / 2,
                    width: axisSize,
                    height: this.theme.fontSize + offsetY
                  };
                }
              }, {
                key: "render",
                value: function render(_ref2) {
                  var _radialAxes$this$name, _axes$this$name;
                  var axes2 = _ref2.axes, radialAxes2 = _ref2.radialAxes, layout2 = _ref2.layout, theme2 = _ref2.theme;
                  var titleOption = this.isCircularAxis ? (_radialAxes$this$name = radialAxes2[this.name]) === null || _radialAxes$this$name === void 0 ? void 0 : _radialAxes$this$name.title : (_axes$this$name = axes2[this.name]) === null || _axes$this$name === void 0 ? void 0 : _axes$this$name.title;
                  this.isShow = !!titleOption;
                  if (!this.isShow) {
                    return;
                  }
                  this.theme = getAxisTheme(theme2, this.name).title;
                  this.rect = layout2["".concat(this.name, "Title")];
                  this.models = this.renderAxisTitle(titleOption, this.getTextAlign(!!(axes2 !== null && axes2 !== void 0 && axes2.centerYAxis)));
                }
              }]);
              return AxisTitle2;
            }(Component);
            ;
            function title_typeof(obj) {
              "@babel/helpers - typeof";
              if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                title_typeof = function _typeof2(obj2) {
                  return typeof obj2;
                };
              } else {
                title_typeof = function _typeof2(obj2) {
                  return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                };
              }
              return title_typeof(obj);
            }
            function title_classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function title_defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            function title_createClass(Constructor, protoProps, staticProps) {
              if (protoProps)
                title_defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                title_defineProperties(Constructor, staticProps);
              return Constructor;
            }
            function title_inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function");
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
              if (superClass)
                title_setPrototypeOf(subClass, superClass);
            }
            function title_setPrototypeOf(o, p) {
              title_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
                o2.__proto__ = p2;
                return o2;
              };
              return title_setPrototypeOf(o, p);
            }
            function title_createSuper(Derived) {
              var hasNativeReflectConstruct = title_isNativeReflectConstruct();
              return function _createSuperInternal() {
                var Super = title_getPrototypeOf(Derived), result;
                if (hasNativeReflectConstruct) {
                  var NewTarget = title_getPrototypeOf(this).constructor;
                  result = Reflect.construct(Super, arguments, NewTarget);
                } else {
                  result = Super.apply(this, arguments);
                }
                return title_possibleConstructorReturn(this, result);
              };
            }
            function title_possibleConstructorReturn(self2, call) {
              if (call && (title_typeof(call) === "object" || typeof call === "function")) {
                return call;
              }
              return title_assertThisInitialized(self2);
            }
            function title_assertThisInitialized(self2) {
              if (self2 === void 0) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return self2;
            }
            function title_isNativeReflectConstruct() {
              if (typeof Reflect === "undefined" || !Reflect.construct)
                return false;
              if (Reflect.construct.sham)
                return false;
              if (typeof Proxy === "function")
                return true;
              try {
                Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                }));
                return true;
              } catch (e) {
                return false;
              }
            }
            function title_getPrototypeOf(o) {
              title_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
                return o2.__proto__ || Object.getPrototypeOf(o2);
              };
              return title_getPrototypeOf(o);
            }
            function title_defineProperty(obj, key, value) {
              if (key in obj) {
                Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
              } else {
                obj[key] = value;
              }
              return obj;
            }
            var Title = function(_Component) {
              title_inherits(Title2, _Component);
              var _super = title_createSuper(Title2);
              function Title2() {
                var _this;
                title_classCallCheck(this, Title2);
                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }
                _this = _super.call.apply(_super, [this].concat(args));
                title_defineProperty(title_assertThisInitialized(_this), "models", void 0);
                title_defineProperty(title_assertThisInitialized(_this), "theme", void 0);
                return _this;
              }
              title_createClass(Title2, [{
                key: "initialize",
                value: function initialize() {
                  this.type = "title";
                  this.name = "title";
                }
              }, {
                key: "renderTitle",
                value: function renderTitle(options2) {
                  var text = "";
                  var x = 0;
                  var y = 0;
                  var align = "left";
                  if (utils_isString(options2)) {
                    text = options2;
                  } else {
                    var _options$align, _options$offsetX, _options$offsetY;
                    text = options2.text;
                    align = (_options$align = options2.align) !== null && _options$align !== void 0 ? _options$align : "left";
                    x += (_options$offsetX = options2.offsetX) !== null && _options$offsetX !== void 0 ? _options$offsetX : 0;
                    y += (_options$offsetY = options2.offsetY) !== null && _options$offsetY !== void 0 ? _options$offsetY : 0;
                  }
                  var font = getTitleFontString(this.theme);
                  var textWidth = getTextWidth(text, font);
                  if (align === "center") {
                    x += (this.rect.width - textWidth) / 2;
                  } else if (align === "right") {
                    x += this.rect.width - textWidth;
                  }
                  return [{
                    type: "label",
                    x,
                    y,
                    text,
                    style: ["title", {
                      font,
                      fillStyle: this.theme.color
                    }]
                  }];
                }
              }, {
                key: "render",
                value: function render(_ref) {
                  var _options$chart;
                  var options2 = _ref.options, layout2 = _ref.layout, theme2 = _ref.theme;
                  this.isShow = !!((_options$chart = options2.chart) !== null && _options$chart !== void 0 && _options$chart.title);
                  if (!this.isShow) {
                    return;
                  }
                  this.theme = theme2.title;
                  this.rect = layout2.title;
                  this.models = this.renderTitle(options2.chart.title);
                }
              }]);
              return Title2;
            }(Component);
            ;
            function hoveredSeries_typeof(obj) {
              "@babel/helpers - typeof";
              if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                hoveredSeries_typeof = function _typeof2(obj2) {
                  return typeof obj2;
                };
              } else {
                hoveredSeries_typeof = function _typeof2(obj2) {
                  return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                };
              }
              return hoveredSeries_typeof(obj);
            }
            function hoveredSeries_slicedToArray(arr, i) {
              return hoveredSeries_arrayWithHoles(arr) || hoveredSeries_iterableToArrayLimit(arr, i) || hoveredSeries_unsupportedIterableToArray(arr, i) || hoveredSeries_nonIterableRest();
            }
            function hoveredSeries_nonIterableRest() {
              throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            function hoveredSeries_iterableToArrayLimit(arr, i) {
              var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]);
              if (_i == null)
                return;
              var _arr = [];
              var _n = true;
              var _d = false;
              var _s, _e;
              try {
                for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
                  _arr.push(_s.value);
                  if (i && _arr.length === i)
                    break;
                }
              } catch (err) {
                _d = true;
                _e = err;
              } finally {
                try {
                  if (!_n && _i["return"] != null)
                    _i["return"]();
                } finally {
                  if (_d)
                    throw _e;
                }
              }
              return _arr;
            }
            function hoveredSeries_arrayWithHoles(arr) {
              if (Array.isArray(arr))
                return arr;
            }
            function _objectWithoutProperties(source, excluded) {
              if (source == null)
                return {};
              var target = _objectWithoutPropertiesLoose(source, excluded);
              var key, i;
              if (Object.getOwnPropertySymbols) {
                var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
                for (i = 0; i < sourceSymbolKeys.length; i++) {
                  key = sourceSymbolKeys[i];
                  if (excluded.indexOf(key) >= 0)
                    continue;
                  if (!Object.prototype.propertyIsEnumerable.call(source, key))
                    continue;
                  target[key] = source[key];
                }
              }
              return target;
            }
            function _objectWithoutPropertiesLoose(source, excluded) {
              if (source == null)
                return {};
              var target = {};
              var sourceKeys = Object.keys(source);
              var key, i;
              for (i = 0; i < sourceKeys.length; i++) {
                key = sourceKeys[i];
                if (excluded.indexOf(key) >= 0)
                  continue;
                target[key] = source[key];
              }
              return target;
            }
            function hoveredSeries_toConsumableArray(arr) {
              return hoveredSeries_arrayWithoutHoles(arr) || hoveredSeries_iterableToArray(arr) || hoveredSeries_unsupportedIterableToArray(arr) || hoveredSeries_nonIterableSpread();
            }
            function hoveredSeries_nonIterableSpread() {
              throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            function hoveredSeries_unsupportedIterableToArray(o, minLen) {
              if (!o)
                return;
              if (typeof o === "string")
                return hoveredSeries_arrayLikeToArray(o, minLen);
              var n = Object.prototype.toString.call(o).slice(8, -1);
              if (n === "Object" && o.constructor)
                n = o.constructor.name;
              if (n === "Map" || n === "Set")
                return Array.from(o);
              if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                return hoveredSeries_arrayLikeToArray(o, minLen);
            }
            function hoveredSeries_iterableToArray(iter) {
              if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
                return Array.from(iter);
            }
            function hoveredSeries_arrayWithoutHoles(arr) {
              if (Array.isArray(arr))
                return hoveredSeries_arrayLikeToArray(arr);
            }
            function hoveredSeries_arrayLikeToArray(arr, len) {
              if (len == null || len > arr.length)
                len = arr.length;
              for (var i = 0, arr2 = new Array(len); i < len; i++) {
                arr2[i] = arr[i];
              }
              return arr2;
            }
            function hoveredSeries_classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function hoveredSeries_defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            function hoveredSeries_createClass(Constructor, protoProps, staticProps) {
              if (protoProps)
                hoveredSeries_defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                hoveredSeries_defineProperties(Constructor, staticProps);
              return Constructor;
            }
            function hoveredSeries_inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function");
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
              if (superClass)
                hoveredSeries_setPrototypeOf(subClass, superClass);
            }
            function hoveredSeries_setPrototypeOf(o, p) {
              hoveredSeries_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
                o2.__proto__ = p2;
                return o2;
              };
              return hoveredSeries_setPrototypeOf(o, p);
            }
            function hoveredSeries_createSuper(Derived) {
              var hasNativeReflectConstruct = hoveredSeries_isNativeReflectConstruct();
              return function _createSuperInternal() {
                var Super = hoveredSeries_getPrototypeOf(Derived), result;
                if (hasNativeReflectConstruct) {
                  var NewTarget = hoveredSeries_getPrototypeOf(this).constructor;
                  result = Reflect.construct(Super, arguments, NewTarget);
                } else {
                  result = Super.apply(this, arguments);
                }
                return hoveredSeries_possibleConstructorReturn(this, result);
              };
            }
            function hoveredSeries_possibleConstructorReturn(self2, call) {
              if (call && (hoveredSeries_typeof(call) === "object" || typeof call === "function")) {
                return call;
              }
              return hoveredSeries_assertThisInitialized(self2);
            }
            function hoveredSeries_assertThisInitialized(self2) {
              if (self2 === void 0) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return self2;
            }
            function hoveredSeries_isNativeReflectConstruct() {
              if (typeof Reflect === "undefined" || !Reflect.construct)
                return false;
              if (Reflect.construct.sham)
                return false;
              if (typeof Proxy === "function")
                return true;
              try {
                Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                }));
                return true;
              } catch (e) {
                return false;
              }
            }
            function hoveredSeries_getPrototypeOf(o) {
              hoveredSeries_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
                return o2.__proto__ || Object.getPrototypeOf(o2);
              };
              return hoveredSeries_getPrototypeOf(o);
            }
            function hoveredSeries_defineProperty(obj, key, value) {
              if (key in obj) {
                Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
              } else {
                obj[key] = value;
              }
              return obj;
            }
            var guideLineType = {
              line: "circle",
              area: "circle",
              boxPlot: "boxPlot"
            };
            var HoveredSeries = function(_Component) {
              hoveredSeries_inherits(HoveredSeries2, _Component);
              var _super = hoveredSeries_createSuper(HoveredSeries2);
              function HoveredSeries2() {
                var _this;
                hoveredSeries_classCallCheck(this, HoveredSeries2);
                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }
                _this = _super.call.apply(_super, [this].concat(args));
                hoveredSeries_defineProperty(hoveredSeries_assertThisInitialized(_this), "models", {
                  guideLine: []
                });
                hoveredSeries_defineProperty(hoveredSeries_assertThisInitialized(_this), "isShow", false);
                hoveredSeries_defineProperty(hoveredSeries_assertThisInitialized(_this), "modelForGuideLine", void 0);
                hoveredSeries_defineProperty(hoveredSeries_assertThisInitialized(_this), "renderHoveredSeries", function(_ref) {
                  var models = _ref.models, name = _ref.name, eventDetectType = _ref.eventDetectType;
                  var prevModels = _this.getSeriesModels(name);
                  _this.models[name] = hoveredSeries_toConsumableArray(models);
                  _this.isShow = !!_this.getSeriesModels().length;
                  var isSame = !!(prevModels !== null && prevModels !== void 0 && prevModels.length) && !!models.length && isSameSeriesResponder({
                    models,
                    comparisonModel: prevModels,
                    eventDetectType,
                    name
                  });
                  if (prevModels !== null && prevModels !== void 0 && prevModels.length && !models.length) {
                    _this.eventBus.emit("unhoverSeries", makeObservableObjectToNormal(prevModels));
                  } else if (models.length && !isSame) {
                    _this.eventBus.emit("hoverSeries", makeObservableObjectToNormal(models));
                  }
                  _this.modelForGuideLine = _this.getModelForGuideLine(name);
                  if (eventDetectType === "grouped") {
                    _this.renderGroupedModels(name);
                  }
                });
                hoveredSeries_defineProperty(hoveredSeries_assertThisInitialized(_this), "resetHoveredSeries", function() {
                  _this.models = {
                    guideLine: []
                  };
                });
                return _this;
              }
              hoveredSeries_createClass(HoveredSeries2, [{
                key: "getSeriesModels",
                value: function getSeriesModels(type) {
                  var _ref2;
                  var _this$models = this.models, guideLine = _this$models.guideLine, models = _objectWithoutProperties(_this$models, ["guideLine"]);
                  return (_ref2 = type ? models[type] : Object.values(models)) === null || _ref2 === void 0 ? void 0 : _ref2.flatMap(function(val) {
                    return val;
                  });
                }
              }, {
                key: "hasGuideLine",
                value: function hasGuideLine() {
                  var _this$getSeriesModels = this.getSeriesModels().filter(function(_ref3) {
                    var type = _ref3.type;
                    return type === "rect";
                  }), _this$getSeriesModels2 = hoveredSeries_slicedToArray(_this$getSeriesModels, 1), rectModel = _this$getSeriesModels2[0];
                  return !isUndefined(this.modelForGuideLine) && isUndefined(rectModel);
                }
              }, {
                key: "getModelForGuideLine",
                value: function getModelForGuideLine(name) {
                  return this.getSeriesModels().filter(function(_ref4) {
                    var type = _ref4.type;
                    return type === guideLineType[name];
                  })[0];
                }
              }, {
                key: "renderGroupedModels",
                value: function renderGroupedModels(name) {
                  if (includes(Object.keys(guideLineType), name)) {
                    if (this.isShow && this.hasGuideLine()) {
                      this.models.guideLine = [this.renderGuideLineModel(this.modelForGuideLine)];
                    } else {
                      this.models.guideLine = [];
                    }
                  }
                }
              }, {
                key: "renderGuideLineModel",
                value: function renderGuideLineModel(model) {
                  var x = crispPixel(model.type === "boxPlot" && model.boxPlotDetection ? model.boxPlotDetection.x + model.boxPlotDetection.width / 2 : model.x);
                  return {
                    type: "line",
                    x,
                    y: 0,
                    x2: x,
                    y2: this.rect.height,
                    strokeStyle: "#ddd",
                    lineWidth: 1
                  };
                }
              }, {
                key: "initialize",
                value: function initialize() {
                  this.type = "hoveredSeries";
                  this.name = "hoveredSeries";
                  this.eventBus.on("renderHoveredSeries", this.renderHoveredSeries);
                  this.eventBus.on("resetHoveredSeries", this.resetHoveredSeries);
                }
              }, {
                key: "render",
                value: function render(_ref5) {
                  var layout2 = _ref5.layout;
                  this.rect = layout2.plot;
                }
              }]);
              return HoveredSeries2;
            }(Component);
            ;
            function rangeSelection_typeof(obj) {
              "@babel/helpers - typeof";
              if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                rangeSelection_typeof = function _typeof2(obj2) {
                  return typeof obj2;
                };
              } else {
                rangeSelection_typeof = function _typeof2(obj2) {
                  return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                };
              }
              return rangeSelection_typeof(obj);
            }
            function rangeSelection_toConsumableArray(arr) {
              return rangeSelection_arrayWithoutHoles(arr) || rangeSelection_iterableToArray(arr) || rangeSelection_unsupportedIterableToArray(arr) || rangeSelection_nonIterableSpread();
            }
            function rangeSelection_nonIterableSpread() {
              throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            function rangeSelection_iterableToArray(iter) {
              if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
                return Array.from(iter);
            }
            function rangeSelection_arrayWithoutHoles(arr) {
              if (Array.isArray(arr))
                return rangeSelection_arrayLikeToArray(arr);
            }
            function rangeSelection_slicedToArray(arr, i) {
              return rangeSelection_arrayWithHoles(arr) || rangeSelection_iterableToArrayLimit(arr, i) || rangeSelection_unsupportedIterableToArray(arr, i) || rangeSelection_nonIterableRest();
            }
            function rangeSelection_nonIterableRest() {
              throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            function rangeSelection_unsupportedIterableToArray(o, minLen) {
              if (!o)
                return;
              if (typeof o === "string")
                return rangeSelection_arrayLikeToArray(o, minLen);
              var n = Object.prototype.toString.call(o).slice(8, -1);
              if (n === "Object" && o.constructor)
                n = o.constructor.name;
              if (n === "Map" || n === "Set")
                return Array.from(o);
              if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                return rangeSelection_arrayLikeToArray(o, minLen);
            }
            function rangeSelection_arrayLikeToArray(arr, len) {
              if (len == null || len > arr.length)
                len = arr.length;
              for (var i = 0, arr2 = new Array(len); i < len; i++) {
                arr2[i] = arr[i];
              }
              return arr2;
            }
            function rangeSelection_iterableToArrayLimit(arr, i) {
              var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]);
              if (_i == null)
                return;
              var _arr = [];
              var _n = true;
              var _d = false;
              var _s, _e;
              try {
                for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
                  _arr.push(_s.value);
                  if (i && _arr.length === i)
                    break;
                }
              } catch (err) {
                _d = true;
                _e = err;
              } finally {
                try {
                  if (!_n && _i["return"] != null)
                    _i["return"]();
                } finally {
                  if (_d)
                    throw _e;
                }
              }
              return _arr;
            }
            function rangeSelection_arrayWithHoles(arr) {
              if (Array.isArray(arr))
                return arr;
            }
            function rangeSelection_ownKeys(object, enumerableOnly) {
              var keys = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object);
                if (enumerableOnly) {
                  symbols = symbols.filter(function(sym) {
                    return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                  });
                }
                keys.push.apply(keys, symbols);
              }
              return keys;
            }
            function rangeSelection_objectSpread(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i] != null ? arguments[i] : {};
                if (i % 2) {
                  rangeSelection_ownKeys(Object(source), true).forEach(function(key) {
                    rangeSelection_defineProperty(target, key, source[key]);
                  });
                } else if (Object.getOwnPropertyDescriptors) {
                  Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                } else {
                  rangeSelection_ownKeys(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  });
                }
              }
              return target;
            }
            function rangeSelection_classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function rangeSelection_defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            function rangeSelection_createClass(Constructor, protoProps, staticProps) {
              if (protoProps)
                rangeSelection_defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                rangeSelection_defineProperties(Constructor, staticProps);
              return Constructor;
            }
            function rangeSelection_inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function");
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
              if (superClass)
                rangeSelection_setPrototypeOf(subClass, superClass);
            }
            function rangeSelection_setPrototypeOf(o, p) {
              rangeSelection_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
                o2.__proto__ = p2;
                return o2;
              };
              return rangeSelection_setPrototypeOf(o, p);
            }
            function rangeSelection_createSuper(Derived) {
              var hasNativeReflectConstruct = rangeSelection_isNativeReflectConstruct();
              return function _createSuperInternal() {
                var Super = rangeSelection_getPrototypeOf(Derived), result;
                if (hasNativeReflectConstruct) {
                  var NewTarget = rangeSelection_getPrototypeOf(this).constructor;
                  result = Reflect.construct(Super, arguments, NewTarget);
                } else {
                  result = Super.apply(this, arguments);
                }
                return rangeSelection_possibleConstructorReturn(this, result);
              };
            }
            function rangeSelection_possibleConstructorReturn(self2, call) {
              if (call && (rangeSelection_typeof(call) === "object" || typeof call === "function")) {
                return call;
              }
              return rangeSelection_assertThisInitialized(self2);
            }
            function rangeSelection_assertThisInitialized(self2) {
              if (self2 === void 0) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return self2;
            }
            function rangeSelection_isNativeReflectConstruct() {
              if (typeof Reflect === "undefined" || !Reflect.construct)
                return false;
              if (Reflect.construct.sham)
                return false;
              if (typeof Proxy === "function")
                return true;
              try {
                Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                }));
                return true;
              } catch (e) {
                return false;
              }
            }
            function rangeSelection_getPrototypeOf(o) {
              rangeSelection_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
                return o2.__proto__ || Object.getPrototypeOf(o2);
              };
              return rangeSelection_getPrototypeOf(o);
            }
            function rangeSelection_defineProperty(obj, key, value) {
              if (key in obj) {
                Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
              } else {
                obj[key] = value;
              }
              return obj;
            }
            var DRAG_MIN_WIDTH = 15;
            var RangeSelection = function(_Component) {
              rangeSelection_inherits(RangeSelection2, _Component);
              var _super = rangeSelection_createSuper(RangeSelection2);
              function RangeSelection2() {
                var _this;
                rangeSelection_classCallCheck(this, RangeSelection2);
                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }
                _this = _super.call.apply(_super, [this].concat(args));
                rangeSelection_defineProperty(rangeSelection_assertThisInitialized(_this), "models", {
                  selectionArea: []
                });
                rangeSelection_defineProperty(rangeSelection_assertThisInitialized(_this), "responders", void 0);
                rangeSelection_defineProperty(rangeSelection_assertThisInitialized(_this), "startIndex", void 0);
                rangeSelection_defineProperty(rangeSelection_assertThisInitialized(_this), "dragStartPosition", null);
                rangeSelection_defineProperty(rangeSelection_assertThisInitialized(_this), "dragStartPoint", null);
                rangeSelection_defineProperty(rangeSelection_assertThisInitialized(_this), "isDragging", false);
                return _this;
              }
              rangeSelection_createClass(RangeSelection2, [{
                key: "initialize",
                value: function initialize() {
                  this.type = "rangeSelection";
                }
              }, {
                key: "render",
                value: function render(state, computed2) {
                  var _viewRange$;
                  if (!state.selectionRange && !state.zoomRange) {
                    return;
                  }
                  this.resetSelectionArea();
                  var viewRange = computed2.viewRange;
                  var layout2 = state.layout, axes2 = state.axes, series = state.series, scale2 = state.scale;
                  var categories = state.categories;
                  this.rect = layout2.plot;
                  this.startIndex = (_viewRange$ = viewRange === null || viewRange === void 0 ? void 0 : viewRange[0]) !== null && _viewRange$ !== void 0 ? _viewRange$ : 0;
                  var coordinateChart = isCoordinateSeries(series);
                  if (coordinateChart) {
                    var responderInfo = this.getRectResponderInfoForCoordinateType(series, scale2, axes2.xAxis, categories);
                    this.responders = this.makeRectResponderModelForCoordinateType(responderInfo, categories);
                  } else {
                    this.responders = this.makeRectResponderModel(categories, axes2.xAxis);
                  }
                }
              }, {
                key: "getRectResponderInfoForCoordinateType",
                value: function getRectResponderInfoForCoordinateType(series, scale2, axisData, categories) {
                  var _this2 = this;
                  var points = [];
                  var duplicateCheckMap = {};
                  Object.keys(series).forEach(function(seriesName) {
                    var data = series[seriesName].data;
                    data.forEach(function(_ref) {
                      var rawData = _ref.rawData;
                      rawData.forEach(function(datum, idx) {
                        if (isNull(datum)) {
                          return;
                        }
                        var dataIndex = getCoordinateDataIndex(datum, categories, idx, _this2.startIndex);
                        var x = getXPosition(axisData, _this2.rect.width, getCoordinateXValue(datum), dataIndex);
                        var xWithinRect = x >= 0 && x <= _this2.rect.width;
                        if (!duplicateCheckMap[x] && xWithinRect) {
                          duplicateCheckMap[x] = true;
                          points.push({
                            x,
                            label: categories[dataIndex]
                          });
                        }
                      });
                    });
                  });
                  return points;
                }
              }, {
                key: "resetSelectionArea",
                value: function resetSelectionArea() {
                  this.dragStartPosition = null;
                  this.dragStartPoint = null;
                  this.models.selectionArea = [];
                  this.isDragging = false;
                }
              }, {
                key: "onMousedown",
                value: function onMousedown(_ref2) {
                  var responders = _ref2.responders, mousePosition = _ref2.mousePosition;
                  if (responders.length) {
                    this.dragStartPoint = responders.find(function(responder) {
                      return responder.data.name === "selectionArea";
                    });
                    this.dragStartPosition = mousePosition;
                  }
                }
              }, {
                key: "onMouseup",
                value: function onMouseup(_ref3) {
                  var _this3 = this;
                  var responders = _ref3.responders;
                  if (this.isDragging && this.dragStartPoint && responders.length) {
                    var dragRange = [this.dragStartPoint, responders[0]].sort(function(a, b) {
                      return a.index - b.index;
                    }).map(function(m) {
                      var _m$data;
                      return (_m$data = m.data) === null || _m$data === void 0 ? void 0 : _m$data.value;
                    });
                    var _this$store$state = this.store.state, series = _this$store$state.series, options2 = _this$store$state.options;
                    var seriesOptions = options2.series;
                    if (!series.column && seriesOptions !== null && seriesOptions !== void 0 && seriesOptions.zoomable) {
                      this.store.dispatch("zoom", dragRange);
                      this.eventBus.emit("zoom", makeObservableObjectToNormal(dragRange));
                    }
                    if (seriesOptions !== null && seriesOptions !== void 0 && seriesOptions.rangeSelectable) {
                      this.eventBus.emit("rangeSelection", dragRange);
                    }
                    this.eventBus.emit("resetHoveredSeries");
                    this.eventBus.emit("hideTooltip");
                    setTimeout(function() {
                      _this3.eventBus.emit("resetSelectedSeries");
                    });
                  }
                  this.resetSelectionArea();
                }
              }, {
                key: "makeRectResponderModel",
                value: function makeRectResponderModel2(categories, axisData) {
                  var categorySize = categories.length;
                  var pointOnColumn = axisData.pointOnColumn, tickDistance = axisData.tickDistance;
                  var height = this.rect.height;
                  var halfDetectAreaIndex = pointOnColumn ? [] : [0, categorySize - 1];
                  var halfWidth = tickDistance / 2;
                  return range(0, categorySize).map(function(index) {
                    var half = halfDetectAreaIndex.includes(index);
                    var width = half ? halfWidth : tickDistance;
                    var startX = 0;
                    if (index !== 0) {
                      startX += pointOnColumn ? tickDistance * index : halfWidth + tickDistance * (index - 1);
                    }
                    return {
                      type: "rect",
                      x: startX,
                      y: 0,
                      height,
                      width,
                      index,
                      data: {
                        name: "selectionArea",
                        value: categories[index]
                      }
                    };
                  });
                }
              }, {
                key: "makeRectResponderModelForCoordinateType",
                value: function makeRectResponderModelForCoordinateType(responderInfo, categories) {
                  var responders = responders_makeRectResponderModelForCoordinateType(responderInfo, this.rect);
                  return responders.map(function(m, idx) {
                    return rangeSelection_objectSpread(rangeSelection_objectSpread({}, m), {}, {
                      data: {
                        name: "selectionArea",
                        value: categories[idx]
                      }
                    });
                  });
                }
              }, {
                key: "onMousemove",
                value: function onMousemove(_ref4) {
                  var responders = _ref4.responders, mousePosition = _ref4.mousePosition;
                  if (!responders.length) {
                    return;
                  }
                  if (this.dragStartPosition && !this.isDragging) {
                    var x = mousePosition.x;
                    var startX = this.dragStartPosition.x;
                    this.isDragging = Math.abs(startX - x) > DRAG_MIN_WIDTH;
                  }
                  if (this.isDragging) {
                    var startIndex = this.dragStartPoint.index;
                    var endIndex = responders[0].index;
                    var _sort = [startIndex, endIndex].sort(sortNumber), _sort2 = rangeSelection_slicedToArray(_sort, 2), start = _sort2[0], end = _sort2[1];
                    var includedResponders = this.responders.slice(start, end + 1);
                    this.models.selectionArea = rangeSelection_toConsumableArray(includedResponders.map(function(m) {
                      return rangeSelection_objectSpread(rangeSelection_objectSpread({}, m), {}, {
                        x: m.x,
                        y: 0,
                        type: "rect",
                        color: "rgba(0, 0, 0, 0.2)"
                      });
                    }));
                    this.eventBus.emit("needDraw");
                  }
                }
              }, {
                key: "onMouseoutComponent",
                value: function onMouseoutComponent() {
                  this.resetSelectionArea();
                }
              }]);
              return RangeSelection2;
            }(Component);
            ;
            function resetButton_typeof(obj) {
              "@babel/helpers - typeof";
              if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                resetButton_typeof = function _typeof2(obj2) {
                  return typeof obj2;
                };
              } else {
                resetButton_typeof = function _typeof2(obj2) {
                  return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                };
              }
              return resetButton_typeof(obj);
            }
            function resetButton_classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function resetButton_defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            function resetButton_createClass(Constructor, protoProps, staticProps) {
              if (protoProps)
                resetButton_defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                resetButton_defineProperties(Constructor, staticProps);
              return Constructor;
            }
            function resetButton_inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function");
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
              if (superClass)
                resetButton_setPrototypeOf(subClass, superClass);
            }
            function resetButton_setPrototypeOf(o, p) {
              resetButton_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
                o2.__proto__ = p2;
                return o2;
              };
              return resetButton_setPrototypeOf(o, p);
            }
            function resetButton_createSuper(Derived) {
              var hasNativeReflectConstruct = resetButton_isNativeReflectConstruct();
              return function _createSuperInternal() {
                var Super = resetButton_getPrototypeOf(Derived), result;
                if (hasNativeReflectConstruct) {
                  var NewTarget = resetButton_getPrototypeOf(this).constructor;
                  result = Reflect.construct(Super, arguments, NewTarget);
                } else {
                  result = Super.apply(this, arguments);
                }
                return resetButton_possibleConstructorReturn(this, result);
              };
            }
            function resetButton_possibleConstructorReturn(self2, call) {
              if (call && (resetButton_typeof(call) === "object" || typeof call === "function")) {
                return call;
              }
              return resetButton_assertThisInitialized(self2);
            }
            function resetButton_assertThisInitialized(self2) {
              if (self2 === void 0) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return self2;
            }
            function resetButton_isNativeReflectConstruct() {
              if (typeof Reflect === "undefined" || !Reflect.construct)
                return false;
              if (Reflect.construct.sham)
                return false;
              if (typeof Proxy === "function")
                return true;
              try {
                Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                }));
                return true;
              } catch (e) {
                return false;
              }
            }
            function resetButton_getPrototypeOf(o) {
              resetButton_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
                return o2.__proto__ || Object.getPrototypeOf(o2);
              };
              return resetButton_getPrototypeOf(o);
            }
            function resetButton_defineProperty(obj, key, value) {
              if (key in obj) {
                Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
              } else {
                obj[key] = value;
              }
              return obj;
            }
            var ResetButton = function(_Component) {
              resetButton_inherits(ResetButton2, _Component);
              var _super = resetButton_createSuper(ResetButton2);
              function ResetButton2() {
                var _this;
                resetButton_classCallCheck(this, ResetButton2);
                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }
                _this = _super.call.apply(_super, [this].concat(args));
                resetButton_defineProperty(resetButton_assertThisInitialized(_this), "responders", void 0);
                resetButton_defineProperty(resetButton_assertThisInitialized(_this), "models", void 0);
                return _this;
              }
              resetButton_createClass(ResetButton2, [{
                key: "initialize",
                value: function initialize() {
                  this.type = "resetButton";
                  this.name = "resetButton";
                }
              }, {
                key: "onClick",
                value: function onClick(_ref) {
                  var responders = _ref.responders;
                  if (responders.length) {
                    this.eventBus.emit("resetZoom");
                    this.store.dispatch("resetZoom");
                  }
                }
              }, {
                key: "render",
                value: function render(_ref2, computed2) {
                  var options2 = _ref2.options, layout2 = _ref2.layout;
                  if (!isUsingResetButton(options2)) {
                    return;
                  }
                  this.rect = layout2.resetButton;
                  this.isShow = computed2.isLineTypeSeriesZooming;
                  this.models = this.isShow ? [{
                    type: "resetButton",
                    x: 0,
                    y: 0
                  }] : [];
                  this.responders = this.isShow ? [{
                    type: "rect",
                    x: 0,
                    y: 0,
                    width: BUTTON_RECT_SIZE,
                    height: BUTTON_RECT_SIZE
                  }] : [];
                }
              }]);
              return ResetButton2;
            }(Component);
            ;
            function selectedSeries_typeof(obj) {
              "@babel/helpers - typeof";
              if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                selectedSeries_typeof = function _typeof2(obj2) {
                  return typeof obj2;
                };
              } else {
                selectedSeries_typeof = function _typeof2(obj2) {
                  return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                };
              }
              return selectedSeries_typeof(obj);
            }
            function selectedSeries_ownKeys(object, enumerableOnly) {
              var keys = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object);
                if (enumerableOnly) {
                  symbols = symbols.filter(function(sym) {
                    return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                  });
                }
                keys.push.apply(keys, symbols);
              }
              return keys;
            }
            function selectedSeries_objectSpread(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i] != null ? arguments[i] : {};
                if (i % 2) {
                  selectedSeries_ownKeys(Object(source), true).forEach(function(key) {
                    selectedSeries_defineProperty(target, key, source[key]);
                  });
                } else if (Object.getOwnPropertyDescriptors) {
                  Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                } else {
                  selectedSeries_ownKeys(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  });
                }
              }
              return target;
            }
            function selectedSeries_classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function selectedSeries_defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            function selectedSeries_createClass(Constructor, protoProps, staticProps) {
              if (protoProps)
                selectedSeries_defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                selectedSeries_defineProperties(Constructor, staticProps);
              return Constructor;
            }
            function selectedSeries_inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function");
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
              if (superClass)
                selectedSeries_setPrototypeOf(subClass, superClass);
            }
            function selectedSeries_setPrototypeOf(o, p) {
              selectedSeries_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
                o2.__proto__ = p2;
                return o2;
              };
              return selectedSeries_setPrototypeOf(o, p);
            }
            function selectedSeries_createSuper(Derived) {
              var hasNativeReflectConstruct = selectedSeries_isNativeReflectConstruct();
              return function _createSuperInternal() {
                var Super = selectedSeries_getPrototypeOf(Derived), result;
                if (hasNativeReflectConstruct) {
                  var NewTarget = selectedSeries_getPrototypeOf(this).constructor;
                  result = Reflect.construct(Super, arguments, NewTarget);
                } else {
                  result = Super.apply(this, arguments);
                }
                return selectedSeries_possibleConstructorReturn(this, result);
              };
            }
            function selectedSeries_possibleConstructorReturn(self2, call) {
              if (call && (selectedSeries_typeof(call) === "object" || typeof call === "function")) {
                return call;
              }
              return selectedSeries_assertThisInitialized(self2);
            }
            function selectedSeries_assertThisInitialized(self2) {
              if (self2 === void 0) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return self2;
            }
            function selectedSeries_isNativeReflectConstruct() {
              if (typeof Reflect === "undefined" || !Reflect.construct)
                return false;
              if (Reflect.construct.sham)
                return false;
              if (typeof Proxy === "function")
                return true;
              try {
                Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                }));
                return true;
              } catch (e) {
                return false;
              }
            }
            function selectedSeries_getPrototypeOf(o) {
              selectedSeries_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
                return o2.__proto__ || Object.getPrototypeOf(o2);
              };
              return selectedSeries_getPrototypeOf(o);
            }
            function selectedSeries_defineProperty(obj, key, value) {
              if (key in obj) {
                Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
              } else {
                obj[key] = value;
              }
              return obj;
            }
            var SelectedSeries = function(_Component) {
              selectedSeries_inherits(SelectedSeries2, _Component);
              var _super = selectedSeries_createSuper(SelectedSeries2);
              function SelectedSeries2() {
                var _this;
                selectedSeries_classCallCheck(this, SelectedSeries2);
                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }
                _this = _super.call.apply(_super, [this].concat(args));
                selectedSeries_defineProperty(selectedSeries_assertThisInitialized(_this), "models", {});
                selectedSeries_defineProperty(selectedSeries_assertThisInitialized(_this), "seriesModels", {});
                selectedSeries_defineProperty(selectedSeries_assertThisInitialized(_this), "activeSeriesNames", {});
                selectedSeries_defineProperty(selectedSeries_assertThisInitialized(_this), "isShow", false);
                selectedSeries_defineProperty(selectedSeries_assertThisInitialized(_this), "renderSelectedSeries", function(selectedSeriesEventModel) {
                  var name = selectedSeriesEventModel.name, alias = selectedSeriesEventModel.alias;
                  var models = _this.getSelectedSeriesModelsForRendering(selectedSeriesEventModel);
                  _this.models[alias || name] = isSameSeriesResponder(selectedSeries_objectSpread(selectedSeries_objectSpread({}, selectedSeriesEventModel), {}, {
                    models,
                    comparisonModel: _this.models[alias || name]
                  })) ? [] : models;
                  _this.seriesModels[alias || name] = _this.getSelectedSeriesModels(selectedSeriesEventModel);
                  _this.isShow = !!Object.values(_this.models).flatMap(function(value) {
                    return value;
                  }).length;
                  _this.eventBus.emit(_this.isShow ? "selectSeries" : "unselectSeries", makeObservableObjectToNormal(_this.seriesModels));
                  _this.activeSeriesNames[name] = _this.getSeriesNames(selectedSeriesEventModel.models, name);
                  _this.setActiveState();
                });
                selectedSeries_defineProperty(selectedSeries_assertThisInitialized(_this), "resetSelectedSeries", function() {
                  _this.models = {};
                  _this.store.dispatch("setAllLegendActiveState", true);
                });
                return _this;
              }
              selectedSeries_createClass(SelectedSeries2, [{
                key: "getSeriesNames",
                value: function getSeriesNames(selectedSeries, name) {
                  var _this2 = this;
                  var names = [];
                  if (includes(["line", "area", "radar", "bubble", "scatter", "bullet", "boxPlot"], name)) {
                    selectedSeries.forEach(function(model) {
                      var label2 = model.name;
                      if (label2) {
                        names.push(label2);
                      }
                    });
                  } else if (includes(["bar", "column", "radialBar"], name)) {
                    selectedSeries.forEach(function(model) {
                      var _data;
                      var label2 = (_data = model.data) === null || _data === void 0 ? void 0 : _data.label;
                      if (label2) {
                        names.push(label2);
                      }
                    });
                  } else if (name === "pie") {
                    Object.keys(this.models).flatMap(function(key) {
                      return _this2.models[key];
                    }).forEach(function(model) {
                      var _data2, _data3;
                      var label2 = ((_data2 = model.data) === null || _data2 === void 0 ? void 0 : _data2.rootParentName) || ((_data3 = model.data) === null || _data3 === void 0 ? void 0 : _data3.label);
                      if (label2) {
                        names.push(label2);
                      }
                    });
                  }
                  return names;
                }
              }, {
                key: "getSelectedSeriesModelsForRendering",
                value: function getSelectedSeriesModelsForRendering(selectedSeriesEventModel) {
                  var models = selectedSeriesEventModel.models, eventDetectType = selectedSeriesEventModel.eventDetectType, name = selectedSeriesEventModel.name;
                  var renderingModels = models;
                  if ((name === "column" || name === "bar" || name === "bullet") && eventDetectType === "grouped") {
                    renderingModels = models.filter(function(model) {
                      return !model.data;
                    });
                  } else if (name === "radialBar" && eventDetectType === "grouped") {
                    renderingModels = models.filter(function(model) {
                      return !model.data;
                    });
                  }
                  return renderingModels;
                }
              }, {
                key: "getSelectedSeriesModels",
                value: function getSelectedSeriesModels(selectedSeriesEventModel) {
                  var models = selectedSeriesEventModel.models, eventDetectType = selectedSeriesEventModel.eventDetectType, name = selectedSeriesEventModel.name;
                  var selectedSeriesModels = models;
                  if ((name === "column" || name === "bar" || name === "bullet") && eventDetectType === "grouped") {
                    selectedSeriesModels = models.filter(function(model) {
                      return model.data;
                    });
                  } else if (name === "radialBar" && eventDetectType === "grouped") {
                    selectedSeriesModels = models.filter(function(model) {
                      return model.data;
                    });
                  }
                  return selectedSeriesModels;
                }
              }, {
                key: "setActiveState",
                value: function setActiveState() {
                  var _this3 = this;
                  if (this.isShow) {
                    this.store.dispatch("setAllLegendActiveState", false);
                    Object.values(this.activeSeriesNames).forEach(function(names) {
                      names.forEach(function(name) {
                        _this3.store.dispatch("setLegendActiveState", {
                          name,
                          active: true
                        });
                      });
                    });
                  } else {
                    this.store.dispatch("setAllLegendActiveState", true);
                  }
                  this.eventBus.emit("needDraw");
                }
              }, {
                key: "initialize",
                value: function initialize() {
                  this.type = "selectedSeries";
                  this.name = "selectedSeries";
                  this.eventBus.on("renderSelectedSeries", this.renderSelectedSeries);
                  this.eventBus.on("resetSelectedSeries", this.resetSelectedSeries);
                }
              }, {
                key: "render",
                value: function render(_ref) {
                  var layout2 = _ref.layout;
                  this.rect = layout2.plot;
                }
              }]);
              return SelectedSeries2;
            }(Component);
            ;
            function background_typeof(obj) {
              "@babel/helpers - typeof";
              if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                background_typeof = function _typeof2(obj2) {
                  return typeof obj2;
                };
              } else {
                background_typeof = function _typeof2(obj2) {
                  return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                };
              }
              return background_typeof(obj);
            }
            function background_ownKeys(object, enumerableOnly) {
              var keys = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object);
                if (enumerableOnly) {
                  symbols = symbols.filter(function(sym) {
                    return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                  });
                }
                keys.push.apply(keys, symbols);
              }
              return keys;
            }
            function background_objectSpread(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i] != null ? arguments[i] : {};
                if (i % 2) {
                  background_ownKeys(Object(source), true).forEach(function(key) {
                    background_defineProperty(target, key, source[key]);
                  });
                } else if (Object.getOwnPropertyDescriptors) {
                  Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                } else {
                  background_ownKeys(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  });
                }
              }
              return target;
            }
            function background_classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function background_defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            function background_createClass(Constructor, protoProps, staticProps) {
              if (protoProps)
                background_defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                background_defineProperties(Constructor, staticProps);
              return Constructor;
            }
            function background_inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function");
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
              if (superClass)
                background_setPrototypeOf(subClass, superClass);
            }
            function background_setPrototypeOf(o, p) {
              background_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
                o2.__proto__ = p2;
                return o2;
              };
              return background_setPrototypeOf(o, p);
            }
            function background_createSuper(Derived) {
              var hasNativeReflectConstruct = background_isNativeReflectConstruct();
              return function _createSuperInternal() {
                var Super = background_getPrototypeOf(Derived), result;
                if (hasNativeReflectConstruct) {
                  var NewTarget = background_getPrototypeOf(this).constructor;
                  result = Reflect.construct(Super, arguments, NewTarget);
                } else {
                  result = Super.apply(this, arguments);
                }
                return background_possibleConstructorReturn(this, result);
              };
            }
            function background_possibleConstructorReturn(self2, call) {
              if (call && (background_typeof(call) === "object" || typeof call === "function")) {
                return call;
              }
              return background_assertThisInitialized(self2);
            }
            function background_assertThisInitialized(self2) {
              if (self2 === void 0) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return self2;
            }
            function background_isNativeReflectConstruct() {
              if (typeof Reflect === "undefined" || !Reflect.construct)
                return false;
              if (Reflect.construct.sham)
                return false;
              if (typeof Proxy === "function")
                return true;
              try {
                Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                }));
                return true;
              } catch (e) {
                return false;
              }
            }
            function background_getPrototypeOf(o) {
              background_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
                return o2.__proto__ || Object.getPrototypeOf(o2);
              };
              return background_getPrototypeOf(o);
            }
            function background_defineProperty(obj, key, value) {
              if (key in obj) {
                Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
              } else {
                obj[key] = value;
              }
              return obj;
            }
            var Background = function(_Component) {
              background_inherits(Background2, _Component);
              var _super = background_createSuper(Background2);
              function Background2() {
                var _this;
                background_classCallCheck(this, Background2);
                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }
                _this = _super.call.apply(_super, [this].concat(args));
                background_defineProperty(background_assertThisInitialized(_this), "models", void 0);
                background_defineProperty(background_assertThisInitialized(_this), "theme", void 0);
                return _this;
              }
              background_createClass(Background2, [{
                key: "initialize",
                value: function initialize() {
                  this.type = "background";
                  this.name = "background";
                }
              }, {
                key: "render",
                value: function render(_ref) {
                  var layout2 = _ref.layout, theme2 = _ref.theme;
                  var _layout$chart = layout2.chart, width = _layout$chart.width, height = _layout$chart.height;
                  this.theme = theme2.chart;
                  this.rect = {
                    x: 0,
                    y: 0,
                    width,
                    height
                  };
                  this.models = [background_objectSpread(background_objectSpread({
                    type: "rect"
                  }, this.rect), {}, {
                    color: this.theme.backgroundColor
                  })];
                }
              }]);
              return Background2;
            }(Component);
            ;
            function noDataText_typeof(obj) {
              "@babel/helpers - typeof";
              if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                noDataText_typeof = function _typeof2(obj2) {
                  return typeof obj2;
                };
              } else {
                noDataText_typeof = function _typeof2(obj2) {
                  return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                };
              }
              return noDataText_typeof(obj);
            }
            function noDataText_ownKeys(object, enumerableOnly) {
              var keys = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object);
                if (enumerableOnly) {
                  symbols = symbols.filter(function(sym) {
                    return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                  });
                }
                keys.push.apply(keys, symbols);
              }
              return keys;
            }
            function noDataText_objectSpread(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i] != null ? arguments[i] : {};
                if (i % 2) {
                  noDataText_ownKeys(Object(source), true).forEach(function(key) {
                    noDataText_defineProperty(target, key, source[key]);
                  });
                } else if (Object.getOwnPropertyDescriptors) {
                  Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                } else {
                  noDataText_ownKeys(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  });
                }
              }
              return target;
            }
            function noDataText_classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function noDataText_defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            function noDataText_createClass(Constructor, protoProps, staticProps) {
              if (protoProps)
                noDataText_defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                noDataText_defineProperties(Constructor, staticProps);
              return Constructor;
            }
            function noDataText_inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function");
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
              if (superClass)
                noDataText_setPrototypeOf(subClass, superClass);
            }
            function noDataText_setPrototypeOf(o, p) {
              noDataText_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
                o2.__proto__ = p2;
                return o2;
              };
              return noDataText_setPrototypeOf(o, p);
            }
            function noDataText_createSuper(Derived) {
              var hasNativeReflectConstruct = noDataText_isNativeReflectConstruct();
              return function _createSuperInternal() {
                var Super = noDataText_getPrototypeOf(Derived), result;
                if (hasNativeReflectConstruct) {
                  var NewTarget = noDataText_getPrototypeOf(this).constructor;
                  result = Reflect.construct(Super, arguments, NewTarget);
                } else {
                  result = Super.apply(this, arguments);
                }
                return noDataText_possibleConstructorReturn(this, result);
              };
            }
            function noDataText_possibleConstructorReturn(self2, call) {
              if (call && (noDataText_typeof(call) === "object" || typeof call === "function")) {
                return call;
              }
              return noDataText_assertThisInitialized(self2);
            }
            function noDataText_assertThisInitialized(self2) {
              if (self2 === void 0) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return self2;
            }
            function noDataText_isNativeReflectConstruct() {
              if (typeof Reflect === "undefined" || !Reflect.construct)
                return false;
              if (Reflect.construct.sham)
                return false;
              if (typeof Proxy === "function")
                return true;
              try {
                Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                }));
                return true;
              } catch (e) {
                return false;
              }
            }
            function noDataText_getPrototypeOf(o) {
              noDataText_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
                return o2.__proto__ || Object.getPrototypeOf(o2);
              };
              return noDataText_getPrototypeOf(o);
            }
            function noDataText_defineProperty(obj, key, value) {
              if (key in obj) {
                Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
              } else {
                obj[key] = value;
              }
              return obj;
            }
            var DEFAULT_NO_DATA_TEXT = "No data to display";
            var NoDataText = function(_Component) {
              noDataText_inherits(NoDataText2, _Component);
              var _super = noDataText_createSuper(NoDataText2);
              function NoDataText2() {
                var _this;
                noDataText_classCallCheck(this, NoDataText2);
                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }
                _this = _super.call.apply(_super, [this].concat(args));
                noDataText_defineProperty(noDataText_assertThisInitialized(_this), "models", void 0);
                return _this;
              }
              noDataText_createClass(NoDataText2, [{
                key: "initialize",
                value: function initialize() {
                  this.type = "noDataText";
                  this.name = "noDataText";
                }
              }, {
                key: "getCenterPosition",
                value: function getCenterPosition(text, font) {
                  var textWidth = getTextWidth(text, font);
                  var textHeight = getTextHeight(text, font);
                  return {
                    x: (this.rect.width - textWidth) / 2,
                    y: (this.rect.height - textHeight) / 2
                  };
                }
              }, {
                key: "render",
                value: function render(_ref) {
                  var _options$lang$noData, _options$lang;
                  var layout2 = _ref.layout, series = _ref.series, options2 = _ref.options, theme2 = _ref.theme;
                  var text = (_options$lang$noData = options2 === null || options2 === void 0 ? void 0 : (_options$lang = options2.lang) === null || _options$lang === void 0 ? void 0 : _options$lang.noData) !== null && _options$lang$noData !== void 0 ? _options$lang$noData : DEFAULT_NO_DATA_TEXT;
                  var labelTheme = theme2.noData;
                  var font = getTitleFontString(labelTheme);
                  var fillStyle2 = labelTheme.color;
                  this.isShow = isNoData(series);
                  this.rect = layout2.plot;
                  this.models = [noDataText_objectSpread(noDataText_objectSpread({
                    type: "label"
                  }, this.getCenterPosition(text, font)), {}, {
                    text,
                    style: [{
                      font,
                      fillStyle: fillStyle2
                    }]
                  })];
                }
              }]);
              return NoDataText2;
            }(Component);
            ;
            function linePoints(ctx2, pointsModel) {
              var strokeStyle = pointsModel.color, lineWidth = pointsModel.lineWidth, points = pointsModel.points, _pointsModel$dashSegm = pointsModel.dashSegments, dashSegments = _pointsModel$dashSegm === void 0 ? [] : _pointsModel$dashSegm;
              ctx2.lineCap = "round";
              ctx2.beginPath();
              if (dashSegments) {
                setLineDash(ctx2, dashSegments);
              }
              var start = false;
              points.forEach(function(point, idx) {
                var _points, _points$controlPoint;
                if (isNull(point)) {
                  start = false;
                  return;
                }
                if (!start) {
                  ctx2.moveTo(point.x, point.y);
                  start = true;
                  return;
                }
                if (point.controlPoint && (_points = points[idx - 1]) !== null && _points !== void 0 && (_points$controlPoint = _points.controlPoint) !== null && _points$controlPoint !== void 0 && _points$controlPoint.next) {
                  var _next = points[idx - 1].controlPoint.next, prevX = _next.x, prevY = _next.y;
                  var controlPoint = point.controlPoint, x = point.x, y = point.y;
                  ctx2.bezierCurveTo(prevX, prevY, controlPoint.prev.x, controlPoint.prev.y, x, y);
                } else {
                  ctx2.lineTo(point.x, point.y);
                }
              });
              strokeWithOptions(ctx2, {
                lineWidth,
                strokeStyle
              });
              ctx2.closePath();
              setLineDash(ctx2, []);
            }
            function areaPoints(ctx2, areaPointsModel) {
              var fillColor = areaPointsModel.fillColor;
              ctx2.beginPath();
              linePoints(ctx2, areaPointsModel);
              fillStyle(ctx2, fillColor);
              ctx2.closePath();
            }
            ;
            function exportMenu_ownKeys(object, enumerableOnly) {
              var keys = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object);
                if (enumerableOnly) {
                  symbols = symbols.filter(function(sym) {
                    return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                  });
                }
                keys.push.apply(keys, symbols);
              }
              return keys;
            }
            function exportMenu_objectSpread(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i] != null ? arguments[i] : {};
                if (i % 2) {
                  exportMenu_ownKeys(Object(source), true).forEach(function(key) {
                    brushes_exportMenu_defineProperty(target, key, source[key]);
                  });
                } else if (Object.getOwnPropertyDescriptors) {
                  Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                } else {
                  exportMenu_ownKeys(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  });
                }
              }
              return target;
            }
            function brushes_exportMenu_defineProperty(obj, key, value) {
              if (key in obj) {
                Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
              } else {
                obj[key] = value;
              }
              return obj;
            }
            function drawXIcon(ctx2, icon, rectSize) {
              var startX = icon.x, startY = icon.y, _icon$theme = icon.theme, strokeStyle = _icon$theme.color, lineWidth = _icon$theme.lineWidth;
              var offset = rectSize / 3;
              var x = startX + offset;
              var y = startY + offset;
              var x2 = startX + offset * 2;
              var y2 = startY + offset * 2;
              var points = [{
                x,
                y,
                x2,
                y2
              }, {
                x,
                y: y2,
                x2,
                y2: y
              }];
              points.forEach(function(p) {
                line(ctx2, exportMenu_objectSpread(exportMenu_objectSpread({
                  type: "line"
                }, p), {}, {
                  strokeStyle,
                  lineWidth
                }));
              });
            }
            function drawMoreIcon(ctx2, icon, rectSize) {
              var x = icon.x, y = icon.y, _icon$theme2 = icon.theme, color = _icon$theme2.color, width = _icon$theme2.width, height = _icon$theme2.height, gap = _icon$theme2.gap;
              var paddingX = (rectSize - width) / 2;
              var paddingY = (rectSize - (height * 3 + gap * 2)) / 2;
              var centerX = x + paddingX;
              var points = [{
                x: centerX,
                y: y + paddingY
              }, {
                x: centerX,
                y: y + paddingY + height + gap
              }, {
                x: centerX,
                y: y + paddingY + (height + gap) * 2
              }];
              points.forEach(function(p) {
                rect(ctx2, exportMenu_objectSpread(exportMenu_objectSpread({
                  type: "rect"
                }, p), {}, {
                  color,
                  width,
                  height
                }));
              });
            }
            function exportMenuButton(ctx2, exportMenuButtonModel) {
              var opened = exportMenuButtonModel.opened, xPos = exportMenuButtonModel.x, yPos = exportMenuButtonModel.y, theme2 = exportMenuButtonModel.theme;
              var _ref = theme2, borderColor = _ref.borderColor, backgroundColor = _ref.backgroundColor, borderWidth = _ref.borderWidth, borderRadius = _ref.borderRadius, xIcon = _ref.xIcon, dotIcon = _ref.dotIcon;
              var x = xPos + borderWidth;
              var y = yPos + borderWidth;
              var rectSize = BUTTON_RECT_SIZE - 2 * borderWidth;
              pathRect(ctx2, {
                type: "pathRect",
                x,
                y,
                fill: backgroundColor,
                stroke: borderColor,
                width: rectSize,
                height: rectSize,
                radius: borderRadius,
                lineWidth: borderWidth
              });
              if (opened) {
                drawXIcon(ctx2, {
                  x,
                  y,
                  theme: xIcon
                }, rectSize);
              } else {
                drawMoreIcon(ctx2, {
                  x,
                  y,
                  theme: dotIcon
                }, rectSize);
              }
            }
            ;
            var ARROW_HEIGHT = 3;
            var ARROW_WIDTH = 6;
            function drawResetIcon(ctx2, point) {
              var x = point.x, y = point.y;
              var centerX = x + BUTTON_RECT_SIZE / 2;
              var centerY = y + BUTTON_RECT_SIZE / 2;
              var tickSize = BUTTON_RECT_SIZE / 10;
              var color = "#545454";
              circle(ctx2, {
                type: "circle",
                x: centerX,
                y: centerY,
                radius: tickSize * 2,
                angle: {
                  start: 0,
                  end: Math.PI / 2
                },
                color: "transparent",
                style: [{
                  lineWidth: 2,
                  strokeStyle: color
                }]
              });
              var pointStartX = centerX + tickSize * 2;
              var pointStartY = centerY;
              var points = [{
                x: pointStartX - ARROW_WIDTH / 2,
                y: pointStartY
              }, {
                x: pointStartX + ARROW_WIDTH / 2,
                y: pointStartY
              }, {
                x: pointStartX,
                y: pointStartY + ARROW_HEIGHT
              }];
              areaPoints(ctx2, {
                type: "areaPoints",
                points,
                lineWidth: 1,
                color,
                fillColor: color
              });
            }
            function drawBackIcon(ctx2, point) {
              var barWidth = 4;
              var radius = BUTTON_RECT_SIZE / 7;
              var x = point.x, y = point.y;
              var centerX = x + BUTTON_RECT_SIZE / 2;
              var centerY = y + BUTTON_RECT_SIZE / 2;
              var color = "#545454";
              line(ctx2, {
                type: "line",
                lineWidth: 2,
                x: centerX - barWidth / 2,
                y: centerY + radius,
                x2: centerX + barWidth / 2,
                y2: centerY + radius,
                strokeStyle: color
              });
              line(ctx2, {
                type: "line",
                lineWidth: 2,
                x: centerX - barWidth / 2,
                y: centerY - radius,
                x2: centerX + barWidth / 2,
                y2: centerY - radius,
                strokeStyle: color
              });
              circle(ctx2, {
                type: "circle",
                x: centerX + barWidth / 2,
                y: centerY,
                radius,
                angle: {
                  start: Math.PI / 2,
                  end: Math.PI * 3 / 2
                },
                color: "transparent",
                style: [{
                  lineWidth: 2,
                  strokeStyle: color
                }]
              });
              var pointStartX = centerX - barWidth / 2;
              var pointStartY = centerY - radius;
              var points = [{
                x: pointStartX - ARROW_HEIGHT,
                y: pointStartY
              }, {
                x: pointStartX,
                y: pointStartY - ARROW_WIDTH / 2
              }, {
                x: pointStartX,
                y: pointStartY + ARROW_WIDTH / 2
              }];
              areaPoints(ctx2, {
                type: "areaPoints",
                points,
                lineWidth: 1,
                color,
                fillColor: color
              });
            }
            function backButton(ctx2, backButtonModel) {
              var x = backButtonModel.x, y = backButtonModel.y;
              pathRect(ctx2, {
                type: "pathRect",
                x,
                y,
                fill: "#f4f4f4",
                stroke: "#f4f4f4",
                width: BUTTON_RECT_SIZE,
                height: BUTTON_RECT_SIZE,
                radius: 5
              });
              drawBackIcon(ctx2, {
                x,
                y
              });
            }
            function resetButton(ctx2, resetButtonModel) {
              var x = resetButtonModel.x, y = resetButtonModel.y;
              pathRect(ctx2, {
                type: "pathRect",
                x,
                y,
                fill: "#f4f4f4",
                stroke: "#f4f4f4",
                width: BUTTON_RECT_SIZE,
                height: BUTTON_RECT_SIZE,
                radius: 5
              });
              drawResetIcon(ctx2, {
                x,
                y
              });
            }
            ;
            function lineChart_typeof(obj) {
              "@babel/helpers - typeof";
              if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                lineChart_typeof = function _typeof2(obj2) {
                  return typeof obj2;
                };
              } else {
                lineChart_typeof = function _typeof2(obj2) {
                  return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                };
              }
              return lineChart_typeof(obj);
            }
            function lineChart_ownKeys(object, enumerableOnly) {
              var keys = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object);
                if (enumerableOnly) {
                  symbols = symbols.filter(function(sym) {
                    return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                  });
                }
                keys.push.apply(keys, symbols);
              }
              return keys;
            }
            function lineChart_objectSpread(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i] != null ? arguments[i] : {};
                if (i % 2) {
                  lineChart_ownKeys(Object(source), true).forEach(function(key) {
                    lineChart_defineProperty(target, key, source[key]);
                  });
                } else if (Object.getOwnPropertyDescriptors) {
                  Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                } else {
                  lineChart_ownKeys(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  });
                }
              }
              return target;
            }
            function lineChart_defineProperty(obj, key, value) {
              if (key in obj) {
                Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
              } else {
                obj[key] = value;
              }
              return obj;
            }
            function lineChart_classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function lineChart_defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            function lineChart_createClass(Constructor, protoProps, staticProps) {
              if (protoProps)
                lineChart_defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                lineChart_defineProperties(Constructor, staticProps);
              return Constructor;
            }
            function _get(target, property, receiver) {
              if (typeof Reflect !== "undefined" && Reflect.get) {
                _get = Reflect.get;
              } else {
                _get = function _get2(target2, property2, receiver2) {
                  var base = _superPropBase(target2, property2);
                  if (!base)
                    return;
                  var desc = Object.getOwnPropertyDescriptor(base, property2);
                  if (desc.get) {
                    return desc.get.call(receiver2);
                  }
                  return desc.value;
                };
              }
              return _get(target, property, receiver || target);
            }
            function _superPropBase(object, property) {
              while (!Object.prototype.hasOwnProperty.call(object, property)) {
                object = lineChart_getPrototypeOf(object);
                if (object === null)
                  break;
              }
              return object;
            }
            function lineChart_inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function");
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
              if (superClass)
                lineChart_setPrototypeOf(subClass, superClass);
            }
            function lineChart_setPrototypeOf(o, p) {
              lineChart_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
                o2.__proto__ = p2;
                return o2;
              };
              return lineChart_setPrototypeOf(o, p);
            }
            function lineChart_createSuper(Derived) {
              var hasNativeReflectConstruct = lineChart_isNativeReflectConstruct();
              return function _createSuperInternal() {
                var Super = lineChart_getPrototypeOf(Derived), result;
                if (hasNativeReflectConstruct) {
                  var NewTarget = lineChart_getPrototypeOf(this).constructor;
                  result = Reflect.construct(Super, arguments, NewTarget);
                } else {
                  result = Super.apply(this, arguments);
                }
                return lineChart_possibleConstructorReturn(this, result);
              };
            }
            function lineChart_possibleConstructorReturn(self2, call) {
              if (call && (lineChart_typeof(call) === "object" || typeof call === "function")) {
                return call;
              }
              return lineChart_assertThisInitialized(self2);
            }
            function lineChart_assertThisInitialized(self2) {
              if (self2 === void 0) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return self2;
            }
            function lineChart_isNativeReflectConstruct() {
              if (typeof Reflect === "undefined" || !Reflect.construct)
                return false;
              if (Reflect.construct.sham)
                return false;
              if (typeof Proxy === "function")
                return true;
              try {
                Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                }));
                return true;
              } catch (e) {
                return false;
              }
            }
            function lineChart_getPrototypeOf(o) {
              lineChart_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
                return o2.__proto__ || Object.getPrototypeOf(o2);
              };
              return lineChart_getPrototypeOf(o);
            }
            var LineChart = function(_Chart) {
              lineChart_inherits(LineChart2, _Chart);
              var _super = lineChart_createSuper(LineChart2);
              function LineChart2(props) {
                var _props$data;
                lineChart_classCallCheck(this, LineChart2);
                return _super.call(this, {
                  el: props.el,
                  options: props.options,
                  series: {
                    line: props.data.series
                  },
                  categories: (_props$data = props.data) === null || _props$data === void 0 ? void 0 : _props$data.categories,
                  modules: [store_dataRange, store_scale, store_axes, store_plot]
                });
              }
              lineChart_createClass(LineChart2, [{
                key: "initialize",
                value: function initialize() {
                  _get(lineChart_getPrototypeOf(LineChart2.prototype), "initialize", this).call(this);
                  this.componentManager.add(Background);
                  this.componentManager.add(Title);
                  this.componentManager.add(Plot);
                  this.componentManager.add(Legend);
                  this.componentManager.add(LineSeries);
                  this.componentManager.add(Axis, {
                    name: "yAxis"
                  });
                  this.componentManager.add(Axis, {
                    name: "xAxis"
                  });
                  this.componentManager.add(Axis, {
                    name: "secondaryYAxis"
                  });
                  this.componentManager.add(DataLabels);
                  this.componentManager.add(AxisTitle, {
                    name: "xAxis"
                  });
                  this.componentManager.add(AxisTitle, {
                    name: "yAxis"
                  });
                  this.componentManager.add(AxisTitle, {
                    name: "secondaryYAxis"
                  });
                  this.componentManager.add(ExportMenu, {
                    chartEl: this.el
                  });
                  this.componentManager.add(HoveredSeries);
                  this.componentManager.add(SelectedSeries);
                  this.componentManager.add(Tooltip, {
                    chartEl: this.el
                  });
                  this.componentManager.add(RangeSelection);
                  this.componentManager.add(ResetButton);
                  this.componentManager.add(NoDataText);
                  this.painter.addGroups([basic_namespaceObject, axis_namespaceObject, brushes_lineSeries_namespaceObject, legend_namespaceObject, label_namespaceObject, brushes_exportMenu_namespaceObject, dataLabel_namespaceObject, brushes_resetButton_namespaceObject]);
                }
                /**
                 * Add data.
                 * @param {Array<number|Object|Array>} data - Array of data to be added.
                 * @param {string} category - Category to be added.
                 * @api
                 * @example
                 * chart.addData([10, 20], '6');
                 */
              }, {
                key: "addData",
                value: function addData(data, category2) {
                  var _this$store$state$opt;
                  if ((_this$store$state$opt = this.store.state.options.series) !== null && _this$store$state$opt !== void 0 && _this$store$state$opt.showDot) {
                    this.animationControlFlag.updating = true;
                  }
                  this.resetSeries();
                  this.store.dispatch("addData", {
                    data,
                    category: category2
                  });
                }
                /**
                 * Add series.
                 * @param {Object} data - Data to be added.
                 *   @param {string} data.name - Series name.
                 *   @param {Array<number|Object|Array>} data.data - Array of data to be added.
                 * @api
                 * @example
                 * chart.addSeries({
                 *   name: 'newSeries',
                 *   data: [10, 100, 50, 40, 70, 55, 33, 70, 90, 110],
                 * });
                 */
              }, {
                key: "addSeries",
                value: function addSeries(data) {
                  this.resetSeries();
                  this.store.dispatch("addSeries", {
                    data
                  });
                }
                /**
                 * Convert the chart data to new data.
                 * @param {Object} data - Data to be set.
                 * @api
                 * @example
                 * chart.setData({
                 *   categories: ['1', '2', '3'],
                 *   series: [
                 *     {
                 *       name: 'new series',
                 *       data: [1, 2, 3],
                 *     },
                 *     {
                 *       name: 'new series2',
                 *       data: [4, 5, 6],
                 *     }
                 *   ]
                 * });
                 */
              }, {
                key: "setData",
                value: function setData(data) {
                  var categories = data.categories, series = data.series;
                  this.resetSeries();
                  this.store.dispatch("setData", {
                    series: {
                      line: series
                    },
                    categories
                  });
                }
                /**
                 * Add plot line.
                 * @param {Object} data - Plot info.
                 *    @param {string|number} data.value - The value where the plot line will be drawn.
                 *    @param {string} data.color - Plot line color.
                 *    @param {string} [data.id] - Plot id. The value on which the removePlotLine is based.
                 * @api
                 * @example
                 * chart.addPlotLine({
                 *   value: 2,
                 *   color: '#00ff22',
                 *   id: 'plot-1',
                 * });
                 */
              }, {
                key: "addPlotLine",
                value: function addPlotLine(data) {
                  this.store.dispatch("addPlotLine", {
                    data
                  });
                }
                /**
                 * Remove plot line with id.
                 * @param {string} id - Id of the plot line to be removed.
                 * @api
                 * @example
                 * chart.removePlotLine('plot-1');
                 */
              }, {
                key: "removePlotLine",
                value: function removePlotLine(id) {
                  this.store.dispatch("removePlotLine", {
                    id
                  });
                }
                /**
                 * Add plot band.
                 * @param {Object} data - Plot info.
                 *   @param {Array<string|number>} data.range - The range to be drawn.
                 *   @param {string} data.color - Plot band color.
                 *   @param {string} [data.id] - Plot id. The value on which the removePlotBand is based.
                 * @api
                 * @example
                 * chart.addPlotBand({
                 *   value: [2, 4],
                 *   color: '#00ff22',
                 *   id: 'plot-1',
                 * });
                 */
              }, {
                key: "addPlotBand",
                value: function addPlotBand(data) {
                  this.store.dispatch("addPlotBand", {
                    data
                  });
                }
                /**
                 * Remove plot band with id.
                 * @param {string} id - id of the plot band to be removed
                 * @api
                 * @example
                 * chart.removePlotBand('plot-1');
                 */
              }, {
                key: "removePlotBand",
                value: function removePlotBand(id) {
                  this.store.dispatch("removePlotBand", {
                    id
                  });
                }
                /**
                 * Hide series data label.
                 * @api
                 * @example
                 * chart.hideSeriesDataLabel();
                 */
              }, {
                key: "hideSeriesDataLabel",
                value: function hideSeriesDataLabel() {
                  this.store.dispatch("updateOptions", {
                    options: {
                      series: {
                        dataLabels: {
                          visible: false
                        }
                      }
                    }
                  });
                }
                /**
                 * Show series data label.
                 * @api
                 * @example
                 * chart.showSeriesDataLabel();
                 */
              }, {
                key: "showSeriesDataLabel",
                value: function showSeriesDataLabel() {
                  this.store.dispatch("updateOptions", {
                    options: {
                      series: {
                        dataLabels: {
                          visible: true
                        }
                      }
                    }
                  });
                }
                /**
                 * Convert the chart options to new options.
                 * @param {Object} options - Chart options.
                 * @api
                 * @example
                 * chart.setOptions({
                 *   chart: {
                 *     width: 500,
                 *     height: 'auto',
                 *     title: 'Energy Usage',
                 *   },
                 *   xAxis: {
                 *     title: 'Month',
                 *     date: { format: 'yy/MM' },
                 *   },
                 *   yAxis: {
                 *     title: 'Energy (kWh)',
                 *   },
                 *   series: {
                 *     selectable: true,
                 *   },
                 *   tooltip: {
                 *     formatter: (value) => `${value}kWh`,
                 *   },
                 * });
                 */
              }, {
                key: "setOptions",
                value: function setOptions(options2) {
                  this.resetSeries();
                  this.dispatchOptionsEvent("initOptions", options2);
                }
                /**
                 * Update chart options.
                 * @param {Object} options - Chart options.
                 * @api
                 * @example
                 * chart.updateOptions({
                 *   chart: {
                 *     height: 'auto',
                 *     title: 'Energy Usage',
                 *   },
                 *   tooltip: {
                 *     formatter: (value) => `${value}kWh`,
                 *   },
                 * });
                 */
              }, {
                key: "updateOptions",
                value: function updateOptions(options2) {
                  this.resetSeries();
                  this.dispatchOptionsEvent("updateOptions", options2);
                }
                /**
                 * Show tooltip.
                 * @param {Object} seriesInfo - Information of the series for the tooltip to be displayed.
                 *      @param {number} seriesInfo.index - Index of data within series. If 'series.eventDetectType' is "grouped", only seriesIndex is needed.
                 *      @param {number} [seriesInfo.seriesIndex] - Index of series.
                 * @api
                 * @example
                 * chart.showTooltip({index: 1, seriesIndex: 2});
                 */
              }, {
                key: "showTooltip",
                value: function showTooltip(seriesInfo) {
                  this.eventBus.emit("showTooltip", lineChart_objectSpread({}, seriesInfo));
                }
                /**
                 * Hide tooltip.
                 * @api
                 * @example
                 * chart.hideTooltip();
                 */
              }, {
                key: "hideTooltip",
                value: function hideTooltip() {
                  this.eventBus.emit("hideTooltip");
                }
              }]);
              return LineChart2;
            }(Chart);
            ;
            function pieSeries_typeof(obj) {
              "@babel/helpers - typeof";
              if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                pieSeries_typeof = function _typeof2(obj2) {
                  return typeof obj2;
                };
              } else {
                pieSeries_typeof = function _typeof2(obj2) {
                  return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                };
              }
              return pieSeries_typeof(obj);
            }
            function pieSeries_ownKeys(object, enumerableOnly) {
              var keys = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object);
                if (enumerableOnly) {
                  symbols = symbols.filter(function(sym) {
                    return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                  });
                }
                keys.push.apply(keys, symbols);
              }
              return keys;
            }
            function pieSeries_objectSpread(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i] != null ? arguments[i] : {};
                if (i % 2) {
                  pieSeries_ownKeys(Object(source), true).forEach(function(key) {
                    pieSeries_defineProperty(target, key, source[key]);
                  });
                } else if (Object.getOwnPropertyDescriptors) {
                  Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                } else {
                  pieSeries_ownKeys(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  });
                }
              }
              return target;
            }
            function pieSeries_classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function pieSeries_defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            function pieSeries_createClass(Constructor, protoProps, staticProps) {
              if (protoProps)
                pieSeries_defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                pieSeries_defineProperties(Constructor, staticProps);
              return Constructor;
            }
            function pieSeries_inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function");
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
              if (superClass)
                pieSeries_setPrototypeOf(subClass, superClass);
            }
            function pieSeries_setPrototypeOf(o, p) {
              pieSeries_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
                o2.__proto__ = p2;
                return o2;
              };
              return pieSeries_setPrototypeOf(o, p);
            }
            function pieSeries_createSuper(Derived) {
              var hasNativeReflectConstruct = pieSeries_isNativeReflectConstruct();
              return function _createSuperInternal() {
                var Super = pieSeries_getPrototypeOf(Derived), result;
                if (hasNativeReflectConstruct) {
                  var NewTarget = pieSeries_getPrototypeOf(this).constructor;
                  result = Reflect.construct(Super, arguments, NewTarget);
                } else {
                  result = Super.apply(this, arguments);
                }
                return pieSeries_possibleConstructorReturn(this, result);
              };
            }
            function pieSeries_possibleConstructorReturn(self2, call) {
              if (call && (pieSeries_typeof(call) === "object" || typeof call === "function")) {
                return call;
              }
              return pieSeries_assertThisInitialized(self2);
            }
            function pieSeries_assertThisInitialized(self2) {
              if (self2 === void 0) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return self2;
            }
            function pieSeries_isNativeReflectConstruct() {
              if (typeof Reflect === "undefined" || !Reflect.construct)
                return false;
              if (Reflect.construct.sham)
                return false;
              if (typeof Proxy === "function")
                return true;
              try {
                Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                }));
                return true;
              } catch (e) {
                return false;
              }
            }
            function pieSeries_getPrototypeOf(o) {
              pieSeries_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
                return o2.__proto__ || Object.getPrototypeOf(o2);
              };
              return pieSeries_getPrototypeOf(o);
            }
            function pieSeries_defineProperty(obj, key, value) {
              if (key in obj) {
                Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
              } else {
                obj[key] = value;
              }
              return obj;
            }
            function getCalculatedRadiusRange(_ref) {
              var alias = _ref.alias, renderOptions = _ref.renderOptions, radiusRangeMap = _ref.radiusRangeMap, pieIndex = _ref.pieIndex, radiusRanges = _ref.radiusRanges, totalPieAliasCount = _ref.totalPieAliasCount;
              var radiusRangeLength = Object.keys(radiusRangeMap).length;
              var _renderOptions$defaul = renderOptions.defaultRadius, defaultRadius = _renderOptions$defaul === void 0 ? 0 : _renderOptions$defaul;
              var _renderOptions$radius = renderOptions.radiusRange, inner = _renderOptions$radius.inner, outer = _renderOptions$radius.outer;
              if (!radiusRangeMap[alias]) {
                if (!radiusRangeLength) {
                  var radius = defaultRadius / totalPieAliasCount;
                  inner = pieIndex * radius;
                  outer = (pieIndex + 1) * radius;
                } else {
                  var _radiusRanges;
                  if (pieIndex && radiusRanges[pieIndex - 1].outer) {
                    inner = radiusRanges[pieIndex - 1].outer;
                  }
                  if ((_radiusRanges = radiusRanges[pieIndex + 1]) !== null && _radiusRanges !== void 0 && _radiusRanges.inner) {
                    outer = radiusRanges[pieIndex + 1].inner;
                  } else if (pieIndex === totalPieAliasCount - 1) {
                    outer = defaultRadius;
                  } else {
                    var _radiusRanges$outer, _radiusRanges2, _radiusRanges$inner, _radiusRanges3;
                    var _radius = (defaultRadius - ((_radiusRanges$outer = (_radiusRanges2 = radiusRanges[pieIndex - 1]) === null || _radiusRanges2 === void 0 ? void 0 : _radiusRanges2.outer) !== null && _radiusRanges$outer !== void 0 ? _radiusRanges$outer : 0) - ((_radiusRanges$inner = (_radiusRanges3 = radiusRanges[pieIndex + 1]) === null || _radiusRanges3 === void 0 ? void 0 : _radiusRanges3.inner) !== null && _radiusRanges$inner !== void 0 ? _radiusRanges$inner : 0)) / (totalPieAliasCount - radiusRangeLength);
                    outer = inner + _radius;
                  }
                }
              }
              return {
                inner,
                outer
              };
            }
            function getPieSeriesOpacityByDepth(originAlpha, depth, indexOfGroup) {
              var brightness = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0.85;
              var depthAlpha = Number((originAlpha * Math.pow(brightness, depth)).toFixed(2));
              return Number(Math.pow(depthAlpha, indexOfGroup + 1).toFixed(2));
            }
            function getMaxDataLabelSize(seriesNameLabels, options2, dataLabelTheme) {
              var _options$pieSeriesNam, _options$pieSeriesNam2;
              var outerLabels = [{
                hasOuterLabel: options2.visible && options2.anchor === "outer",
                labels: ["00.00%"],
                // up to 5 digits
                theme: dataLabelTheme
              }, {
                hasOuterLabel: ((_options$pieSeriesNam = options2.pieSeriesName) === null || _options$pieSeriesNam === void 0 ? void 0 : _options$pieSeriesNam.visible) && ((_options$pieSeriesNam2 = options2.pieSeriesName) === null || _options$pieSeriesNam2 === void 0 ? void 0 : _options$pieSeriesNam2.anchor) === "outer",
                labels: seriesNameLabels,
                theme: dataLabelTheme.pieSeriesName
              }];
              return outerLabels.reduce(function(acc, cur) {
                var width = acc.width, height = acc.height;
                var hasOuterLabel = cur.hasOuterLabel, labels = cur.labels, theme2 = cur.theme;
                if (hasOuterLabel) {
                  var _getMaxLabelSize = getMaxLabelSize(labels, 0, getFont(theme2)), maxLabelWidth = _getMaxLabelSize.maxLabelWidth, maxLabelHeight = _getMaxLabelSize.maxLabelHeight;
                  return {
                    width: Math.max(maxLabelWidth + RADIUS_PADDING, width),
                    height: Math.max(maxLabelHeight + RADIUS_PADDING, height)
                  };
                }
                return acc;
              }, {
                width: 0,
                height: 0
              });
            }
            var PieSeries = function(_Component) {
              pieSeries_inherits(PieSeries2, _Component);
              var _super = pieSeries_createSuper(PieSeries2);
              function PieSeries2() {
                var _this;
                pieSeries_classCallCheck(this, PieSeries2);
                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }
                _this = _super.call.apply(_super, [this].concat(args));
                pieSeries_defineProperty(pieSeries_assertThisInitialized(_this), "models", {
                  series: []
                });
                pieSeries_defineProperty(pieSeries_assertThisInitialized(_this), "drawModels", void 0);
                pieSeries_defineProperty(pieSeries_assertThisInitialized(_this), "responders", void 0);
                pieSeries_defineProperty(pieSeries_assertThisInitialized(_this), "activatedResponders", []);
                pieSeries_defineProperty(pieSeries_assertThisInitialized(_this), "alias", void 0);
                pieSeries_defineProperty(pieSeries_assertThisInitialized(_this), "theme", void 0);
                pieSeries_defineProperty(pieSeries_assertThisInitialized(_this), "onMouseoutComponent", function() {
                  _this.eventBus.emit("seriesPointHovered", {
                    models: [],
                    name: _this.alias || _this.name
                  });
                  _this.eventBus.emit("renderHoveredSeries", {
                    models: [],
                    name: _this.alias || _this.name
                  });
                  _this.eventBus.emit("needDraw");
                });
                pieSeries_defineProperty(pieSeries_assertThisInitialized(_this), "selectSeries", function(_ref2) {
                  var seriesIndex = _ref2.seriesIndex, name = _ref2.name;
                  if (!isNumber(seriesIndex) || !isUndefined(name) && name !== _this.alias) {
                    return;
                  }
                  var model = _this.responders[seriesIndex];
                  if (!model) {
                    throw new Error(message.SELECT_SERIES_API_INDEX_ERROR);
                  }
                  _this.eventBus.emit("renderSelectedSeries", {
                    models: _this.getResponderModelsWithTheme([model], "select"),
                    name: _this.name,
                    alias: _this.alias
                  });
                  _this.eventBus.emit("needDraw");
                });
                pieSeries_defineProperty(pieSeries_assertThisInitialized(_this), "showTooltip", function(_ref3) {
                  var seriesIndex = _ref3.seriesIndex, name = _ref3.name;
                  if (!isNumber(seriesIndex) || !isUndefined(name) && name !== _this.alias) {
                    return;
                  }
                  var models = [_this.responders[seriesIndex]];
                  if (!models.length) {
                    return;
                  }
                  _this.eventBus.emit("renderHoveredSeries", {
                    models: _this.getResponderModelsWithTheme(models, "hover"),
                    name: _this.name,
                    alias: _this.alias
                  });
                  _this.activatedResponders = _this.makeTooltipResponder(models);
                  _this.eventBus.emit("seriesPointHovered", {
                    models: _this.activatedResponders,
                    name: _this.alias || _this.name
                  });
                  _this.eventBus.emit("needDraw");
                });
                return _this;
              }
              pieSeries_createClass(PieSeries2, [{
                key: "initUpdate",
                value: function initUpdate(delta) {
                  if (!this.drawModels) {
                    return;
                  }
                  var currentDegree;
                  var index = this.models.series.findIndex(function(_ref4) {
                    var clockwise = _ref4.clockwise, _ref4$degree = _ref4.degree, start = _ref4$degree.start, end = _ref4$degree.end, totalAngle = _ref4.totalAngle;
                    currentDegree = clockwise ? totalAngle * delta : DEGREE_360 - totalAngle * delta;
                    return withinRadian(clockwise, start, end, currentDegree);
                  });
                  this.syncEndAngle(index < 0 ? this.models.series.length : index);
                  if (~index) {
                    this.drawModels.series[index].degree.end = currentDegree;
                  }
                }
              }, {
                key: "syncEndAngle",
                value: function syncEndAngle(index) {
                  if (index < 1) {
                    return;
                  }
                  for (var i = 0; i < index; i += 1) {
                    var prevTargetEndDegree = this.models.series[i].degree.end;
                    if (this.drawModels.series[i].degree.end !== prevTargetEndDegree) {
                      this.drawModels.series[i].degree.end = prevTargetEndDegree;
                    }
                  }
                }
              }, {
                key: "initialize",
                value: function initialize(param) {
                  var _param$alias;
                  this.type = "series";
                  this.name = "pie";
                  this.alias = (_param$alias = param === null || param === void 0 ? void 0 : param.alias) !== null && _param$alias !== void 0 ? _param$alias : "";
                  this.eventBus.on("selectSeries", this.selectSeries);
                  this.eventBus.on("showTooltip", this.showTooltip);
                  this.eventBus.on("hideTooltip", this.onMouseoutComponent);
                }
              }, {
                key: "render",
                value: function render(chartState) {
                  var _ref5, _this2 = this;
                  var layout2 = chartState.layout, series = chartState.series, legend2 = chartState.legend, options2 = chartState.options, nestedPieSeries = chartState.nestedPieSeries, theme2 = chartState.theme;
                  var categories = (_ref5 = chartState.categories) !== null && _ref5 !== void 0 ? _ref5 : [];
                  if (!series.pie) {
                    throw new Error(message.noDataError(this.name));
                  }
                  var pieTheme = theme2.series.pie;
                  this.theme = this.alias ? pieTheme[this.alias] : pieTheme;
                  this.rect = layout2.plot;
                  this.activeSeriesMap = getActiveSeriesMap(legend2);
                  this.selectable = this.getSelectableOption(options2);
                  var seriesModel, tooltipDataModel;
                  var dataLabelsOptions = getDataLabelsOptions(options2, this.alias);
                  if (nestedPieSeries) {
                    var data = nestedPieSeries[this.alias].data;
                    var pieAlias = Object.keys(nestedPieSeries);
                    var pieIndex = pieAlias.findIndex(function(alias) {
                      return alias === _this2.alias;
                    });
                    var lastAlias = last(pieAlias);
                    var lastSeries = nestedPieSeries[lastAlias];
                    var maxPieDataLabelSize = getMaxDataLabelSize(lastSeries.data.map(function(_ref6) {
                      var name = _ref6.name;
                      return name;
                    }), getDataLabelsOptions(options2, lastAlias), this.theme.dataLabels);
                    var renderOptionsMap = this.getRenderOptionsMap(options2, pieAlias, maxPieDataLabelSize);
                    seriesModel = this.renderPieModel(data, renderOptionsMap[this.alias], pieIndex);
                    tooltipDataModel = makePieTooltipData(data, categories === null || categories === void 0 ? void 0 : categories[pieIndex]);
                  } else {
                    var _series$pie;
                    var pieData = (_series$pie = series.pie) === null || _series$pie === void 0 ? void 0 : _series$pie.data;
                    var _getMaxDataLabelSize = getMaxDataLabelSize(pieData.map(function(_ref7) {
                      var name = _ref7.name;
                      return name;
                    }), dataLabelsOptions, this.theme.dataLabels), width = _getMaxDataLabelSize.width, height = _getMaxDataLabelSize.height;
                    var renderOptions = this.makeRenderOptions(options2, width, height);
                    seriesModel = this.renderPieModel(pieData, renderOptions);
                    tooltipDataModel = makePieTooltipData(pieData, categories === null || categories === void 0 ? void 0 : categories[0]);
                  }
                  this.models.series = seriesModel;
                  if (!this.drawModels) {
                    this.drawModels = {
                      series: this.models.series.map(function(m) {
                        return pieSeries_objectSpread(pieSeries_objectSpread({}, m), {}, {
                          degree: pieSeries_objectSpread(pieSeries_objectSpread({}, m.degree), {}, {
                            end: m.degree.start
                          })
                        });
                      })
                    };
                  }
                  if (dataLabelsOptions.visible) {
                    var dataLabelData = seriesModel.map(function(m) {
                      return pieSeries_objectSpread(pieSeries_objectSpread({}, m), {}, {
                        value: "".concat(pieTooltipLabelFormatter(m.percentValue)),
                        theme: _this2.theme.dataLabels
                      });
                    });
                    this.renderDataLabels(dataLabelData, this.alias);
                  }
                  this.responders = seriesModel.map(function(m, index) {
                    return pieSeries_objectSpread(pieSeries_objectSpread({}, m), {}, {
                      type: "sector",
                      radius: m.radius,
                      seriesIndex: index,
                      data: pieSeries_objectSpread(pieSeries_objectSpread({}, tooltipDataModel[index]), {}, {
                        percentValue: m.percentValue
                      }),
                      color: getRGBA(m.color, 1)
                    });
                  });
                }
              }, {
                key: "getRadiusRangeMap",
                value: function getRadiusRangeMap(options2, pieAlias) {
                  var _this3 = this;
                  return pieAlias.reduce(function(acc, alias) {
                    var seriesOptions = _this3.getOptions(options2, alias).series;
                    if (seriesOptions !== null && seriesOptions !== void 0 && seriesOptions.radiusRange) {
                      acc[alias] = seriesOptions === null || seriesOptions === void 0 ? void 0 : seriesOptions.radiusRange;
                    }
                    return acc;
                  }, {});
                }
              }, {
                key: "getRenderOptionsMap",
                value: function getRenderOptionsMap(options2, pieAlias, maxPieDataLabelSize) {
                  var renderOptionsMap = this.initRenderOptionsMap(options2, pieAlias, maxPieDataLabelSize);
                  var radiusRangeMap = this.getRadiusRangeMap(options2, pieAlias);
                  pieAlias.forEach(function(alias, pieIndex) {
                    var radiusRanges = Object.values(renderOptionsMap).map(function(_ref8) {
                      var radiusRange = _ref8.radiusRange;
                      return radiusRange;
                    });
                    renderOptionsMap[alias].radiusRange = getCalculatedRadiusRange({
                      alias,
                      renderOptions: renderOptionsMap[alias],
                      radiusRangeMap,
                      pieIndex,
                      radiusRanges,
                      totalPieAliasCount: pieAlias.length
                    });
                  });
                  return renderOptionsMap;
                }
              }, {
                key: "initRenderOptionsMap",
                value: function initRenderOptionsMap(options2, pieAlias, _ref9) {
                  var _this4 = this;
                  var width = _ref9.width, height = _ref9.height;
                  return pieAlias.reduce(function(acc, alias) {
                    return pieSeries_objectSpread(pieSeries_objectSpread({}, acc), {}, pieSeries_defineProperty({}, alias, _this4.makeRenderOptions(_this4.getOptions(options2, alias), width, height)));
                  }, {});
                }
              }, {
                key: "getOptions",
                value: function getOptions(chartOptions, alias) {
                  var options2 = pieSeries_objectSpread({}, chartOptions);
                  if (options2 !== null && options2 !== void 0 && options2.series && alias) {
                    options2.series = pieSeries_objectSpread(pieSeries_objectSpread({}, options2.series), options2.series[alias]);
                  }
                  return options2;
                }
              }, {
                key: "makeRenderOptions",
                value: function makeRenderOptions(options2) {
                  var _seriesOptions$clockw, _seriesOptions$angleR, _seriesOptions$angleR2, _seriesOptions$angleR3, _seriesOptions$angleR4, _seriesOptions$radius, _seriesOptions$radius2, _seriesOptions$radius3, _seriesOptions$radius4;
                  var maxDataLabelWidth = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
                  var maxDataLabelHeight = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
                  var seriesOptions = options2.series;
                  var clockwise = (_seriesOptions$clockw = seriesOptions === null || seriesOptions === void 0 ? void 0 : seriesOptions.clockwise) !== null && _seriesOptions$clockw !== void 0 ? _seriesOptions$clockw : true;
                  var startAngle = (_seriesOptions$angleR = seriesOptions === null || seriesOptions === void 0 ? void 0 : (_seriesOptions$angleR2 = seriesOptions.angleRange) === null || _seriesOptions$angleR2 === void 0 ? void 0 : _seriesOptions$angleR2.start) !== null && _seriesOptions$angleR !== void 0 ? _seriesOptions$angleR : DEGREE_0;
                  var endAngle = (_seriesOptions$angleR3 = seriesOptions === null || seriesOptions === void 0 ? void 0 : (_seriesOptions$angleR4 = seriesOptions.angleRange) === null || _seriesOptions$angleR4 === void 0 ? void 0 : _seriesOptions$angleR4.end) !== null && _seriesOptions$angleR3 !== void 0 ? _seriesOptions$angleR3 : DEGREE_360;
                  var totalAngle = getTotalAngle(clockwise, startAngle, endAngle);
                  var isSemiCircular = isSemiCircle(clockwise, startAngle, endAngle);
                  var _this$rect = this.rect, width = _this$rect.width, height = _this$rect.height;
                  var defaultRadius = getDefaultRadius(this.rect, isSemiCircular, maxDataLabelWidth, maxDataLabelHeight);
                  var innerRadius = calculateSizeWithPercentString(defaultRadius, (_seriesOptions$radius = seriesOptions === null || seriesOptions === void 0 ? void 0 : (_seriesOptions$radius2 = seriesOptions.radiusRange) === null || _seriesOptions$radius2 === void 0 ? void 0 : _seriesOptions$radius2.inner) !== null && _seriesOptions$radius !== void 0 ? _seriesOptions$radius : 0);
                  var outerRadius = calculateSizeWithPercentString(defaultRadius, (_seriesOptions$radius3 = seriesOptions === null || seriesOptions === void 0 ? void 0 : (_seriesOptions$radius4 = seriesOptions.radiusRange) === null || _seriesOptions$radius4 === void 0 ? void 0 : _seriesOptions$radius4.outer) !== null && _seriesOptions$radius3 !== void 0 ? _seriesOptions$radius3 : this.alias ? 0 : defaultRadius);
                  var cx = width / 2;
                  var cy = isSemiCircular ? getSemiCircleCenterY(this.rect.height, clockwise) : height / 2;
                  return {
                    clockwise,
                    cx,
                    cy,
                    drawingStartAngle: startAngle - DEGREE_90,
                    radiusRange: {
                      inner: innerRadius,
                      outer: outerRadius
                    },
                    angleRange: {
                      start: startAngle,
                      end: endAngle
                    },
                    totalAngle,
                    defaultRadius
                  };
                }
              }, {
                key: "renderPieModel",
                value: function renderPieModel(seriesRawData, renderOptions, pieIndex) {
                  var _this5 = this;
                  var sectorModels = [];
                  var total = seriesRawData.reduce(function(sum2, _ref10) {
                    var data = _ref10.data;
                    return sum2 + (data !== null && data !== void 0 ? data : 0);
                  }, 0);
                  var clockwise = renderOptions.clockwise, cx = renderOptions.cx, cy = renderOptions.cy, drawingStartAngle = renderOptions.drawingStartAngle, _renderOptions$radius2 = renderOptions.radiusRange, inner = _renderOptions$radius2.inner, outer = _renderOptions$radius2.outer, totalAngle = renderOptions.totalAngle;
                  var defaultStartDegree = clockwise ? DEGREE_0 : DEGREE_360;
                  var _this$theme = this.theme, lineWidth = _this$theme.lineWidth, strokeStyle = _this$theme.strokeStyle;
                  seriesRawData.forEach(function(rawData, seriesIndex) {
                    var color = _this5.alias ? _this5.getAliasSeriesColor(rawData, seriesRawData, pieIndex) : _this5.getSeriesColor(rawData);
                    var data = rawData.data, name = rawData.name;
                    if (data) {
                      var degree = Math.max(data / total * totalAngle, 1) * (clockwise ? 1 : -1);
                      var percentValue = data / total * 100;
                      var prevModel = sectorModels[sectorModels.length - 1];
                      var startDegree = seriesIndex && prevModel ? prevModel.degree.end : defaultStartDegree;
                      var endDegree = clockwise ? Math.min(startDegree + degree, DEGREE_360) : Math.max(startDegree + degree, DEGREE_0);
                      sectorModels.push({
                        type: "sector",
                        name,
                        color,
                        x: cx,
                        y: cy,
                        degree: {
                          start: startDegree,
                          end: endDegree
                        },
                        radius: {
                          inner,
                          outer
                        },
                        value: data,
                        style: [{
                          strokeStyle
                        }],
                        lineWidth,
                        clockwise,
                        drawingStartAngle,
                        totalAngle,
                        percentValue
                      });
                    }
                  });
                  return sectorModels;
                }
              }, {
                key: "makeTooltipResponder",
                value: function makeTooltipResponder(responders) {
                  var _this6 = this;
                  return responders.map(function(responder) {
                    return pieSeries_objectSpread(pieSeries_objectSpread({}, responder), getRadialAnchorPosition(makeAnchorPositionParam("center", _this6.models.series[responder.seriesIndex])));
                  });
                }
              }, {
                key: "onMousemove",
                value: function onMousemove(_ref11) {
                  var responders = _ref11.responders;
                  this.eventBus.emit("renderHoveredSeries", {
                    models: this.getResponderModelsWithTheme(responders, "hover"),
                    name: this.alias || this.name
                  });
                  this.activatedResponders = this.makeTooltipResponder(responders);
                  this.eventBus.emit("seriesPointHovered", {
                    models: this.activatedResponders,
                    name: this.alias || this.name
                  });
                  this.eventBus.emit("needDraw");
                }
              }, {
                key: "onClick",
                value: function onClick(_ref12) {
                  var responders = _ref12.responders;
                  if (this.selectable) {
                    this.eventBus.emit("renderSelectedSeries", {
                      models: this.getResponderModelsWithTheme(responders, "select"),
                      name: this.name,
                      alias: this.alias
                    });
                    this.eventBus.emit("needDraw");
                  }
                }
              }, {
                key: "getResponderModelsWithTheme",
                value: function getResponderModelsWithTheme(responders, type) {
                  var theme2 = this.theme[type];
                  var lineWidth = theme2.lineWidth;
                  var isSameLineWidth = this.theme.lineWidth === lineWidth;
                  var thickness = isSameLineWidth ? 0 : lineWidth * 0.5;
                  return responders.map(function(m) {
                    var _theme$color;
                    return pieSeries_objectSpread(pieSeries_objectSpread({}, m), {}, {
                      color: (_theme$color = theme2 === null || theme2 === void 0 ? void 0 : theme2.color) !== null && _theme$color !== void 0 ? _theme$color : m.color,
                      lineWidth,
                      style: [pick(theme2, "strokeStyle", "shadowBlur", "shadowColor", "shadowOffsetX", "shadowOffsetY")],
                      radius: {
                        inner: Math.max(m.radius.inner - thickness, 0),
                        outer: m.radius.outer + thickness
                      }
                    });
                  });
                }
              }, {
                key: "getOpacity",
                value: function getOpacity(active, selectedState) {
                  var _this$theme2 = this.theme, select = _this$theme2.select, areaOpacity = _this$theme2.areaOpacity;
                  var _ref13 = select, selectedAreaOpacity = _ref13.areaOpacity, restAreaOpacity = _ref13.restSeries.areaOpacity;
                  var selectThemeOpacity = active ? selectedAreaOpacity : restAreaOpacity;
                  return selectedState ? selectThemeOpacity : areaOpacity;
                }
              }, {
                key: "getIndexOfGroup",
                value: function getIndexOfGroup(seriesRawData, parentName, name) {
                  return seriesRawData.filter(function(datum) {
                    return parentName === datum.parentName;
                  }).findIndex(function(datum) {
                    return name === datum.name;
                  });
                }
              }, {
                key: "getSeriesColor",
                value: function getSeriesColor(rawData) {
                  var color = rawData.color, name = rawData.name;
                  var active = this.activeSeriesMap[name];
                  var opacity = this.getOpacity(active, this.hasActiveSeries());
                  return getRGBA(color, opacity);
                }
              }, {
                key: "getAliasSeriesColor",
                value: function getAliasSeriesColor(rawData, seriesRawData, pieIndex) {
                  var color = rawData.color, name = rawData.name;
                  var selectedColor = this.theme.select.color;
                  var rootParentName = rawData.rootParentName, parentName = rawData.parentName;
                  var indexOfGroup = this.getIndexOfGroup(seriesRawData, parentName, name);
                  var opacity = this.getAliasSeriesOpacity(rootParentName, parentName, pieIndex, indexOfGroup, name);
                  var active = this.activeSeriesMap[rootParentName !== null && rootParentName !== void 0 ? rootParentName : name];
                  var seriesColor = active ? selectedColor !== null && selectedColor !== void 0 ? selectedColor : color : color;
                  return getRGBA(seriesColor, opacity);
                }
              }, {
                key: "getAliasSeriesOpacity",
                value: function getAliasSeriesOpacity(rootParentName, parentName, pieIndex, indexOfGroup, name) {
                  var active = this.activeSeriesMap[rootParentName !== null && rootParentName !== void 0 ? rootParentName : name];
                  var opacity = this.getOpacity(active, this.hasActiveSeries());
                  return pieIndex && parentName ? getPieSeriesOpacityByDepth(opacity, pieIndex, indexOfGroup) : opacity;
                }
              }, {
                key: "hasActiveSeries",
                value: function hasActiveSeries() {
                  return Object.values(this.activeSeriesMap).some(function(elem) {
                    return !elem;
                  });
                }
              }]);
              return PieSeries2;
            }(Component);
            ;
            function sector(ctx2, sectorModel) {
              var _sectorModel$degree = sectorModel.degree, start = _sectorModel$degree.start, end = _sectorModel$degree.end, color = sectorModel.color, style = sectorModel.style, lineWidth = sectorModel.lineWidth;
              if (start === end) {
                return;
              }
              var isCircle = Math.abs(start - end) === DEGREE_360;
              ctx2.beginPath();
              if (style) {
                var styleObj = makeStyleObj(style, {});
                Object.keys(styleObj).forEach(function(key) {
                  ctx2[key] = styleObj[key];
                });
              }
              if (isCircle) {
                drawCircle(ctx2, sectorModel);
              } else {
                drawSector(ctx2, sectorModel);
              }
              ctx2.closePath();
              fillStyle(ctx2, color);
              if (lineWidth) {
                ctx2.lineWidth = lineWidth;
                ctx2.stroke();
              }
            }
            function drawSector(ctx2, sectorModel) {
              var x = sectorModel.x, y = sectorModel.y, _sectorModel$radius = sectorModel.radius, inner = _sectorModel$radius.inner, outer = _sectorModel$radius.outer, _sectorModel$degree2 = sectorModel.degree, start = _sectorModel$degree2.start, end = _sectorModel$degree2.end, clockwise = sectorModel.clockwise, drawingStartAngle = sectorModel.drawingStartAngle;
              if (inner < 0 || outer < 0) {
                return;
              }
              var startRadian = calculateDegreeToRadian(start, drawingStartAngle);
              var endRadian = calculateDegreeToRadian(end, drawingStartAngle);
              if (!inner) {
                ctx2.moveTo(x, y);
              }
              ctx2.arc(x, y, outer, startRadian, endRadian, !clockwise);
              if (inner) {
                ctx2.arc(x, y, inner, endRadian, startRadian, clockwise);
              }
            }
            function drawCircle(ctx2, sectorModel) {
              var x = sectorModel.x, y = sectorModel.y, _sectorModel$radius2 = sectorModel.radius, inner = _sectorModel$radius2.inner, outer = _sectorModel$radius2.outer, clockwise = sectorModel.clockwise;
              ctx2.arc(x, y, outer, 0, 2 * Math.PI, !clockwise);
              if (inner) {
                var _getRadialPosition = getRadialPosition(x, y, inner, 0), innerStartPosX = _getRadialPosition.x, innerStartPosY = _getRadialPosition.y;
                var startX = inner ? innerStartPosX : x;
                var startY = inner ? innerStartPosY : y;
                ctx2.moveTo(startX, startY);
                ctx2.arc(x, y, inner, 0, 2 * Math.PI, clockwise);
              }
            }
            ;
            function pieChart_typeof(obj) {
              "@babel/helpers - typeof";
              if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                pieChart_typeof = function _typeof2(obj2) {
                  return typeof obj2;
                };
              } else {
                pieChart_typeof = function _typeof2(obj2) {
                  return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                };
              }
              return pieChart_typeof(obj);
            }
            function pieChart_ownKeys(object, enumerableOnly) {
              var keys = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object);
                if (enumerableOnly) {
                  symbols = symbols.filter(function(sym) {
                    return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                  });
                }
                keys.push.apply(keys, symbols);
              }
              return keys;
            }
            function pieChart_objectSpread(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i] != null ? arguments[i] : {};
                if (i % 2) {
                  pieChart_ownKeys(Object(source), true).forEach(function(key) {
                    pieChart_defineProperty(target, key, source[key]);
                  });
                } else if (Object.getOwnPropertyDescriptors) {
                  Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                } else {
                  pieChart_ownKeys(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  });
                }
              }
              return target;
            }
            function pieChart_defineProperty(obj, key, value) {
              if (key in obj) {
                Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
              } else {
                obj[key] = value;
              }
              return obj;
            }
            function pieChart_classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function pieChart_defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            function pieChart_createClass(Constructor, protoProps, staticProps) {
              if (protoProps)
                pieChart_defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                pieChart_defineProperties(Constructor, staticProps);
              return Constructor;
            }
            function pieChart_get(target, property, receiver) {
              if (typeof Reflect !== "undefined" && Reflect.get) {
                pieChart_get = Reflect.get;
              } else {
                pieChart_get = function _get2(target2, property2, receiver2) {
                  var base = pieChart_superPropBase(target2, property2);
                  if (!base)
                    return;
                  var desc = Object.getOwnPropertyDescriptor(base, property2);
                  if (desc.get) {
                    return desc.get.call(receiver2);
                  }
                  return desc.value;
                };
              }
              return pieChart_get(target, property, receiver || target);
            }
            function pieChart_superPropBase(object, property) {
              while (!Object.prototype.hasOwnProperty.call(object, property)) {
                object = pieChart_getPrototypeOf(object);
                if (object === null)
                  break;
              }
              return object;
            }
            function pieChart_inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function");
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
              if (superClass)
                pieChart_setPrototypeOf(subClass, superClass);
            }
            function pieChart_setPrototypeOf(o, p) {
              pieChart_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
                o2.__proto__ = p2;
                return o2;
              };
              return pieChart_setPrototypeOf(o, p);
            }
            function pieChart_createSuper(Derived) {
              var hasNativeReflectConstruct = pieChart_isNativeReflectConstruct();
              return function _createSuperInternal() {
                var Super = pieChart_getPrototypeOf(Derived), result;
                if (hasNativeReflectConstruct) {
                  var NewTarget = pieChart_getPrototypeOf(this).constructor;
                  result = Reflect.construct(Super, arguments, NewTarget);
                } else {
                  result = Super.apply(this, arguments);
                }
                return pieChart_possibleConstructorReturn(this, result);
              };
            }
            function pieChart_possibleConstructorReturn(self2, call) {
              if (call && (pieChart_typeof(call) === "object" || typeof call === "function")) {
                return call;
              }
              return pieChart_assertThisInitialized(self2);
            }
            function pieChart_assertThisInitialized(self2) {
              if (self2 === void 0) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return self2;
            }
            function pieChart_isNativeReflectConstruct() {
              if (typeof Reflect === "undefined" || !Reflect.construct)
                return false;
              if (Reflect.construct.sham)
                return false;
              if (typeof Proxy === "function")
                return true;
              try {
                Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                }));
                return true;
              } catch (e) {
                return false;
              }
            }
            function pieChart_getPrototypeOf(o) {
              pieChart_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
                return o2.__proto__ || Object.getPrototypeOf(o2);
              };
              return pieChart_getPrototypeOf(o);
            }
            var PieChart = function(_Chart) {
              pieChart_inherits(PieChart2, _Chart);
              var _super = pieChart_createSuper(PieChart2);
              function PieChart2(_ref) {
                var el = _ref.el, options2 = _ref.options, data = _ref.data;
                pieChart_classCallCheck(this, PieChart2);
                return _super.call(this, {
                  el,
                  options: options2,
                  series: {
                    pie: data.series
                  },
                  categories: data.categories
                });
              }
              pieChart_createClass(PieChart2, [{
                key: "initialize",
                value: function initialize() {
                  pieChart_get(pieChart_getPrototypeOf(PieChart2.prototype), "initialize", this).call(this);
                  this.componentManager.add(Background);
                  this.componentManager.add(Title);
                  this.componentManager.add(Legend);
                  this.componentManager.add(PieSeries);
                  this.componentManager.add(ExportMenu, {
                    chartEl: this.el
                  });
                  this.componentManager.add(HoveredSeries);
                  this.componentManager.add(SelectedSeries);
                  this.componentManager.add(DataLabels);
                  this.componentManager.add(Tooltip, {
                    chartEl: this.el
                  });
                  this.componentManager.add(NoDataText);
                  this.painter.addGroups([basic_namespaceObject, legend_namespaceObject, label_namespaceObject, brushes_exportMenu_namespaceObject, brushes_sector_namespaceObject, dataLabel_namespaceObject]);
                }
                /**
                 * Add series.
                 * @param {Object} data - Data to be added.
                 *   @param {string} data.name - Series name.
                 *   @param {Array<Object>} data.data - Array of data to be added.
                 * @api
                 * @example
                 * chart.addSeries({
                 *   name: 'newSeries',
                 *   data: 10,
                 * });
                 */
              }, {
                key: "addSeries",
                value: function addSeries(data) {
                  this.resetSeries();
                  this.store.dispatch("addSeries", {
                    data
                  });
                }
                /**
                 * Convert the chart data to new data.
                 * @param {Object} data - Data to be set.
                 * @api
                 * @example
                 * chart.setData({
                 *   categories: ['A'],
                 *   series: [
                 *     {name: 'a', data: 10},
                 *     {name: 'b', data: 20},
                 *   ]
                 * });
                 */
              }, {
                key: "setData",
                value: function setData(data) {
                  var categories = data.categories, series = data.series;
                  this.resetSeries();
                  this.store.dispatch("setData", {
                    series: {
                      pie: series
                    },
                    categories
                  });
                }
                /**
                 * Hide series data label.
                 * @api
                 * @example
                 * chart.hideSeriesDataLabel();
                 */
              }, {
                key: "hideSeriesDataLabel",
                value: function hideSeriesDataLabel() {
                  this.store.dispatch("updateOptions", {
                    options: {
                      series: {
                        dataLabels: {
                          visible: false
                        }
                      }
                    }
                  });
                }
                /**
                 * Show series data label.
                 * @api
                 * @example
                 * chart.showSeriesDataLabel();
                 */
              }, {
                key: "showSeriesDataLabel",
                value: function showSeriesDataLabel() {
                  this.store.dispatch("updateOptions", {
                    options: {
                      series: {
                        dataLabels: {
                          visible: true
                        }
                      }
                    }
                  });
                }
                /**
                 * Convert the chart options to new options.
                 * @param {Object} options - Chart options.
                 * @api
                 * @example
                 * chart.setOptions({
                 *   chart: {
                 *     width: 500,
                 *     height: 'auto',
                 *     title: 'Energy Usage',
                 *   },
                 *   series: {
                 *     selectable: true,
                 *   },
                 *   tooltip: {
                 *     formatter: (value) => `${value}kWh`,
                 *   },
                 * });
                 */
              }, {
                key: "setOptions",
                value: function setOptions(options2) {
                  this.resetSeries();
                  this.dispatchOptionsEvent("initOptions", options2);
                }
                /**
                 * Update chart options.
                 * @param {Object} options - Chart options.
                 * @api
                 * @example
                 * chart.updateOptions({
                 *   chart: {
                 *     height: 'auto',
                 *     title: 'Energy Usage',
                 *   },
                 *   tooltip: {
                 *     formatter: (value) => `${value}kWh`,
                 *   },
                 * });
                 */
              }, {
                key: "updateOptions",
                value: function updateOptions(options2) {
                  this.resetSeries();
                  this.dispatchOptionsEvent("updateOptions", options2);
                }
                /**
                 * Show tooltip.
                 * @param {Object} seriesInfo - Information of the series for the tooltip to be displayed.
                 *      @param {number} seriesInfo.seriesIndex - Index of series.
                 *      @param {number} seriesInfo.alias - alias name.
                 * @api
                 * @example
                 * chart.showTooltip({seriesIndex: 1, alias: 'name'});
                 */
              }, {
                key: "showTooltip",
                value: function showTooltip(seriesInfo) {
                  this.eventBus.emit("showTooltip", pieChart_objectSpread(pieChart_objectSpread({}, seriesInfo), {}, {
                    state: this.store.state
                  }));
                }
                /**
                 * Hide tooltip.
                 * @api
                 * @example
                 * chart.hideTooltip();
                 */
              }, {
                key: "hideTooltip",
                value: function hideTooltip() {
                  this.eventBus.emit("hideTooltip");
                }
              }]);
              return PieChart2;
            }(Chart);
            ;
            function heatmapAxes_ownKeys(object, enumerableOnly) {
              var keys = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object);
                if (enumerableOnly) {
                  symbols = symbols.filter(function(sym) {
                    return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                  });
                }
                keys.push.apply(keys, symbols);
              }
              return keys;
            }
            function heatmapAxes_objectSpread(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i] != null ? arguments[i] : {};
                if (i % 2) {
                  heatmapAxes_ownKeys(Object(source), true).forEach(function(key) {
                    heatmapAxes_defineProperty(target, key, source[key]);
                  });
                } else if (Object.getOwnPropertyDescriptors) {
                  Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                } else {
                  heatmapAxes_ownKeys(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  });
                }
              }
              return target;
            }
            function heatmapAxes_defineProperty(obj, key, value) {
              if (key in obj) {
                Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
              } else {
                obj[key] = value;
              }
              return obj;
            }
            function getHeatmapAxisData(stateProp, axisType) {
              var _options$axisType$tic, _options$axisType, _options$axisType$tic2, _options$axisType$lab, _options$axisType2, _options$axisType2$la, _options$axisType3;
              var categories = stateProp.categories, axisSize = stateProp.axisSize, axisLayout = stateProp.axisLayout, options2 = stateProp.options, theme2 = stateProp.theme;
              var isLabelAxis = axisType === AxisType.X;
              var axisName = isLabelAxis ? "x" : "y";
              var dateType = isDateType(options2, axisType);
              var labels = getLabelsAppliedFormatter(categories[axisName], options2, dateType, axisType);
              var tickIntervalCount = labels.length;
              var tickDistance = tickIntervalCount ? axisSize / tickIntervalCount : axisSize;
              var labelDistance = axisSize / tickIntervalCount;
              var pointOnColumn = true;
              var tickCount = tickIntervalCount + 1;
              var tickInterval = (_options$axisType$tic = (_options$axisType = options2[axisType]) === null || _options$axisType === void 0 ? void 0 : (_options$axisType$tic2 = _options$axisType.tick) === null || _options$axisType$tic2 === void 0 ? void 0 : _options$axisType$tic2.interval) !== null && _options$axisType$tic !== void 0 ? _options$axisType$tic : 1;
              var labelInterval = (_options$axisType$lab = (_options$axisType2 = options2[axisType]) === null || _options$axisType2 === void 0 ? void 0 : (_options$axisType2$la = _options$axisType2.label) === null || _options$axisType2$la === void 0 ? void 0 : _options$axisType2$la.interval) !== null && _options$axisType$lab !== void 0 ? _options$axisType$lab : 1;
              var viewLabels = getViewAxisLabels({
                labels,
                pointOnColumn,
                tickDistance,
                tickCount,
                tickInterval,
                labelInterval
              }, axisSize);
              var labelXMargin = getLabelXMargin(axisType, options2);
              var _getMaxLabelSize = getMaxLabelSize(labels, labelXMargin, getTitleFontString(theme2.label)), maxLabelWidth = _getMaxLabelSize.maxLabelWidth, maxLabelHeight = _getMaxLabelSize.maxLabelHeight;
              var axisData = {
                labels,
                viewLabels,
                pointOnColumn,
                isLabelAxis,
                tickCount,
                tickDistance,
                labelDistance,
                tickInterval,
                labelInterval,
                title: makeTitleOption((_options$axisType3 = options2[axisType]) === null || _options$axisType3 === void 0 ? void 0 : _options$axisType3.title),
                maxLabelWidth,
                maxLabelHeight
              };
              if (axisType === AxisType.X) {
                var _options$xAxis$label$, _options$xAxis, _options$xAxis$label;
                var labelMargin = (_options$xAxis$label$ = (_options$xAxis = options2.xAxis) === null || _options$xAxis === void 0 ? void 0 : (_options$xAxis$label = _options$xAxis.label) === null || _options$xAxis$label === void 0 ? void 0 : _options$xAxis$label.margin) !== null && _options$xAxis$label$ !== void 0 ? _options$xAxis$label$ : 0;
                var offsetY = getAxisLabelAnchorPoint(maxLabelHeight) + labelMargin;
                var distance = axisSize / viewLabels.length;
                var rotationData = makeRotationData(maxLabelWidth, maxLabelHeight, distance, getRotatableOption(options2), axisLayout);
                var needRotateLabel = rotationData.needRotateLabel, rotationHeight = rotationData.rotationHeight;
                var maxHeight = (needRotateLabel ? rotationHeight : maxLabelHeight) + offsetY;
                return heatmapAxes_objectSpread(heatmapAxes_objectSpread(heatmapAxes_objectSpread({}, axisData), rotationData), {}, {
                  maxHeight,
                  offsetY
                });
              }
              return axisData;
            }
            var heatmapAxes_axes = {
              name: "axes",
              state: function state() {
                return {
                  axes: {
                    xAxis: {},
                    yAxis: {}
                  }
                };
              },
              action: {
                setAxesData: function setAxesData(_ref) {
                  var state = _ref.state;
                  var layout2 = state.layout, theme2 = state.theme;
                  var _layout$plot = layout2.plot, width = _layout$plot.width, height = _layout$plot.height;
                  var categories = state.categories;
                  var options2 = state.options;
                  var xAxisData = getHeatmapAxisData({
                    axisSize: width,
                    categories,
                    options: options2,
                    theme: getAxisTheme(theme2, AxisType.X),
                    axisLayout: layout2[AxisType.X]
                  }, AxisType.X);
                  var yAxisData = getHeatmapAxisData({
                    axisSize: height,
                    categories,
                    options: options2,
                    theme: getAxisTheme(theme2, AxisType.Y)
                  }, AxisType.Y);
                  var axesState = {
                    xAxis: xAxisData,
                    yAxis: yAxisData
                  };
                  if (hasAxesLayoutChanged(state.axes, axesState)) {
                    this.notify(state, "layout");
                  }
                  state.axes = axesState;
                }
              },
              computed: {},
              observe: {
                updateAxes: function updateAxes() {
                  this.dispatch("setAxesData");
                }
              }
            };
            var heatmapAxes = heatmapAxes_axes;
            ;
            function makeHeatmapSeries(series, categories, viewRange) {
              if (!series.heatmap) {
                return [];
              }
              return series.heatmap.data.map(function(rowSeries, y) {
                var yCategory = rowSeries.yCategory, data = rowSeries.data;
                return getDataInRange(data, viewRange).map(function(colorValue, x) {
                  return {
                    colorValue,
                    category: {
                      x: categories.x[x],
                      y: yCategory
                    },
                    indexes: [x, y]
                  };
                });
              });
            }
            var heatmapSeriesData = {
              name: "heatmapSeriesData",
              state: function state() {
                return {
                  heatmapSeries: []
                };
              },
              action: {
                setHeatmapSeriesData: function setHeatmapSeriesData(_ref) {
                  var state = _ref.state, computed2 = _ref.computed;
                  state.heatmapSeries = makeHeatmapSeries(state.series, state.categories, computed2.viewRange);
                }
              },
              observe: {
                updateTreemapSeriesData: function updateTreemapSeriesData() {
                  this.dispatch("setHeatmapSeriesData");
                }
              }
            };
            var store_heatmapSeriesData = heatmapSeriesData;
            ;
            function treemapSeriesData_toConsumableArray(arr) {
              return treemapSeriesData_arrayWithoutHoles(arr) || treemapSeriesData_iterableToArray(arr) || treemapSeriesData_unsupportedIterableToArray(arr) || treemapSeriesData_nonIterableSpread();
            }
            function treemapSeriesData_nonIterableSpread() {
              throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            function treemapSeriesData_unsupportedIterableToArray(o, minLen) {
              if (!o)
                return;
              if (typeof o === "string")
                return treemapSeriesData_arrayLikeToArray(o, minLen);
              var n = Object.prototype.toString.call(o).slice(8, -1);
              if (n === "Object" && o.constructor)
                n = o.constructor.name;
              if (n === "Map" || n === "Set")
                return Array.from(o);
              if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                return treemapSeriesData_arrayLikeToArray(o, minLen);
            }
            function treemapSeriesData_iterableToArray(iter) {
              if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
                return Array.from(iter);
            }
            function treemapSeriesData_arrayWithoutHoles(arr) {
              if (Array.isArray(arr))
                return treemapSeriesData_arrayLikeToArray(arr);
            }
            function treemapSeriesData_arrayLikeToArray(arr, len) {
              if (len == null || len > arr.length)
                len = arr.length;
              for (var i = 0, arr2 = new Array(len); i < len; i++) {
                arr2[i] = arr[i];
              }
              return arr2;
            }
            var TREEMAP_ID_PREFIX = "__TOAST_UI_TREEMAP";
            var TREEMAP_ROOT_ID = "".concat(TREEMAP_ID_PREFIX, "_ROOT");
            function makeTreeModel(series, indexes, depth, parentId) {
              var _series$data;
              var idx = last(indexes);
              var id = parentId ? "".concat(parentId, "_").concat(idx) : "".concat(TREEMAP_ID_PREFIX, "_").concat(idx);
              var colorValue = series.colorValue;
              var models = [{
                label: series.label,
                hasChild: !!series.children,
                id,
                indexes,
                parentId: parentId ? parentId : TREEMAP_ROOT_ID,
                depth,
                data: (_series$data = series.data) !== null && _series$data !== void 0 ? _series$data : 0,
                colorValue
              }];
              if (series.children) {
                series.children.forEach(function(child, childIdx) {
                  if (!isNull(child.data)) {
                    models.push.apply(models, treemapSeriesData_toConsumableArray(makeTreeModel(child, [].concat(treemapSeriesData_toConsumableArray(indexes), [childIdx]), depth + 1, id)));
                  }
                });
              }
              return models;
            }
            function setParentSeriesData(treemapSeries) {
              treemapSeries.forEach(function(_ref) {
                var parentId = _ref.parentId, data = _ref.data;
                if (parentId !== TREEMAP_ROOT_ID) {
                  treemapSeries.find(function(_ref2) {
                    var id = _ref2.id;
                    return id === parentId;
                  }).data += data;
                }
              });
            }
            function setParentColorValue(treemapSeries) {
              treemapSeries.forEach(function(datum) {
                var id = datum.id, colorValue = datum.colorValue;
                if (isUndefined(colorValue)) {
                  var series = treemapSeries.filter(function(_ref3) {
                    var parentId = _ref3.parentId;
                    return parentId === id;
                  });
                  var totalColorValue = series.reduce(function(acc, cur) {
                    return acc + (isUndefined(cur.colorValue) ? 0 : cur.colorValue);
                  }, 0);
                  datum.colorValue = totalColorValue / series.length;
                }
              });
            }
            function setRatio(treemapSeries) {
              var rootTotal = treemapSeries.filter(function(_ref4) {
                var parentId = _ref4.parentId;
                return parentId === TREEMAP_ROOT_ID;
              }).reduce(function(acc, _ref5) {
                var data = _ref5.data;
                return acc + data;
              }, 0);
              treemapSeries.forEach(function(series) {
                var total = series.parentId === TREEMAP_ROOT_ID ? rootTotal : treemapSeries.find(function(_ref6) {
                  var id = _ref6.id;
                  return id === series.parentId;
                }).data;
                series.ratio = series.data / total;
              });
            }
            function makeTreemapSeries(series, options2) {
              var _options$series;
              if (!series.treemap) {
                return [];
              }
              var treemapSeries = series.treemap.data.filter(function(datum) {
                return !isNull(datum.data);
              }).map(function(datum, idx) {
                return makeTreeModel(datum, [idx], 0);
              }).flatMap(function(s) {
                return s;
              }).sort(function(a, b) {
                return b.depth - a.depth;
              });
              setParentSeriesData(treemapSeries);
              setRatio(treemapSeries);
              if ((_options$series = options2.series) !== null && _options$series !== void 0 && _options$series.useColorValue) {
                setParentColorValue(treemapSeries);
              }
              return treemapSeries;
            }
            var treemapSeriesData = {
              name: "treemapSeriesData",
              state: function state() {
                return {
                  treemapSeries: []
                };
              },
              action: {
                setTreemapSeriesData: function setTreemapSeriesData(_ref7) {
                  var state = _ref7.state;
                  state.treemapSeries = makeTreemapSeries(state.series, state.options);
                }
              },
              observe: {
                updateTreemapSeriesData: function updateTreemapSeriesData() {
                  this.dispatch("setTreemapSeriesData");
                }
              }
            };
            var store_treemapSeriesData = treemapSeriesData;
            ;
            function colorValueScale_toConsumableArray(arr) {
              return colorValueScale_arrayWithoutHoles(arr) || colorValueScale_iterableToArray(arr) || colorValueScale_unsupportedIterableToArray(arr) || colorValueScale_nonIterableSpread();
            }
            function colorValueScale_nonIterableSpread() {
              throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            function colorValueScale_unsupportedIterableToArray(o, minLen) {
              if (!o)
                return;
              if (typeof o === "string")
                return colorValueScale_arrayLikeToArray(o, minLen);
              var n = Object.prototype.toString.call(o).slice(8, -1);
              if (n === "Object" && o.constructor)
                n = o.constructor.name;
              if (n === "Map" || n === "Set")
                return Array.from(o);
              if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                return colorValueScale_arrayLikeToArray(o, minLen);
            }
            function colorValueScale_iterableToArray(iter) {
              if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
                return Array.from(iter);
            }
            function colorValueScale_arrayWithoutHoles(arr) {
              if (Array.isArray(arr))
                return colorValueScale_arrayLikeToArray(arr);
            }
            function colorValueScale_arrayLikeToArray(arr, len) {
              if (len == null || len > arr.length)
                len = arr.length;
              for (var i = 0, arr2 = new Array(len); i < len; i++) {
                arr2[i] = arr[i];
              }
              return arr2;
            }
            var colorValueScale = {
              name: "colorValueScale",
              state: function state() {
                return {
                  treemapZoomId: {
                    prev: TREEMAP_ROOT_ID,
                    cur: TREEMAP_ROOT_ID
                  },
                  colorValueScale: {}
                };
              },
              action: {
                setColorValueScale: function setColorValueScale(_ref) {
                  var state = _ref.state;
                  var layout2 = state.layout, treemapSeries = state.treemapSeries, legend2 = state.legend, heatmapSeries = state.heatmapSeries;
                  if (!legend2.useSpectrumLegend) {
                    return;
                  }
                  var series = treemapSeries !== null && treemapSeries !== void 0 ? treemapSeries : heatmapSeries.flatMap(function(value) {
                    return value;
                  });
                  var values = series.reduce(function(acc, _ref2) {
                    var colorValue = _ref2.colorValue;
                    return colorValue ? [].concat(colorValueScale_toConsumableArray(acc), [colorValue]) : acc;
                  }, []);
                  var dataRange2 = getLimitSafely(colorValueScale_toConsumableArray(new Set(values)));
                  var offsetSize = isVerticalAlign(legend2.align) ? layout2.plot.width / 2 : layout2.plot.height;
                  store_extend(state.colorValueScale, calculateCoordinateScale({
                    dataRange: dataRange2,
                    offsetSize,
                    useSpectrumLegend: true,
                    scaleOption: {}
                  }));
                },
                setTreemapZoomId: function setTreemapZoomId(_ref3, id) {
                  var state = _ref3.state;
                  state.treemapZoomId.prev = state.treemapZoomId.cur;
                  state.treemapZoomId.cur = id;
                },
                zoomBack: function zoomBack(_ref4) {
                  var _prevSeries$parentId;
                  var state = _ref4.state;
                  var treemapSeries = state.treemapSeries, treemapZoomId = state.treemapZoomId;
                  var prev = treemapZoomId.prev;
                  var prevSeries = treemapSeries.find(function(_ref5) {
                    var id = _ref5.id;
                    return id === prev;
                  });
                  state.treemapZoomId.prev = (_prevSeries$parentId = prevSeries === null || prevSeries === void 0 ? void 0 : prevSeries.parentId) !== null && _prevSeries$parentId !== void 0 ? _prevSeries$parentId : TREEMAP_ROOT_ID;
                  state.treemapZoomId.cur = prev;
                }
              },
              observe: {
                updateColorValueScale: function updateColorValueScale() {
                  this.dispatch("setColorValueScale");
                }
              },
              computed: {
                isTreemapSeriesZooming: function isTreemapSeriesZooming(_ref6) {
                  var treemapZoomId = _ref6.treemapZoomId;
                  return treemapZoomId && treemapZoomId.cur !== treemapZoomId.prev;
                }
              }
            };
            var store_colorValueScale = colorValueScale;
            ;
            function spectrumLegend_typeof(obj) {
              "@babel/helpers - typeof";
              if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                spectrumLegend_typeof = function _typeof2(obj2) {
                  return typeof obj2;
                };
              } else {
                spectrumLegend_typeof = function _typeof2(obj2) {
                  return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                };
              }
              return spectrumLegend_typeof(obj);
            }
            function spectrumLegend_toConsumableArray(arr) {
              return spectrumLegend_arrayWithoutHoles(arr) || spectrumLegend_iterableToArray(arr) || spectrumLegend_unsupportedIterableToArray(arr) || spectrumLegend_nonIterableSpread();
            }
            function spectrumLegend_nonIterableSpread() {
              throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            function spectrumLegend_iterableToArray(iter) {
              if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
                return Array.from(iter);
            }
            function spectrumLegend_arrayWithoutHoles(arr) {
              if (Array.isArray(arr))
                return spectrumLegend_arrayLikeToArray(arr);
            }
            function spectrumLegend_slicedToArray(arr, i) {
              return spectrumLegend_arrayWithHoles(arr) || spectrumLegend_iterableToArrayLimit(arr, i) || spectrumLegend_unsupportedIterableToArray(arr, i) || spectrumLegend_nonIterableRest();
            }
            function spectrumLegend_nonIterableRest() {
              throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            function spectrumLegend_unsupportedIterableToArray(o, minLen) {
              if (!o)
                return;
              if (typeof o === "string")
                return spectrumLegend_arrayLikeToArray(o, minLen);
              var n = Object.prototype.toString.call(o).slice(8, -1);
              if (n === "Object" && o.constructor)
                n = o.constructor.name;
              if (n === "Map" || n === "Set")
                return Array.from(o);
              if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                return spectrumLegend_arrayLikeToArray(o, minLen);
            }
            function spectrumLegend_arrayLikeToArray(arr, len) {
              if (len == null || len > arr.length)
                len = arr.length;
              for (var i = 0, arr2 = new Array(len); i < len; i++) {
                arr2[i] = arr[i];
              }
              return arr2;
            }
            function spectrumLegend_iterableToArrayLimit(arr, i) {
              var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]);
              if (_i == null)
                return;
              var _arr = [];
              var _n = true;
              var _d = false;
              var _s, _e;
              try {
                for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
                  _arr.push(_s.value);
                  if (i && _arr.length === i)
                    break;
                }
              } catch (err) {
                _d = true;
                _e = err;
              } finally {
                try {
                  if (!_n && _i["return"] != null)
                    _i["return"]();
                } finally {
                  if (_d)
                    throw _e;
                }
              }
              return _arr;
            }
            function spectrumLegend_arrayWithHoles(arr) {
              if (Array.isArray(arr))
                return arr;
            }
            function spectrumLegend_classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function spectrumLegend_defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            function spectrumLegend_createClass(Constructor, protoProps, staticProps) {
              if (protoProps)
                spectrumLegend_defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                spectrumLegend_defineProperties(Constructor, staticProps);
              return Constructor;
            }
            function spectrumLegend_inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function");
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
              if (superClass)
                spectrumLegend_setPrototypeOf(subClass, superClass);
            }
            function spectrumLegend_setPrototypeOf(o, p) {
              spectrumLegend_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
                o2.__proto__ = p2;
                return o2;
              };
              return spectrumLegend_setPrototypeOf(o, p);
            }
            function spectrumLegend_createSuper(Derived) {
              var hasNativeReflectConstruct = spectrumLegend_isNativeReflectConstruct();
              return function _createSuperInternal() {
                var Super = spectrumLegend_getPrototypeOf(Derived), result;
                if (hasNativeReflectConstruct) {
                  var NewTarget = spectrumLegend_getPrototypeOf(this).constructor;
                  result = Reflect.construct(Super, arguments, NewTarget);
                } else {
                  result = Super.apply(this, arguments);
                }
                return spectrumLegend_possibleConstructorReturn(this, result);
              };
            }
            function spectrumLegend_possibleConstructorReturn(self2, call) {
              if (call && (spectrumLegend_typeof(call) === "object" || typeof call === "function")) {
                return call;
              }
              return spectrumLegend_assertThisInitialized(self2);
            }
            function spectrumLegend_assertThisInitialized(self2) {
              if (self2 === void 0) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return self2;
            }
            function spectrumLegend_isNativeReflectConstruct() {
              if (typeof Reflect === "undefined" || !Reflect.construct)
                return false;
              if (Reflect.construct.sham)
                return false;
              if (typeof Proxy === "function")
                return true;
              try {
                Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                }));
                return true;
              } catch (e) {
                return false;
              }
            }
            function spectrumLegend_getPrototypeOf(o) {
              spectrumLegend_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
                return o2.__proto__ || Object.getPrototypeOf(o2);
              };
              return spectrumLegend_getPrototypeOf(o);
            }
            function component_spectrumLegend_defineProperty(obj, key, value) {
              if (key in obj) {
                Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
              } else {
                obj[key] = value;
              }
              return obj;
            }
            var SpectrumLegend = function(_Component) {
              spectrumLegend_inherits(SpectrumLegend2, _Component);
              var _super = spectrumLegend_createSuper(SpectrumLegend2);
              function SpectrumLegend2() {
                var _this;
                spectrumLegend_classCallCheck(this, SpectrumLegend2);
                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }
                _this = _super.call.apply(_super, [this].concat(args));
                component_spectrumLegend_defineProperty(spectrumLegend_assertThisInitialized(_this), "models", void 0);
                component_spectrumLegend_defineProperty(spectrumLegend_assertThisInitialized(_this), "labels", []);
                component_spectrumLegend_defineProperty(spectrumLegend_assertThisInitialized(_this), "align", void 0);
                component_spectrumLegend_defineProperty(spectrumLegend_assertThisInitialized(_this), "renderSpectrumTooltip", function(_ref) {
                  var _ref2 = spectrumLegend_slicedToArray(_ref, 1), responderData = _ref2[0];
                  if (responderData) {
                    var _assertThisInitialize = spectrumLegend_assertThisInitialized(_this), labels = _assertThisInitialize.labels, align = _assertThisInitialize.align;
                    var colorValue = responderData.colorValue, color = responderData.color;
                    var _this$rect = _this.rect, width = _this$rect.width, height = _this$rect.height;
                    _this.models.tooltip = [{
                      type: "spectrumTooltip",
                      width,
                      height,
                      x: 0,
                      y: 0,
                      labels,
                      align,
                      colorRatio: responderData.colorRatio,
                      color,
                      text: String(colorValue),
                      verticalAlign: isVerticalAlign(align)
                    }];
                  } else {
                    _this.models.tooltip = [];
                  }
                });
                return _this;
              }
              spectrumLegend_createClass(SpectrumLegend2, [{
                key: "initialize",
                value: function initialize() {
                  this.type = "spectrumLegend";
                  this.name = "spectrumLegend";
                }
              }, {
                key: "makeLabels",
                value: function makeLabels2(scale2) {
                  var stepCount = scale2.stepCount, limit = scale2.limit, stepSize = scale2.stepSize;
                  var minValue = limit.min;
                  return range(0, stepCount + 1).reduce(function(labels, value) {
                    return [].concat(spectrumLegend_toConsumableArray(labels), [String(minValue + stepSize * value)]);
                  }, []);
                }
              }, {
                key: "renderSpectrumLegendModel",
                value: function renderSpectrumLegendModel(startColor, endColor) {
                  var labels = this.labels, align = this.align;
                  var _this$rect2 = this.rect, width = _this$rect2.width, height = _this$rect2.height;
                  return [{
                    type: "spectrumLegend",
                    width,
                    height,
                    x: 0,
                    y: 0,
                    labels,
                    align,
                    startColor,
                    endColor,
                    verticalAlign: isVerticalAlign(this.align)
                  }];
                }
              }, {
                key: "render",
                value: function render(_ref3) {
                  var _theme$series, _theme$series2;
                  var layout2 = _ref3.layout, legend2 = _ref3.legend, colorValueScale2 = _ref3.colorValueScale, theme2 = _ref3.theme;
                  this.rect = layout2.legend;
                  this.align = legend2.align;
                  this.isShow = legend2.visible && !!legend2.data.length;
                  if (!this.isShow) {
                    return;
                  }
                  this.labels = this.makeLabels(colorValueScale2);
                  var _ref4 = ((_theme$series = theme2.series) === null || _theme$series === void 0 ? void 0 : _theme$series.heatmap) || ((_theme$series2 = theme2.series) === null || _theme$series2 === void 0 ? void 0 : _theme$series2.treemap), startColor = _ref4.startColor, endColor = _ref4.endColor;
                  this.models = {
                    legend: this.renderSpectrumLegendModel(startColor, endColor),
                    tooltip: []
                  };
                  this.eventBus.on("renderSpectrumTooltip", this.renderSpectrumTooltip);
                }
              }]);
              return SpectrumLegend2;
            }(Component);
            ;
            function colorSpectrum_toConsumableArray(arr) {
              return colorSpectrum_arrayWithoutHoles(arr) || colorSpectrum_iterableToArray(arr) || colorSpectrum_unsupportedIterableToArray(arr) || colorSpectrum_nonIterableSpread();
            }
            function colorSpectrum_nonIterableSpread() {
              throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            function colorSpectrum_unsupportedIterableToArray(o, minLen) {
              if (!o)
                return;
              if (typeof o === "string")
                return colorSpectrum_arrayLikeToArray(o, minLen);
              var n = Object.prototype.toString.call(o).slice(8, -1);
              if (n === "Object" && o.constructor)
                n = o.constructor.name;
              if (n === "Map" || n === "Set")
                return Array.from(o);
              if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                return colorSpectrum_arrayLikeToArray(o, minLen);
            }
            function colorSpectrum_iterableToArray(iter) {
              if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
                return Array.from(iter);
            }
            function colorSpectrum_arrayWithoutHoles(arr) {
              if (Array.isArray(arr))
                return colorSpectrum_arrayLikeToArray(arr);
            }
            function colorSpectrum_arrayLikeToArray(arr, len) {
              if (len == null || len > arr.length)
                len = arr.length;
              for (var i = 0, arr2 = new Array(len); i < len; i++) {
                arr2[i] = arr[i];
              }
              return arr2;
            }
            function makeDistances(startRGB, endRGB) {
              return startRGB.map(function(value, index) {
                return endRGB[index] - value;
              });
            }
            function getColorRatio(limit, value) {
              if (isUndefined(value)) {
                return;
              }
              var divNumber = Math.abs(limit.max - limit.min);
              return divNumber && !isNull(value) ? (value - limit.min) / divNumber : 0;
            }
            function getSpectrumColor(ratio, distances, startRGB) {
              var rgbColor = startRGB.map(function(start, index) {
                return start + parseInt(String(distances[index] * ratio), 10);
              });
              var color = rgbToHEX.apply(void 0, colorSpectrum_toConsumableArray(rgbColor));
              return utils_isString(color) ? color : "";
            }
            ;
            function heatmapSeries_typeof(obj) {
              "@babel/helpers - typeof";
              if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                heatmapSeries_typeof = function _typeof2(obj2) {
                  return typeof obj2;
                };
              } else {
                heatmapSeries_typeof = function _typeof2(obj2) {
                  return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                };
              }
              return heatmapSeries_typeof(obj);
            }
            function heatmapSeries_slicedToArray(arr, i) {
              return heatmapSeries_arrayWithHoles(arr) || heatmapSeries_iterableToArrayLimit(arr, i) || heatmapSeries_unsupportedIterableToArray(arr, i) || heatmapSeries_nonIterableRest();
            }
            function heatmapSeries_nonIterableRest() {
              throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            function heatmapSeries_iterableToArrayLimit(arr, i) {
              var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]);
              if (_i == null)
                return;
              var _arr = [];
              var _n = true;
              var _d = false;
              var _s, _e;
              try {
                for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
                  _arr.push(_s.value);
                  if (i && _arr.length === i)
                    break;
                }
              } catch (err) {
                _d = true;
                _e = err;
              } finally {
                try {
                  if (!_n && _i["return"] != null)
                    _i["return"]();
                } finally {
                  if (_d)
                    throw _e;
                }
              }
              return _arr;
            }
            function heatmapSeries_arrayWithHoles(arr) {
              if (Array.isArray(arr))
                return arr;
            }
            function heatmapSeries_ownKeys(object, enumerableOnly) {
              var keys = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object);
                if (enumerableOnly) {
                  symbols = symbols.filter(function(sym) {
                    return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                  });
                }
                keys.push.apply(keys, symbols);
              }
              return keys;
            }
            function heatmapSeries_objectSpread(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i] != null ? arguments[i] : {};
                if (i % 2) {
                  heatmapSeries_ownKeys(Object(source), true).forEach(function(key) {
                    heatmapSeries_defineProperty(target, key, source[key]);
                  });
                } else if (Object.getOwnPropertyDescriptors) {
                  Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                } else {
                  heatmapSeries_ownKeys(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  });
                }
              }
              return target;
            }
            function heatmapSeries_toConsumableArray(arr) {
              return heatmapSeries_arrayWithoutHoles(arr) || heatmapSeries_iterableToArray(arr) || heatmapSeries_unsupportedIterableToArray(arr) || heatmapSeries_nonIterableSpread();
            }
            function heatmapSeries_nonIterableSpread() {
              throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            function heatmapSeries_unsupportedIterableToArray(o, minLen) {
              if (!o)
                return;
              if (typeof o === "string")
                return heatmapSeries_arrayLikeToArray(o, minLen);
              var n = Object.prototype.toString.call(o).slice(8, -1);
              if (n === "Object" && o.constructor)
                n = o.constructor.name;
              if (n === "Map" || n === "Set")
                return Array.from(o);
              if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                return heatmapSeries_arrayLikeToArray(o, minLen);
            }
            function heatmapSeries_iterableToArray(iter) {
              if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
                return Array.from(iter);
            }
            function heatmapSeries_arrayWithoutHoles(arr) {
              if (Array.isArray(arr))
                return heatmapSeries_arrayLikeToArray(arr);
            }
            function heatmapSeries_arrayLikeToArray(arr, len) {
              if (len == null || len > arr.length)
                len = arr.length;
              for (var i = 0, arr2 = new Array(len); i < len; i++) {
                arr2[i] = arr[i];
              }
              return arr2;
            }
            function heatmapSeries_classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function heatmapSeries_defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            function heatmapSeries_createClass(Constructor, protoProps, staticProps) {
              if (protoProps)
                heatmapSeries_defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                heatmapSeries_defineProperties(Constructor, staticProps);
              return Constructor;
            }
            function heatmapSeries_inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function");
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
              if (superClass)
                heatmapSeries_setPrototypeOf(subClass, superClass);
            }
            function heatmapSeries_setPrototypeOf(o, p) {
              heatmapSeries_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
                o2.__proto__ = p2;
                return o2;
              };
              return heatmapSeries_setPrototypeOf(o, p);
            }
            function heatmapSeries_createSuper(Derived) {
              var hasNativeReflectConstruct = heatmapSeries_isNativeReflectConstruct();
              return function _createSuperInternal() {
                var Super = heatmapSeries_getPrototypeOf(Derived), result;
                if (hasNativeReflectConstruct) {
                  var NewTarget = heatmapSeries_getPrototypeOf(this).constructor;
                  result = Reflect.construct(Super, arguments, NewTarget);
                } else {
                  result = Super.apply(this, arguments);
                }
                return heatmapSeries_possibleConstructorReturn(this, result);
              };
            }
            function heatmapSeries_possibleConstructorReturn(self2, call) {
              if (call && (heatmapSeries_typeof(call) === "object" || typeof call === "function")) {
                return call;
              }
              return heatmapSeries_assertThisInitialized(self2);
            }
            function heatmapSeries_assertThisInitialized(self2) {
              if (self2 === void 0) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return self2;
            }
            function heatmapSeries_isNativeReflectConstruct() {
              if (typeof Reflect === "undefined" || !Reflect.construct)
                return false;
              if (Reflect.construct.sham)
                return false;
              if (typeof Proxy === "function")
                return true;
              try {
                Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                }));
                return true;
              } catch (e) {
                return false;
              }
            }
            function heatmapSeries_getPrototypeOf(o) {
              heatmapSeries_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
                return o2.__proto__ || Object.getPrototypeOf(o2);
              };
              return heatmapSeries_getPrototypeOf(o);
            }
            function heatmapSeries_defineProperty(obj, key, value) {
              if (key in obj) {
                Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
              } else {
                obj[key] = value;
              }
              return obj;
            }
            var HeatmapSeries = function(_Component) {
              heatmapSeries_inherits(HeatmapSeries2, _Component);
              var _super = heatmapSeries_createSuper(HeatmapSeries2);
              function HeatmapSeries2() {
                var _this;
                heatmapSeries_classCallCheck(this, HeatmapSeries2);
                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }
                _this = _super.call.apply(_super, [this].concat(args));
                heatmapSeries_defineProperty(heatmapSeries_assertThisInitialized(_this), "models", void 0);
                heatmapSeries_defineProperty(heatmapSeries_assertThisInitialized(_this), "responders", void 0);
                heatmapSeries_defineProperty(heatmapSeries_assertThisInitialized(_this), "theme", void 0);
                heatmapSeries_defineProperty(heatmapSeries_assertThisInitialized(_this), "activatedResponders", []);
                heatmapSeries_defineProperty(heatmapSeries_assertThisInitialized(_this), "onMouseoutComponent", function() {
                  _this.emitMouseEvent([]);
                });
                heatmapSeries_defineProperty(heatmapSeries_assertThisInitialized(_this), "selectSeries", function(_ref) {
                  var _state$series$heatmap;
                  var index = _ref.index, seriesIndex = _ref.seriesIndex, state = _ref.state;
                  if (!isNumber(index) || !isNumber(seriesIndex)) {
                    return;
                  }
                  var dataSize = (_state$series$heatmap = state.series.heatmap) === null || _state$series$heatmap === void 0 ? void 0 : _state$series$heatmap[0].data.length;
                  var responderIndex = seriesIndex * dataSize + index;
                  var model = _this.responders[responderIndex];
                  if (!model) {
                    throw new Error(message.SELECT_SERIES_API_INDEX_ERROR);
                  }
                  _this.eventBus.emit("renderSelectedSeries", {
                    models: _this.getRespondersWithTheme([model], "select"),
                    name: _this.name
                  });
                  _this.eventBus.emit("needDraw");
                });
                heatmapSeries_defineProperty(heatmapSeries_assertThisInitialized(_this), "showTooltip", function(_ref2) {
                  var _state$series$heatmap2;
                  var index = _ref2.index, seriesIndex = _ref2.seriesIndex, state = _ref2.state;
                  if (!isNumber(index) || !isNumber(seriesIndex)) {
                    return;
                  }
                  var dataSize = (_state$series$heatmap2 = state.series.heatmap) === null || _state$series$heatmap2 === void 0 ? void 0 : _state$series$heatmap2[0].data.length;
                  var responderIndex = seriesIndex * dataSize + index;
                  var model = _this.responders[responderIndex];
                  if (model) {
                    _this.emitMouseEvent([model]);
                  }
                });
                return _this;
              }
              heatmapSeries_createClass(HeatmapSeries2, [{
                key: "initialize",
                value: function initialize() {
                  this.type = "series";
                  this.name = "heatmap";
                  this.eventBus.on("selectSeries", this.selectSeries);
                  this.eventBus.on("showTooltip", this.showTooltip);
                  this.eventBus.on("hideTooltip", this.onMouseoutComponent);
                }
              }, {
                key: "render",
                value: function render(chartState) {
                  var layout2 = chartState.layout, heatmapSeries = chartState.heatmapSeries, axes2 = chartState.axes, theme2 = chartState.theme, colorValueScale2 = chartState.colorValueScale, options2 = chartState.options;
                  if (!heatmapSeries) {
                    throw new Error(message.noDataError(this.name));
                  }
                  this.theme = theme2.series.heatmap;
                  this.selectable = this.getSelectableOption(options2);
                  this.rect = layout2.plot;
                  var cellSize = {
                    height: axes2.yAxis.tickDistance,
                    width: axes2.xAxis.tickDistance
                  };
                  this.models = {
                    series: this.renderHeatmapSeries(heatmapSeries, cellSize, colorValueScale2)
                  };
                  if (getDataLabelsOptions(options2, this.name).visible) {
                    this.renderDataLabels(this.makeDataLabels());
                  }
                  this.responders = this.makeHeatmapSeriesResponder();
                }
              }, {
                key: "makeDataLabels",
                value: function makeDataLabels() {
                  var dataLabelTheme = this.theme.dataLabels;
                  return this.models.series.reduce(function(acc, m) {
                    return isNull(m.colorValue) ? acc : [].concat(heatmapSeries_toConsumableArray(acc), [heatmapSeries_objectSpread(heatmapSeries_objectSpread({}, m), {}, {
                      type: "treemapSeriesName",
                      value: m.colorValue,
                      direction: "left",
                      plot: {
                        x: 0,
                        y: 0,
                        size: 0
                      },
                      theme: heatmapSeries_objectSpread(heatmapSeries_objectSpread({}, dataLabelTheme), {}, {
                        color: dataLabelTheme.useSeriesColor ? m.color : dataLabelTheme.color
                      })
                    })]);
                  }, []);
                }
              }, {
                key: "makeHeatmapSeriesResponder",
                value: function makeHeatmapSeriesResponder() {
                  return this.models.series.reduce(function(acc, model) {
                    return isNull(model.colorValue) ? acc : [].concat(heatmapSeries_toConsumableArray(acc), [heatmapSeries_objectSpread(heatmapSeries_objectSpread({}, model), {}, {
                      data: heatmapSeries_objectSpread(heatmapSeries_objectSpread({}, model), {}, {
                        label: model.name,
                        value: model.colorValue,
                        templateType: "heatmap"
                      }),
                      thickness: boxDefault.HOVER_THICKNESS,
                      style: ["shadow"]
                    })]);
                  }, []);
                }
              }, {
                key: "renderHeatmapSeries",
                value: function renderHeatmapSeries(seriesData2, cellSize, colorValueScale2) {
                  var _this$theme = this.theme, startColor = _this$theme.startColor, endColor = _this$theme.endColor, borderColor = _this$theme.borderColor, borderWidth = _this$theme.borderWidth;
                  var startRGB = hexToRGB(startColor);
                  var distances = makeDistances(startRGB, hexToRGB(endColor));
                  var height = cellSize.height, width = cellSize.width;
                  return seriesData2.flatMap(function(data) {
                    return data.flatMap(function(datum) {
                      var indexes = datum.indexes, colorValue = datum.colorValue, category2 = datum.category;
                      var name = "".concat(category2.x, ", ").concat(category2.y);
                      var _indexes = heatmapSeries_slicedToArray(indexes, 2), xIndex = _indexes[0], yIndex = _indexes[1];
                      var colorRatio = getColorRatio(colorValueScale2.limit, colorValue);
                      var color = isNull(colorValue) ? "rgba(0, 0, 0, 0)" : getSpectrumColor(colorRatio, distances, startRGB);
                      var thickness = borderWidth;
                      return {
                        type: "rect",
                        name,
                        width: width - thickness * 2,
                        height: height - thickness * 2,
                        x: width * xIndex + thickness,
                        y: height * yIndex + thickness,
                        colorValue,
                        colorRatio,
                        color,
                        thickness,
                        borderColor
                      };
                    });
                  });
                }
              }, {
                key: "getRespondersWithTheme",
                value: function getRespondersWithTheme(responders, type) {
                  var _this2 = this;
                  return responders.map(function(responder) {
                    return deepMergedCopy(responder, heatmapSeries_objectSpread(heatmapSeries_objectSpread({}, _this2.theme[type]), {}, {
                      style: ["shadow"]
                    }));
                  });
                }
              }, {
                key: "onClick",
                value: function onClick(_ref3) {
                  var responders = _ref3.responders;
                  if (this.selectable) {
                    this.eventBus.emit("renderSelectedSeries", {
                      models: this.getRespondersWithTheme(responders, "select"),
                      name: this.name
                    });
                    this.eventBus.emit("needDraw");
                  }
                }
              }, {
                key: "onMousemove",
                value: function onMousemove(_ref4) {
                  var responders = _ref4.responders;
                  this.activatedResponders = responders;
                  this.emitMouseEvent(responders);
                }
              }, {
                key: "emitMouseEvent",
                value: function emitMouseEvent(responders) {
                  this.eventBus.emit("renderHoveredSeries", {
                    models: this.getRespondersWithTheme(responders, "hover"),
                    name: this.name
                  });
                  this.eventBus.emit("seriesPointHovered", {
                    models: responders,
                    name: this.name
                  });
                  this.eventBus.emit("renderSpectrumTooltip", responders);
                  this.eventBus.emit("needDraw");
                }
              }]);
              return HeatmapSeries2;
            }(Component);
            ;
            function heatmapChart_typeof(obj) {
              "@babel/helpers - typeof";
              if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                heatmapChart_typeof = function _typeof2(obj2) {
                  return typeof obj2;
                };
              } else {
                heatmapChart_typeof = function _typeof2(obj2) {
                  return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                };
              }
              return heatmapChart_typeof(obj);
            }
            function heatmapChart_ownKeys(object, enumerableOnly) {
              var keys = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object);
                if (enumerableOnly) {
                  symbols = symbols.filter(function(sym) {
                    return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                  });
                }
                keys.push.apply(keys, symbols);
              }
              return keys;
            }
            function heatmapChart_objectSpread(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i] != null ? arguments[i] : {};
                if (i % 2) {
                  heatmapChart_ownKeys(Object(source), true).forEach(function(key) {
                    heatmapChart_defineProperty(target, key, source[key]);
                  });
                } else if (Object.getOwnPropertyDescriptors) {
                  Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                } else {
                  heatmapChart_ownKeys(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  });
                }
              }
              return target;
            }
            function heatmapChart_defineProperty(obj, key, value) {
              if (key in obj) {
                Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
              } else {
                obj[key] = value;
              }
              return obj;
            }
            function heatmapChart_classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function heatmapChart_defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            function heatmapChart_createClass(Constructor, protoProps, staticProps) {
              if (protoProps)
                heatmapChart_defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                heatmapChart_defineProperties(Constructor, staticProps);
              return Constructor;
            }
            function heatmapChart_get(target, property, receiver) {
              if (typeof Reflect !== "undefined" && Reflect.get) {
                heatmapChart_get = Reflect.get;
              } else {
                heatmapChart_get = function _get2(target2, property2, receiver2) {
                  var base = heatmapChart_superPropBase(target2, property2);
                  if (!base)
                    return;
                  var desc = Object.getOwnPropertyDescriptor(base, property2);
                  if (desc.get) {
                    return desc.get.call(receiver2);
                  }
                  return desc.value;
                };
              }
              return heatmapChart_get(target, property, receiver || target);
            }
            function heatmapChart_superPropBase(object, property) {
              while (!Object.prototype.hasOwnProperty.call(object, property)) {
                object = heatmapChart_getPrototypeOf(object);
                if (object === null)
                  break;
              }
              return object;
            }
            function heatmapChart_inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function");
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
              if (superClass)
                heatmapChart_setPrototypeOf(subClass, superClass);
            }
            function heatmapChart_setPrototypeOf(o, p) {
              heatmapChart_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
                o2.__proto__ = p2;
                return o2;
              };
              return heatmapChart_setPrototypeOf(o, p);
            }
            function heatmapChart_createSuper(Derived) {
              var hasNativeReflectConstruct = heatmapChart_isNativeReflectConstruct();
              return function _createSuperInternal() {
                var Super = heatmapChart_getPrototypeOf(Derived), result;
                if (hasNativeReflectConstruct) {
                  var NewTarget = heatmapChart_getPrototypeOf(this).constructor;
                  result = Reflect.construct(Super, arguments, NewTarget);
                } else {
                  result = Super.apply(this, arguments);
                }
                return heatmapChart_possibleConstructorReturn(this, result);
              };
            }
            function heatmapChart_possibleConstructorReturn(self2, call) {
              if (call && (heatmapChart_typeof(call) === "object" || typeof call === "function")) {
                return call;
              }
              return heatmapChart_assertThisInitialized(self2);
            }
            function heatmapChart_assertThisInitialized(self2) {
              if (self2 === void 0) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return self2;
            }
            function heatmapChart_isNativeReflectConstruct() {
              if (typeof Reflect === "undefined" || !Reflect.construct)
                return false;
              if (Reflect.construct.sham)
                return false;
              if (typeof Proxy === "function")
                return true;
              try {
                Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                }));
                return true;
              } catch (e) {
                return false;
              }
            }
            function heatmapChart_getPrototypeOf(o) {
              heatmapChart_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
                return o2.__proto__ || Object.getPrototypeOf(o2);
              };
              return heatmapChart_getPrototypeOf(o);
            }
            function getSeriesWithYCategory(series, categories) {
              return series.map(function(rowSeries, y) {
                return {
                  data: rowSeries,
                  yCategory: categories.y[y]
                };
              });
            }
            var HeatmapChart = function(_Chart) {
              heatmapChart_inherits(HeatmapChart2, _Chart);
              var _super = heatmapChart_createSuper(HeatmapChart2);
              function HeatmapChart2(props) {
                heatmapChart_classCallCheck(this, HeatmapChart2);
                return _super.call(this, {
                  el: props.el,
                  categories: props.data.categories,
                  options: props.options,
                  series: {
                    heatmap: getSeriesWithYCategory(props.data.series, props.data.categories)
                  },
                  modules: [store_heatmapSeriesData, store_colorValueScale, heatmapAxes]
                });
              }
              heatmapChart_createClass(HeatmapChart2, [{
                key: "initialize",
                value: function initialize() {
                  heatmapChart_get(heatmapChart_getPrototypeOf(HeatmapChart2.prototype), "initialize", this).call(this);
                  this.componentManager.add(Background);
                  this.componentManager.add(Title);
                  this.componentManager.add(SpectrumLegend);
                  this.componentManager.add(ExportMenu, {
                    chartEl: this.el
                  });
                  this.componentManager.add(HeatmapSeries);
                  this.componentManager.add(Axis, {
                    name: "yAxis"
                  });
                  this.componentManager.add(Axis, {
                    name: "xAxis"
                  });
                  this.componentManager.add(AxisTitle, {
                    name: "xAxis"
                  });
                  this.componentManager.add(AxisTitle, {
                    name: "yAxis"
                  });
                  this.componentManager.add(HoveredSeries);
                  this.componentManager.add(SelectedSeries);
                  this.componentManager.add(DataLabels);
                  this.componentManager.add(Tooltip, {
                    chartEl: this.el
                  });
                  this.componentManager.add(NoDataText);
                  this.painter.addGroups([basic_namespaceObject, axis_namespaceObject, legend_namespaceObject, label_namespaceObject, brushes_exportMenu_namespaceObject, dataLabel_namespaceObject, spectrumLegend_namespaceObject]);
                }
                /**
                 * Add data.
                 * @param {Array} data - Array of data to be added.
                 * @param {string} category - Category to be added.
                 * @api
                 * @example
                 * chart.addData([10, 20], '6');
                 */
              }, {
                key: "addData",
                value: function addData(data, category2) {
                  this.animationControlFlag.updating = true;
                  this.resetSeries();
                  this.store.dispatch("addData", {
                    data,
                    category: category2
                  });
                }
                /**
                 * Add series.
                 * @param {Object} data - Data to be added.
                 *   @param {string} data.name - Series name.
                 *   @param {Array<number>} data.data - Array of data to be added.
                 * @param {Object} dataInfo - Category information of the series.
                 *   @param {Object} dataInfo.category - Y category.
                 * @api
                 * @example
                 * chart.addSeries({
                 *   name: 'newSeries',
                 *   data: [10, 100, 50, 40, 70, 55, 33, 70, 90, 110],
                 * });
                 */
              }, {
                key: "addSeries",
                value: function addSeries(data, dataInfo) {
                  this.resetSeries();
                  this.store.dispatch("addHeatmapSeries", heatmapChart_objectSpread({
                    data
                  }, dataInfo));
                }
                /**
                 * Convert the chart data to new data.
                 * @param {Object} data - Data to be set.
                 *   @param {Array<string>} data.categories.x - X Categories.
                 *   @param {Array<string>} data.categories.y - Y Categories.
                 * @param {Array<Array<number>>} data.series - Series data.
                 * @api
                 * @example
                 * chart.setData({
                 *   categories: {
                 *     x: ['1', '2', '3' ],
                 *     y: ['A', 'B'],
                 *   },
                 *   series: [
                 *     [1, 2, 3],
                 *     [4, 5, 6],
                 *   ]
                 * });
                 */
              }, {
                key: "setData",
                value: function setData(data) {
                  var categories = data.categories, series = data.series;
                  this.resetSeries();
                  this.store.dispatch("setData", {
                    series: {
                      heatmap: getSeriesWithYCategory(series, categories)
                    },
                    categories
                  });
                }
                /**
                 * Hide series data label.
                 * @api
                 * @example
                 * chart.hideSeriesDataLabel();
                 */
              }, {
                key: "hideSeriesDataLabel",
                value: function hideSeriesDataLabel() {
                  this.store.dispatch("updateOptions", {
                    options: {
                      series: {
                        dataLabels: {
                          visible: false
                        }
                      }
                    }
                  });
                }
                /**
                 * Show series data label.
                 * @api
                 * @example
                 * chart.showSeriesDataLabel();
                 */
              }, {
                key: "showSeriesDataLabel",
                value: function showSeriesDataLabel() {
                  this.store.dispatch("updateOptions", {
                    options: {
                      series: {
                        dataLabels: {
                          visible: true
                        }
                      }
                    }
                  });
                }
                /**
                 * Convert the chart options to new options.
                 * @param {Object} options - Chart options
                 * @api
                 * @example
                 * chart.setOptions({
                 *   chart: {
                 *     width: 500,
                 *     height: 'auto',
                 *     title: 'Energy Usage',
                 *   },
                 *   xAxis: {
                 *     title: 'Month',
                 *   },
                 *   yAxis: {
                 *     title: 'Energy (kWh)',
                 *   },
                 *   series: {
                 *     selectable: true,
                 *   },
                 *   tooltip: {
                 *     formatter: (value) => `${value}kWh`,
                 *   },
                 * });
                 */
              }, {
                key: "setOptions",
                value: function setOptions(options2) {
                  this.resetSeries();
                  this.dispatchOptionsEvent("initOptions", options2);
                }
                /**
                 * Update chart options.
                 * @param {Object} options - Chart options
                 * @api
                 * @example
                 * chart.updateOptions({
                 *   chart: {
                 *     height: 'auto',
                 *     title: 'Energy Usage',
                 *   },
                 *   tooltip: {
                 *     formatter: (value) => `${value}kWh`,
                 *   },
                 * });
                 */
              }, {
                key: "updateOptions",
                value: function updateOptions(options2) {
                  this.resetSeries();
                  this.dispatchOptionsEvent("updateOptions", options2);
                }
                /**
                 * Show tooltip.
                 * @param {Object} seriesInfo - Information of the series for the tooltip to be displayed.
                 *      @param {number} seriesInfo.seriesIndex - Index of series.
                 *      @param {number} seriesInfo.index - Index of data within series.
                 * @api
                 * @example
                 * chart.showTooltip({index: 1, seriesIndex: 2});
                 */
              }, {
                key: "showTooltip",
                value: function showTooltip(seriesInfo) {
                  this.eventBus.emit("showTooltip", heatmapChart_objectSpread(heatmapChart_objectSpread({}, seriesInfo), {}, {
                    state: this.store.state
                  }));
                }
                /**
                 * Hide tooltip.
                 * @api
                 * @example
                 * chart.hideTooltip();
                 */
              }, {
                key: "hideTooltip",
                value: function hideTooltip() {
                  this.eventBus.emit("hideTooltip");
                }
              }]);
              return HeatmapChart2;
            }(Chart);
            ;
            function areaSeries_typeof(obj) {
              "@babel/helpers - typeof";
              if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                areaSeries_typeof = function _typeof2(obj2) {
                  return typeof obj2;
                };
              } else {
                areaSeries_typeof = function _typeof2(obj2) {
                  return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                };
              }
              return areaSeries_typeof(obj);
            }
            function areaSeries_toConsumableArray(arr) {
              return areaSeries_arrayWithoutHoles(arr) || areaSeries_iterableToArray(arr) || areaSeries_unsupportedIterableToArray(arr) || areaSeries_nonIterableSpread();
            }
            function areaSeries_nonIterableSpread() {
              throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            function areaSeries_unsupportedIterableToArray(o, minLen) {
              if (!o)
                return;
              if (typeof o === "string")
                return areaSeries_arrayLikeToArray(o, minLen);
              var n = Object.prototype.toString.call(o).slice(8, -1);
              if (n === "Object" && o.constructor)
                n = o.constructor.name;
              if (n === "Map" || n === "Set")
                return Array.from(o);
              if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                return areaSeries_arrayLikeToArray(o, minLen);
            }
            function areaSeries_iterableToArray(iter) {
              if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
                return Array.from(iter);
            }
            function areaSeries_arrayWithoutHoles(arr) {
              if (Array.isArray(arr))
                return areaSeries_arrayLikeToArray(arr);
            }
            function areaSeries_arrayLikeToArray(arr, len) {
              if (len == null || len > arr.length)
                len = arr.length;
              for (var i = 0, arr2 = new Array(len); i < len; i++) {
                arr2[i] = arr[i];
              }
              return arr2;
            }
            function areaSeries_ownKeys(object, enumerableOnly) {
              var keys = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object);
                if (enumerableOnly) {
                  symbols = symbols.filter(function(sym) {
                    return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                  });
                }
                keys.push.apply(keys, symbols);
              }
              return keys;
            }
            function areaSeries_objectSpread(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i] != null ? arguments[i] : {};
                if (i % 2) {
                  areaSeries_ownKeys(Object(source), true).forEach(function(key) {
                    areaSeries_defineProperty(target, key, source[key]);
                  });
                } else if (Object.getOwnPropertyDescriptors) {
                  Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                } else {
                  areaSeries_ownKeys(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  });
                }
              }
              return target;
            }
            function areaSeries_classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function areaSeries_defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            function areaSeries_createClass(Constructor, protoProps, staticProps) {
              if (protoProps)
                areaSeries_defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                areaSeries_defineProperties(Constructor, staticProps);
              return Constructor;
            }
            function areaSeries_inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function");
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
              if (superClass)
                areaSeries_setPrototypeOf(subClass, superClass);
            }
            function areaSeries_setPrototypeOf(o, p) {
              areaSeries_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
                o2.__proto__ = p2;
                return o2;
              };
              return areaSeries_setPrototypeOf(o, p);
            }
            function areaSeries_createSuper(Derived) {
              var hasNativeReflectConstruct = areaSeries_isNativeReflectConstruct();
              return function _createSuperInternal() {
                var Super = areaSeries_getPrototypeOf(Derived), result;
                if (hasNativeReflectConstruct) {
                  var NewTarget = areaSeries_getPrototypeOf(this).constructor;
                  result = Reflect.construct(Super, arguments, NewTarget);
                } else {
                  result = Super.apply(this, arguments);
                }
                return areaSeries_possibleConstructorReturn(this, result);
              };
            }
            function areaSeries_possibleConstructorReturn(self2, call) {
              if (call && (areaSeries_typeof(call) === "object" || typeof call === "function")) {
                return call;
              }
              return areaSeries_assertThisInitialized(self2);
            }
            function areaSeries_assertThisInitialized(self2) {
              if (self2 === void 0) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return self2;
            }
            function areaSeries_isNativeReflectConstruct() {
              if (typeof Reflect === "undefined" || !Reflect.construct)
                return false;
              if (Reflect.construct.sham)
                return false;
              if (typeof Proxy === "function")
                return true;
              try {
                Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                }));
                return true;
              } catch (e) {
                return false;
              }
            }
            function areaSeries_getPrototypeOf(o) {
              areaSeries_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
                return o2.__proto__ || Object.getPrototypeOf(o2);
              };
              return areaSeries_getPrototypeOf(o);
            }
            function areaSeries_defineProperty(obj, key, value) {
              if (key in obj) {
                Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
              } else {
                obj[key] = value;
              }
              return obj;
            }
            var seriesOpacity = {
              INACTIVE: 0.06,
              ACTIVE: 1
            };
            var AreaSeries = function(_Component) {
              areaSeries_inherits(AreaSeries2, _Component);
              var _super = areaSeries_createSuper(AreaSeries2);
              function AreaSeries2() {
                var _this;
                areaSeries_classCallCheck(this, AreaSeries2);
                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }
                _this = _super.call.apply(_super, [this].concat(args));
                areaSeries_defineProperty(areaSeries_assertThisInitialized(_this), "models", {
                  rect: [],
                  series: [],
                  dot: []
                });
                areaSeries_defineProperty(areaSeries_assertThisInitialized(_this), "drawModels", void 0);
                areaSeries_defineProperty(areaSeries_assertThisInitialized(_this), "theme", void 0);
                areaSeries_defineProperty(areaSeries_assertThisInitialized(_this), "responders", void 0);
                areaSeries_defineProperty(areaSeries_assertThisInitialized(_this), "activatedResponders", []);
                areaSeries_defineProperty(areaSeries_assertThisInitialized(_this), "eventDetectType", "nearest");
                areaSeries_defineProperty(areaSeries_assertThisInitialized(_this), "tooltipCircleMap", void 0);
                areaSeries_defineProperty(areaSeries_assertThisInitialized(_this), "linePointsModel", void 0);
                areaSeries_defineProperty(areaSeries_assertThisInitialized(_this), "baseYPosition", void 0);
                areaSeries_defineProperty(areaSeries_assertThisInitialized(_this), "isStackChart", false);
                areaSeries_defineProperty(areaSeries_assertThisInitialized(_this), "isRangeChart", false);
                areaSeries_defineProperty(areaSeries_assertThisInitialized(_this), "isSplineChart", false);
                areaSeries_defineProperty(areaSeries_assertThisInitialized(_this), "startIndex", void 0);
                areaSeries_defineProperty(areaSeries_assertThisInitialized(_this), "onMouseoutComponent", function() {
                  _this.eventBus.emit("seriesPointHovered", {
                    models: [],
                    name: _this.name
                  });
                  _this.eventBus.emit("renderHoveredSeries", {
                    models: [],
                    name: _this.name,
                    eventDetectType: _this.eventDetectType
                  });
                  _this.eventBus.emit("needDraw");
                });
                areaSeries_defineProperty(areaSeries_assertThisInitialized(_this), "selectSeries", function(info) {
                  var index = info.index, seriesIndex = info.seriesIndex;
                  if (!isAvailableSelectSeries(info, "area")) {
                    return;
                  }
                  var category2 = _this.getResponderCategoryByIndex(index);
                  if (!category2) {
                    throw new Error(message.SELECT_SERIES_API_INDEX_ERROR);
                  }
                  var model = _this.tooltipCircleMap[category2][seriesIndex];
                  if (!model) {
                    throw new Error(message.SELECT_SERIES_API_INDEX_ERROR);
                  }
                  var models = _this.getResponderSeriesWithTheme([model], "select");
                  _this.eventBus.emit("renderSelectedSeries", {
                    models,
                    name: _this.name
                  });
                  _this.eventBus.emit("needDraw");
                });
                areaSeries_defineProperty(areaSeries_assertThisInitialized(_this), "showTooltip", function(info) {
                  var index = info.index, seriesIndex = info.seriesIndex;
                  if (!isAvailableShowTooltipInfo(info, _this.eventDetectType, "area")) {
                    return;
                  }
                  var category2 = _this.getResponderCategoryByIndex(index);
                  if (!category2) {
                    return;
                  }
                  var models = _this.eventDetectType === "grouped" ? _this.tooltipCircleMap[category2] : [_this.tooltipCircleMap[category2][seriesIndex]];
                  if (!models.length) {
                    return;
                  }
                  _this.onMousemoveNearType(models);
                  _this.eventBus.emit("seriesPointHovered", {
                    models: _this.activatedResponders,
                    name: _this.name
                  });
                  _this.eventBus.emit("needDraw");
                });
                return _this;
              }
              areaSeries_createClass(AreaSeries2, [{
                key: "initialize",
                value: function initialize() {
                  this.type = "series";
                  this.name = "area";
                  this.eventBus.on("selectSeries", this.selectSeries);
                  this.eventBus.on("showTooltip", this.showTooltip);
                  this.eventBus.on("hideTooltip", this.onMouseoutComponent);
                }
              }, {
                key: "initUpdate",
                value: function initUpdate(delta) {
                  if (!this.drawModels) {
                    return;
                  }
                  this.drawModels.rect[0].width = this.models.rect[0].width * delta;
                }
              }, {
                key: "getBaseYPosition",
                value: function getBaseYPosition(limit) {
                  var baseValue = limit.min >= 0 ? limit.min : Math.min(limit.max, 0);
                  var intervalSize = this.rect.height / (limit.max - limit.min);
                  return (limit.max - baseValue) * intervalSize;
                }
              }, {
                key: "getStackValue",
                value: function getStackValue(areaStackSeries, seriesIndex, index) {
                  var type = areaStackSeries.stack.type;
                  var _areaStackSeries$stac = areaStackSeries.stackData[index], values = _areaStackSeries$stac.values, sumValue = _areaStackSeries$stac.sum;
                  var stackedValue = sum(values.slice(0, seriesIndex + 1));
                  return type === "percent" ? stackedValue * 100 / sumValue : stackedValue;
                }
              }, {
                key: "setEventDetectType",
                value: function setEventDetectType(series, options2) {
                  var _options$series;
                  if (options2 !== null && options2 !== void 0 && (_options$series = options2.series) !== null && _options$series !== void 0 && _options$series.eventDetectType) {
                    this.eventDetectType = options2.series.eventDetectType;
                  }
                  if (series.line || this.isStackChart) {
                    this.eventDetectType = "grouped";
                  }
                }
              }, {
                key: "getAreaOptions",
                value: function getAreaOptions(options2) {
                  var _newOptions$series;
                  var newOptions = areaSeries_objectSpread({}, options2);
                  if ((_newOptions$series = newOptions.series) !== null && _newOptions$series !== void 0 && _newOptions$series.area) {
                    newOptions.series = areaSeries_objectSpread(areaSeries_objectSpread({}, newOptions.series), newOptions.series.area);
                  }
                  return newOptions;
                }
              }, {
                key: "render",
                value: function render(chartState, computed2) {
                  var _ref, _viewRange$, _options$series$splin, _options$series2, _getFirstValidValue, _options$series3;
                  var viewRange = computed2.viewRange;
                  var layout2 = chartState.layout, series = chartState.series, scale2 = chartState.scale, axes2 = chartState.axes, legend2 = chartState.legend, stackSeries = chartState.stackSeries, theme2 = chartState.theme;
                  if (!series.area) {
                    throw new Error(message.noDataError(this.name));
                  }
                  var areaStackSeries;
                  var options2 = this.getAreaOptions(chartState.options);
                  var categories = chartState.categories;
                  var rawCategories = (_ref = chartState.rawCategories) !== null && _ref !== void 0 ? _ref : [];
                  this.theme = theme2.series.area;
                  this.rect = layout2.plot;
                  this.activeSeriesMap = getActiveSeriesMap(legend2);
                  this.startIndex = (_viewRange$ = viewRange === null || viewRange === void 0 ? void 0 : viewRange[0]) !== null && _viewRange$ !== void 0 ? _viewRange$ : 0;
                  this.selectable = this.getSelectableOption(options2);
                  this.isSplineChart = (_options$series$splin = (_options$series2 = options2.series) === null || _options$series2 === void 0 ? void 0 : _options$series2.spline) !== null && _options$series$splin !== void 0 ? _options$series$splin : false;
                  var limit = scale2[getValueAxisName(options2, this.name, "yAxis")].limit;
                  var _ref2 = axes2.xAxis, tickDistance = _ref2.tickDistance, pointOnColumn = _ref2.pointOnColumn, tickCount = _ref2.tickCount;
                  var areaData = series.area.data;
                  this.baseYPosition = this.getBaseYPosition(limit);
                  if (stackSeries !== null && stackSeries !== void 0 && stackSeries.area) {
                    this.isStackChart = true;
                    areaStackSeries = stackSeries.area;
                  } else if (isRangeData((_getFirstValidValue = getFirstValidValue(areaData)) === null || _getFirstValidValue === void 0 ? void 0 : _getFirstValidValue.data)) {
                    this.isRangeChart = true;
                  }
                  this.setEventDetectType(series, options2);
                  var renderOptions = {
                    pointOnColumn,
                    options: options2.series || {},
                    tickDistance,
                    tickCount,
                    areaStackSeries
                  };
                  this.linePointsModel = this.renderLinePointsModel(areaData, limit, renderOptions);
                  var areaSeriesModel = this.renderAreaPointsModel();
                  var showDot = !!((_options$series3 = options2.series) !== null && _options$series3 !== void 0 && _options$series3.showDot);
                  var _this$renderCircleMod = this.renderCircleModel(showDot), dotSeriesModel = _this$renderCircleMod.dotSeriesModel, responderModel = _this$renderCircleMod.responderModel;
                  var tooltipDataArr = this.makeTooltipData(areaData, rawCategories);
                  this.models = deepCopy({
                    rect: [this.renderClipRectAreaModel()],
                    series: [].concat(areaSeries_toConsumableArray(this.linePointsModel), areaSeries_toConsumableArray(areaSeriesModel)),
                    dot: dotSeriesModel
                  });
                  if (!this.drawModels) {
                    this.drawModels = areaSeries_objectSpread(areaSeries_objectSpread({}, this.models), {}, {
                      rect: [this.renderClipRectAreaModel(true)]
                    });
                  }
                  if (getDataLabelsOptions(options2, this.name).visible) {
                    this.renderDataLabels(this.getDataLabels(areaSeriesModel));
                  }
                  this.tooltipCircleMap = makeTooltipCircleMap(responderModel, tooltipDataArr);
                  this.responders = this.getResponders(responderModel, tooltipDataArr, categories, rawCategories, axes2.xAxis);
                }
              }, {
                key: "getResponders",
                value: function getResponders(responderModel, tooltipDataArr, categories, rawCategories, axisData) {
                  if (this.eventDetectType === "near") {
                    return this.makeNearTypeResponderModel(responderModel, tooltipDataArr, rawCategories);
                  }
                  if (this.eventDetectType === "point") {
                    return this.makeNearTypeResponderModel(responderModel, tooltipDataArr, rawCategories, 0);
                  }
                  return makeRectResponderModel(this.rect, axisData, categories);
                }
              }, {
                key: "makeNearTypeResponderModel",
                value: function makeNearTypeResponderModel(seriesCircleModel, tooltipDataArr, categories, detectionSize) {
                  var tooltipDataLength = tooltipDataArr.length;
                  return seriesCircleModel.map(function(m, dataIndex) {
                    return areaSeries_objectSpread(areaSeries_objectSpread({}, m), {}, {
                      data: tooltipDataArr[dataIndex % tooltipDataLength],
                      detectionSize,
                      label: categories[m.index]
                    });
                  });
                }
              }, {
                key: "renderClipRectAreaModel",
                value: function renderClipRectAreaModel(isDrawModel) {
                  return {
                    type: "clipRectArea",
                    x: 0,
                    y: 0,
                    width: isDrawModel ? 0 : this.rect.width,
                    height: this.rect.height
                  };
                }
              }, {
                key: "makeTooltipData",
                value: function makeTooltipData(areaData, categories) {
                  var _this2 = this;
                  return areaData.flatMap(function(_ref3, seriesIndex) {
                    var rawData = _ref3.rawData, name = _ref3.name, color = _ref3.color;
                    var tooltipData = [];
                    rawData.forEach(function(datum, index) {
                      if (!isNull(datum)) {
                        var value = _this2.isRangeChart ? "".concat(datum[0], " ~ ").concat(datum[1]) : datum;
                        tooltipData.push({
                          label: name,
                          color,
                          value,
                          category: categories[index],
                          seriesIndex,
                          index
                        });
                      }
                    });
                    return tooltipData;
                  });
                }
              }, {
                key: "getLinePointModelValue",
                value: function getLinePointModelValue(datum, pairModel) {
                  if (this.isRangeChart) {
                    return pairModel ? datum[0] : datum[1];
                  }
                  return datum;
                }
              }, {
                key: "getLinePointModel",
                value: function getLinePointModel(series, seriesIndex, limit, renderOptions) {
                  var _this3 = this;
                  var pointOnColumn = renderOptions.pointOnColumn, tickDistance = renderOptions.tickDistance, pairModel = renderOptions.pairModel, areaStackSeries = renderOptions.areaStackSeries;
                  var rawData = series.rawData, name = series.name, seriesColor = series.color;
                  var active = this.activeSeriesMap[name];
                  var points = [];
                  var color = getRGBA(seriesColor, active ? seriesOpacity.ACTIVE : seriesOpacity.INACTIVE);
                  var _this$theme = this.theme, lineWidth = _this$theme.lineWidth, dashSegments = _this$theme.dashSegments;
                  rawData.forEach(function(datum, idx) {
                    if (isNull(datum)) {
                      points.push(null);
                      return;
                    }
                    var value = _this3.getLinePointModelValue(datum, pairModel);
                    var stackedValue = _this3.isStackChart ? _this3.getStackValue(areaStackSeries, seriesIndex, idx) : value;
                    var valueRatio = getValueRatio(stackedValue, limit);
                    var x = tickDistance * (idx - _this3.startIndex) + (pointOnColumn ? tickDistance / 2 : 0);
                    var y = (1 - valueRatio) * _this3.rect.height;
                    points.push({
                      x,
                      y,
                      value
                    });
                  });
                  if (pairModel) {
                    points.reverse();
                  }
                  if (this.isSplineChart) {
                    setSplineControlPoint(points);
                  }
                  return {
                    type: "linePoints",
                    lineWidth,
                    dashSegments,
                    color,
                    points,
                    seriesIndex,
                    name
                  };
                }
              }, {
                key: "renderLinePointsModel",
                value: function renderLinePointsModel(seriesRawData, limit, renderOptions) {
                  var _this4 = this;
                  var linePointsModels = seriesRawData.map(function(series, seriesIndex) {
                    return _this4.getLinePointModel(series, seriesIndex, limit, renderOptions);
                  });
                  if (this.isRangeChart) {
                    var renderOptionsForPair = deepMergedCopy(renderOptions, {
                      pairModel: true
                    });
                    var pair = seriesRawData.map(function(series, seriesIndex) {
                      return _this4.getLinePointModel(series, seriesIndex, limit, renderOptionsForPair);
                    });
                    linePointsModels.push.apply(linePointsModels, areaSeries_toConsumableArray(pair));
                  }
                  return linePointsModels;
                }
              }, {
                key: "getCombinedPoints",
                value: function getCombinedPoints(start, end) {
                  var startPoints = start >= 0 ? this.linePointsModel[start].points : [];
                  var reversedEndPoints = areaSeries_toConsumableArray(this.linePointsModel[end].points).reverse();
                  return [].concat(areaSeries_toConsumableArray(startPoints), areaSeries_toConsumableArray(reversedEndPoints));
                }
              }, {
                key: "renderRangeAreaSeries",
                value: function renderRangeAreaSeries(linePointsModel) {
                  var _this5 = this;
                  var model = [];
                  linePointsModel.forEach(function(m) {
                    var areaPoints2 = [];
                    var points = m.points;
                    points.slice(0, points.length / 2 + 1).forEach(function(point, i) {
                      var lastPoint = i === points.length / 2 - 1;
                      var nullPoint = isNull(point);
                      if (!nullPoint) {
                        areaPoints2.push(point);
                      }
                      if (areaPoints2.length && (lastPoint || nullPoint)) {
                        var pairPoints = areaPoints2.map(function(areaPoint, idx) {
                          var curIdx = points.length / 2 + i - areaPoints2.length + idx + (!nullPoint && lastPoint ? 1 : 0);
                          return points[curIdx];
                        }).reverse();
                        model.push(areaSeries_objectSpread(areaSeries_objectSpread({}, m), {}, {
                          type: "areaPoints",
                          lineWidth: 0,
                          color: "rgba(0, 0, 0, 0)",
                          // make area border transparent
                          fillColor: _this5.getAreaOpacity(m.name, m.color),
                          points: [].concat(areaSeries_toConsumableArray(areaPoints2), areaSeries_toConsumableArray(pairPoints))
                        }));
                        areaPoints2 = [];
                      }
                    });
                  });
                  return model;
                }
              }, {
                key: "renderAreaSeries",
                value: function renderAreaSeries(linePointsModel) {
                  var _this6 = this;
                  var model = [];
                  var bottomYPoint = [];
                  linePointsModel.forEach(function(m) {
                    var areaPoints2 = [];
                    var curBottomYPoint = [].concat(bottomYPoint);
                    var points = m.points;
                    points.forEach(function(point, i) {
                      var lastPoint = i === points.length - 1;
                      var nullPoint = isNull(point);
                      if (!isNull(point)) {
                        areaPoints2.push(point);
                      }
                      if (areaPoints2.length && (nullPoint || lastPoint)) {
                        var pairPoints = areaPoints2.map(function(areaPoint, idx) {
                          var curIdx = i - areaPoints2.length + idx + (!nullPoint && lastPoint ? 1 : 0);
                          var bottom = isUndefined(curBottomYPoint[curIdx]) ? _this6.baseYPosition : curBottomYPoint[curIdx];
                          if (_this6.isStackChart) {
                            bottomYPoint[curIdx] = areaPoint.y;
                          }
                          return {
                            x: areaPoint.x,
                            y: bottom
                          };
                        }).reverse();
                        if (_this6.isStackChart && _this6.isSplineChart) {
                          setSplineControlPoint(pairPoints);
                        }
                        model.push(areaSeries_objectSpread(areaSeries_objectSpread({}, m), {}, {
                          type: "areaPoints",
                          lineWidth: 0,
                          color: "rgba(0, 0, 0, 0)",
                          // make area border transparent
                          fillColor: _this6.getAreaOpacity(m.name, m.color),
                          points: [].concat(areaSeries_toConsumableArray(areaPoints2), areaSeries_toConsumableArray(pairPoints))
                        }));
                        areaPoints2 = [];
                      }
                    });
                  });
                  return model;
                }
              }, {
                key: "getCombinedLinePointsModel",
                value: function getCombinedLinePointsModel() {
                  var _this7 = this;
                  if (!this.isRangeChart) {
                    return this.linePointsModel;
                  }
                  var len = this.linePointsModel.length / 2;
                  return range(0, len).reduce(function(acc, i) {
                    var start = i;
                    var end = len + i;
                    var points = _this7.getCombinedPoints(start, end);
                    return [].concat(areaSeries_toConsumableArray(acc), [areaSeries_objectSpread(areaSeries_objectSpread({}, _this7.linePointsModel[i]), {}, {
                      points
                    })]);
                  }, []);
                }
              }, {
                key: "getAreaOpacity",
                value: function getAreaOpacity(name, color) {
                  var _this$theme2 = this.theme, select = _this$theme2.select, areaOpacity = _this$theme2.areaOpacity;
                  var active = this.activeSeriesMap[name];
                  var selected = Object.values(this.activeSeriesMap).some(function(elem) {
                    return !elem;
                  });
                  return selected ? getRGBA(color, active ? select.areaOpacity : select.restSeries.areaOpacity) : getRGBA(color, areaOpacity);
                }
              }, {
                key: "renderAreaPointsModel",
                value: function renderAreaPointsModel() {
                  var combinedLinePointsModel = this.getCombinedLinePointsModel();
                  return this.isRangeChart ? this.renderRangeAreaSeries(combinedLinePointsModel) : this.renderAreaSeries(combinedLinePointsModel);
                }
              }, {
                key: "renderCircleModel",
                value: function renderCircleModel(showDot) {
                  var _this8 = this;
                  var dotSeriesModel = [];
                  var responderModel = [];
                  var dotTheme = this.theme.dot;
                  this.linePointsModel.forEach(function(_ref4, modelIndex) {
                    var points = _ref4.points, color = _ref4.color, seriesIndex = _ref4.seriesIndex, name = _ref4.name;
                    var isPairLinePointsModel = _this8.isRangeChart && modelIndex >= _this8.linePointsModel.length / 2;
                    var active = _this8.activeSeriesMap[name];
                    points.forEach(function(point, index) {
                      if (isNull(point)) {
                        return;
                      }
                      var model = areaSeries_objectSpread(areaSeries_objectSpread({
                        type: "circle"
                      }, point), {}, {
                        seriesIndex,
                        name,
                        index: isPairLinePointsModel ? points.length - index - 1 : index
                      });
                      if (showDot) {
                        var _dotTheme$borderColor;
                        dotSeriesModel.push(areaSeries_objectSpread(areaSeries_objectSpread({}, model), {}, {
                          radius: dotTheme.radius,
                          color: getRGBA(color, active ? 1 : 0.3),
                          style: [{
                            lineWidth: dotTheme.borderWidth,
                            strokeStyle: (_dotTheme$borderColor = dotTheme.borderColor) !== null && _dotTheme$borderColor !== void 0 ? _dotTheme$borderColor : color
                          }]
                        }));
                      }
                      responderModel.push.apply(responderModel, areaSeries_toConsumableArray(_this8.getResponderSeriesWithTheme([model], "hover", color)));
                    });
                  });
                  return {
                    dotSeriesModel,
                    responderModel
                  };
                }
              }, {
                key: "getPairCircleModel",
                value: function getPairCircleModel(circleModels) {
                  var _this9 = this;
                  var pairCircleModels = [];
                  circleModels.forEach(function(circle2) {
                    var seriesIndex = circle2.seriesIndex, y = circle2.y, data = circle2.data;
                    var category2 = data.category;
                    var pairCircleModel = _this9.tooltipCircleMap[category2].find(function(model) {
                      return model.seriesIndex === seriesIndex && model.y !== y;
                    });
                    pairCircleModels.push(pairCircleModel);
                  });
                  return pairCircleModels;
                }
              }, {
                key: "getCircleModelsFromRectResponders",
                value: function getCircleModelsFromRectResponders(responders, mousePositions) {
                  var _this$tooltipCircleMa;
                  if (!responders.length || !responders[0].label) {
                    return [];
                  }
                  var models = (_this$tooltipCircleMa = this.tooltipCircleMap[responders[0].label]) !== null && _this$tooltipCircleMa !== void 0 ? _this$tooltipCircleMa : [];
                  return this.eventDetectType === "grouped" ? models : getNearestResponder(models, mousePositions, this.rect);
                }
              }, {
                key: "onMousemoveGroupedType",
                value: function onMousemoveGroupedType(responders) {
                  var circleModels = this.getCircleModelsFromRectResponders(responders);
                  this.eventBus.emit("renderHoveredSeries", {
                    models: circleModels,
                    name: this.name,
                    eventDetectType: this.eventDetectType
                  });
                  this.activatedResponders = this.isRangeChart ? circleModels.slice(0, circleModels.length / 2) : circleModels;
                }
              }, {
                key: "onMousemoveNearestType",
                value: function onMousemoveNearestType(responders, mousePositions) {
                  var circleModels = this.getCircleModelsFromRectResponders(responders, mousePositions);
                  this.onMousemoveNearType(circleModels);
                }
              }, {
                key: "onMousemoveNearType",
                value: function onMousemoveNearType(responders) {
                  var pairCircleModels = [];
                  if (this.isRangeChart) {
                    pairCircleModels = this.getPairCircleModel(responders);
                  }
                  var hoveredSeries = [].concat(areaSeries_toConsumableArray(responders), areaSeries_toConsumableArray(pairCircleModels));
                  this.eventBus.emit("renderHoveredSeries", {
                    models: hoveredSeries,
                    name: this.name,
                    eventDetectType: this.eventDetectType
                  });
                  this.activatedResponders = responders;
                }
              }, {
                key: "onMousemove",
                value: function onMousemove(_ref5) {
                  var responders = _ref5.responders, mousePosition = _ref5.mousePosition;
                  if (this.eventDetectType === "nearest") {
                    this.onMousemoveNearestType(responders, mousePosition);
                  } else if (["near", "point"].includes(this.eventDetectType)) {
                    this.onMousemoveNearType(responders);
                  } else {
                    this.onMousemoveGroupedType(responders);
                  }
                  this.eventBus.emit("seriesPointHovered", {
                    models: this.activatedResponders,
                    name: this.name
                  });
                  this.eventBus.emit("needDraw");
                }
              }, {
                key: "getDataLabels",
                value: function getDataLabels(seriesModels) {
                  var dataLabelTheme = this.theme.dataLabels;
                  return seriesModels.flatMap(function(_ref6) {
                    var points = _ref6.points, name = _ref6.name, fillColor = _ref6.fillColor;
                    return points.map(function(point) {
                      return isNull(point) ? {} : areaSeries_objectSpread(areaSeries_objectSpread({
                        type: "point"
                      }, point), {}, {
                        name,
                        theme: areaSeries_objectSpread(areaSeries_objectSpread({}, dataLabelTheme), {}, {
                          color: dataLabelTheme.useSeriesColor ? getRGBA(fillColor, 1) : dataLabelTheme.color
                        })
                      });
                    });
                  });
                }
              }, {
                key: "getResponderSeriesWithTheme",
                value: function getResponderSeriesWithTheme(models, type, seriesColor) {
                  var _ref7 = this.theme[type].dot, radius = _ref7.radius, color = _ref7.color, borderWidth = _ref7.borderWidth, borderColor = _ref7.borderColor;
                  return models.map(function(model) {
                    var _ref8;
                    var modelColor = (_ref8 = color !== null && color !== void 0 ? color : model.color) !== null && _ref8 !== void 0 ? _ref8 : seriesColor;
                    return areaSeries_objectSpread(areaSeries_objectSpread({}, model), {}, {
                      radius,
                      color: modelColor,
                      style: [{
                        lineWidth: borderWidth,
                        strokeStyle: borderColor !== null && borderColor !== void 0 ? borderColor : getRGBA(modelColor, 0.5)
                      }]
                    });
                  });
                }
              }, {
                key: "onClick",
                value: function onClick(_ref9) {
                  var responders = _ref9.responders, mousePosition = _ref9.mousePosition;
                  if (this.selectable) {
                    var models;
                    if (this.eventDetectType === "near") {
                      models = responders;
                    } else {
                      models = this.getCircleModelsFromRectResponders(responders, mousePosition);
                    }
                    this.eventBus.emit("renderSelectedSeries", {
                      models: this.getResponderSeriesWithTheme(models, "select"),
                      name: this.name
                    });
                    this.eventBus.emit("needDraw");
                  }
                }
              }, {
                key: "getResponderCategoryByIndex",
                value: function getResponderCategoryByIndex(index) {
                  var _responder$data;
                  var responder = Object.values(this.tooltipCircleMap).flatMap(function(val) {
                    return val;
                  }).find(function(model) {
                    return model.index === index;
                  });
                  return responder === null || responder === void 0 ? void 0 : (_responder$data = responder.data) === null || _responder$data === void 0 ? void 0 : _responder$data.category;
                }
              }]);
              return AreaSeries2;
            }(Component);
            ;
            function areaChart_typeof(obj) {
              "@babel/helpers - typeof";
              if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                areaChart_typeof = function _typeof2(obj2) {
                  return typeof obj2;
                };
              } else {
                areaChart_typeof = function _typeof2(obj2) {
                  return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                };
              }
              return areaChart_typeof(obj);
            }
            function areaChart_ownKeys(object, enumerableOnly) {
              var keys = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object);
                if (enumerableOnly) {
                  symbols = symbols.filter(function(sym) {
                    return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                  });
                }
                keys.push.apply(keys, symbols);
              }
              return keys;
            }
            function areaChart_objectSpread(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i] != null ? arguments[i] : {};
                if (i % 2) {
                  areaChart_ownKeys(Object(source), true).forEach(function(key) {
                    areaChart_defineProperty(target, key, source[key]);
                  });
                } else if (Object.getOwnPropertyDescriptors) {
                  Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                } else {
                  areaChart_ownKeys(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  });
                }
              }
              return target;
            }
            function areaChart_defineProperty(obj, key, value) {
              if (key in obj) {
                Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
              } else {
                obj[key] = value;
              }
              return obj;
            }
            function areaChart_classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function areaChart_defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            function areaChart_createClass(Constructor, protoProps, staticProps) {
              if (protoProps)
                areaChart_defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                areaChart_defineProperties(Constructor, staticProps);
              return Constructor;
            }
            function areaChart_get(target, property, receiver) {
              if (typeof Reflect !== "undefined" && Reflect.get) {
                areaChart_get = Reflect.get;
              } else {
                areaChart_get = function _get2(target2, property2, receiver2) {
                  var base = areaChart_superPropBase(target2, property2);
                  if (!base)
                    return;
                  var desc = Object.getOwnPropertyDescriptor(base, property2);
                  if (desc.get) {
                    return desc.get.call(receiver2);
                  }
                  return desc.value;
                };
              }
              return areaChart_get(target, property, receiver || target);
            }
            function areaChart_superPropBase(object, property) {
              while (!Object.prototype.hasOwnProperty.call(object, property)) {
                object = areaChart_getPrototypeOf(object);
                if (object === null)
                  break;
              }
              return object;
            }
            function areaChart_inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function");
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
              if (superClass)
                areaChart_setPrototypeOf(subClass, superClass);
            }
            function areaChart_setPrototypeOf(o, p) {
              areaChart_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
                o2.__proto__ = p2;
                return o2;
              };
              return areaChart_setPrototypeOf(o, p);
            }
            function areaChart_createSuper(Derived) {
              var hasNativeReflectConstruct = areaChart_isNativeReflectConstruct();
              return function _createSuperInternal() {
                var Super = areaChart_getPrototypeOf(Derived), result;
                if (hasNativeReflectConstruct) {
                  var NewTarget = areaChart_getPrototypeOf(this).constructor;
                  result = Reflect.construct(Super, arguments, NewTarget);
                } else {
                  result = Super.apply(this, arguments);
                }
                return areaChart_possibleConstructorReturn(this, result);
              };
            }
            function areaChart_possibleConstructorReturn(self2, call) {
              if (call && (areaChart_typeof(call) === "object" || typeof call === "function")) {
                return call;
              }
              return areaChart_assertThisInitialized(self2);
            }
            function areaChart_assertThisInitialized(self2) {
              if (self2 === void 0) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return self2;
            }
            function areaChart_isNativeReflectConstruct() {
              if (typeof Reflect === "undefined" || !Reflect.construct)
                return false;
              if (Reflect.construct.sham)
                return false;
              if (typeof Proxy === "function")
                return true;
              try {
                Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                }));
                return true;
              } catch (e) {
                return false;
              }
            }
            function areaChart_getPrototypeOf(o) {
              areaChart_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
                return o2.__proto__ || Object.getPrototypeOf(o2);
              };
              return areaChart_getPrototypeOf(o);
            }
            var AreaChart = function(_Chart) {
              areaChart_inherits(AreaChart2, _Chart);
              var _super = areaChart_createSuper(AreaChart2);
              function AreaChart2(props) {
                areaChart_classCallCheck(this, AreaChart2);
                return _super.call(this, {
                  el: props.el,
                  options: props.options,
                  series: {
                    area: props.data.series
                  },
                  categories: props.data.categories,
                  modules: [store_stackSeriesData, store_dataRange, store_scale, store_axes, store_plot]
                });
              }
              areaChart_createClass(AreaChart2, [{
                key: "initialize",
                value: function initialize() {
                  areaChart_get(areaChart_getPrototypeOf(AreaChart2.prototype), "initialize", this).call(this);
                  this.componentManager.add(Background);
                  this.componentManager.add(Title);
                  this.componentManager.add(Plot);
                  this.componentManager.add(Legend);
                  this.componentManager.add(AreaSeries);
                  this.componentManager.add(Axis, {
                    name: "xAxis"
                  });
                  this.componentManager.add(Axis, {
                    name: "yAxis"
                  });
                  this.componentManager.add(Axis, {
                    name: "secondaryYAxis"
                  });
                  this.componentManager.add(DataLabels);
                  this.componentManager.add(AxisTitle, {
                    name: "xAxis"
                  });
                  this.componentManager.add(AxisTitle, {
                    name: "yAxis"
                  });
                  this.componentManager.add(AxisTitle, {
                    name: "secondaryYAxis"
                  });
                  this.componentManager.add(ExportMenu, {
                    chartEl: this.el
                  });
                  this.componentManager.add(HoveredSeries);
                  this.componentManager.add(SelectedSeries);
                  this.componentManager.add(Tooltip, {
                    chartEl: this.el
                  });
                  this.componentManager.add(ResetButton);
                  this.componentManager.add(RangeSelection);
                  this.componentManager.add(NoDataText);
                  this.painter.addGroups([basic_namespaceObject, axis_namespaceObject, brushes_lineSeries_namespaceObject, legend_namespaceObject, label_namespaceObject, brushes_exportMenu_namespaceObject, dataLabel_namespaceObject, brushes_resetButton_namespaceObject]);
                }
                /**
                 * Add data.
                 * @param {Array} data - Array of data to be added.
                 * @param {string} category - Category to be added.
                 * @api
                 * @example
                 * chart.addData([10, 20], '6');
                 */
              }, {
                key: "addData",
                value: function addData(data, category2) {
                  this.resetSeries();
                  this.animationControlFlag.updating = true;
                  this.store.dispatch("addData", {
                    data,
                    category: category2
                  });
                }
                /**
                 * Add series.
                 * @param {Object} data - Data to be added.
                 *   @param {string} data.name - Series name.
                 *   @param {Array<number|Array<number>>} data.data - Array of data to be added.
                 * @api
                 * @example
                 * chart.addSeries({
                 *   name: 'newSeries',
                 *   data: [10, 100, 50, 40, 70, 55, 33, 70, 90, 110],
                 * });
                 */
              }, {
                key: "addSeries",
                value: function addSeries(data) {
                  this.resetSeries();
                  this.store.dispatch("addSeries", {
                    data
                  });
                }
                /**
                 * Convert the chart data to new data.
                 * @param {Object} data - Data to be set
                 * @api
                 * @example
                 * chart.setData({
                 *   categories: ['1', '2', '3'],
                 *   series: [
                 *     {
                 *       name: 'new series',
                 *       data: [1, 2, 3],
                 *     },
                 *     {
                 *       name: 'new series2',
                 *       data: [4, 5, 6],
                 *     }
                 *   ]
                 * });
                 */
              }, {
                key: "setData",
                value: function setData(data) {
                  var categories = data.categories, series = data.series;
                  this.resetSeries();
                  this.store.dispatch("setData", {
                    series: {
                      area: series
                    },
                    categories
                  });
                }
                /**
                 * Add plot line.
                 * @param {Object} data - Plot info.
                 *   @param {string|number} data.value - The value where the plot line will be drawn.
                 *   @param {string} data.color - Plot line color.
                 *   @param {string} [data.id] - Plot id. The value on which the removePlotLine is based.
                 * @api
                 * @example
                 * chart.addPlotLine({
                 *   value: 2,
                 *   color: '#00ff22',
                 *   id: 'plot-1',
                 * });
                 */
              }, {
                key: "addPlotLine",
                value: function addPlotLine(data) {
                  this.store.dispatch("addPlotLine", {
                    data
                  });
                }
                /**
                 * Remove plot line with id.
                 * @param {string} id - Id of the plot line to be removed.
                 * @api
                 * @example
                 * chart.removePlotLine('plot-1');
                 */
              }, {
                key: "removePlotLine",
                value: function removePlotLine(id) {
                  this.store.dispatch("removePlotLine", {
                    id
                  });
                }
                /**
                 * Add plot band.
                 * @param {Object} data - Plot info.
                 * @param {Array<string|number>} data.range - The range to be drawn.
                 * @param {string} data.color - Plot band color.
                 * @param {string} [data.id] - Plot id. The value on which the removePlotBand is based.
                 * @api
                 * @example
                 * chart.addPlotBand({
                 *   value: [2, 4],
                 *   color: '#00ff22',
                 *   id: 'plot-1',
                 * });
                 */
              }, {
                key: "addPlotBand",
                value: function addPlotBand(data) {
                  this.store.dispatch("addPlotBand", {
                    data
                  });
                }
                /**
                 * Remove plot band with id.
                 * @param {string} id - id of the plot band to be removed.
                 * @api
                 * @example
                 * chart.removePlotBand('plot-1');
                 */
              }, {
                key: "removePlotBand",
                value: function removePlotBand(id) {
                  this.store.dispatch("removePlotBand", {
                    id
                  });
                }
                /**
                 * Hide series data label.
                 * @api
                 * @example
                 * chart.hideSeriesDataLabel();
                 */
              }, {
                key: "hideSeriesDataLabel",
                value: function hideSeriesDataLabel() {
                  this.store.dispatch("updateOptions", {
                    options: {
                      series: {
                        dataLabels: {
                          visible: false
                        }
                      }
                    }
                  });
                }
                /**
                 * Show series data label.
                 * @api
                 * @example
                 * chart.showSeriesDataLabel();
                 */
              }, {
                key: "showSeriesDataLabel",
                value: function showSeriesDataLabel() {
                  this.store.dispatch("updateOptions", {
                    options: {
                      series: {
                        dataLabels: {
                          visible: true
                        }
                      }
                    }
                  });
                }
                /**
                 * Convert the chart options to new options.
                 * @param {Object} options - Chart options.
                 * @api
                 * @example
                 * chart.setOptions({
                 *   chart: {
                 *     width: 500,
                 *     height: 'auto',
                 *     title: 'Energy Usage',
                 *   },
                 *   xAxis: {
                 *     title: 'Month',
                 *     date: { format: 'yy/MM' },
                 *   },
                 *   yAxis: {
                 *     title: 'Energy (kWh)',
                 *   },
                 *   series: {
                 *     selectable: true,
                 *   },
                 *   tooltip: {
                 *     formatter: (value) => `${value}kWh`,
                 *   },
                 * });
                 */
              }, {
                key: "setOptions",
                value: function setOptions(options2) {
                  this.resetSeries();
                  this.dispatchOptionsEvent("initOptions", options2);
                }
                /**
                 * Update chart options.
                 * @param {Object} options - Chart options.
                 * @api
                 * @example
                 * chart.updateOptions({
                 *   chart: {
                 *     height: 'auto',
                 *     title: 'Energy Usage',
                 *   },
                 *   tooltip: {
                 *     formatter: (value) => `${value}kWh`,
                 *   },
                 * });
                 */
              }, {
                key: "updateOptions",
                value: function updateOptions(options2) {
                  this.resetSeries();
                  this.dispatchOptionsEvent("updateOptions", options2);
                }
                /**
                 * Show tooltip.
                 * @param {Object} seriesInfo - Information of the series for the tooltip to be displayed.
                 *      @param {number} seriesInfo.index - Index of data within series. If 'series.eventDetectType' is "grouped", only seriesIndex is needed.
                 *      @param {number} [seriesInfo.seriesIndex] - Index of series.
                 * @api
                 * @example
                 * chart.showTooltip({index: 1, seriesIndex: 2});
                 */
              }, {
                key: "showTooltip",
                value: function showTooltip(seriesInfo) {
                  this.eventBus.emit("showTooltip", areaChart_objectSpread({}, seriesInfo));
                }
                /**
                 * Hide tooltip.
                 * @api
                 * @example
                 * chart.hideTooltip();
                 */
              }, {
                key: "hideTooltip",
                value: function hideTooltip() {
                  this.eventBus.emit("hideTooltip");
                }
              }]);
              return AreaChart2;
            }(Chart);
            ;
            function scatterSeries_typeof(obj) {
              "@babel/helpers - typeof";
              if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                scatterSeries_typeof = function _typeof2(obj2) {
                  return typeof obj2;
                };
              } else {
                scatterSeries_typeof = function _typeof2(obj2) {
                  return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                };
              }
              return scatterSeries_typeof(obj);
            }
            function scatterSeries_toConsumableArray(arr) {
              return scatterSeries_arrayWithoutHoles(arr) || scatterSeries_iterableToArray(arr) || scatterSeries_unsupportedIterableToArray(arr) || scatterSeries_nonIterableSpread();
            }
            function scatterSeries_nonIterableSpread() {
              throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            function scatterSeries_unsupportedIterableToArray(o, minLen) {
              if (!o)
                return;
              if (typeof o === "string")
                return scatterSeries_arrayLikeToArray(o, minLen);
              var n = Object.prototype.toString.call(o).slice(8, -1);
              if (n === "Object" && o.constructor)
                n = o.constructor.name;
              if (n === "Map" || n === "Set")
                return Array.from(o);
              if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                return scatterSeries_arrayLikeToArray(o, minLen);
            }
            function scatterSeries_iterableToArray(iter) {
              if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
                return Array.from(iter);
            }
            function scatterSeries_arrayWithoutHoles(arr) {
              if (Array.isArray(arr))
                return scatterSeries_arrayLikeToArray(arr);
            }
            function scatterSeries_arrayLikeToArray(arr, len) {
              if (len == null || len > arr.length)
                len = arr.length;
              for (var i = 0, arr2 = new Array(len); i < len; i++) {
                arr2[i] = arr[i];
              }
              return arr2;
            }
            function component_scatterSeries_ownKeys(object, enumerableOnly) {
              var keys = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object);
                if (enumerableOnly) {
                  symbols = symbols.filter(function(sym) {
                    return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                  });
                }
                keys.push.apply(keys, symbols);
              }
              return keys;
            }
            function component_scatterSeries_objectSpread(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i] != null ? arguments[i] : {};
                if (i % 2) {
                  component_scatterSeries_ownKeys(Object(source), true).forEach(function(key) {
                    component_scatterSeries_defineProperty(target, key, source[key]);
                  });
                } else if (Object.getOwnPropertyDescriptors) {
                  Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                } else {
                  component_scatterSeries_ownKeys(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  });
                }
              }
              return target;
            }
            function scatterSeries_classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function scatterSeries_defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            function scatterSeries_createClass(Constructor, protoProps, staticProps) {
              if (protoProps)
                scatterSeries_defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                scatterSeries_defineProperties(Constructor, staticProps);
              return Constructor;
            }
            function scatterSeries_inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function");
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
              if (superClass)
                scatterSeries_setPrototypeOf(subClass, superClass);
            }
            function scatterSeries_setPrototypeOf(o, p) {
              scatterSeries_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
                o2.__proto__ = p2;
                return o2;
              };
              return scatterSeries_setPrototypeOf(o, p);
            }
            function scatterSeries_createSuper(Derived) {
              var hasNativeReflectConstruct = scatterSeries_isNativeReflectConstruct();
              return function _createSuperInternal() {
                var Super = scatterSeries_getPrototypeOf(Derived), result;
                if (hasNativeReflectConstruct) {
                  var NewTarget = scatterSeries_getPrototypeOf(this).constructor;
                  result = Reflect.construct(Super, arguments, NewTarget);
                } else {
                  result = Super.apply(this, arguments);
                }
                return scatterSeries_possibleConstructorReturn(this, result);
              };
            }
            function scatterSeries_possibleConstructorReturn(self2, call) {
              if (call && (scatterSeries_typeof(call) === "object" || typeof call === "function")) {
                return call;
              }
              return scatterSeries_assertThisInitialized(self2);
            }
            function scatterSeries_assertThisInitialized(self2) {
              if (self2 === void 0) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return self2;
            }
            function scatterSeries_isNativeReflectConstruct() {
              if (typeof Reflect === "undefined" || !Reflect.construct)
                return false;
              if (Reflect.construct.sham)
                return false;
              if (typeof Proxy === "function")
                return true;
              try {
                Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                }));
                return true;
              } catch (e) {
                return false;
              }
            }
            function scatterSeries_getPrototypeOf(o) {
              scatterSeries_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
                return o2.__proto__ || Object.getPrototypeOf(o2);
              };
              return scatterSeries_getPrototypeOf(o);
            }
            function component_scatterSeries_defineProperty(obj, key, value) {
              if (key in obj) {
                Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
              } else {
                obj[key] = value;
              }
              return obj;
            }
            var ScatterSeries = function(_Component) {
              scatterSeries_inherits(ScatterSeries2, _Component);
              var _super = scatterSeries_createSuper(ScatterSeries2);
              function ScatterSeries2() {
                var _this;
                scatterSeries_classCallCheck(this, ScatterSeries2);
                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }
                _this = _super.call.apply(_super, [this].concat(args));
                component_scatterSeries_defineProperty(scatterSeries_assertThisInitialized(_this), "theme", void 0);
                component_scatterSeries_defineProperty(scatterSeries_assertThisInitialized(_this), "models", {
                  series: []
                });
                component_scatterSeries_defineProperty(scatterSeries_assertThisInitialized(_this), "drawModels", void 0);
                component_scatterSeries_defineProperty(scatterSeries_assertThisInitialized(_this), "responders", void 0);
                component_scatterSeries_defineProperty(scatterSeries_assertThisInitialized(_this), "activatedResponders", []);
                component_scatterSeries_defineProperty(scatterSeries_assertThisInitialized(_this), "rect", void 0);
                component_scatterSeries_defineProperty(scatterSeries_assertThisInitialized(_this), "onMouseoutComponent", function() {
                  _this.eventBus.emit("seriesPointHovered", {
                    models: [],
                    name: _this.name
                  });
                  _this.eventBus.emit("renderHoveredSeries", {
                    models: [],
                    name: _this.name
                  });
                  _this.eventBus.emit("needDraw");
                });
                component_scatterSeries_defineProperty(scatterSeries_assertThisInitialized(_this), "getModelsForSelectInfo", function(info) {
                  var index = info.index, seriesIndex = info.seriesIndex, state = info.state;
                  if (!isNumber(index) || !isNumber(seriesIndex) || !isAvailableSelectSeries(info, "scatter")) {
                    return;
                  }
                  var name = state.series.scatter.data[seriesIndex].name;
                  return [_this.responders.filter(function(_ref) {
                    var dataName = _ref.name;
                    return dataName === name;
                  })[index]];
                });
                component_scatterSeries_defineProperty(scatterSeries_assertThisInitialized(_this), "selectSeries", function(info) {
                  var models = _this.getModelsForSelectInfo(info);
                  if (!models) {
                    return;
                  }
                  var closestModel = _this.getClosestModel(models);
                  if (!models.length) {
                    throw new Error(message.SELECT_SERIES_API_INDEX_ERROR);
                  }
                  _this.eventBus.emit("renderSelectedSeries", {
                    models: _this.getResponderAppliedTheme(closestModel, "select"),
                    name: _this.name
                  });
                  _this.eventBus.emit("needDraw");
                });
                component_scatterSeries_defineProperty(scatterSeries_assertThisInitialized(_this), "showTooltip", function(info) {
                  var models = _this.getModelsForSelectInfo(info);
                  if (!models) {
                    return;
                  }
                  _this.eventBus.emit("renderHoveredSeries", {
                    models,
                    name: _this.name
                  });
                  _this.activatedResponders = models;
                  _this.eventBus.emit("seriesPointHovered", {
                    models: _this.activatedResponders,
                    name: _this.name
                  });
                  _this.eventBus.emit("needDraw");
                });
                return _this;
              }
              scatterSeries_createClass(ScatterSeries2, [{
                key: "initialize",
                value: function initialize() {
                  this.type = "series";
                  this.name = "scatter";
                  this.eventBus.on("selectSeries", this.selectSeries);
                  this.eventBus.on("showTooltip", this.showTooltip);
                  this.eventBus.on("hideTooltip", this.onMouseoutComponent);
                }
              }, {
                key: "initUpdate",
                value: function initUpdate(delta) {
                  var _this2 = this;
                  this.drawModels.series.forEach(function(model, index) {
                    model.size = _this2.models.series[index].size * delta;
                  });
                }
              }, {
                key: "render",
                value: function render(chartState) {
                  var _labelRange, _axes$xAxis, _this3 = this;
                  var layout2 = chartState.layout, series = chartState.series, scale2 = chartState.scale, legend2 = chartState.legend, options2 = chartState.options, theme2 = chartState.theme, axes2 = chartState.axes;
                  if (!series.scatter) {
                    throw new Error(message.noDataError(this.name));
                  }
                  var scatterData = series.scatter.data;
                  this.theme = theme2.series.scatter;
                  this.rect = layout2.plot;
                  this.activeSeriesMap = getActiveSeriesMap(legend2);
                  this.selectable = this.getSelectableOption(options2);
                  var limit = (_labelRange = (_axes$xAxis = axes2.xAxis) === null || _axes$xAxis === void 0 ? void 0 : _axes$xAxis.labelRange) !== null && _labelRange !== void 0 ? _labelRange : scale2.xAxis.limit;
                  var seriesModel = this.renderScatterPointsModel(scatterData, limit, scale2[getValueAxisName(options2, this.name, "yAxis")].limit);
                  var tooltipModel = this.makeTooltipModel(scatterData);
                  this.models.series = seriesModel;
                  if (!this.drawModels) {
                    this.drawModels = deepCopy(this.models);
                  }
                  this.responders = seriesModel.map(function(m, index) {
                    return component_scatterSeries_objectSpread(component_scatterSeries_objectSpread({}, m), {}, {
                      type: "circle",
                      detectionSize: 0,
                      radius: _this3.theme.size / 2,
                      color: m.fillColor,
                      style: [{
                        strokeStyle: m.borderColor,
                        lineWidth: m.borderWidth
                      }],
                      data: tooltipModel[index]
                    });
                  });
                }
              }, {
                key: "renderScatterPointsModel",
                value: function renderScatterPointsModel(seriesRawData, xAxisLimit, yAxisLimit) {
                  var _this4 = this;
                  return seriesRawData.flatMap(function(_ref2, seriesIndex) {
                    var data = _ref2.data, name = _ref2.name, seriesColor = _ref2.color, iconType = _ref2.iconType;
                    var models = [];
                    var active = _this4.activeSeriesMap[name];
                    var color = getRGBA(seriesColor, active ? 1 : 0.3);
                    data.forEach(function(datum, index) {
                      var rawXValue = getCoordinateXValue(datum);
                      var xValue = utils_isString(rawXValue) ? Number(new Date(rawXValue)) : Number(rawXValue);
                      var yValue = getCoordinateYValue(datum);
                      var xValueRatio = getValueRatio(xValue, xAxisLimit);
                      var yValueRatio = getValueRatio(yValue, yAxisLimit);
                      var x = xValueRatio * _this4.rect.width;
                      var y = (1 - yValueRatio) * _this4.rect.height;
                      models.push(component_scatterSeries_objectSpread({
                        x,
                        y,
                        type: "scatterSeries",
                        iconType,
                        seriesIndex,
                        name,
                        borderColor: color,
                        index
                      }, pick(_this4.theme, "borderWidth", "size", "fillColor")));
                    });
                    return models;
                  });
                }
              }, {
                key: "makeTooltipModel",
                value: function makeTooltipModel(circleData) {
                  return scatterSeries_toConsumableArray(circleData).flatMap(function(_ref3) {
                    var data = _ref3.data, name = _ref3.name, color = _ref3.color;
                    var tooltipData = [];
                    data.forEach(function(datum) {
                      var value = {
                        x: getCoordinateXValue(datum),
                        y: getCoordinateYValue(datum)
                      };
                      tooltipData.push({
                        label: name,
                        color,
                        value
                      });
                    });
                    return tooltipData;
                  });
                }
              }, {
                key: "getClosestModel",
                value: function getClosestModel(closestResponder) {
                  if (!closestResponder.length) {
                    return [];
                  }
                  var model = this.models.series.find(function(_ref4) {
                    var index = _ref4.index, seriesIndex = _ref4.seriesIndex;
                    return isNumber(index) && isNumber(seriesIndex) && index === closestResponder[0].index && seriesIndex === closestResponder[0].seriesIndex;
                  });
                  return model ? [model] : [];
                }
              }, {
                key: "getResponderAppliedTheme",
                value: function getResponderAppliedTheme(closestModel, type) {
                  var _this5 = this;
                  var _this$theme$type = this.theme[type], fillColor = _this$theme$type.fillColor, size = _this$theme$type.size;
                  return closestModel.map(function(m) {
                    return deepMergedCopy(m, component_scatterSeries_objectSpread(component_scatterSeries_objectSpread({}, _this5.theme[type]), {}, {
                      color: fillColor,
                      radius: size / 2
                    }));
                  });
                }
              }, {
                key: "onMousemove",
                value: function onMousemove(_ref5) {
                  var responders = _ref5.responders, mousePosition = _ref5.mousePosition;
                  var closestResponder = getNearestResponder(responders, mousePosition, this.rect);
                  var closestModel = this.getClosestModel(closestResponder);
                  closestModel = this.getResponderAppliedTheme(closestModel, "hover");
                  this.eventBus.emit("renderHoveredSeries", {
                    models: closestModel,
                    name: this.name
                  });
                  this.activatedResponders = closestResponder;
                  this.eventBus.emit("seriesPointHovered", {
                    models: this.activatedResponders,
                    name: this.name
                  });
                  this.eventBus.emit("needDraw");
                }
              }, {
                key: "onClick",
                value: function onClick(_ref6) {
                  var responders = _ref6.responders, mousePosition = _ref6.mousePosition;
                  if (this.selectable) {
                    var closestResponder = getNearestResponder(responders, mousePosition, this.rect);
                    var closestModel = this.getClosestModel(closestResponder);
                    closestModel = this.getResponderAppliedTheme(closestModel, "select");
                    this.eventBus.emit("renderSelectedSeries", {
                      models: closestModel,
                      name: this.name
                    });
                    this.eventBus.emit("needDraw");
                  }
                }
              }]);
              return ScatterSeries2;
            }(Component);
            ;
            function lineScatterChart_typeof(obj) {
              "@babel/helpers - typeof";
              if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                lineScatterChart_typeof = function _typeof2(obj2) {
                  return typeof obj2;
                };
              } else {
                lineScatterChart_typeof = function _typeof2(obj2) {
                  return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                };
              }
              return lineScatterChart_typeof(obj);
            }
            function lineScatterChart_ownKeys(object, enumerableOnly) {
              var keys = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object);
                if (enumerableOnly) {
                  symbols = symbols.filter(function(sym) {
                    return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                  });
                }
                keys.push.apply(keys, symbols);
              }
              return keys;
            }
            function lineScatterChart_objectSpread(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i] != null ? arguments[i] : {};
                if (i % 2) {
                  lineScatterChart_ownKeys(Object(source), true).forEach(function(key) {
                    lineScatterChart_defineProperty(target, key, source[key]);
                  });
                } else if (Object.getOwnPropertyDescriptors) {
                  Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                } else {
                  lineScatterChart_ownKeys(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  });
                }
              }
              return target;
            }
            function lineScatterChart_defineProperty(obj, key, value) {
              if (key in obj) {
                Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
              } else {
                obj[key] = value;
              }
              return obj;
            }
            function lineScatterChart_classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function lineScatterChart_defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            function lineScatterChart_createClass(Constructor, protoProps, staticProps) {
              if (protoProps)
                lineScatterChart_defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                lineScatterChart_defineProperties(Constructor, staticProps);
              return Constructor;
            }
            function lineScatterChart_get(target, property, receiver) {
              if (typeof Reflect !== "undefined" && Reflect.get) {
                lineScatterChart_get = Reflect.get;
              } else {
                lineScatterChart_get = function _get2(target2, property2, receiver2) {
                  var base = lineScatterChart_superPropBase(target2, property2);
                  if (!base)
                    return;
                  var desc = Object.getOwnPropertyDescriptor(base, property2);
                  if (desc.get) {
                    return desc.get.call(receiver2);
                  }
                  return desc.value;
                };
              }
              return lineScatterChart_get(target, property, receiver || target);
            }
            function lineScatterChart_superPropBase(object, property) {
              while (!Object.prototype.hasOwnProperty.call(object, property)) {
                object = lineScatterChart_getPrototypeOf(object);
                if (object === null)
                  break;
              }
              return object;
            }
            function lineScatterChart_inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function");
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
              if (superClass)
                lineScatterChart_setPrototypeOf(subClass, superClass);
            }
            function lineScatterChart_setPrototypeOf(o, p) {
              lineScatterChart_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
                o2.__proto__ = p2;
                return o2;
              };
              return lineScatterChart_setPrototypeOf(o, p);
            }
            function lineScatterChart_createSuper(Derived) {
              var hasNativeReflectConstruct = lineScatterChart_isNativeReflectConstruct();
              return function _createSuperInternal() {
                var Super = lineScatterChart_getPrototypeOf(Derived), result;
                if (hasNativeReflectConstruct) {
                  var NewTarget = lineScatterChart_getPrototypeOf(this).constructor;
                  result = Reflect.construct(Super, arguments, NewTarget);
                } else {
                  result = Super.apply(this, arguments);
                }
                return lineScatterChart_possibleConstructorReturn(this, result);
              };
            }
            function lineScatterChart_possibleConstructorReturn(self2, call) {
              if (call && (lineScatterChart_typeof(call) === "object" || typeof call === "function")) {
                return call;
              }
              return lineScatterChart_assertThisInitialized(self2);
            }
            function lineScatterChart_assertThisInitialized(self2) {
              if (self2 === void 0) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return self2;
            }
            function lineScatterChart_isNativeReflectConstruct() {
              if (typeof Reflect === "undefined" || !Reflect.construct)
                return false;
              if (Reflect.construct.sham)
                return false;
              if (typeof Proxy === "function")
                return true;
              try {
                Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                }));
                return true;
              } catch (e) {
                return false;
              }
            }
            function lineScatterChart_getPrototypeOf(o) {
              lineScatterChart_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
                return o2.__proto__ || Object.getPrototypeOf(o2);
              };
              return lineScatterChart_getPrototypeOf(o);
            }
            var LineScatterChart = function(_Chart) {
              lineScatterChart_inherits(LineScatterChart2, _Chart);
              var _super = lineScatterChart_createSuper(LineScatterChart2);
              function LineScatterChart2(props) {
                lineScatterChart_classCallCheck(this, LineScatterChart2);
                return _super.call(this, {
                  el: props.el,
                  options: props.options,
                  series: props.data.series,
                  modules: [store_dataRange, store_scale, store_axes, store_plot]
                });
              }
              lineScatterChart_createClass(LineScatterChart2, [{
                key: "initialize",
                value: function initialize() {
                  lineScatterChart_get(lineScatterChart_getPrototypeOf(LineScatterChart2.prototype), "initialize", this).call(this);
                  this.componentManager.add(Background);
                  this.componentManager.add(Title);
                  this.componentManager.add(Plot);
                  this.componentManager.add(Legend);
                  this.componentManager.add(LineSeries);
                  this.componentManager.add(ScatterSeries);
                  this.componentManager.add(Axis, {
                    name: "yAxis"
                  });
                  this.componentManager.add(Axis, {
                    name: "xAxis"
                  });
                  this.componentManager.add(Axis, {
                    name: "secondaryYAxis"
                  });
                  this.componentManager.add(DataLabels);
                  this.componentManager.add(AxisTitle, {
                    name: "xAxis"
                  });
                  this.componentManager.add(AxisTitle, {
                    name: "yAxis"
                  });
                  this.componentManager.add(AxisTitle, {
                    name: "secondaryYAxis"
                  });
                  this.componentManager.add(ExportMenu, {
                    chartEl: this.el
                  });
                  this.componentManager.add(HoveredSeries);
                  this.componentManager.add(SelectedSeries);
                  this.componentManager.add(Tooltip, {
                    chartEl: this.el
                  });
                  this.componentManager.add(RangeSelection);
                  this.componentManager.add(NoDataText);
                  this.painter.addGroups([basic_namespaceObject, axis_namespaceObject, brushes_lineSeries_namespaceObject, legend_namespaceObject, label_namespaceObject, brushes_exportMenu_namespaceObject, dataLabel_namespaceObject, brushes_resetButton_namespaceObject, scatterSeries_namespaceObject]);
                }
                /**
                 * Add data.
                 * @param {Array} data - Array of data to be added.
                 * @param {string} chartType - Which type of chart to add.
                 * @api
                 * @example
                 * chart.addData([{x: 10, y: 20}, {x: 30, y: 40}], 'line');
                 */
              }, {
                key: "addData",
                value: function addData(data, chartType) {
                  this.animationControlFlag.updating = true;
                  this.resetSeries();
                  this.store.dispatch("addData", {
                    data,
                    chartType
                  });
                }
                /**
                 * Add series.
                 * @param {Object} data - Data to be added.
                 *   @param {string} data.name - Series name.
                 *   @param {Array<Object>} data.data - Array of data to be added.
                 * @param {Object} dataInfo - Which type of chart to add.
                 *   @param {Object} dataInfo.chartType - Chart type.
                 * @api
                 * @example
                 * chart.addSeries(
                 *   {
                 *     name: 'newSeries',
                 *     data: [{x: 10, y: 20}, {x: 30, y: 40}],
                 *   },
                 *   {
                 *     chartType: 'line'
                 *   });
                 */
              }, {
                key: "addSeries",
                value: function addSeries(data, dataInfo) {
                  this.resetSeries();
                  this.store.dispatch("addSeries", lineScatterChart_objectSpread({
                    data
                  }, dataInfo));
                }
                /**
                 * Convert the chart data to new data.
                 * @param {Object} data - Data to be set
                 * @api
                 * @example
                 * chart.setData({
                 *   series: {
                 *     line: [
                 *       {
                 *         name: 'A',
                 *         data: [{x: 10, y: 20}, {x: 30, y: 40}],
                 *       }
                 *     ],
                 *     scatter: [
                 *       {
                 *         name: 'B',
                 *         data: [{x: 30, y: 20}, {x: 40, y: 40}],
                 *       }
                 *     ]
                 *   }
                 * });
                 */
              }, {
                key: "setData",
                value: function setData(data) {
                  this.resetSeries();
                  this.store.dispatch("setData", data);
                }
                /**
                 * Convert the chart options to new options.
                 * @param {Object} options - Chart options
                 * @api
                 * @example
                 * chart.setOptions({
                 *   chart: {
                 *     width: 500,
                 *     height: 'auto',
                 *     title: 'Energy Usage',
                 *   },
                 *   xAxis: {
                 *     title: 'Month',
                 *     date: { format: 'yy/MM' },
                 *   },
                 *   yAxis: {
                 *     title: 'Energy (kWh)',
                 *   },
                 *   series: {
                 *     line: {
                 *       showDot: true,
                 *     },
                 *     selectable: true,
                 *   },
                 *   tooltip: {
                 *     formatter: (value) => `${value}kWh`,
                 *   },
                 * });
                 */
              }, {
                key: "setOptions",
                value: function setOptions(options2) {
                  this.resetSeries();
                  this.dispatchOptionsEvent("initOptions", options2);
                }
                /**
                 * Update chart options.
                 * @param {Object} options - Chart options
                 * @api
                 * @example
                 * chart.updateOptions({
                 *   chart: {
                 *     height: 'auto',
                 *     title: 'Energy Usage',
                 *   },
                 *   series: {
                 *     line: {
                 *       showDot: true,
                 *     },
                 *   },
                 * });
                 */
              }, {
                key: "updateOptions",
                value: function updateOptions(options2) {
                  this.resetSeries();
                  this.dispatchOptionsEvent("updateOptions", options2);
                }
                /**
                 * Show tooltip.
                 * @param {Object} seriesInfo - Information of the series for the tooltip to be displayed
                 *      @param {number} seriesInfo.seriesIndex - Index of series
                 *      @param {number} seriesInfo.index - Index of data within series
                 *      @param {string} seriesInfo.chartType - Specify which chart to select.
                 * @api
                 * @example
                 * chart.showTooltip({index: 1, seriesIndex: 2, chartType: 'scatter'});
                 */
              }, {
                key: "showTooltip",
                value: function showTooltip(seriesInfo) {
                  this.eventBus.emit("showTooltip", lineScatterChart_objectSpread(lineScatterChart_objectSpread({}, seriesInfo), {}, {
                    state: this.store.state
                  }));
                }
                /**
                 * Hide tooltip.
                 * @api
                 * @example
                 * chart.hideTooltip();
                 */
              }, {
                key: "hideTooltip",
                value: function hideTooltip() {
                  this.eventBus.emit("hideTooltip");
                }
              }]);
              return LineScatterChart2;
            }(Chart);
            ;
            function lineAreaChart_typeof(obj) {
              "@babel/helpers - typeof";
              if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                lineAreaChart_typeof = function _typeof2(obj2) {
                  return typeof obj2;
                };
              } else {
                lineAreaChart_typeof = function _typeof2(obj2) {
                  return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                };
              }
              return lineAreaChart_typeof(obj);
            }
            function lineAreaChart_ownKeys(object, enumerableOnly) {
              var keys = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object);
                if (enumerableOnly) {
                  symbols = symbols.filter(function(sym) {
                    return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                  });
                }
                keys.push.apply(keys, symbols);
              }
              return keys;
            }
            function lineAreaChart_objectSpread(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i] != null ? arguments[i] : {};
                if (i % 2) {
                  lineAreaChart_ownKeys(Object(source), true).forEach(function(key) {
                    lineAreaChart_defineProperty(target, key, source[key]);
                  });
                } else if (Object.getOwnPropertyDescriptors) {
                  Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                } else {
                  lineAreaChart_ownKeys(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  });
                }
              }
              return target;
            }
            function lineAreaChart_defineProperty(obj, key, value) {
              if (key in obj) {
                Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
              } else {
                obj[key] = value;
              }
              return obj;
            }
            function lineAreaChart_classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function lineAreaChart_defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            function lineAreaChart_createClass(Constructor, protoProps, staticProps) {
              if (protoProps)
                lineAreaChart_defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                lineAreaChart_defineProperties(Constructor, staticProps);
              return Constructor;
            }
            function lineAreaChart_get(target, property, receiver) {
              if (typeof Reflect !== "undefined" && Reflect.get) {
                lineAreaChart_get = Reflect.get;
              } else {
                lineAreaChart_get = function _get2(target2, property2, receiver2) {
                  var base = lineAreaChart_superPropBase(target2, property2);
                  if (!base)
                    return;
                  var desc = Object.getOwnPropertyDescriptor(base, property2);
                  if (desc.get) {
                    return desc.get.call(receiver2);
                  }
                  return desc.value;
                };
              }
              return lineAreaChart_get(target, property, receiver || target);
            }
            function lineAreaChart_superPropBase(object, property) {
              while (!Object.prototype.hasOwnProperty.call(object, property)) {
                object = lineAreaChart_getPrototypeOf(object);
                if (object === null)
                  break;
              }
              return object;
            }
            function lineAreaChart_inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function");
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
              if (superClass)
                lineAreaChart_setPrototypeOf(subClass, superClass);
            }
            function lineAreaChart_setPrototypeOf(o, p) {
              lineAreaChart_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
                o2.__proto__ = p2;
                return o2;
              };
              return lineAreaChart_setPrototypeOf(o, p);
            }
            function lineAreaChart_createSuper(Derived) {
              var hasNativeReflectConstruct = lineAreaChart_isNativeReflectConstruct();
              return function _createSuperInternal() {
                var Super = lineAreaChart_getPrototypeOf(Derived), result;
                if (hasNativeReflectConstruct) {
                  var NewTarget = lineAreaChart_getPrototypeOf(this).constructor;
                  result = Reflect.construct(Super, arguments, NewTarget);
                } else {
                  result = Super.apply(this, arguments);
                }
                return lineAreaChart_possibleConstructorReturn(this, result);
              };
            }
            function lineAreaChart_possibleConstructorReturn(self2, call) {
              if (call && (lineAreaChart_typeof(call) === "object" || typeof call === "function")) {
                return call;
              }
              return lineAreaChart_assertThisInitialized(self2);
            }
            function lineAreaChart_assertThisInitialized(self2) {
              if (self2 === void 0) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return self2;
            }
            function lineAreaChart_isNativeReflectConstruct() {
              if (typeof Reflect === "undefined" || !Reflect.construct)
                return false;
              if (Reflect.construct.sham)
                return false;
              if (typeof Proxy === "function")
                return true;
              try {
                Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                }));
                return true;
              } catch (e) {
                return false;
              }
            }
            function lineAreaChart_getPrototypeOf(o) {
              lineAreaChart_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
                return o2.__proto__ || Object.getPrototypeOf(o2);
              };
              return lineAreaChart_getPrototypeOf(o);
            }
            var LineAreaChart = function(_Chart) {
              lineAreaChart_inherits(LineAreaChart2, _Chart);
              var _super = lineAreaChart_createSuper(LineAreaChart2);
              function LineAreaChart2(props) {
                lineAreaChart_classCallCheck(this, LineAreaChart2);
                return _super.call(this, {
                  el: props.el,
                  options: props.options,
                  series: props.data.series,
                  categories: props.data.categories,
                  modules: [store_stackSeriesData, store_dataRange, store_scale, store_axes, store_plot]
                });
              }
              lineAreaChart_createClass(LineAreaChart2, [{
                key: "initialize",
                value: function initialize() {
                  lineAreaChart_get(lineAreaChart_getPrototypeOf(LineAreaChart2.prototype), "initialize", this).call(this);
                  this.componentManager.add(Background);
                  this.componentManager.add(Title);
                  this.componentManager.add(Plot);
                  this.componentManager.add(Legend);
                  this.componentManager.add(AreaSeries);
                  this.componentManager.add(LineSeries);
                  this.componentManager.add(Axis, {
                    name: "yAxis"
                  });
                  this.componentManager.add(Axis, {
                    name: "xAxis"
                  });
                  this.componentManager.add(Axis, {
                    name: "secondaryYAxis"
                  });
                  this.componentManager.add(DataLabels);
                  this.componentManager.add(AxisTitle, {
                    name: "xAxis"
                  });
                  this.componentManager.add(AxisTitle, {
                    name: "yAxis"
                  });
                  this.componentManager.add(AxisTitle, {
                    name: "secondaryYAxis"
                  });
                  this.componentManager.add(ExportMenu, {
                    chartEl: this.el
                  });
                  this.componentManager.add(HoveredSeries);
                  this.componentManager.add(SelectedSeries);
                  this.componentManager.add(Tooltip, {
                    chartEl: this.el
                  });
                  this.componentManager.add(RangeSelection);
                  this.componentManager.add(ResetButton);
                  this.componentManager.add(NoDataText);
                  this.painter.addGroups([basic_namespaceObject, axis_namespaceObject, brushes_lineSeries_namespaceObject, legend_namespaceObject, label_namespaceObject, brushes_exportMenu_namespaceObject, dataLabel_namespaceObject, brushes_resetButton_namespaceObject]);
                }
                /**
                 * Add data.
                 * @param {Array<number>} data - Array of data to be added.
                 * @param {string} category - Category to be added.
                 * @param {string} chartType - Which type of chart to add.
                 * @api
                 * @example
                 * chart.addData([10, 20], '6', 'line');
                 */
              }, {
                key: "addData",
                value: function addData(data, category2, chartType) {
                  this.animationControlFlag.updating = true;
                  this.resetSeries();
                  this.store.dispatch("addData", {
                    data,
                    category: category2,
                    chartType
                  });
                }
                /**
                 * Add series.
                 * @param {Object} data - Data to be added.
                 *   @param {string} data.name - Series name.
                 *   @param {Array<number>} data.data - Array of data to be added.
                 * @param {Object} dataInfo - Which type of chart to add.
                 *   @param {Object} dataInfo.chartType - Chart type.
                 * @api
                 * @example
                 * chart.addSeries(
                 *   {
                 *     name: 'newSeries',
                 *     data: [10, 100, 50, 40, 70, 55, 33, 70, 90, 110],
                 *   },
                 *   {
                 *     chartType: 'line'
                 *   });
                 */
              }, {
                key: "addSeries",
                value: function addSeries(data, dataInfo) {
                  this.resetSeries();
                  this.store.dispatch("addSeries", lineAreaChart_objectSpread({
                    data
                  }, dataInfo));
                }
                /**
                 * Convert the chart data to new data.
                 * @param {Object} data - Data to be set
                 * @api
                 * @example
                 * chart.setData({
                 *   categories: ['1', '2', '3'],
                 *   series: {
                 *     line: [
                 *       {
                 *         name: 'A',
                 *         data: [1, 2, 3],
                 *       }
                 *     ],
                 *     area: [
                 *       {
                 *         name: 'B',
                 *         data: [4, 5, 6],
                 *       }
                 *     ]
                 *   }
                 * });
                 */
              }, {
                key: "setData",
                value: function setData(data) {
                  this.resetSeries();
                  this.store.dispatch("setData", data);
                }
                /**
                 * Add plot line.
                 * @param {Object} data - plot info
                 *   @param {string|number} data.value - The value where the plot line will be drawn.
                 *   @param {string} data.color - Plot line color.
                 *   @param {string} [data.id] - Plot id. The value on which the removePlotLine is based.
                 * @api
                 * @example
                 * chart.addPlotLine({
                 *   value: 2,
                 *   color: '#00ff22',
                 *   id: 'plot-1',
                 * });
                 */
              }, {
                key: "addPlotLine",
                value: function addPlotLine(data) {
                  this.store.dispatch("addPlotLine", {
                    data
                  });
                }
                /**
                 * Remove plot line with id.
                 * @param {string} id - Id of the plot line to be removed.
                 * @api
                 * @example
                 * chart.removePlotLine('plot-1');
                 */
              }, {
                key: "removePlotLine",
                value: function removePlotLine(id) {
                  this.store.dispatch("removePlotLine", {
                    id
                  });
                }
                /**
                 * Add plot band.
                 * @param {Object} data - Plot info.
                 * @param {Array<string|number>} data.range - The range to be drawn.
                 * @param {string} data.color - Plot band color.
                 * @param {string} [data.id] - Plot id. The value on which the removePlotBand is based.
                 * @api
                 * @example
                 * chart.addPlotBand({
                 *   value: [2, 4],
                 *   color: '#00ff22',
                 *   id: 'plot-1',
                 * });
                 */
              }, {
                key: "addPlotBand",
                value: function addPlotBand(data) {
                  this.store.dispatch("addPlotBand", {
                    data
                  });
                }
                /**
                 * Remove plot band with id.
                 * @param {string} id - Id of the plot band to be removed.
                 * @api
                 * @example
                 * chart.removePlotBand('plot-1');
                 */
              }, {
                key: "removePlotBand",
                value: function removePlotBand(id) {
                  this.store.dispatch("removePlotBand", {
                    id
                  });
                }
                /**
                 * Hide series data label.
                 * @api
                 * @example
                 * chart.hideSeriesDataLabel();
                 */
              }, {
                key: "hideSeriesDataLabel",
                value: function hideSeriesDataLabel() {
                  this.store.dispatch("updateOptions", {
                    options: {
                      series: {
                        dataLabels: {
                          visible: false
                        }
                      }
                    }
                  });
                }
                /**
                 * Show series data label.
                 * @api
                 * @example
                 * chart.showSeriesDataLabel();
                 */
              }, {
                key: "showSeriesDataLabel",
                value: function showSeriesDataLabel() {
                  this.store.dispatch("updateOptions", {
                    options: {
                      series: {
                        dataLabels: {
                          visible: true
                        }
                      }
                    }
                  });
                }
                /**
                 * Convert the chart options to new options.
                 * @param {Object} options - Chart options.
                 * @api
                 * @example
                 * chart.setOptions({
                 *   chart: {
                 *     width: 500,
                 *     height: 'auto',
                 *     title: 'Energy Usage',
                 *   },
                 *   xAxis: {
                 *     title: 'Month',
                 *     date: { format: 'yy/MM' },
                 *   },
                 *   yAxis: {
                 *     title: 'Energy (kWh)',
                 *   },
                 *   series: {
                 *     line: {
                 *       showDot: true
                 *     },
                 *     selectable: true,
                 *   },
                 *   tooltip: {
                 *     formatter: (value) => `${value}kWh`,
                 *   },
                 * });
                 */
              }, {
                key: "setOptions",
                value: function setOptions(options2) {
                  this.resetSeries();
                  this.dispatchOptionsEvent("initOptions", options2);
                }
                /**
                 * Update chart options.
                 * @param {Object} options - Chart options.
                 * @api
                 * @example
                 * chart.updateOptions({
                 *   chart: {
                 *     height: 'auto',
                 *     title: 'Energy Usage',
                 *   },
                 *   series: {
                 *     line: {
                 *       showDot: true,
                 *     },
                 *   },
                 * });
                 */
              }, {
                key: "updateOptions",
                value: function updateOptions(options2) {
                  this.resetSeries();
                  this.dispatchOptionsEvent("updateOptions", options2);
                }
                /**
                 * Show tooltip.
                 * @param {Object} seriesInfo - Information of the series for the tooltip to be displayed.
                 *      @param {number} seriesInfo.seriesIndex - Index of series.
                 *      @param {number} seriesInfo.index - Index of data within series.
                 *      @param {string} seriesInfo.chartType - Specify which chart to select.
                 * @api
                 * @example
                 * chart.showTooltip({index: 1, seriesIndex: 2, chartType: 'line'});
                 */
              }, {
                key: "showTooltip",
                value: function showTooltip(seriesInfo) {
                  this.eventBus.emit("showTooltip", lineAreaChart_objectSpread({}, seriesInfo));
                }
                /**
                 * Hide tooltip.
                 * @api
                 * @example
                 * chart.hideTooltip();
                 */
              }, {
                key: "hideTooltip",
                value: function hideTooltip() {
                  this.eventBus.emit("hideTooltip");
                }
              }]);
              return LineAreaChart2;
            }(Chart);
            ;
            function limitNegative(value, min, max2) {
              var result = value;
              if (result >= max2) {
                return 0;
              }
              if (max2 < 0) {
                result = Math.min(value - max2, 0);
              }
              if (value < min) {
                result -= value - min;
              }
              return result;
            }
            function limitPositive(value, min, max2) {
              var result = value;
              if (min > 0) {
                result = Math.max(value - min, 0);
              }
              if (value > max2) {
                result -= value - max2;
              }
              return result;
            }
            function calibrateDrawingValue(value, min, max2) {
              return value < 0 ? limitNegative(value, min, max2) : limitPositive(value, min, max2);
            }
            function sumValuesBeforeIndex(values, targetIndex) {
              var includeTarget = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
              var target = values[targetIndex];
              return values.reduce(function(total, value, idx) {
                var isBefore = includeTarget ? idx <= targetIndex : idx < targetIndex;
                var isSameSign = value * target >= 0;
                return isBefore && isSameSign ? total + value : total;
              }, 0);
            }
            function outsideRange(values, currentIndex, min, max2) {
              var value = values[currentIndex];
              var totalOfIndexBefore = sumValuesBeforeIndex(values, currentIndex, false);
              var positive = value >= 0;
              var negative = value < 0;
              return positive && totalOfIndexBefore >= max2 || negative && totalOfIndexBefore <= min || currentIndex === 0 && positive && value < min || currentIndex === 0 && negative && value > max2;
            }
            function calibrateBoxStackDrawingValue(values, currentIndex, min, max2) {
              var totalOfIndexBefore = sumValuesBeforeIndex(values, currentIndex, false);
              var totalOfValues = sumValuesBeforeIndex(values, currentIndex, true);
              if (outsideRange(values, currentIndex, min, max2)) {
                return null;
              }
              if (currentIndex === 0) {
                return calibrateDrawingValue(values[currentIndex], min, max2);
              }
              if (totalOfIndexBefore < min && totalOfValues > max2) {
                return max2 - min;
              }
              var result = values[currentIndex];
              if (totalOfValues > max2) {
                result = max2 - totalOfIndexBefore;
              } else if (totalOfValues < min) {
                result = min - totalOfIndexBefore;
              } else if (totalOfIndexBefore < min) {
                result = totalOfValues - min;
              } else if (totalOfIndexBefore > max2) {
                result = totalOfValues - max2;
              }
              return result;
            }
            ;
            function boxSeries_typeof(obj) {
              "@babel/helpers - typeof";
              if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                boxSeries_typeof = function _typeof2(obj2) {
                  return typeof obj2;
                };
              } else {
                boxSeries_typeof = function _typeof2(obj2) {
                  return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                };
              }
              return boxSeries_typeof(obj);
            }
            function boxSeries_toConsumableArray(arr) {
              return boxSeries_arrayWithoutHoles(arr) || boxSeries_iterableToArray(arr) || boxSeries_unsupportedIterableToArray(arr) || boxSeries_nonIterableSpread();
            }
            function boxSeries_nonIterableSpread() {
              throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            function boxSeries_iterableToArray(iter) {
              if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
                return Array.from(iter);
            }
            function boxSeries_arrayWithoutHoles(arr) {
              if (Array.isArray(arr))
                return boxSeries_arrayLikeToArray(arr);
            }
            function boxSeries_ownKeys(object, enumerableOnly) {
              var keys = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object);
                if (enumerableOnly) {
                  symbols = symbols.filter(function(sym) {
                    return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                  });
                }
                keys.push.apply(keys, symbols);
              }
              return keys;
            }
            function boxSeries_objectSpread(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i] != null ? arguments[i] : {};
                if (i % 2) {
                  boxSeries_ownKeys(Object(source), true).forEach(function(key) {
                    boxSeries_defineProperty(target, key, source[key]);
                  });
                } else if (Object.getOwnPropertyDescriptors) {
                  Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                } else {
                  boxSeries_ownKeys(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  });
                }
              }
              return target;
            }
            function boxSeries_classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function boxSeries_defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            function boxSeries_createClass(Constructor, protoProps, staticProps) {
              if (protoProps)
                boxSeries_defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                boxSeries_defineProperties(Constructor, staticProps);
              return Constructor;
            }
            function boxSeries_inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function");
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
              if (superClass)
                boxSeries_setPrototypeOf(subClass, superClass);
            }
            function boxSeries_setPrototypeOf(o, p) {
              boxSeries_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
                o2.__proto__ = p2;
                return o2;
              };
              return boxSeries_setPrototypeOf(o, p);
            }
            function boxSeries_createSuper(Derived) {
              var hasNativeReflectConstruct = boxSeries_isNativeReflectConstruct();
              return function _createSuperInternal() {
                var Super = boxSeries_getPrototypeOf(Derived), result;
                if (hasNativeReflectConstruct) {
                  var NewTarget = boxSeries_getPrototypeOf(this).constructor;
                  result = Reflect.construct(Super, arguments, NewTarget);
                } else {
                  result = Super.apply(this, arguments);
                }
                return boxSeries_possibleConstructorReturn(this, result);
              };
            }
            function boxSeries_possibleConstructorReturn(self2, call) {
              if (call && (boxSeries_typeof(call) === "object" || typeof call === "function")) {
                return call;
              }
              return boxSeries_assertThisInitialized(self2);
            }
            function boxSeries_assertThisInitialized(self2) {
              if (self2 === void 0) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return self2;
            }
            function boxSeries_isNativeReflectConstruct() {
              if (typeof Reflect === "undefined" || !Reflect.construct)
                return false;
              if (Reflect.construct.sham)
                return false;
              if (typeof Proxy === "function")
                return true;
              try {
                Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                }));
                return true;
              } catch (e) {
                return false;
              }
            }
            function boxSeries_getPrototypeOf(o) {
              boxSeries_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
                return o2.__proto__ || Object.getPrototypeOf(o2);
              };
              return boxSeries_getPrototypeOf(o);
            }
            function boxSeries_defineProperty(obj, key, value) {
              if (key in obj) {
                Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
              } else {
                obj[key] = value;
              }
              return obj;
            }
            function boxSeries_slicedToArray(arr, i) {
              return boxSeries_arrayWithHoles(arr) || boxSeries_iterableToArrayLimit(arr, i) || boxSeries_unsupportedIterableToArray(arr, i) || boxSeries_nonIterableRest();
            }
            function boxSeries_nonIterableRest() {
              throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            function boxSeries_unsupportedIterableToArray(o, minLen) {
              if (!o)
                return;
              if (typeof o === "string")
                return boxSeries_arrayLikeToArray(o, minLen);
              var n = Object.prototype.toString.call(o).slice(8, -1);
              if (n === "Object" && o.constructor)
                n = o.constructor.name;
              if (n === "Map" || n === "Set")
                return Array.from(o);
              if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                return boxSeries_arrayLikeToArray(o, minLen);
            }
            function boxSeries_arrayLikeToArray(arr, len) {
              if (len == null || len > arr.length)
                len = arr.length;
              for (var i = 0, arr2 = new Array(len); i < len; i++) {
                arr2[i] = arr[i];
              }
              return arr2;
            }
            function boxSeries_iterableToArrayLimit(arr, i) {
              var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]);
              if (_i == null)
                return;
              var _arr = [];
              var _n = true;
              var _d = false;
              var _s, _e;
              try {
                for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
                  _arr.push(_s.value);
                  if (i && _arr.length === i)
                    break;
                }
              } catch (err) {
                _d = true;
                _e = err;
              } finally {
                try {
                  if (!_n && _i["return"] != null)
                    _i["return"]();
                } finally {
                  if (_d)
                    throw _e;
                }
              }
              return _arr;
            }
            function boxSeries_arrayWithHoles(arr) {
              if (Array.isArray(arr))
                return arr;
            }
            var SeriesDirection;
            (function(SeriesDirection2) {
              SeriesDirection2[SeriesDirection2["POSITIVE"] = 0] = "POSITIVE";
              SeriesDirection2[SeriesDirection2["NEGATIVE"] = 1] = "NEGATIVE";
              SeriesDirection2[SeriesDirection2["BOTH"] = 2] = "BOTH";
            })(SeriesDirection || (SeriesDirection = {}));
            var BOX = {
              BAR: "bar",
              COLUMN: "column"
            };
            function isLeftBottomSide(seriesIndex) {
              return !!(seriesIndex % 2);
            }
            function calculateBarLength(value, min, max2) {
              if (isRangeValue(value)) {
                var _value = boxSeries_slicedToArray(value, 2), start = _value[0], end = _value[1];
                if (start < min) {
                  start = min;
                }
                if (end > max2) {
                  end = max2;
                }
                return end - start;
              }
              return calibrateDrawingValue(value, min, max2);
            }
            var BoxSeries = function(_Component) {
              boxSeries_inherits(BoxSeries2, _Component);
              var _super = boxSeries_createSuper(BoxSeries2);
              function BoxSeries2() {
                var _this;
                boxSeries_classCallCheck(this, BoxSeries2);
                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }
                _this = _super.call.apply(_super, [this].concat(args));
                boxSeries_defineProperty(boxSeries_assertThisInitialized(_this), "models", {
                  series: []
                });
                boxSeries_defineProperty(boxSeries_assertThisInitialized(_this), "drawModels", void 0);
                boxSeries_defineProperty(boxSeries_assertThisInitialized(_this), "responders", void 0);
                boxSeries_defineProperty(boxSeries_assertThisInitialized(_this), "activatedResponders", []);
                boxSeries_defineProperty(boxSeries_assertThisInitialized(_this), "isBar", true);
                boxSeries_defineProperty(boxSeries_assertThisInitialized(_this), "valueAxis", "xAxis");
                boxSeries_defineProperty(boxSeries_assertThisInitialized(_this), "labelAxis", "yAxis");
                boxSeries_defineProperty(boxSeries_assertThisInitialized(_this), "anchorSizeKey", "height");
                boxSeries_defineProperty(boxSeries_assertThisInitialized(_this), "offsetSizeKey", "width");
                boxSeries_defineProperty(boxSeries_assertThisInitialized(_this), "basePosition", 0);
                boxSeries_defineProperty(boxSeries_assertThisInitialized(_this), "leftBasePosition", 0);
                boxSeries_defineProperty(boxSeries_assertThisInitialized(_this), "rightBasePosition", 0);
                boxSeries_defineProperty(boxSeries_assertThisInitialized(_this), "isRangeData", false);
                boxSeries_defineProperty(boxSeries_assertThisInitialized(_this), "offsetKey", "x");
                boxSeries_defineProperty(boxSeries_assertThisInitialized(_this), "eventDetectType", "point");
                boxSeries_defineProperty(boxSeries_assertThisInitialized(_this), "tooltipRectMap", void 0);
                boxSeries_defineProperty(boxSeries_assertThisInitialized(_this), "theme", void 0);
                boxSeries_defineProperty(boxSeries_assertThisInitialized(_this), "onMouseoutComponent", function() {
                  _this.eventBus.emit("seriesPointHovered", {
                    models: [],
                    name: _this.name
                  });
                  _this.eventBus.emit("renderHoveredSeries", {
                    models: [],
                    name: _this.name,
                    eventDetectType: _this.eventDetectType
                  });
                  _this.eventBus.emit("needDraw");
                });
                boxSeries_defineProperty(boxSeries_assertThisInitialized(_this), "selectSeries", function(info) {
                  var index = info.index, seriesIndex = info.seriesIndex;
                  if (!isAvailableSelectSeries(info, "column")) {
                    return;
                  }
                  var model = _this.tooltipRectMap[seriesIndex][index];
                  if (!model) {
                    throw new Error(message.SELECT_SERIES_API_INDEX_ERROR);
                  }
                  _this.eventBus.emit("renderSelectedSeries", {
                    models: _this.getRespondersWithTheme([model], "select"),
                    name: _this.name
                  });
                  _this.eventBus.emit("needDraw");
                });
                boxSeries_defineProperty(boxSeries_assertThisInitialized(_this), "showTooltip", function(info) {
                  var index = info.index, seriesIndex = info.seriesIndex;
                  if (!isAvailableShowTooltipInfo(info, _this.eventDetectType, "column")) {
                    return;
                  }
                  var models = _this.eventDetectType === "grouped" ? _this.getGroupedRect([_this.responders[index]], "hover") : _this.getRespondersWithTheme([_this.tooltipRectMap[index][seriesIndex]], "hover");
                  if (!models.length) {
                    return;
                  }
                  _this.eventBus.emit("renderHoveredSeries", {
                    models,
                    name: _this.name,
                    eventDetectType: _this.eventDetectType
                  });
                  _this.activatedResponders = _this.eventDetectType === "grouped" ? _this.tooltipRectMap[index] : models;
                  _this.eventBus.emit("seriesPointHovered", {
                    models: _this.activatedResponders,
                    name: _this.name
                  });
                  _this.eventBus.emit("needDraw");
                });
                return _this;
              }
              boxSeries_createClass(BoxSeries2, [{
                key: "initialize",
                value: function initialize(_ref) {
                  var name = _ref.name, stackChart = _ref.stackChart;
                  this.initializeFields(name);
                  if (!stackChart) {
                    this.eventBus.on("selectSeries", this.selectSeries);
                    this.eventBus.on("showTooltip", this.showTooltip);
                    this.eventBus.on("hideTooltip", this.onMouseoutComponent);
                  }
                }
              }, {
                key: "initializeFields",
                value: function initializeFields(name) {
                  this.type = "series";
                  this.name = name;
                  this.isBar = name === BOX.BAR;
                  this.offsetKey = this.isBar ? "x" : "y";
                  this.valueAxis = this.isBar ? "xAxis" : "yAxis";
                  this.labelAxis = this.isBar ? "yAxis" : "xAxis";
                  this.anchorSizeKey = this.isBar ? "height" : "width";
                  this.offsetSizeKey = this.isBar ? "width" : "height";
                }
              }, {
                key: "initUpdate",
                value: function initUpdate(delta) {
                  if (!this.drawModels) {
                    return;
                  }
                  if (this.isRangeData) {
                    this.initUpdateRangeData(delta);
                    return;
                  }
                  this.initUpdateClipRect(delta);
                  this.initUpdateConnector(delta);
                }
              }, {
                key: "initUpdateRangeData",
                value: function initUpdateRangeData(delta) {
                  var _this2 = this;
                  var series = this.drawModels.series;
                  this.drawModels.clipRect = this.models.clipRect;
                  var target = this.models.series;
                  series.forEach(function(current, index) {
                    var targetModel = target[index];
                    if (delta === 0) {
                      current[_this2.offsetSizeKey] = 0;
                    }
                    var offsetSize = current[_this2.offsetSizeKey] + (targetModel[_this2.offsetSizeKey] - current[_this2.offsetSizeKey]) * delta;
                    current[_this2.offsetSizeKey] = offsetSize;
                    if (!_this2.isBar) {
                      current[_this2.offsetKey] = targetModel[_this2.offsetKey] + targetModel[_this2.offsetSizeKey] - offsetSize;
                    }
                  });
                }
              }, {
                key: "initUpdateClipRect",
                value: function initUpdateClipRect(delta) {
                  var clipRect = this.drawModels.clipRect;
                  if (!clipRect) {
                    return;
                  }
                  var current = clipRect[0];
                  var key = this.offsetSizeKey;
                  var target = this.models.clipRect[0];
                  var offsetSize = current[key] + (target[key] - current[key]) * delta;
                  current[key] = offsetSize;
                  current[this.offsetKey] = Math.max(this.basePosition - offsetSize * this.basePosition / target[key], 0);
                }
              }, {
                key: "initUpdateConnector",
                value: function initUpdateConnector(delta) {
                  var connector = this.drawModels.connector;
                  if (!connector) {
                    return;
                  }
                  var target = this.models.connector;
                  connector.forEach(function(current, index) {
                    var alpha = getAlpha(target[index].strokeStyle) * delta;
                    current.strokeStyle = getRGBA(current.strokeStyle, alpha);
                  });
                }
              }, {
                key: "setEventDetectType",
                value: function setEventDetectType(series, options2) {
                  var _options$series;
                  if (series.line) {
                    this.eventDetectType = "grouped";
                  }
                  if (options2 !== null && options2 !== void 0 && (_options$series = options2.series) !== null && _options$series !== void 0 && _options$series.eventDetectType) {
                    this.eventDetectType = options2.series.eventDetectType;
                  }
                }
              }, {
                key: "getOptions",
                value: function getOptions(chartOptions) {
                  var options2 = boxSeries_objectSpread({}, chartOptions);
                  if (options2 !== null && options2 !== void 0 && options2.series && options2.series.column) {
                    options2.series = boxSeries_objectSpread(boxSeries_objectSpread({}, options2.series), options2.series.column);
                  }
                  return options2;
                }
              }, {
                key: "render",
                value: function render(chartState, computed2) {
                  var _ref2, _options$series2, _this3 = this;
                  var layout2 = chartState.layout, series = chartState.series, axes2 = chartState.axes, stackSeries = chartState.stackSeries, legend2 = chartState.legend, theme2 = chartState.theme, scale2 = chartState.scale;
                  this.isShow = !(stackSeries && stackSeries[this.name]);
                  if (!this.isShow) {
                    return;
                  }
                  var categories = (_ref2 = chartState.categories) !== null && _ref2 !== void 0 ? _ref2 : [];
                  var options2 = this.getOptions(chartState.options);
                  this.setEventDetectType(series, options2);
                  this.theme = theme2.series[this.name];
                  this.rect = layout2.plot;
                  this.activeSeriesMap = getActiveSeriesMap(legend2);
                  this.selectable = this.getSelectableOption(options2);
                  this.valueAxis = getValueAxisName(options2, this.name, this.isBar ? "xAxis" : "yAxis");
                  var seriesData2 = series[this.name].data.map(function(seriesDatum) {
                    return boxSeries_objectSpread(boxSeries_objectSpread({}, seriesDatum), {}, {
                      data: getDataInRange(seriesDatum.data, computed2.viewRange)
                    });
                  });
                  if (axes2.centerYAxis) {
                    this.valueAxis = "centerYAxis";
                  }
                  var tickDistance = axes2[this.labelAxis].tickDistance;
                  var diverging = !!((_options$series2 = options2.series) !== null && _options$series2 !== void 0 && _options$series2.diverging);
                  var _this$getScaleData = this.getScaleData(scale2), limit = _this$getScaleData.limit, stepSize = _this$getScaleData.stepSize;
                  var labels = makeLabelsFromLimit(limit, stepSize);
                  var _getLimitOnAxis = getLimitOnAxis(labels), min = _getLimitOnAxis.min, max2 = _getLimitOnAxis.max;
                  this.basePosition = this.getBasePosition(axes2[this.valueAxis]);
                  var offsetSize = this.getOffsetSize();
                  var centerYAxis = axes2.centerYAxis;
                  if (diverging) {
                    var _this$getDivergingBas = this.getDivergingBasePosition(centerYAxis), _this$getDivergingBas2 = boxSeries_slicedToArray(_this$getDivergingBas, 2), left = _this$getDivergingBas2[0], right = _this$getDivergingBas2[1];
                    this.basePosition = this.getOffsetSize() / 2;
                    this.leftBasePosition = left;
                    this.rightBasePosition = right;
                    offsetSize = this.getOffsetSizeWithDiverging(centerYAxis);
                  }
                  var renderOptions = {
                    min,
                    max: max2,
                    tickDistance,
                    diverging,
                    ratio: this.getValueRatio(min, max2, offsetSize),
                    hasNegativeValue: hasNegative(labels),
                    seriesDirection: this.getSeriesDirection(labels),
                    defaultPadding: getBoxTypeSeriesPadding(tickDistance)
                  };
                  var seriesModels = this.renderSeriesModel(seriesData2, renderOptions);
                  var tooltipData = this.makeTooltipData(seriesData2, renderOptions, categories);
                  var clipRect = this.renderClipRectAreaModel();
                  this.models = {
                    clipRect: [clipRect],
                    series: seriesModels
                  };
                  if (!this.drawModels) {
                    this.drawModels = {
                      clipRect: [this.initClipRect(clipRect)],
                      series: deepCopyArray(seriesModels)
                    };
                  }
                  if (getDataLabelsOptions(options2, this.name).visible) {
                    var dataLabelData = seriesModels.reduce(function(acc, data) {
                      return isRangeValue(data.value) ? [].concat(boxSeries_toConsumableArray(acc), boxSeries_toConsumableArray(_this3.makeDataLabelRangeData(data))) : [].concat(boxSeries_toConsumableArray(acc), [_this3.makeDataLabel(data, centerYAxis)]);
                    }, []);
                    this.renderDataLabels(dataLabelData);
                  }
                  this.tooltipRectMap = this.makeTooltipRectMap(seriesModels, tooltipData);
                  this.responders = this.getBoxSeriesResponders(seriesModels, tooltipData, axes2, categories);
                }
              }, {
                key: "getScaleData",
                value: function getScaleData(scale2) {
                  return scale2[this.valueAxis === "centerYAxis" ? "xAxis" : this.valueAxis];
                }
              }, {
                key: "getBoxSeriesResponders",
                value: function getBoxSeriesResponders(seriesModels, tooltipData, axes2, categories) {
                  var hoveredSeries = this.renderHoveredSeriesModel(seriesModels);
                  return this.eventDetectType === "grouped" ? makeRectResponderModel(this.rect, this.isBar ? axes2.yAxis : axes2.xAxis, categories, !this.isBar) : hoveredSeries.map(function(m, index) {
                    return boxSeries_objectSpread(boxSeries_objectSpread({}, m), {}, {
                      data: tooltipData[index]
                    });
                  });
                }
              }, {
                key: "makeTooltipRectMap",
                value: function makeTooltipRectMap(seriesModels, tooltipDataArr) {
                  return seriesModels.reduce(function(acc, cur, dataIndex) {
                    var index = cur.index;
                    var tooltipModel = boxSeries_objectSpread(boxSeries_objectSpread({}, cur), {}, {
                      data: tooltipDataArr[dataIndex]
                    });
                    if (!acc[index]) {
                      acc[index] = [];
                    }
                    acc[index].push(tooltipModel);
                    return acc;
                  }, []);
                }
              }, {
                key: "renderClipRectAreaModel",
                value: function renderClipRectAreaModel() {
                  return {
                    type: "clipRectArea",
                    x: 0,
                    y: 0,
                    width: this.rect.width,
                    height: this.rect.height
                  };
                }
              }, {
                key: "initClipRect",
                value: function initClipRect(clipRect) {
                  return {
                    type: "clipRectArea",
                    width: this.isBar ? 0 : clipRect.width,
                    height: this.isBar ? clipRect.height : 0,
                    x: this.isBar ? 0 : clipRect.x,
                    y: this.isBar ? clipRect.y : 0
                  };
                }
              }, {
                key: "renderSeriesModel",
                value: function renderSeriesModel(seriesData2, renderOptions) {
                  var _this4 = this;
                  var tickDistance = renderOptions.tickDistance, diverging = renderOptions.diverging;
                  var seriesLength = seriesData2.length;
                  var validDiverging = diverging && seriesData2.length === 2;
                  var columnWidth = this.getColumnWidth(renderOptions, seriesLength, validDiverging);
                  var seriesModels = [];
                  var padding2 = (tickDistance - columnWidth * (validDiverging ? 1 : seriesLength)) / 2;
                  seriesData2.forEach(function(_ref3, seriesIndex) {
                    var data = _ref3.data, seriesColor = _ref3.color, name = _ref3.name, colorByCategories = _ref3.colorByCategories;
                    var seriesPos = (diverging ? 0 : seriesIndex) * columnWidth + padding2;
                    var isLBSideWithDiverging = diverging && isLeftBottomSide(seriesIndex);
                    var colorLength = colorByCategories ? seriesColor.length : 1;
                    _this4.isRangeData = isRangeData(data);
                    data.forEach(function(value, index) {
                      var dataStart = seriesPos + index * tickDistance;
                      var barLength = _this4.makeBarLength(value, renderOptions);
                      var color = _this4.getSeriesColor(name, colorByCategories ? seriesColor[index % colorLength] : seriesColor);
                      if (isNumber(barLength)) {
                        var startPosition = _this4.getStartPosition(barLength, value, renderOptions, isLBSideWithDiverging);
                        seriesModels.push(boxSeries_objectSpread(boxSeries_objectSpread({
                          type: "rect",
                          color,
                          value
                        }, _this4.getAdjustedRect(dataStart, startPosition, barLength, columnWidth)), {}, {
                          name,
                          index
                        }));
                      }
                    });
                  });
                  return seriesModels;
                }
              }, {
                key: "renderHoveredSeriesModel",
                value: function renderHoveredSeriesModel(seriesModel) {
                  var _this5 = this;
                  return seriesModel.map(function(data) {
                    return _this5.makeHoveredSeriesModel(data);
                  });
                }
              }, {
                key: "makeHoveredSeriesModel",
                value: function makeHoveredSeriesModel(data) {
                  var _ref4 = data, x = _ref4.x, y = _ref4.y, width = _ref4.width, height = _ref4.height, color = _ref4.color, index = _ref4.index;
                  return {
                    type: "rect",
                    color: getRGBA(color, 1),
                    x,
                    y,
                    width,
                    height,
                    index
                  };
                }
              }, {
                key: "getRectModelsFromRectResponders",
                value: function getRectModelsFromRectResponders(responders) {
                  var _this$tooltipRectMap;
                  if (!responders.length) {
                    return [];
                  }
                  return (_this$tooltipRectMap = this.tooltipRectMap[responders[0].index]) !== null && _this$tooltipRectMap !== void 0 ? _this$tooltipRectMap : [];
                }
              }, {
                key: "getGroupedRect",
                value: function getGroupedRect(responders, type) {
                  var rectModels = this.getRectModelsFromRectResponders(responders);
                  var _ref5 = this.theme[type].groupedRect, color = _ref5.color, opacity = _ref5.opacity;
                  return rectModels.length ? responders.map(function(m) {
                    return boxSeries_objectSpread(boxSeries_objectSpread({}, m), {}, {
                      color: getRGBA(color, opacity)
                    });
                  }) : [];
                }
              }, {
                key: "onMousemoveGroupedType",
                value: function onMousemoveGroupedType(responders) {
                  var rectModels = this.getRectModelsFromRectResponders(responders);
                  this.eventBus.emit("renderHoveredSeries", {
                    models: this.getGroupedRect(responders, "hover"),
                    name: this.name,
                    eventDetectType: this.eventDetectType
                  });
                  this.activatedResponders = rectModels;
                }
              }, {
                key: "onMousemove",
                value: function onMousemove(_ref6) {
                  var responders = _ref6.responders;
                  if (this.eventDetectType === "grouped") {
                    this.onMousemoveGroupedType(responders);
                  } else {
                    this.eventBus.emit("renderHoveredSeries", {
                      models: this.getRespondersWithTheme(responders, "hover"),
                      name: this.name,
                      eventDetectType: this.eventDetectType
                    });
                    this.activatedResponders = responders;
                  }
                  this.eventBus.emit("seriesPointHovered", {
                    models: this.activatedResponders,
                    name: this.name
                  });
                  this.eventBus.emit("needDraw");
                }
              }, {
                key: "makeTooltipData",
                value: function makeTooltipData(seriesData2, renderOptions, categories) {
                  var _this6 = this;
                  var tooltipData = [];
                  seriesData2.forEach(function(_ref7) {
                    var data = _ref7.data, name = _ref7.name, color = _ref7.color, colorByCategories = _ref7.colorByCategories;
                    data.forEach(function(value, dataIndex) {
                      if (!isNull(value)) {
                        var barLength = _this6.makeBarLength(value, renderOptions);
                        if (isNumber(barLength)) {
                          tooltipData.push({
                            label: name,
                            color: colorByCategories ? color[dataIndex] : color,
                            value: _this6.getTooltipValue(value),
                            category: categories.length ? categories[dataIndex] : ""
                          });
                        }
                      }
                    });
                  });
                  return tooltipData;
                }
              }, {
                key: "getTooltipValue",
                value: function getTooltipValue(value) {
                  return isRangeValue(value) ? "".concat(value[0], " ~ ").concat(value[1]) : value;
                }
              }, {
                key: "getBasePosition",
                value: function getBasePosition(_ref8) {
                  var labels = _ref8.labels, tickCount = _ref8.tickCount, zeroPosition = _ref8.zeroPosition;
                  var valueLabels = this.isBar ? labels : boxSeries_toConsumableArray(labels).reverse();
                  var tickPositions = makeTickPixelPositions(this.getOffsetSize(), tickCount);
                  var seriesDirection = this.getSeriesDirection(valueLabels);
                  return zeroPosition ? zeroPosition : this.getTickPositionIfNotZero(tickPositions, seriesDirection);
                }
              }, {
                key: "getDivergingBasePosition",
                value: function getDivergingBasePosition(centerYAxis) {
                  var leftZeroPosition, rightZeroPosition;
                  if (centerYAxis) {
                    leftZeroPosition = centerYAxis.xAxisHalfSize;
                    rightZeroPosition = centerYAxis.secondStartX;
                  } else {
                    var divergingZeroPosition = this.getOffsetSize() / 2;
                    leftZeroPosition = rightZeroPosition = divergingZeroPosition;
                  }
                  return [leftZeroPosition, rightZeroPosition];
                }
              }, {
                key: "getOffsetSize",
                value: function getOffsetSize() {
                  return this.rect[this.offsetSizeKey];
                }
              }, {
                key: "getValueRatio",
                value: function getValueRatio2(min, max2, size) {
                  return size / (max2 - min);
                }
              }, {
                key: "makeBarLength",
                value: function makeBarLength(value, renderOptions) {
                  if (isNull(value)) {
                    return null;
                  }
                  var min = renderOptions.min, max2 = renderOptions.max, ratio = renderOptions.ratio;
                  var calculatedValue = calculateBarLength(value, min, max2);
                  return Math.max(this.getBarLength(calculatedValue, ratio), 2);
                }
              }, {
                key: "getBarLength",
                value: function getBarLength(value, ratio) {
                  return value < 0 ? Math.abs(value) * ratio : value * ratio;
                }
              }, {
                key: "getStartPositionWithRangeValue",
                value: function getStartPositionWithRangeValue(value, barLength, renderOptions) {
                  var min = renderOptions.min, ratio = renderOptions.ratio;
                  var _value2 = boxSeries_slicedToArray(value, 1), start = _value2[0];
                  if (start < min) {
                    start = min;
                  }
                  var startPosition = (start - min) * ratio;
                  return this.isBar ? startPosition : this.getOffsetSize() - startPosition - barLength;
                }
              }, {
                key: "getStartPosition",
                value: function getStartPosition(barLength, value, renderOptions, isLBSideWithDiverging) {
                  var diverging = renderOptions.diverging, seriesDirection = renderOptions.seriesDirection;
                  var startPos;
                  if (isRangeValue(value)) {
                    startPos = this.getStartPositionWithRangeValue(value, barLength, renderOptions);
                  } else if (diverging) {
                    startPos = isLBSideWithDiverging ? this.getStartPosOnLeftBottomSide(barLength, diverging) : this.getStartPosOnRightTopSide(barLength, diverging);
                  } else if (seriesDirection === SeriesDirection.POSITIVE) {
                    startPos = this.getStartPosOnRightTopSide(barLength);
                  } else if (seriesDirection === SeriesDirection.NEGATIVE) {
                    startPos = this.getStartPosOnLeftBottomSide(barLength);
                  } else {
                    startPos = value < 0 ? this.getStartPosOnLeftBottomSide(barLength) : this.getStartPosOnRightTopSide(barLength);
                  }
                  return startPos;
                }
              }, {
                key: "getStartPosOnRightTopSide",
                value: function getStartPosOnRightTopSide(barLength) {
                  var diverging = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                  var pos;
                  if (diverging) {
                    pos = this.isBar ? this.rightBasePosition : this.rightBasePosition - barLength;
                  } else {
                    pos = this.isBar ? this.basePosition : this.basePosition - barLength;
                  }
                  return pos;
                }
              }, {
                key: "getStartPosOnLeftBottomSide",
                value: function getStartPosOnLeftBottomSide(barLength) {
                  var diverging = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                  var pos;
                  if (diverging) {
                    pos = this.isBar ? this.leftBasePosition - barLength : this.leftBasePosition;
                  } else {
                    pos = this.isBar ? this.basePosition - barLength : this.basePosition;
                  }
                  return pos;
                }
              }, {
                key: "getAdjustedRect",
                value: function getAdjustedRect(seriesPosition, dataPosition, barLength, columnWidth) {
                  return {
                    x: this.isBar ? dataPosition : seriesPosition,
                    y: this.isBar ? seriesPosition : dataPosition,
                    width: this.isBar ? barLength : columnWidth,
                    height: this.isBar ? columnWidth : barLength
                  };
                }
              }, {
                key: "getColumnWidth",
                value: function getColumnWidth(renderOptions, seriesLength) {
                  var validDiverging = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
                  var tickDistance = renderOptions.tickDistance, defaultPadding = renderOptions.defaultPadding;
                  seriesLength = validDiverging ? 1 : seriesLength;
                  var themeBarWidth = this.theme.barWidth;
                  return themeBarWidth ? calculateSizeWithPercentString(tickDistance, themeBarWidth) : (tickDistance - defaultPadding * 2) / seriesLength;
                }
              }, {
                key: "getSeriesDirection",
                value: function getSeriesDirection(labels) {
                  var result = SeriesDirection.BOTH;
                  if (hasPositiveOnly(labels)) {
                    result = SeriesDirection.POSITIVE;
                  } else if (hasNegativeOnly(labels)) {
                    result = SeriesDirection.NEGATIVE;
                  }
                  return result;
                }
              }, {
                key: "getTickPositionIfNotZero",
                value: function getTickPositionIfNotZero(tickPositions, direction) {
                  if (!tickPositions.length) {
                    return 0;
                  }
                  var firstTickPosition = Number(first(tickPositions));
                  var lastTickPosition = Number(last(tickPositions));
                  if (direction === SeriesDirection.POSITIVE) {
                    return this.isBar ? firstTickPosition : lastTickPosition;
                  }
                  if (direction === SeriesDirection.NEGATIVE) {
                    return this.isBar ? lastTickPosition : firstTickPosition;
                  }
                  return 0;
                }
              }, {
                key: "makeDataLabel",
                value: function makeDataLabel(rect2, centerYAxis) {
                  var dataLabels = this.theme.dataLabels;
                  return boxSeries_objectSpread(boxSeries_objectSpread({}, rect2), {}, {
                    direction: this.getDataLabelDirection(rect2, centerYAxis),
                    plot: {
                      x: 0,
                      y: 0,
                      size: this.getOffsetSize()
                    },
                    theme: boxSeries_objectSpread(boxSeries_objectSpread({}, omit(dataLabels, "stackTotal")), {}, {
                      color: dataLabels.useSeriesColor ? rect2.color : dataLabels.color
                    })
                  });
                }
              }, {
                key: "makeDataLabelRangeData",
                value: function makeDataLabelRangeData(rect2) {
                  var _this7 = this;
                  var dataLabels = this.theme.dataLabels;
                  return rect2.value.reduce(function(acc, value, index) {
                    return [].concat(boxSeries_toConsumableArray(acc), [boxSeries_objectSpread(boxSeries_objectSpread({}, rect2), {}, {
                      value,
                      direction: _this7.getDataLabelRangeDataDirection(index % 2 === 0),
                      plot: {
                        x: 0,
                        y: 0,
                        size: _this7.getOffsetSize()
                      },
                      theme: boxSeries_objectSpread(boxSeries_objectSpread({}, omit(dataLabels, "stackTotal")), {}, {
                        color: dataLabels.useSeriesColor ? rect2.color : dataLabels.color
                      })
                    })]);
                  }, []);
                }
              }, {
                key: "getDataLabelRangeDataDirection",
                value: function getDataLabelRangeDataDirection(isEven) {
                  var direction;
                  if (this.isBar) {
                    direction = isEven ? "left" : "right";
                  } else {
                    direction = isEven ? "bottom" : "top";
                  }
                  return direction;
                }
              }, {
                key: "getDataLabelDirection",
                value: function getDataLabelDirection(rect2, centerYAxis) {
                  var direction;
                  if (this.isBar) {
                    var basePos = centerYAxis ? this.leftBasePosition : this.basePosition;
                    direction = rect2.x < basePos ? "left" : "right";
                  } else {
                    direction = rect2.y >= this.basePosition ? "bottom" : "top";
                  }
                  return direction;
                }
              }, {
                key: "getOffsetSizeWithDiverging",
                value: function getOffsetSizeWithDiverging(centerYAxis) {
                  return centerYAxis ? centerYAxis.xAxisHalfSize : this.getOffsetSize() / 2;
                }
              }, {
                key: "onClick",
                value: function onClick(_ref9) {
                  var responders = _ref9.responders;
                  if (this.selectable) {
                    var models;
                    if (this.eventDetectType === "grouped") {
                      models = [].concat(boxSeries_toConsumableArray(this.getGroupedRect(responders, "select")), boxSeries_toConsumableArray(this.getRectModelsFromRectResponders(responders)));
                    } else {
                      models = this.getRespondersWithTheme(responders, "select");
                    }
                    this.eventBus.emit("renderSelectedSeries", {
                      models,
                      name: this.name,
                      eventDetectType: this.eventDetectType
                    });
                    this.eventBus.emit("needDraw");
                  }
                }
              }, {
                key: "getRespondersWithTheme",
                value: function getRespondersWithTheme(responders, type) {
                  var _this$theme$type = this.theme[type], color = _this$theme$type.color, borderColor = _this$theme$type.borderColor, borderWidth = _this$theme$type.borderWidth, shadowBlur = _this$theme$type.shadowBlur, shadowColor = _this$theme$type.shadowColor, shadowOffsetX = _this$theme$type.shadowOffsetX, shadowOffsetY = _this$theme$type.shadowOffsetY;
                  return responders.map(function(model) {
                    return boxSeries_objectSpread(boxSeries_objectSpread({}, model), {}, {
                      color: color !== null && color !== void 0 ? color : model.color,
                      thickness: borderWidth,
                      borderColor,
                      style: [{
                        shadowBlur,
                        shadowColor,
                        shadowOffsetX,
                        shadowOffsetY
                      }]
                    });
                  });
                }
              }, {
                key: "getSeriesColor",
                value: function getSeriesColor(name, color) {
                  var _this$theme = this.theme, select = _this$theme.select, areaOpacity = _this$theme.areaOpacity;
                  var active = this.activeSeriesMap[name];
                  var selected = Object.values(this.activeSeriesMap).some(function(elem) {
                    return !elem;
                  });
                  return selected ? getRGBA(color, active ? select.areaOpacity : select.restSeries.areaOpacity) : getRGBA(color, areaOpacity);
                }
              }]);
              return BoxSeries2;
            }(Component);
            ;
            function boxStackSeries_typeof(obj) {
              "@babel/helpers - typeof";
              if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                boxStackSeries_typeof = function _typeof2(obj2) {
                  return typeof obj2;
                };
              } else {
                boxStackSeries_typeof = function _typeof2(obj2) {
                  return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                };
              }
              return boxStackSeries_typeof(obj);
            }
            function boxStackSeries_toConsumableArray(arr) {
              return boxStackSeries_arrayWithoutHoles(arr) || boxStackSeries_iterableToArray(arr) || boxStackSeries_unsupportedIterableToArray(arr) || boxStackSeries_nonIterableSpread();
            }
            function boxStackSeries_nonIterableSpread() {
              throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            function boxStackSeries_iterableToArray(iter) {
              if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
                return Array.from(iter);
            }
            function boxStackSeries_arrayWithoutHoles(arr) {
              if (Array.isArray(arr))
                return boxStackSeries_arrayLikeToArray(arr);
            }
            function boxStackSeries_slicedToArray(arr, i) {
              return boxStackSeries_arrayWithHoles(arr) || boxStackSeries_iterableToArrayLimit(arr, i) || boxStackSeries_unsupportedIterableToArray(arr, i) || boxStackSeries_nonIterableRest();
            }
            function boxStackSeries_nonIterableRest() {
              throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            function boxStackSeries_unsupportedIterableToArray(o, minLen) {
              if (!o)
                return;
              if (typeof o === "string")
                return boxStackSeries_arrayLikeToArray(o, minLen);
              var n = Object.prototype.toString.call(o).slice(8, -1);
              if (n === "Object" && o.constructor)
                n = o.constructor.name;
              if (n === "Map" || n === "Set")
                return Array.from(o);
              if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                return boxStackSeries_arrayLikeToArray(o, minLen);
            }
            function boxStackSeries_arrayLikeToArray(arr, len) {
              if (len == null || len > arr.length)
                len = arr.length;
              for (var i = 0, arr2 = new Array(len); i < len; i++) {
                arr2[i] = arr[i];
              }
              return arr2;
            }
            function boxStackSeries_iterableToArrayLimit(arr, i) {
              var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]);
              if (_i == null)
                return;
              var _arr = [];
              var _n = true;
              var _d = false;
              var _s, _e;
              try {
                for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
                  _arr.push(_s.value);
                  if (i && _arr.length === i)
                    break;
                }
              } catch (err) {
                _d = true;
                _e = err;
              } finally {
                try {
                  if (!_n && _i["return"] != null)
                    _i["return"]();
                } finally {
                  if (_d)
                    throw _e;
                }
              }
              return _arr;
            }
            function boxStackSeries_arrayWithHoles(arr) {
              if (Array.isArray(arr))
                return arr;
            }
            function boxStackSeries_classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function boxStackSeries_defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            function boxStackSeries_createClass(Constructor, protoProps, staticProps) {
              if (protoProps)
                boxStackSeries_defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                boxStackSeries_defineProperties(Constructor, staticProps);
              return Constructor;
            }
            function boxStackSeries_inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function");
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
              if (superClass)
                boxStackSeries_setPrototypeOf(subClass, superClass);
            }
            function boxStackSeries_setPrototypeOf(o, p) {
              boxStackSeries_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
                o2.__proto__ = p2;
                return o2;
              };
              return boxStackSeries_setPrototypeOf(o, p);
            }
            function boxStackSeries_createSuper(Derived) {
              var hasNativeReflectConstruct = boxStackSeries_isNativeReflectConstruct();
              return function _createSuperInternal() {
                var Super = boxStackSeries_getPrototypeOf(Derived), result;
                if (hasNativeReflectConstruct) {
                  var NewTarget = boxStackSeries_getPrototypeOf(this).constructor;
                  result = Reflect.construct(Super, arguments, NewTarget);
                } else {
                  result = Super.apply(this, arguments);
                }
                return boxStackSeries_possibleConstructorReturn(this, result);
              };
            }
            function boxStackSeries_possibleConstructorReturn(self2, call) {
              if (call && (boxStackSeries_typeof(call) === "object" || typeof call === "function")) {
                return call;
              }
              return boxStackSeries_assertThisInitialized(self2);
            }
            function boxStackSeries_assertThisInitialized(self2) {
              if (self2 === void 0) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return self2;
            }
            function boxStackSeries_isNativeReflectConstruct() {
              if (typeof Reflect === "undefined" || !Reflect.construct)
                return false;
              if (Reflect.construct.sham)
                return false;
              if (typeof Proxy === "function")
                return true;
              try {
                Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                }));
                return true;
              } catch (e) {
                return false;
              }
            }
            function boxStackSeries_getPrototypeOf(o) {
              boxStackSeries_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
                return o2.__proto__ || Object.getPrototypeOf(o2);
              };
              return boxStackSeries_getPrototypeOf(o);
            }
            function boxStackSeries_ownKeys(object, enumerableOnly) {
              var keys = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object);
                if (enumerableOnly) {
                  symbols = symbols.filter(function(sym) {
                    return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                  });
                }
                keys.push.apply(keys, symbols);
              }
              return keys;
            }
            function boxStackSeries_objectSpread(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i] != null ? arguments[i] : {};
                if (i % 2) {
                  boxStackSeries_ownKeys(Object(source), true).forEach(function(key) {
                    boxStackSeries_defineProperty(target, key, source[key]);
                  });
                } else if (Object.getOwnPropertyDescriptors) {
                  Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                } else {
                  boxStackSeries_ownKeys(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  });
                }
              }
              return target;
            }
            function boxStackSeries_defineProperty(obj, key, value) {
              if (key in obj) {
                Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
              } else {
                obj[key] = value;
              }
              return obj;
            }
            function boxStackSeries_calibrateDrawingValue(values, seriesIndex, renderOptions) {
              var stack = renderOptions.stack, min = renderOptions.min, max2 = renderOptions.max;
              return isPercentStack(stack) ? values[seriesIndex] : calibrateBoxStackDrawingValue(values, seriesIndex, min, max2);
            }
            function getDivisorForPercent(total, scaleType) {
              var positive = total.positive, negative = total.negative;
              var divisor = positive + Math.abs(negative);
              if (includes(["dualPercentStack", "divergingPercentStack"], scaleType)) {
                divisor *= 2;
              }
              return divisor;
            }
            function getDirectionKeys(seriesDirection) {
              var result = ["positive", "negative"];
              if (seriesDirection === SeriesDirection.POSITIVE) {
                result = ["positive"];
              } else if (seriesDirection === SeriesDirection.NEGATIVE) {
                result = ["negative"];
              }
              return result;
            }
            function getStackSeriesDataInViewRange(stackSeriesData2, viewRange) {
              if (!viewRange) {
                return stackSeriesData2;
              }
              var stackData = Array.isArray(stackSeriesData2.stackData) ? getDataInRange(stackSeriesData2.stackData, viewRange) : boxStackSeries_objectSpread({}, Object.keys(stackSeriesData2.stackData).reduce(function(acc, name) {
                return boxStackSeries_objectSpread(boxStackSeries_objectSpread({}, acc), {}, boxStackSeries_defineProperty({}, name, getDataInRange(stackSeriesData2.stackData[name], viewRange)));
              }, {}));
              var data = stackSeriesData2.data.map(function(seriesDatum) {
                return boxStackSeries_objectSpread(boxStackSeries_objectSpread({}, seriesDatum), {}, {
                  data: getDataInRange(seriesDatum.data, viewRange)
                });
              });
              return boxStackSeries_objectSpread(boxStackSeries_objectSpread({}, stackSeriesData2), {}, {
                data,
                stackData
              });
            }
            var BoxStackSeries = function(_BoxSeries) {
              boxStackSeries_inherits(BoxStackSeries2, _BoxSeries);
              var _super = boxStackSeries_createSuper(BoxStackSeries2);
              function BoxStackSeries2() {
                var _this;
                boxStackSeries_classCallCheck(this, BoxStackSeries2);
                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }
                _this = _super.call.apply(_super, [this].concat(args));
                boxStackSeries_defineProperty(boxStackSeries_assertThisInitialized(_this), "selectSeries", function(_ref) {
                  var index = _ref.index, seriesIndex = _ref.seriesIndex, state = _ref.state;
                  if (!isNumber(index) || !isNumber(seriesIndex)) {
                    return;
                  }
                  var stackSeries = state.stackSeries;
                  var stackSeriesData2 = stackSeries[_this.name];
                  var name = stackSeriesData2.data[seriesIndex].name;
                  var model = _this.tooltipRectMap[index].find(function(_ref2) {
                    var seriesName = _ref2.name;
                    return seriesName === name;
                  });
                  if (!model) {
                    throw new Error(message.SELECT_SERIES_API_INDEX_ERROR);
                  }
                  _this.eventBus.emit("renderSelectedSeries", {
                    models: _this.getRespondersWithTheme([model], "select"),
                    name: _this.name,
                    eventDetectType: _this.eventDetectType
                  });
                  _this.eventBus.emit("needDraw");
                });
                return _this;
              }
              boxStackSeries_createClass(BoxStackSeries2, [{
                key: "initialize",
                value: function initialize(_ref3) {
                  var name = _ref3.name, stackChart = _ref3.stackChart;
                  this.initializeFields(name);
                  if (stackChart) {
                    this.eventBus.on("selectSeries", this.selectSeries);
                    this.eventBus.on("showTooltip", this.showTooltip);
                    this.eventBus.on("hideTooltip", this.onMouseoutComponent);
                  }
                }
              }, {
                key: "render",
                value: function render(chartState, computed2) {
                  var _ref4, _options$series;
                  var layout2 = chartState.layout, seriesData2 = chartState.series, axes2 = chartState.axes, stackSeries = chartState.stackSeries, legend2 = chartState.legend, theme2 = chartState.theme, scale2 = chartState.scale;
                  var viewRange = computed2.viewRange;
                  this.isShow = !!stackSeries[this.name];
                  if (!this.isShow) {
                    return;
                  }
                  var categories = (_ref4 = chartState.categories) !== null && _ref4 !== void 0 ? _ref4 : [];
                  var options2 = this.getOptions(chartState.options);
                  this.setEventDetectType(seriesData2, options2);
                  this.theme = theme2.series[this.name];
                  this.rect = layout2.plot;
                  this.activeSeriesMap = getActiveSeriesMap(legend2);
                  this.selectable = this.getSelectableOption(options2);
                  var stackSeriesData2 = getStackSeriesDataInViewRange(stackSeries[this.name], viewRange);
                  var tickDistance = axes2[this.labelAxis].tickDistance;
                  var diverging = !!((_options$series = options2.series) !== null && _options$series !== void 0 && _options$series.diverging);
                  var _this$getScaleData = this.getScaleData(scale2), limit = _this$getScaleData.limit, stepSize = _this$getScaleData.stepSize;
                  var labels = makeLabelsFromLimit(limit, stepSize);
                  var _getLimitOnAxis = getLimitOnAxis(labels), min = _getLimitOnAxis.min, max2 = _getLimitOnAxis.max;
                  var stack = stackSeriesData2.stack, scaleType = stackSeriesData2.scaleType;
                  this.basePosition = this.getBasePosition(axes2[this.valueAxis]);
                  var offsetSize = this.getOffsetSize();
                  var centerYAxis = axes2.centerYAxis;
                  if (diverging) {
                    var _this$getDivergingBas = this.getDivergingBasePosition(centerYAxis), _this$getDivergingBas2 = boxStackSeries_slicedToArray(_this$getDivergingBas, 2), left = _this$getDivergingBas2[0], right = _this$getDivergingBas2[1];
                    this.basePosition = this.getOffsetSize() / 2;
                    this.leftBasePosition = left;
                    this.rightBasePosition = right;
                    offsetSize = this.getOffsetSizeWithDiverging(centerYAxis);
                  }
                  var renderOptions = {
                    stack,
                    scaleType,
                    tickDistance,
                    min,
                    max: max2,
                    diverging,
                    hasNegativeValue: hasNegative(labels),
                    seriesDirection: this.getSeriesDirection(labels),
                    defaultPadding: getBoxTypeSeriesPadding(tickDistance),
                    offsetSize,
                    centerYAxis
                  };
                  var _this$renderStackSeri = this.renderStackSeriesModel(stackSeriesData2, renderOptions), series = _this$renderStackSeri.series, connector = _this$renderStackSeri.connector;
                  var clipRect = this.renderClipRectAreaModel();
                  var tooltipData = this.getTooltipData(stackSeriesData2, categories);
                  this.models = {
                    clipRect: [clipRect],
                    series,
                    connector
                  };
                  if (!this.drawModels) {
                    this.drawModels = {
                      clipRect: [this.initClipRect(clipRect)],
                      series: deepCopyArray(series),
                      connector: deepCopyArray(connector)
                    };
                  }
                  if (getDataLabelsOptions(options2, this.name).visible) {
                    var dataLabelData = this.getDataLabels(series, renderOptions);
                    var stackTotalData = this.getTotalDataLabels(stackSeriesData2, renderOptions);
                    this.renderDataLabels([].concat(boxStackSeries_toConsumableArray(dataLabelData), boxStackSeries_toConsumableArray(stackTotalData)));
                  }
                  this.tooltipRectMap = this.makeTooltipRectMap(series, tooltipData);
                  this.responders = this.getBoxSeriesResponders(series, tooltipData, axes2, categories);
                }
              }, {
                key: "renderStackSeriesModel",
                value: function renderStackSeriesModel(seriesData2, renderOptions) {
                  var stackData = seriesData2.stackData;
                  return isGroupStack(stackData) ? this.makeStackGroupSeriesModel(seriesData2, renderOptions) : this.makeStackSeriesModel(stackData, renderOptions, seriesData2.data);
                }
              }, {
                key: "makeStackSeriesModel",
                value: function makeStackSeriesModel(stackData, renderOptions, seriesRawData) {
                  var _this2 = this;
                  var stackGroupCount = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;
                  var stackGroupIndex = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0;
                  var seriesModels = [];
                  var columnWidth = this.getStackColumnWidth(renderOptions, stackGroupCount);
                  var diverging = renderOptions.diverging;
                  var isLBSideWithDiverging = diverging && isLeftBottomSide(stackGroupIndex);
                  stackData.forEach(function(_ref5, dataIndex) {
                    var values = _ref5.values, total = _ref5.total;
                    var seriesPos = _this2.getSeriesPosition(renderOptions, columnWidth, dataIndex, stackGroupIndex, stackGroupCount);
                    var ratio = _this2.getStackValueRatio(total, renderOptions);
                    values.forEach(function(value, seriesIndex) {
                      var _this2$getStackRectIn = _this2.getStackRectInfo(values, seriesIndex, ratio, renderOptions, isLBSideWithDiverging), barLength = _this2$getStackRectIn.barLength, dataPosition = _this2$getStackRectIn.dataPosition;
                      var _seriesRawData$series = seriesRawData[seriesIndex], name = _seriesRawData$series.name, colorByCategories = _seriesRawData$series.colorByCategories, rawColor = _seriesRawData$series.color;
                      var active = _this2.activeSeriesMap[name];
                      var colorLength = rawColor.length || 1;
                      var hexColor = colorByCategories ? rawColor[dataIndex % colorLength] : rawColor;
                      var color = getRGBA(hexColor, active ? 1 : 0.2);
                      seriesModels.push(boxStackSeries_objectSpread(boxStackSeries_objectSpread({
                        type: "rect",
                        color,
                        name,
                        value
                      }, _this2.getAdjustedRect(seriesPos, dataPosition, barLength !== null && barLength !== void 0 ? barLength : 0, columnWidth)), {}, {
                        index: dataIndex
                      }));
                    });
                  });
                  return {
                    series: seriesModels,
                    connector: this.makeConnectorSeriesModel(stackData, renderOptions, stackGroupCount, stackGroupIndex)
                  };
                }
              }, {
                key: "makeStackGroupSeriesModel",
                value: function makeStackGroupSeriesModel(stackSeries, renderOptions) {
                  var _this3 = this;
                  var stack = renderOptions.stack;
                  var stackGroupData = stackSeries.stackData;
                  var seriesRawData = stackSeries.data;
                  var stackGroupIds = Object.keys(stackGroupData);
                  var seriesModels = [];
                  var connectorModels = [];
                  stackGroupIds.forEach(function(groupId, groupIndex) {
                    var filtered = seriesRawData.filter(function(_ref6) {
                      var stackGroup = _ref6.stackGroup;
                      return stackGroup === groupId;
                    });
                    var _this3$makeStackSerie = _this3.makeStackSeriesModel(stackGroupData[groupId], renderOptions, filtered, stackGroupIds.length, groupIndex), series = _this3$makeStackSerie.series, connector = _this3$makeStackSerie.connector;
                    seriesModels = [].concat(boxStackSeries_toConsumableArray(seriesModels), boxStackSeries_toConsumableArray(series));
                    if (stack.connector) {
                      connectorModels = [].concat(boxStackSeries_toConsumableArray(connectorModels), boxStackSeries_toConsumableArray(connector));
                    }
                  });
                  return {
                    series: seriesModels,
                    connector: connectorModels
                  };
                }
              }, {
                key: "makeConnectorSeriesModel",
                value: function makeConnectorSeriesModel(stackData, renderOptions) {
                  var _this4 = this;
                  var stackGroupCount = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
                  var stackGroupIndex = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
                  var diverging = renderOptions.diverging, connector = renderOptions.stack.connector;
                  if (!connector) {
                    return [];
                  }
                  var columnWidth = this.getStackColumnWidth(renderOptions, stackGroupCount);
                  var isLBSideWithDiverging = diverging && isLeftBottomSide(stackGroupIndex);
                  var connectorPoints = [];
                  stackData.forEach(function(_ref7, index) {
                    var values = _ref7.values, total = _ref7.total;
                    var seriesPos = _this4.getSeriesPosition(renderOptions, columnWidth, index, stackGroupIndex, stackGroupCount);
                    var points = [];
                    var ratio = _this4.getStackValueRatio(total, renderOptions);
                    values.forEach(function(value, seriesIndex) {
                      var _this4$getStackRectIn = _this4.getStackRectInfo(values, seriesIndex, ratio, renderOptions, isLBSideWithDiverging), barLength = _this4$getStackRectIn.barLength, dataPosition = _this4$getStackRectIn.dataPosition;
                      var _this4$getAdjustedRec = _this4.getAdjustedRect(seriesPos, dataPosition, barLength, columnWidth), x = _this4$getAdjustedRec.x, y = _this4$getAdjustedRec.y;
                      var xPos = !isLBSideWithDiverging && _this4.isBar ? x + barLength : x;
                      var yPos = isLBSideWithDiverging && !_this4.isBar ? y + barLength : y;
                      points.push({
                        x: xPos,
                        y: yPos
                      });
                    });
                    connectorPoints.push(points);
                  });
                  return this.makeConnectorModel(connectorPoints, connector, columnWidth);
                }
              }, {
                key: "getTooltipData",
                value: function getTooltipData(seriesData2, categories) {
                  var seriesRawData = seriesData2.data;
                  var stackData = seriesData2.stackData;
                  var colors = seriesRawData.map(function(_ref8) {
                    var color = _ref8.color;
                    return color;
                  });
                  return isGroupStack(stackData) ? this.makeGroupStackTooltipData(seriesRawData, stackData, categories) : this.makeStackTooltipData(seriesRawData, stackData, colors, categories);
                }
              }, {
                key: "makeGroupStackTooltipData",
                value: function makeGroupStackTooltipData(seriesRawData, stackData, categories) {
                  var _this5 = this;
                  return Object.keys(stackData).flatMap(function(groupId) {
                    var rawDataWithSameGroupId = seriesRawData.filter(function(_ref9) {
                      var stackGroup = _ref9.stackGroup;
                      return stackGroup === groupId;
                    });
                    var colors = rawDataWithSameGroupId.map(function(_ref10) {
                      var color = _ref10.color;
                      return color;
                    });
                    return _this5.makeStackTooltipData(rawDataWithSameGroupId, stackData[groupId], colors, categories);
                  });
                }
              }, {
                key: "makeStackTooltipData",
                value: function makeStackTooltipData(seriesRawData, stackData, colors, categories) {
                  var tooltipData = [];
                  stackData.forEach(function(_ref11, dataIndex) {
                    var values = _ref11.values;
                    values.forEach(function(value, seriesIndex) {
                      tooltipData.push({
                        label: seriesRawData[seriesIndex].name,
                        color: colors[seriesIndex],
                        value,
                        category: categories.length ? categories[dataIndex] : ""
                      });
                    });
                  });
                  return tooltipData;
                }
              }, {
                key: "makeConnectorModel",
                value: function makeConnectorModel(pointsForConnector, connector, columnWidth) {
                  var _this6 = this;
                  if (!connector || !pointsForConnector.length) {
                    return [];
                  }
                  var _this$theme$connector = this.theme.connector, color = _this$theme$connector.color, lineWidth = _this$theme$connector.lineWidth, dashSegments = _this$theme$connector.dashSegments;
                  var connectorModels = [];
                  var seriesDataCount = pointsForConnector.length;
                  var seriesCount = pointsForConnector[0].length;
                  var _loop = function _loop2(seriesIndex2) {
                    var points = [];
                    for (var dataIndex = 0; dataIndex < seriesDataCount; dataIndex += 1) {
                      points.push(pointsForConnector[dataIndex][seriesIndex2]);
                    }
                    points.forEach(function(point, index) {
                      var x = point.x, y = point.y;
                      if (index < points.length - 1) {
                        var _points = points[index + 1], nextX = _points.x, nextY = _points.y;
                        connectorModels.push({
                          type: "line",
                          x: _this6.isBar ? x : x + columnWidth,
                          y: _this6.isBar ? y + columnWidth : y,
                          x2: nextX,
                          y2: nextY,
                          dashSegments,
                          strokeStyle: color,
                          lineWidth
                        });
                      }
                    });
                  };
                  for (var seriesIndex = 0; seriesIndex < seriesCount; seriesIndex += 1) {
                    _loop(seriesIndex);
                  }
                  return connectorModels;
                }
              }, {
                key: "getStackValueRatio",
                value: function getStackValueRatio(total, renderOptions) {
                  var stackType = renderOptions.stack.type, scaleType = renderOptions.scaleType, min = renderOptions.min, max2 = renderOptions.max, offsetSize = renderOptions.offsetSize;
                  if (stackType === "percent") {
                    return offsetSize / getDivisorForPercent(total, scaleType);
                  }
                  return this.getValueRatio(min, max2, offsetSize);
                }
              }, {
                key: "getStackBarLength",
                value: function getStackBarLength(values, seriesIndex, ratio, renderOptions) {
                  var value = boxStackSeries_calibrateDrawingValue(values, seriesIndex, renderOptions);
                  return isNumber(value) ? this.getBarLength(value, ratio) : null;
                }
              }, {
                key: "getStackColumnWidth",
                value: function getStackColumnWidth(renderOptions, stackGroupCount) {
                  var tickDistance = renderOptions.tickDistance, diverging = renderOptions.diverging, defaultPadding = renderOptions.defaultPadding;
                  var divisor = diverging ? 1 : stackGroupCount;
                  var themeBarWidth = this.theme.barWidth;
                  return themeBarWidth ? calculateSizeWithPercentString(tickDistance, themeBarWidth) : (tickDistance - defaultPadding * 2) / divisor;
                }
              }, {
                key: "getSeriesPosition",
                value: function getSeriesPosition(renderOptions, columnWidth, dataIndex, stackGroupIndex, stackGroupCount) {
                  var tickDistance = renderOptions.tickDistance, diverging = renderOptions.diverging;
                  var groupIndex = diverging ? 0 : stackGroupIndex;
                  var groupCount = diverging ? 1 : stackGroupCount;
                  var padding2 = (tickDistance - columnWidth * groupCount) / 2;
                  return dataIndex * tickDistance + padding2 + columnWidth * groupIndex;
                }
              }, {
                key: "getStackStartPosition",
                value: function getStackStartPosition(values, currentIndex, ratio, renderOptions, isLBSideWithDiverging) {
                  var stack = renderOptions.stack, diverging = renderOptions.diverging, seriesDirection = renderOptions.seriesDirection;
                  var startPos;
                  if (diverging) {
                    startPos = isLBSideWithDiverging ? this.calcStartPosOnLeftBottomSide(values, currentIndex, renderOptions, ratio) : this.calcStartPosOnRightTopSide(values, currentIndex, renderOptions, ratio);
                  } else if (isPercentStack(stack)) {
                    startPos = this.calcStartPositionWithPercent(values, currentIndex, ratio);
                  } else if (seriesDirection === SeriesDirection.POSITIVE) {
                    startPos = this.calcStartPosOnRightTopSide(values, currentIndex, renderOptions, ratio);
                  } else if (seriesDirection === SeriesDirection.NEGATIVE) {
                    startPos = this.calcStartPosOnLeftBottomSide(values, currentIndex, renderOptions, ratio);
                  } else {
                    startPos = this.calcStartPositionWithStack(values, currentIndex, renderOptions, ratio);
                  }
                  return startPos;
                }
              }, {
                key: "calcStartPosOnLeftBottomSide",
                value: function calcStartPosOnLeftBottomSide(values, currentIndex, renderOptions, ratio) {
                  var min = renderOptions.min, max2 = renderOptions.max, diverging = renderOptions.diverging;
                  var basePosition = diverging ? this.leftBasePosition : this.basePosition;
                  var totalOfIndexBefore = sumValuesBeforeIndex(values, currentIndex, false);
                  var totalOfValues = sumValuesBeforeIndex(values, currentIndex, true);
                  var collideEdge = totalOfValues < min;
                  var usingValue = this.isBar ? totalOfValues : totalOfIndexBefore;
                  var result = max2 < 0 ? Math.min(usingValue - max2, 0) : usingValue;
                  var pos;
                  if (this.isBar) {
                    pos = collideEdge ? 0 : basePosition - Math.abs(result) * ratio;
                  } else {
                    pos = basePosition + Math.abs(result) * ratio;
                  }
                  return pos;
                }
              }, {
                key: "calcStartPosOnRightTopSide",
                value: function calcStartPosOnRightTopSide(values, currentIndex, renderOptions, ratio) {
                  var min = renderOptions.min, max2 = renderOptions.max, diverging = renderOptions.diverging;
                  var basePosition = diverging ? this.rightBasePosition : this.basePosition;
                  var totalOfIndexBefore = sumValuesBeforeIndex(values, currentIndex, false);
                  var totalOfValues = sumValuesBeforeIndex(values, currentIndex, true);
                  var collideEdge = totalOfValues > max2;
                  var usingValue = this.isBar ? totalOfIndexBefore : totalOfValues;
                  var result = min > 0 ? Math.max(usingValue - min, 0) : usingValue;
                  var barLength = result * ratio;
                  var pos;
                  if (this.isBar) {
                    pos = basePosition + barLength;
                  } else {
                    pos = collideEdge ? 0 : basePosition - barLength;
                  }
                  return pos;
                }
              }, {
                key: "calcStartPositionWithStack",
                value: function calcStartPositionWithStack(values, currentIndex, renderOptions, ratio) {
                  return values[currentIndex] < 0 ? this.calcStartPosOnLeftBottomSide(values, currentIndex, renderOptions, ratio) : this.calcStartPosOnRightTopSide(values, currentIndex, renderOptions, ratio);
                }
              }, {
                key: "calcStartPositionWithPercent",
                value: function calcStartPositionWithPercent(values, currentIndex, ratio) {
                  var basePosition = this.basePosition;
                  var totalPrevValues = sumValuesBeforeIndex(values, currentIndex, this.isBar ? values[currentIndex] < 0 : values[currentIndex] > 0);
                  return this.isBar ? totalPrevValues * ratio + basePosition : basePosition - totalPrevValues * ratio;
                }
              }, {
                key: "getStackRectInfo",
                value: function getStackRectInfo(values, seriesIndex, ratio, renderOptions, isLBSideWithDiverging) {
                  var barLength = this.getStackBarLength(values, seriesIndex, ratio, renderOptions);
                  var dataPosition = this.getStackStartPosition(values, seriesIndex, ratio, renderOptions, isLBSideWithDiverging);
                  return {
                    barLength,
                    dataPosition
                  };
                }
              }, {
                key: "getDataLabels",
                value: function getDataLabels(seriesModels, renderOptions) {
                  var _this7 = this;
                  return seriesModels.map(function(data) {
                    return _this7.makeDataLabel(data, renderOptions.centerYAxis);
                  });
                }
              }, {
                key: "getTotalDataLabels",
                value: function getTotalDataLabels(seriesData2, renderOptions) {
                  var stackData = seriesData2.stackData, stack = seriesData2.stack;
                  if (isPercentStack(stack)) {
                    return [];
                  }
                  return isGroupStack(stackData) ? this.makeGroupTotalDataLabels(seriesData2, renderOptions) : this.makeTotalDataLabels(stackData, renderOptions);
                }
              }, {
                key: "makeGroupTotalDataLabels",
                value: function makeGroupTotalDataLabels(stackSeries, renderOptions) {
                  var _this8 = this;
                  var dataLabels = [];
                  var stackGroupData = stackSeries.stackData;
                  var stackGroupIds = Object.keys(stackGroupData);
                  stackGroupIds.forEach(function(groupId, groupIndex) {
                    var totalDataLabels = _this8.makeTotalDataLabels(stackGroupData[groupId], renderOptions, stackGroupIds.length, groupIndex);
                    dataLabels = [].concat(boxStackSeries_toConsumableArray(dataLabels), boxStackSeries_toConsumableArray(totalDataLabels));
                  });
                  return dataLabels;
                }
              }, {
                key: "makeTotalDataLabels",
                value: function makeTotalDataLabels(stackData, renderOptions) {
                  var _this9 = this;
                  var stackGroupCount = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
                  var stackGroupIndex = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
                  var dataLabels = [];
                  var min = renderOptions.min, max2 = renderOptions.max, seriesDirection = renderOptions.seriesDirection, diverging = renderOptions.diverging, centerYAxis = renderOptions.centerYAxis;
                  var columnWidth = this.getStackColumnWidth(renderOptions, stackGroupCount);
                  stackData.forEach(function(data, dataIndex) {
                    var total = data.total;
                    var seriesPos = _this9.getSeriesPosition(renderOptions, columnWidth, dataIndex, stackGroupIndex, stackGroupCount);
                    var ratio = _this9.getStackValueRatio(total, renderOptions);
                    var directionKeys = getDirectionKeys(seriesDirection);
                    directionKeys.forEach(function(key) {
                      var value = total[key];
                      if (!value) {
                        return;
                      }
                      var barLength = _this9.makeBarLength(value, {
                        min,
                        max: max2,
                        ratio
                      });
                      var dataPosition = _this9.getStartPosition(barLength, value, renderOptions, diverging && isLeftBottomSide(stackGroupIndex));
                      var stackTotal = boxStackSeries_objectSpread({
                        type: "stackTotal",
                        value,
                        name: "totalLabel-".concat(key),
                        theme: _this9.theme.dataLabels.stackTotal
                      }, _this9.getAdjustedRect(seriesPos, dataPosition, barLength, columnWidth));
                      dataLabels.push(_this9.makeTotalDataLabel(stackTotal, centerYAxis));
                    });
                  });
                  return dataLabels;
                }
              }, {
                key: "makeTotalDataLabel",
                value: function makeTotalDataLabel(totalLabel, centerYAxis) {
                  return boxStackSeries_objectSpread(boxStackSeries_objectSpread({}, totalLabel), {}, {
                    direction: this.getDataLabelDirection(totalLabel, centerYAxis),
                    plot: {
                      x: 0,
                      y: 0,
                      size: this.getOffsetSize()
                    }
                  });
                }
              }, {
                key: "onMousemoveGroupedType",
                value: function onMousemoveGroupedType(responders) {
                  var rectModels = this.getRectModelsFromRectResponders(responders);
                  this.eventBus.emit("renderHoveredSeries", {
                    models: [].concat(boxStackSeries_toConsumableArray(rectModels), boxStackSeries_toConsumableArray(this.getGroupedRect(responders, "hover"))),
                    name: this.name,
                    eventDetectType: this.eventDetectType
                  });
                  this.activatedResponders = rectModels;
                }
              }]);
              return BoxStackSeries2;
            }(BoxSeries);
            ;
            function zeroAxis_typeof(obj) {
              "@babel/helpers - typeof";
              if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                zeroAxis_typeof = function _typeof2(obj2) {
                  return typeof obj2;
                };
              } else {
                zeroAxis_typeof = function _typeof2(obj2) {
                  return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                };
              }
              return zeroAxis_typeof(obj);
            }
            function zeroAxis_classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function zeroAxis_defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            function zeroAxis_createClass(Constructor, protoProps, staticProps) {
              if (protoProps)
                zeroAxis_defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                zeroAxis_defineProperties(Constructor, staticProps);
              return Constructor;
            }
            function zeroAxis_inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function");
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
              if (superClass)
                zeroAxis_setPrototypeOf(subClass, superClass);
            }
            function zeroAxis_setPrototypeOf(o, p) {
              zeroAxis_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
                o2.__proto__ = p2;
                return o2;
              };
              return zeroAxis_setPrototypeOf(o, p);
            }
            function zeroAxis_createSuper(Derived) {
              var hasNativeReflectConstruct = zeroAxis_isNativeReflectConstruct();
              return function _createSuperInternal() {
                var Super = zeroAxis_getPrototypeOf(Derived), result;
                if (hasNativeReflectConstruct) {
                  var NewTarget = zeroAxis_getPrototypeOf(this).constructor;
                  result = Reflect.construct(Super, arguments, NewTarget);
                } else {
                  result = Super.apply(this, arguments);
                }
                return zeroAxis_possibleConstructorReturn(this, result);
              };
            }
            function zeroAxis_possibleConstructorReturn(self2, call) {
              if (call && (zeroAxis_typeof(call) === "object" || typeof call === "function")) {
                return call;
              }
              return zeroAxis_assertThisInitialized(self2);
            }
            function zeroAxis_assertThisInitialized(self2) {
              if (self2 === void 0) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return self2;
            }
            function zeroAxis_isNativeReflectConstruct() {
              if (typeof Reflect === "undefined" || !Reflect.construct)
                return false;
              if (Reflect.construct.sham)
                return false;
              if (typeof Proxy === "function")
                return true;
              try {
                Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                }));
                return true;
              } catch (e) {
                return false;
              }
            }
            function zeroAxis_getPrototypeOf(o) {
              zeroAxis_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
                return o2.__proto__ || Object.getPrototypeOf(o2);
              };
              return zeroAxis_getPrototypeOf(o);
            }
            function zeroAxis_defineProperty(obj, key, value) {
              if (key in obj) {
                Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
              } else {
                obj[key] = value;
              }
              return obj;
            }
            var ZeroAxis = function(_Component) {
              zeroAxis_inherits(ZeroAxis2, _Component);
              var _super = zeroAxis_createSuper(ZeroAxis2);
              function ZeroAxis2() {
                var _this;
                zeroAxis_classCallCheck(this, ZeroAxis2);
                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }
                _this = _super.call.apply(_super, [this].concat(args));
                zeroAxis_defineProperty(zeroAxis_assertThisInitialized(_this), "models", []);
                return _this;
              }
              zeroAxis_createClass(ZeroAxis2, [{
                key: "initialize",
                value: function initialize() {
                  this.type = "zeroAxis";
                  this.name = "zeroAxis";
                }
              }, {
                key: "render",
                value: function render(_ref) {
                  var layout2 = _ref.layout, axes2 = _ref.axes, series = _ref.series, options2 = _ref.options;
                  this.rect = layout2.plot;
                  var labelAxisOnYAxis = isLabelAxisOnYAxis({
                    series,
                    options: options2
                  });
                  var valueAxisName = labelAxisOnYAxis ? "xAxis" : "yAxis";
                  var _ref2 = axes2[valueAxisName], zeroPosition = _ref2.zeroPosition;
                  if (isNumber(zeroPosition)) {
                    this.models = this.renderZeroModel(zeroPosition, labelAxisOnYAxis);
                  }
                }
              }, {
                key: "renderZeroModel",
                value: function renderZeroModel(zeroPosition, vertical) {
                  var zeroPixel = crispPixel(0);
                  var position = crispPixel(zeroPosition);
                  var model;
                  if (vertical) {
                    model = {
                      type: "line",
                      x: position,
                      y: zeroPixel,
                      x2: position,
                      y2: crispPixel(this.rect.height),
                      strokeStyle: "rgba(0, 0, 0, 0.5)"
                    };
                  } else {
                    model = {
                      type: "line",
                      x: zeroPixel,
                      y: position,
                      x2: crispPixel(this.rect.width),
                      y2: position,
                      strokeStyle: "rgba(0, 0, 0, 0.5)"
                    };
                  }
                  return [model];
                }
              }]);
              return ZeroAxis2;
            }(Component);
            ;
            function axisUsingCenterY_typeof(obj) {
              "@babel/helpers - typeof";
              if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                axisUsingCenterY_typeof = function _typeof2(obj2) {
                  return typeof obj2;
                };
              } else {
                axisUsingCenterY_typeof = function _typeof2(obj2) {
                  return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                };
              }
              return axisUsingCenterY_typeof(obj);
            }
            function axisUsingCenterY_toConsumableArray(arr) {
              return axisUsingCenterY_arrayWithoutHoles(arr) || axisUsingCenterY_iterableToArray(arr) || axisUsingCenterY_unsupportedIterableToArray(arr) || axisUsingCenterY_nonIterableSpread();
            }
            function axisUsingCenterY_nonIterableSpread() {
              throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            function axisUsingCenterY_unsupportedIterableToArray(o, minLen) {
              if (!o)
                return;
              if (typeof o === "string")
                return axisUsingCenterY_arrayLikeToArray(o, minLen);
              var n = Object.prototype.toString.call(o).slice(8, -1);
              if (n === "Object" && o.constructor)
                n = o.constructor.name;
              if (n === "Map" || n === "Set")
                return Array.from(o);
              if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                return axisUsingCenterY_arrayLikeToArray(o, minLen);
            }
            function axisUsingCenterY_iterableToArray(iter) {
              if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
                return Array.from(iter);
            }
            function axisUsingCenterY_arrayWithoutHoles(arr) {
              if (Array.isArray(arr))
                return axisUsingCenterY_arrayLikeToArray(arr);
            }
            function axisUsingCenterY_arrayLikeToArray(arr, len) {
              if (len == null || len > arr.length)
                len = arr.length;
              for (var i = 0, arr2 = new Array(len); i < len; i++) {
                arr2[i] = arr[i];
              }
              return arr2;
            }
            function axisUsingCenterY_ownKeys(object, enumerableOnly) {
              var keys = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object);
                if (enumerableOnly) {
                  symbols = symbols.filter(function(sym) {
                    return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                  });
                }
                keys.push.apply(keys, symbols);
              }
              return keys;
            }
            function axisUsingCenterY_objectSpread(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i] != null ? arguments[i] : {};
                if (i % 2) {
                  axisUsingCenterY_ownKeys(Object(source), true).forEach(function(key) {
                    axisUsingCenterY_defineProperty(target, key, source[key]);
                  });
                } else if (Object.getOwnPropertyDescriptors) {
                  Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                } else {
                  axisUsingCenterY_ownKeys(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  });
                }
              }
              return target;
            }
            function axisUsingCenterY_classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function axisUsingCenterY_defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            function axisUsingCenterY_createClass(Constructor, protoProps, staticProps) {
              if (protoProps)
                axisUsingCenterY_defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                axisUsingCenterY_defineProperties(Constructor, staticProps);
              return Constructor;
            }
            function axisUsingCenterY_inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function");
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
              if (superClass)
                axisUsingCenterY_setPrototypeOf(subClass, superClass);
            }
            function axisUsingCenterY_setPrototypeOf(o, p) {
              axisUsingCenterY_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
                o2.__proto__ = p2;
                return o2;
              };
              return axisUsingCenterY_setPrototypeOf(o, p);
            }
            function axisUsingCenterY_createSuper(Derived) {
              var hasNativeReflectConstruct = axisUsingCenterY_isNativeReflectConstruct();
              return function _createSuperInternal() {
                var Super = axisUsingCenterY_getPrototypeOf(Derived), result;
                if (hasNativeReflectConstruct) {
                  var NewTarget = axisUsingCenterY_getPrototypeOf(this).constructor;
                  result = Reflect.construct(Super, arguments, NewTarget);
                } else {
                  result = Super.apply(this, arguments);
                }
                return axisUsingCenterY_possibleConstructorReturn(this, result);
              };
            }
            function axisUsingCenterY_possibleConstructorReturn(self2, call) {
              if (call && (axisUsingCenterY_typeof(call) === "object" || typeof call === "function")) {
                return call;
              }
              return axisUsingCenterY_assertThisInitialized(self2);
            }
            function axisUsingCenterY_assertThisInitialized(self2) {
              if (self2 === void 0) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return self2;
            }
            function axisUsingCenterY_isNativeReflectConstruct() {
              if (typeof Reflect === "undefined" || !Reflect.construct)
                return false;
              if (Reflect.construct.sham)
                return false;
              if (typeof Proxy === "function")
                return true;
              try {
                Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                }));
                return true;
              } catch (e) {
                return false;
              }
            }
            function axisUsingCenterY_getPrototypeOf(o) {
              axisUsingCenterY_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
                return o2.__proto__ || Object.getPrototypeOf(o2);
              };
              return axisUsingCenterY_getPrototypeOf(o);
            }
            function axisUsingCenterY_defineProperty(obj, key, value) {
              if (key in obj) {
                Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
              } else {
                obj[key] = value;
              }
              return obj;
            }
            var AxisUsingCenterY = function(_Component) {
              axisUsingCenterY_inherits(AxisUsingCenterY2, _Component);
              var _super = axisUsingCenterY_createSuper(AxisUsingCenterY2);
              function AxisUsingCenterY2() {
                var _this;
                axisUsingCenterY_classCallCheck(this, AxisUsingCenterY2);
                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }
                _this = _super.call.apply(_super, [this].concat(args));
                axisUsingCenterY_defineProperty(axisUsingCenterY_assertThisInitialized(_this), "name", void 0);
                axisUsingCenterY_defineProperty(axisUsingCenterY_assertThisInitialized(_this), "models", {
                  label: [],
                  tick: [],
                  axisLine: []
                });
                axisUsingCenterY_defineProperty(axisUsingCenterY_assertThisInitialized(_this), "drawModels", void 0);
                axisUsingCenterY_defineProperty(axisUsingCenterY_assertThisInitialized(_this), "yAxisComponent", void 0);
                axisUsingCenterY_defineProperty(axisUsingCenterY_assertThisInitialized(_this), "theme", void 0);
                return _this;
              }
              axisUsingCenterY_createClass(AxisUsingCenterY2, [{
                key: "initialize",
                value: function initialize(_ref) {
                  var name = _ref.name;
                  this.type = "axis";
                  this.name = name;
                  this.yAxisComponent = name === AxisType.Y;
                }
              }, {
                key: "render",
                value: function render(_ref2) {
                  var _this2 = this;
                  var layout2 = _ref2.layout, axes2 = _ref2.axes, theme2 = _ref2.theme;
                  var centerYAxis = axes2.centerYAxis;
                  if (!centerYAxis) {
                    return;
                  }
                  this.theme = getAxisTheme(theme2, this.name);
                  this.rect = layout2[this.name];
                  if (this.name === "yAxis") {
                    this.rect = axisUsingCenterY_objectSpread(axisUsingCenterY_objectSpread({}, this.rect), {}, {
                      x: centerYAxis.x
                    });
                  }
                  var _ref3 = axes2[this.name], viewLabels = _ref3.viewLabels, tickCount = _ref3.tickCount, tickInterval = _ref3.tickInterval, needRotateLabel = _ref3.needRotateLabel, radian = _ref3.radian, offsetY = _ref3.offsetY;
                  var renderOptions = {
                    tickInterval,
                    centerYAxis,
                    needRotateLabel,
                    radian,
                    offsetY,
                    relativePositions: makeTickPixelPositions(this.axisSize(centerYAxis), tickCount)
                  };
                  var offsetKey = this.yAxisComponent ? "y" : "x";
                  var anchorKey = this.yAxisComponent ? "x" : "y";
                  this.models.label = this.renderLabelModels(viewLabels, offsetKey, anchorKey, renderOptions);
                  this.models.tick = this.renderTickModels(offsetKey, anchorKey, renderOptions);
                  this.models.axisLine = this.renderAxisLineModel(centerYAxis);
                  if (!this.drawModels) {
                    this.drawModels = {
                      tick: [],
                      label: [],
                      axisLine: this.models.axisLine
                    };
                    ["tick", "label"].forEach(function(type) {
                      _this2.drawModels[type] = _this2.models[type].map(function(m) {
                        var drawModel = axisUsingCenterY_objectSpread({}, m);
                        if (_this2.yAxisComponent) {
                          drawModel.y = 0;
                        } else {
                          drawModel.x = 0;
                        }
                        return drawModel;
                      });
                    });
                  }
                }
              }, {
                key: "renderAxisLineModel",
                value: function renderAxisLineModel(_ref4) {
                  var xAxisHalfSize = _ref4.xAxisHalfSize, secondStartX = _ref4.secondStartX;
                  var zeroPixel = crispPixel(0);
                  var widthPixel = crispPixel(this.rect.width);
                  var axisLine;
                  if (this.yAxisComponent) {
                    var heightPixel = crispPixel(this.rect.height);
                    axisLine = [{
                      type: "line",
                      x: widthPixel,
                      y: zeroPixel,
                      x2: widthPixel,
                      y2: heightPixel
                    }, {
                      type: "line",
                      x: zeroPixel,
                      y: zeroPixel,
                      x2: zeroPixel,
                      y2: heightPixel
                    }];
                  } else {
                    axisLine = [{
                      type: "line",
                      x: zeroPixel,
                      y: zeroPixel,
                      x2: crispPixel(xAxisHalfSize),
                      y2: zeroPixel
                    }, {
                      type: "line",
                      x: crispPixel(secondStartX),
                      y: zeroPixel,
                      x2: widthPixel,
                      y2: zeroPixel
                    }];
                  }
                  return axisLine;
                }
              }, {
                key: "renderTickModels",
                value: function renderTickModels(offsetKey, anchorKey, renderOptions) {
                  var _this3 = this;
                  var tickAnchorPoint = this.yAxisComponent ? crispPixel(this.rect.width) : crispPixel(0);
                  var tickInterval = renderOptions.tickInterval, secondStartX = renderOptions.centerYAxis.secondStartX, relativePositions = renderOptions.relativePositions;
                  return relativePositions.reduce(function(positions, position, index) {
                    var _model;
                    if (index % tickInterval) {
                      return positions;
                    }
                    var model = (_model = {
                      type: "tick",
                      isYAxis: _this3.yAxisComponent,
                      tickSize: _this3.yAxisComponent ? -5 : 5
                    }, axisUsingCenterY_defineProperty(_model, offsetKey, crispPixel(position)), axisUsingCenterY_defineProperty(_model, anchorKey, tickAnchorPoint), _model);
                    var addedTickModel = axisUsingCenterY_objectSpread({}, model);
                    if (_this3.yAxisComponent) {
                      addedTickModel[anchorKey] = crispPixel(0);
                      addedTickModel.tickSize = 5;
                    } else {
                      addedTickModel[offsetKey] = crispPixel(position + secondStartX);
                    }
                    return [].concat(axisUsingCenterY_toConsumableArray(positions), [model, addedTickModel]);
                  }, []);
                }
              }, {
                key: "renderLabelModels",
                value: function renderLabelModels(labels, offsetKey, anchorKey, renderOptions) {
                  var _this4 = this;
                  var _renderOptions$center = renderOptions.centerYAxis, secondStartX = _renderOptions$center.secondStartX, yAxisLabelAnchorPoint = _renderOptions$center.yAxisLabelAnchorPoint, offsetY = renderOptions.offsetY, needRotateLabel = renderOptions.needRotateLabel, radian = renderOptions.radian;
                  var labelTheme = this.theme.label;
                  var font = getTitleFontString(labelTheme);
                  var labelAnchorPoint, textAlign, textLabels;
                  if (this.yAxisComponent) {
                    labelAnchorPoint = crispPixel(yAxisLabelAnchorPoint);
                    textAlign = "center";
                    textLabels = labels;
                  } else {
                    labelAnchorPoint = offsetY;
                    textLabels = axisUsingCenterY_toConsumableArray(labels).reverse();
                    textAlign = needRotateLabel ? "left" : "center";
                  }
                  var style = ["default", {
                    textAlign,
                    font,
                    fillStyle: labelTheme.color
                  }];
                  return textLabels.reduce(function(positions, _ref5, index) {
                    var _model2;
                    var text = _ref5.text, offsetPos = _ref5.offsetPos;
                    var model = (_model2 = {
                      type: "label",
                      text,
                      style
                    }, axisUsingCenterY_defineProperty(_model2, offsetKey, crispPixel(offsetPos) + (_this4.yAxisComponent ? 0 : secondStartX)), axisUsingCenterY_defineProperty(_model2, anchorKey, labelAnchorPoint), axisUsingCenterY_defineProperty(_model2, "radian", radian), _model2);
                    var models = [model];
                    if (!_this4.yAxisComponent) {
                      var addedLabelModel = axisUsingCenterY_objectSpread(axisUsingCenterY_objectSpread({}, model), {}, axisUsingCenterY_defineProperty({
                        text: labels[index].text
                      }, offsetKey, crispPixel(model[offsetKey] - secondStartX)));
                      models.push(addedLabelModel);
                    }
                    return [].concat(axisUsingCenterY_toConsumableArray(positions), models);
                  }, []);
                }
              }, {
                key: "axisSize",
                value: function axisSize(centerYAxis) {
                  var size;
                  if (this.yAxisComponent) {
                    size = this.rect.height;
                  } else {
                    size = centerYAxis.xAxisHalfSize;
                  }
                  return size;
                }
              }, {
                key: "beforeDraw",
                value: function beforeDraw(painter) {
                  painter.ctx.strokeStyle = "rgba(0, 0, 0, 0.5)";
                  painter.ctx.lineWidth = 1;
                }
              }]);
              return AxisUsingCenterY2;
            }(Component);
            ;
            function barChart_typeof(obj) {
              "@babel/helpers - typeof";
              if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                barChart_typeof = function _typeof2(obj2) {
                  return typeof obj2;
                };
              } else {
                barChart_typeof = function _typeof2(obj2) {
                  return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                };
              }
              return barChart_typeof(obj);
            }
            function barChart_ownKeys(object, enumerableOnly) {
              var keys = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object);
                if (enumerableOnly) {
                  symbols = symbols.filter(function(sym) {
                    return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                  });
                }
                keys.push.apply(keys, symbols);
              }
              return keys;
            }
            function barChart_objectSpread(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i] != null ? arguments[i] : {};
                if (i % 2) {
                  barChart_ownKeys(Object(source), true).forEach(function(key) {
                    barChart_defineProperty(target, key, source[key]);
                  });
                } else if (Object.getOwnPropertyDescriptors) {
                  Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                } else {
                  barChart_ownKeys(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  });
                }
              }
              return target;
            }
            function barChart_defineProperty(obj, key, value) {
              if (key in obj) {
                Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
              } else {
                obj[key] = value;
              }
              return obj;
            }
            function barChart_classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function barChart_defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            function barChart_createClass(Constructor, protoProps, staticProps) {
              if (protoProps)
                barChart_defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                barChart_defineProperties(Constructor, staticProps);
              return Constructor;
            }
            function barChart_get(target, property, receiver) {
              if (typeof Reflect !== "undefined" && Reflect.get) {
                barChart_get = Reflect.get;
              } else {
                barChart_get = function _get2(target2, property2, receiver2) {
                  var base = barChart_superPropBase(target2, property2);
                  if (!base)
                    return;
                  var desc = Object.getOwnPropertyDescriptor(base, property2);
                  if (desc.get) {
                    return desc.get.call(receiver2);
                  }
                  return desc.value;
                };
              }
              return barChart_get(target, property, receiver || target);
            }
            function barChart_superPropBase(object, property) {
              while (!Object.prototype.hasOwnProperty.call(object, property)) {
                object = barChart_getPrototypeOf(object);
                if (object === null)
                  break;
              }
              return object;
            }
            function barChart_inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function");
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
              if (superClass)
                barChart_setPrototypeOf(subClass, superClass);
            }
            function barChart_setPrototypeOf(o, p) {
              barChart_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
                o2.__proto__ = p2;
                return o2;
              };
              return barChart_setPrototypeOf(o, p);
            }
            function barChart_createSuper(Derived) {
              var hasNativeReflectConstruct = barChart_isNativeReflectConstruct();
              return function _createSuperInternal() {
                var Super = barChart_getPrototypeOf(Derived), result;
                if (hasNativeReflectConstruct) {
                  var NewTarget = barChart_getPrototypeOf(this).constructor;
                  result = Reflect.construct(Super, arguments, NewTarget);
                } else {
                  result = Super.apply(this, arguments);
                }
                return barChart_possibleConstructorReturn(this, result);
              };
            }
            function barChart_possibleConstructorReturn(self2, call) {
              if (call && (barChart_typeof(call) === "object" || typeof call === "function")) {
                return call;
              }
              return barChart_assertThisInitialized(self2);
            }
            function barChart_assertThisInitialized(self2) {
              if (self2 === void 0) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return self2;
            }
            function barChart_isNativeReflectConstruct() {
              if (typeof Reflect === "undefined" || !Reflect.construct)
                return false;
              if (Reflect.construct.sham)
                return false;
              if (typeof Proxy === "function")
                return true;
              try {
                Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                }));
                return true;
              } catch (e) {
                return false;
              }
            }
            function barChart_getPrototypeOf(o) {
              barChart_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
                return o2.__proto__ || Object.getPrototypeOf(o2);
              };
              return barChart_getPrototypeOf(o);
            }
            var BarChart = function(_Chart) {
              barChart_inherits(BarChart2, _Chart);
              var _super = barChart_createSuper(BarChart2);
              function BarChart2(_ref) {
                var el = _ref.el, options2 = _ref.options, data = _ref.data;
                barChart_classCallCheck(this, BarChart2);
                return _super.call(this, {
                  el,
                  options: options2,
                  series: {
                    bar: data.series
                  },
                  categories: data.categories,
                  modules: [store_stackSeriesData, store_dataRange, store_scale, store_axes, store_plot]
                });
              }
              barChart_createClass(BarChart2, [{
                key: "initialize",
                value: function initialize() {
                  var _this$store$initStore;
                  barChart_get(barChart_getPrototypeOf(BarChart2.prototype), "initialize", this).call(this);
                  var stackChart = !!((_this$store$initStore = this.store.initStoreState.options.series) !== null && _this$store$initStore !== void 0 && _this$store$initStore.stack);
                  this.componentManager.add(Background);
                  this.componentManager.add(Title);
                  this.componentManager.add(Plot);
                  this.componentManager.add(Legend);
                  this.componentManager.add(BoxSeries, {
                    name: "bar",
                    stackChart
                  });
                  this.componentManager.add(BoxStackSeries, {
                    name: "bar",
                    stackChart
                  });
                  this.componentManager.add(ZeroAxis);
                  this.componentManager.add(Axis, {
                    name: "yAxis"
                  });
                  this.componentManager.add(Axis, {
                    name: "xAxis"
                  });
                  this.componentManager.add(Axis, {
                    name: "secondaryYAxis"
                  });
                  this.componentManager.add(AxisUsingCenterY, {
                    name: "yAxis"
                  });
                  this.componentManager.add(AxisUsingCenterY, {
                    name: "xAxis"
                  });
                  this.componentManager.add(AxisTitle, {
                    name: "secondaryYAxis"
                  });
                  this.componentManager.add(AxisTitle, {
                    name: "xAxis"
                  });
                  this.componentManager.add(AxisTitle, {
                    name: "yAxis"
                  });
                  this.componentManager.add(ExportMenu, {
                    chartEl: this.el
                  });
                  this.componentManager.add(HoveredSeries);
                  this.componentManager.add(SelectedSeries);
                  this.componentManager.add(DataLabels);
                  this.componentManager.add(Tooltip, {
                    chartEl: this.el
                  });
                  this.componentManager.add(NoDataText);
                  this.painter.addGroups([basic_namespaceObject, axis_namespaceObject, legend_namespaceObject, label_namespaceObject, brushes_exportMenu_namespaceObject, dataLabel_namespaceObject]);
                }
                /**
                 * Add data.
                 * @param {Array} data - Array of data to be added.
                 * @param {string} category - Category to be added.
                 * @api
                 * @example
                 * chart.addData([10, 20], '6');
                 */
              }, {
                key: "addData",
                value: function addData(data, category2) {
                  this.animationControlFlag.updating = true;
                  this.resetSeries();
                  this.store.dispatch("addData", {
                    data,
                    category: category2
                  });
                }
                /**
                 * Add series.
                 * @param {Object} data - Data to be added.
                 *   @param {string} data.name - Series name.
                 *   @param {Array<number|Array<number>>} data.data - Array of data to be added.
                 * @api
                 * @example
                 * chart.addSeries({
                 *   name: 'newSeries',
                 *   data: [10, 100, 50, 40, 70, 55, 33, 70, 90, 110],
                 * });
                 */
              }, {
                key: "addSeries",
                value: function addSeries(data) {
                  this.resetSeries();
                  this.store.dispatch("addSeries", {
                    data
                  });
                }
                /**
                 * Convert the chart data to new data.
                 * @param {Object} data - Data to be set.
                 * @api
                 * @example
                 * chart.setData({
                 *   categories: ['1', '2', '3'],
                 *   series: [
                 *     {
                 *       name: 'new series',
                 *       data: [1, 2, 3],
                 *     },
                 *     {
                 *       name: 'new series2',
                 *       data: [4, 5, 6],
                 *     }
                 *   ]
                 * });
                 */
              }, {
                key: "setData",
                value: function setData(data) {
                  var categories = data.categories, series = data.series;
                  this.resetSeries();
                  this.store.dispatch("setData", {
                    series: {
                      bar: series
                    },
                    categories
                  });
                }
                /**
                 * Hide series data label.
                 * @api
                 * @example
                 * chart.hideSeriesDataLabel();
                 */
              }, {
                key: "hideSeriesDataLabel",
                value: function hideSeriesDataLabel() {
                  this.store.dispatch("updateOptions", {
                    options: {
                      series: {
                        dataLabels: {
                          visible: false
                        }
                      }
                    }
                  });
                }
                /**
                 * Show series data label.
                 * @api
                 * @example
                 * chart.showSeriesDataLabel();
                 */
              }, {
                key: "showSeriesDataLabel",
                value: function showSeriesDataLabel() {
                  this.store.dispatch("updateOptions", {
                    options: {
                      series: {
                        dataLabels: {
                          visible: true
                        }
                      }
                    }
                  });
                }
                /**
                 * Convert the chart options to new options.
                 * @param {Object} options - Chart options.
                 * @api
                 * @example
                 * chart.setOptions({
                 *   chart: {
                 *     width: 500,
                 *     height: 'auto',
                 *     title: 'Energy Usage',
                 *   },
                 *   xAxis: {
                 *     title: 'Month',
                 *     date: { format: 'yy/MM' },
                 *   },
                 *   yAxis: {
                 *     title: 'Energy (kWh)',
                 *   },
                 *   series: {
                 *     selectable: true,
                 *   },
                 *   tooltip: {
                 *     formatter: (value) => `${value}kWh`,
                 *   },
                 * });
                 */
              }, {
                key: "setOptions",
                value: function setOptions(options2) {
                  this.resetSeries();
                  this.dispatchOptionsEvent("initOptions", options2);
                }
                /**
                 * Update chart options.
                 * @param {Object} options - Chart options.
                 * @api
                 * @example
                 * chart.updateOptions({
                 *   chart: {
                 *     height: 'auto',
                 *     title: 'Energy Usage',
                 *   },
                 *   tooltip: {
                 *     formatter: (value) => `${value}kWh`,
                 *   },
                 * });
                 */
              }, {
                key: "updateOptions",
                value: function updateOptions(options2) {
                  this.resetSeries();
                  this.dispatchOptionsEvent("updateOptions", options2);
                }
                /**
                 * Show tooltip.
                 * @param {Object} seriesInfo - Information of the series for the tooltip to be displayed.
                 *   @param {number} seriesInfo.index - Index of data within series. If 'series.eventDetectType' is "grouped", only seriesIndex is needed.
                 *   @param {number} [seriesInfo.seriesIndex] - Index of series
                 * @api
                 * @example
                 * chart.showTooltip({index: 1, seriesIndex: 2});
                 */
              }, {
                key: "showTooltip",
                value: function showTooltip(seriesInfo) {
                  this.eventBus.emit("showTooltip", barChart_objectSpread({}, seriesInfo));
                }
                /**
                 * Hide tooltip.
                 * @api
                 * @example
                 * chart.hideTooltip();
                 */
              }, {
                key: "hideTooltip",
                value: function hideTooltip() {
                  this.eventBus.emit("hideTooltip");
                }
              }]);
              return BarChart2;
            }(Chart);
            ;
            function columnChart_typeof(obj) {
              "@babel/helpers - typeof";
              if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                columnChart_typeof = function _typeof2(obj2) {
                  return typeof obj2;
                };
              } else {
                columnChart_typeof = function _typeof2(obj2) {
                  return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                };
              }
              return columnChart_typeof(obj);
            }
            function columnChart_ownKeys(object, enumerableOnly) {
              var keys = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object);
                if (enumerableOnly) {
                  symbols = symbols.filter(function(sym) {
                    return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                  });
                }
                keys.push.apply(keys, symbols);
              }
              return keys;
            }
            function columnChart_objectSpread(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i] != null ? arguments[i] : {};
                if (i % 2) {
                  columnChart_ownKeys(Object(source), true).forEach(function(key) {
                    columnChart_defineProperty(target, key, source[key]);
                  });
                } else if (Object.getOwnPropertyDescriptors) {
                  Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                } else {
                  columnChart_ownKeys(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  });
                }
              }
              return target;
            }
            function columnChart_defineProperty(obj, key, value) {
              if (key in obj) {
                Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
              } else {
                obj[key] = value;
              }
              return obj;
            }
            function columnChart_classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function columnChart_defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            function columnChart_createClass(Constructor, protoProps, staticProps) {
              if (protoProps)
                columnChart_defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                columnChart_defineProperties(Constructor, staticProps);
              return Constructor;
            }
            function columnChart_get(target, property, receiver) {
              if (typeof Reflect !== "undefined" && Reflect.get) {
                columnChart_get = Reflect.get;
              } else {
                columnChart_get = function _get2(target2, property2, receiver2) {
                  var base = columnChart_superPropBase(target2, property2);
                  if (!base)
                    return;
                  var desc = Object.getOwnPropertyDescriptor(base, property2);
                  if (desc.get) {
                    return desc.get.call(receiver2);
                  }
                  return desc.value;
                };
              }
              return columnChart_get(target, property, receiver || target);
            }
            function columnChart_superPropBase(object, property) {
              while (!Object.prototype.hasOwnProperty.call(object, property)) {
                object = columnChart_getPrototypeOf(object);
                if (object === null)
                  break;
              }
              return object;
            }
            function columnChart_inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function");
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
              if (superClass)
                columnChart_setPrototypeOf(subClass, superClass);
            }
            function columnChart_setPrototypeOf(o, p) {
              columnChart_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
                o2.__proto__ = p2;
                return o2;
              };
              return columnChart_setPrototypeOf(o, p);
            }
            function columnChart_createSuper(Derived) {
              var hasNativeReflectConstruct = columnChart_isNativeReflectConstruct();
              return function _createSuperInternal() {
                var Super = columnChart_getPrototypeOf(Derived), result;
                if (hasNativeReflectConstruct) {
                  var NewTarget = columnChart_getPrototypeOf(this).constructor;
                  result = Reflect.construct(Super, arguments, NewTarget);
                } else {
                  result = Super.apply(this, arguments);
                }
                return columnChart_possibleConstructorReturn(this, result);
              };
            }
            function columnChart_possibleConstructorReturn(self2, call) {
              if (call && (columnChart_typeof(call) === "object" || typeof call === "function")) {
                return call;
              }
              return columnChart_assertThisInitialized(self2);
            }
            function columnChart_assertThisInitialized(self2) {
              if (self2 === void 0) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return self2;
            }
            function columnChart_isNativeReflectConstruct() {
              if (typeof Reflect === "undefined" || !Reflect.construct)
                return false;
              if (Reflect.construct.sham)
                return false;
              if (typeof Proxy === "function")
                return true;
              try {
                Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                }));
                return true;
              } catch (e) {
                return false;
              }
            }
            function columnChart_getPrototypeOf(o) {
              columnChart_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
                return o2.__proto__ || Object.getPrototypeOf(o2);
              };
              return columnChart_getPrototypeOf(o);
            }
            var ColumnChart = function(_Chart) {
              columnChart_inherits(ColumnChart2, _Chart);
              var _super = columnChart_createSuper(ColumnChart2);
              function ColumnChart2(_ref) {
                var el = _ref.el, options2 = _ref.options, data = _ref.data;
                columnChart_classCallCheck(this, ColumnChart2);
                return _super.call(this, {
                  el,
                  options: options2,
                  series: {
                    column: data.series
                  },
                  categories: data.categories,
                  modules: [store_stackSeriesData, store_dataRange, store_scale, store_axes, store_plot]
                });
              }
              columnChart_createClass(ColumnChart2, [{
                key: "initialize",
                value: function initialize() {
                  var _this$store$initStore;
                  columnChart_get(columnChart_getPrototypeOf(ColumnChart2.prototype), "initialize", this).call(this);
                  var stackChart = !!((_this$store$initStore = this.store.initStoreState.options.series) !== null && _this$store$initStore !== void 0 && _this$store$initStore.stack);
                  this.componentManager.add(Background);
                  this.componentManager.add(Title);
                  this.componentManager.add(Plot);
                  this.componentManager.add(Legend);
                  this.componentManager.add(BoxStackSeries, {
                    name: "column",
                    stackChart
                  });
                  this.componentManager.add(BoxSeries, {
                    name: "column",
                    stackChart
                  });
                  this.componentManager.add(ZeroAxis);
                  this.componentManager.add(Axis, {
                    name: "xAxis"
                  });
                  this.componentManager.add(Axis, {
                    name: "yAxis"
                  });
                  this.componentManager.add(AxisTitle, {
                    name: "xAxis"
                  });
                  this.componentManager.add(AxisTitle, {
                    name: "yAxis"
                  });
                  this.componentManager.add(ExportMenu, {
                    chartEl: this.el
                  });
                  this.componentManager.add(HoveredSeries);
                  this.componentManager.add(SelectedSeries);
                  this.componentManager.add(DataLabels);
                  this.componentManager.add(Tooltip, {
                    chartEl: this.el
                  });
                  this.componentManager.add(NoDataText);
                  this.componentManager.add(RangeSelection);
                  this.painter.addGroups([basic_namespaceObject, axis_namespaceObject, legend_namespaceObject, label_namespaceObject, brushes_exportMenu_namespaceObject, dataLabel_namespaceObject]);
                }
                /**
                 * Add data.
                 * @param {Array<number|Array<number>>} data - Array of data to be added
                 * @param {string} category - Category to be added
                 * @api
                 * @example
                 * chart.addData([10, 20], '6');
                 */
              }, {
                key: "addData",
                value: function addData(data, category2) {
                  this.animationControlFlag.updating = true;
                  this.resetSeries();
                  this.store.dispatch("addData", {
                    data,
                    category: category2
                  });
                }
                /**
                 * Add series.
                 * @param {Object} data - Data to be added
                 *   @param {string} data.name - Series name
                 *   @param {Array<number|Array<number>>} data.data - Array of data to be added
                 * @api
                 * @example
                 * chart.addSeries({
                 *   name: 'newSeries',
                 *   data: [10, 100, 50, 40, 70, 55, 33, 70, 90, 110],
                 * });
                 */
              }, {
                key: "addSeries",
                value: function addSeries(data) {
                  this.resetSeries();
                  this.store.dispatch("addSeries", {
                    data
                  });
                }
                /**
                 * Convert the chart data to new data.
                 * @param {Object} data - Data to be set
                 * @api
                 * @example
                 * chart.setData({
                 *   categories: ['1', '2', '3'],
                 *   series: [
                 *     {
                 *       name: 'new series',
                 *       data: [1, 2, 3],
                 *     },
                 *     {
                 *       name: 'new series2',
                 *       data: [4, 5, 6],
                 *     }
                 *   ]
                 * });
                 */
              }, {
                key: "setData",
                value: function setData(data) {
                  var categories = data.categories, series = data.series;
                  this.resetSeries();
                  this.store.dispatch("setData", {
                    series: {
                      column: series
                    },
                    categories
                  });
                }
                /**
                 * Hide series data label.
                 * @api
                 * @example
                 * chart.hideSeriesDataLabel();
                 */
              }, {
                key: "hideSeriesDataLabel",
                value: function hideSeriesDataLabel() {
                  this.store.dispatch("updateOptions", {
                    options: {
                      series: {
                        dataLabels: {
                          visible: false
                        }
                      }
                    }
                  });
                }
                /**
                 * Show series data label.
                 * @api
                 * @example
                 * chart.showSeriesDataLabel();
                 */
              }, {
                key: "showSeriesDataLabel",
                value: function showSeriesDataLabel() {
                  this.store.dispatch("updateOptions", {
                    options: {
                      series: {
                        dataLabels: {
                          visible: true
                        }
                      }
                    }
                  });
                }
                /**
                 * Convert the chart options to new options.
                 * @param {Object} options - Chart options
                 * @api
                 * @example
                 * chart.setOptions({
                 *   chart: {
                 *     width: 500,
                 *     height: 'auto',
                 *     title: 'Energy Usage',
                 *   },
                 *   xAxis: {
                 *     title: 'Month',
                 *     date: { format: 'yy/MM' },
                 *   },
                 *   yAxis: {
                 *     title: 'Energy (kWh)',
                 *   },
                 *   series: {
                 *     selectable: true,
                 *   },
                 *   tooltip: {
                 *     formatter: (value) => `${value}kWh`,
                 *   },
                 * });
                 */
              }, {
                key: "setOptions",
                value: function setOptions(options2) {
                  this.resetSeries();
                  this.dispatchOptionsEvent("initOptions", options2);
                }
                /**
                 * Update chart options.
                 * @param {Object} options - Chart options
                 * @api
                 * @example
                 * chart.updateOptions({
                 *   chart: {
                 *     height: 'auto',
                 *     title: 'Energy Usage',
                 *   },
                 *   tooltip: {
                 *     formatter: (value) => `${value}kWh`,
                 *   },
                 * });
                 */
              }, {
                key: "updateOptions",
                value: function updateOptions(options2) {
                  this.resetSeries();
                  this.dispatchOptionsEvent("updateOptions", options2);
                }
                /**
                 * Show tooltip.
                 * @param {Object} seriesInfo - Information of the series for the tooltip to be displayed.
                 *      @param {number} seriesInfo.index - Index of data within series. If 'series.eventDetectType' is "grouped", only seriesIndex is needed.
                 *      @param {number} [seriesInfo.seriesIndex] - Index of series.
                 * @api
                 * @example
                 * chart.showTooltip({index: 1, seriesIndex: 2});
                 */
              }, {
                key: "showTooltip",
                value: function showTooltip(seriesInfo) {
                  this.eventBus.emit("showTooltip", columnChart_objectSpread({}, seriesInfo));
                }
                /**
                 * Hide tooltip.
                 * @api
                 * @example
                 * chart.hideTooltip();
                 */
              }, {
                key: "hideTooltip",
                value: function hideTooltip() {
                  this.eventBus.emit("hideTooltip");
                }
              }]);
              return ColumnChart2;
            }(Chart);
            ;
            function columnLineChart_typeof(obj) {
              "@babel/helpers - typeof";
              if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                columnLineChart_typeof = function _typeof2(obj2) {
                  return typeof obj2;
                };
              } else {
                columnLineChart_typeof = function _typeof2(obj2) {
                  return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                };
              }
              return columnLineChart_typeof(obj);
            }
            function columnLineChart_ownKeys(object, enumerableOnly) {
              var keys = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object);
                if (enumerableOnly) {
                  symbols = symbols.filter(function(sym) {
                    return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                  });
                }
                keys.push.apply(keys, symbols);
              }
              return keys;
            }
            function columnLineChart_objectSpread(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i] != null ? arguments[i] : {};
                if (i % 2) {
                  columnLineChart_ownKeys(Object(source), true).forEach(function(key) {
                    columnLineChart_defineProperty(target, key, source[key]);
                  });
                } else if (Object.getOwnPropertyDescriptors) {
                  Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                } else {
                  columnLineChart_ownKeys(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  });
                }
              }
              return target;
            }
            function columnLineChart_defineProperty(obj, key, value) {
              if (key in obj) {
                Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
              } else {
                obj[key] = value;
              }
              return obj;
            }
            function columnLineChart_classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function columnLineChart_defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            function columnLineChart_createClass(Constructor, protoProps, staticProps) {
              if (protoProps)
                columnLineChart_defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                columnLineChart_defineProperties(Constructor, staticProps);
              return Constructor;
            }
            function columnLineChart_get(target, property, receiver) {
              if (typeof Reflect !== "undefined" && Reflect.get) {
                columnLineChart_get = Reflect.get;
              } else {
                columnLineChart_get = function _get2(target2, property2, receiver2) {
                  var base = columnLineChart_superPropBase(target2, property2);
                  if (!base)
                    return;
                  var desc = Object.getOwnPropertyDescriptor(base, property2);
                  if (desc.get) {
                    return desc.get.call(receiver2);
                  }
                  return desc.value;
                };
              }
              return columnLineChart_get(target, property, receiver || target);
            }
            function columnLineChart_superPropBase(object, property) {
              while (!Object.prototype.hasOwnProperty.call(object, property)) {
                object = columnLineChart_getPrototypeOf(object);
                if (object === null)
                  break;
              }
              return object;
            }
            function columnLineChart_inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function");
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
              if (superClass)
                columnLineChart_setPrototypeOf(subClass, superClass);
            }
            function columnLineChart_setPrototypeOf(o, p) {
              columnLineChart_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
                o2.__proto__ = p2;
                return o2;
              };
              return columnLineChart_setPrototypeOf(o, p);
            }
            function columnLineChart_createSuper(Derived) {
              var hasNativeReflectConstruct = columnLineChart_isNativeReflectConstruct();
              return function _createSuperInternal() {
                var Super = columnLineChart_getPrototypeOf(Derived), result;
                if (hasNativeReflectConstruct) {
                  var NewTarget = columnLineChart_getPrototypeOf(this).constructor;
                  result = Reflect.construct(Super, arguments, NewTarget);
                } else {
                  result = Super.apply(this, arguments);
                }
                return columnLineChart_possibleConstructorReturn(this, result);
              };
            }
            function columnLineChart_possibleConstructorReturn(self2, call) {
              if (call && (columnLineChart_typeof(call) === "object" || typeof call === "function")) {
                return call;
              }
              return columnLineChart_assertThisInitialized(self2);
            }
            function columnLineChart_assertThisInitialized(self2) {
              if (self2 === void 0) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return self2;
            }
            function columnLineChart_isNativeReflectConstruct() {
              if (typeof Reflect === "undefined" || !Reflect.construct)
                return false;
              if (Reflect.construct.sham)
                return false;
              if (typeof Proxy === "function")
                return true;
              try {
                Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                }));
                return true;
              } catch (e) {
                return false;
              }
            }
            function columnLineChart_getPrototypeOf(o) {
              columnLineChart_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
                return o2.__proto__ || Object.getPrototypeOf(o2);
              };
              return columnLineChart_getPrototypeOf(o);
            }
            function hasPointEventType(respondersModel, name) {
              return respondersModel.find(function(_ref) {
                var component = _ref.component;
                return component.name === name && component.eventDetectType === "point";
              });
            }
            function hasColumnLineUsingPointEventType(respondersModel) {
              return isExist(hasPointEventType(respondersModel, "column")) && isExist(hasPointEventType(respondersModel, "line"));
            }
            var ColumnLineChart = function(_Chart) {
              columnLineChart_inherits(ColumnLineChart2, _Chart);
              var _super = columnLineChart_createSuper(ColumnLineChart2);
              function ColumnLineChart2(_ref2) {
                var el = _ref2.el, options2 = _ref2.options, _ref2$data = _ref2.data, series = _ref2$data.series, categories = _ref2$data.categories;
                columnLineChart_classCallCheck(this, ColumnLineChart2);
                return _super.call(this, {
                  el,
                  options: options2,
                  series,
                  categories,
                  modules: [store_stackSeriesData, store_dataRange, store_scale, store_axes, store_plot]
                });
              }
              columnLineChart_createClass(ColumnLineChart2, [{
                key: "initialize",
                value: function initialize() {
                  columnLineChart_get(columnLineChart_getPrototypeOf(ColumnLineChart2.prototype), "initialize", this).call(this);
                  this.componentManager.add(Background);
                  this.componentManager.add(Title);
                  this.componentManager.add(Plot);
                  this.componentManager.add(Legend);
                  this.componentManager.add(BoxStackSeries, {
                    name: "column"
                  });
                  this.componentManager.add(BoxSeries, {
                    name: "column"
                  });
                  this.componentManager.add(LineSeries);
                  this.componentManager.add(ZeroAxis);
                  this.componentManager.add(Axis, {
                    name: "xAxis"
                  });
                  this.componentManager.add(Axis, {
                    name: "yAxis"
                  });
                  this.componentManager.add(Axis, {
                    name: "secondaryYAxis"
                  });
                  this.componentManager.add(AxisTitle, {
                    name: "xAxis"
                  });
                  this.componentManager.add(AxisTitle, {
                    name: "yAxis"
                  });
                  this.componentManager.add(AxisTitle, {
                    name: "secondaryYAxis"
                  });
                  this.componentManager.add(ExportMenu, {
                    chartEl: this.el
                  });
                  this.componentManager.add(HoveredSeries);
                  this.componentManager.add(SelectedSeries);
                  this.componentManager.add(DataLabels);
                  this.componentManager.add(RangeSelection);
                  this.componentManager.add(Tooltip, {
                    chartEl: this.el
                  });
                  this.componentManager.add(NoDataText);
                  this.painter.addGroups([basic_namespaceObject, axis_namespaceObject, legend_namespaceObject, label_namespaceObject, brushes_exportMenu_namespaceObject, dataLabel_namespaceObject, brushes_lineSeries_namespaceObject]);
                }
              }, {
                key: "handleEventForAllResponders",
                value: function handleEventForAllResponders(event, responderModels, delegationMethod, mousePosition) {
                  if (hasColumnLineUsingPointEventType(responderModels)) {
                    var columnSeries = responderModels.find(function(_ref3) {
                      var component = _ref3.component;
                      return component.name === "column";
                    });
                    columnSeries.component[delegationMethod]({
                      mousePosition,
                      responders: []
                    }, event);
                  }
                }
                /**
                 * Add data.
                 * @param {Array} data - Array of data to be added.
                 * @param {string} category - Category to be added.
                 * @param {string} chartType - Which type of chart to add.
                 * @api
                 * @example
                 * chart.addData([10, 20], '6', 'line');
                 */
              }, {
                key: "addData",
                value: function addData(data, category2, chartType) {
                  this.animationControlFlag.updating = true;
                  this.resetSeries();
                  this.store.dispatch("addData", {
                    data,
                    category: category2,
                    chartType
                  });
                }
                /**
                 * Add series.
                 * @param {Object} data - Data to be added.
                 * @param {string} data.name - Series name.
                 * @param {Array<number>} data.data - Array of data to be added.
                 * @param {Object} dataInfo - Which type of chart to add.
                 * @param {Object} dataInfo.chartType - Chart type.
                 * @api
                 * @example
                 * chart.addSeries(
                 *   {
                 *     name: 'newSeries',
                 *     data: [10, 100, 50, 40, 70, 55, 33, 70, 90, 110],
                 *   },
                 *   {
                 *     chartType: 'line'
                 *   });
                 */
              }, {
                key: "addSeries",
                value: function addSeries(data, dataInfo) {
                  this.resetSeries();
                  this.store.dispatch("addSeries", columnLineChart_objectSpread({
                    data
                  }, dataInfo));
                }
                /**
                 * Convert the chart data to new data.
                 * @param {Object} data - Data to be set
                 * @api
                 * @example
                 * chart.setData({
                 *   categories: ['1', '2', '3'],
                 *   series: {
                 *     column: [
                 *       {
                 *         name: 'A',
                 *         data: [1, 2, 3],
                 *       }
                 *     ],
                 *     line: [
                 *       {
                 *         name: 'B',
                 *         data: [4, 5, 6],
                 *       }
                 *     ]
                 *   }
                 * });
                 */
              }, {
                key: "setData",
                value: function setData(data) {
                  this.resetSeries();
                  this.store.dispatch("setData", data);
                }
                /**
                 * Add plot line.
                 * @param {Object} data - Plot info.
                 *   @param {string|number} data.value - The value where the plot line will be drawn.
                 *   @param {string} data.color - Plot line color.
                 *   @param {string} [data.id] - Plot id. The value on which the removePlotLine is based.
                 * @api
                 * @example
                 * chart.addPlotLine({
                 *   value: 2,
                 *   color: '#00ff22',
                 *   id: 'plot-1',
                 * });
                 */
              }, {
                key: "addPlotLine",
                value: function addPlotLine(data) {
                  this.store.dispatch("addPlotLine", {
                    data
                  });
                }
                /**
                 * Remove plot line with id.
                 * @param {string} id - Id of the plot line to be removed
                 * @api
                 * @example
                 * chart.removePlotLine('plot-1');
                 */
              }, {
                key: "removePlotLine",
                value: function removePlotLine(id) {
                  this.store.dispatch("removePlotLine", {
                    id
                  });
                }
                /**
                 * Add plot band.
                 * @param {Object} data - plot info
                 *   @param {Array<string|number>} data.range - The range to be drawn
                 *   @param {string} data.color - Plot band color
                 *   @param {string} [data.id] - Plot id. The value on which the removePlotBand is based
                 * @api
                 * @example
                 * chart.addPlotBand({
                 *   value: [2, 4],
                 *   color: '#00ff22',
                 *   id: 'plot-1',
                 * });
                 */
              }, {
                key: "addPlotBand",
                value: function addPlotBand(data) {
                  this.store.dispatch("addPlotBand", {
                    data
                  });
                }
                /**
                 * Remove plot band with id.
                 * @param {string} id - id of the plot band to be removed
                 * @api
                 * @example
                 * chart.removePlotBand('plot-1');
                 */
              }, {
                key: "removePlotBand",
                value: function removePlotBand(id) {
                  this.store.dispatch("removePlotBand", {
                    id
                  });
                }
                /**
                 * Hide series data label.
                 * @api
                 * @example
                 * chart.hideSeriesDataLabel();
                 */
              }, {
                key: "hideSeriesDataLabel",
                value: function hideSeriesDataLabel() {
                  this.store.dispatch("updateOptions", {
                    options: {
                      series: {
                        dataLabels: {
                          visible: false
                        }
                      }
                    }
                  });
                }
                /**
                 * Show series data label.
                 * @api
                 * @example
                 * chart.showSeriesDataLabel();
                 */
              }, {
                key: "showSeriesDataLabel",
                value: function showSeriesDataLabel() {
                  this.store.dispatch("updateOptions", {
                    options: {
                      series: {
                        dataLabels: {
                          visible: true
                        }
                      }
                    }
                  });
                }
                /**
                 * Convert the chart options to new options.
                 * @param {Object} options - Chart options
                 * @api
                 * @example
                 * chart.setOptions({
                 *   chart: {
                 *     width: 500,
                 *     height: 'auto',
                 *     title: 'Energy Usage',
                 *   },
                 *   xAxis: {
                 *     title: 'Month',
                 *     date: { format: 'yy/MM' },
                 *   },
                 *   yAxis: {
                 *     title: 'Energy (kWh)',
                 *   },
                 *   series: {
                 *     line: {
                 *       showDot: true,
                 *     },
                 *     selectable: true,
                 *   },
                 *   tooltip: {
                 *     formatter: (value) => `${value}kWh`,
                 *   },
                 * });
                 */
              }, {
                key: "setOptions",
                value: function setOptions(options2) {
                  this.resetSeries();
                  this.dispatchOptionsEvent("initOptions", options2);
                }
                /**
                 * Update chart options.
                 * @param {Object} options - Chart options
                 * @api
                 * @example
                 * chart.updateOptions({
                 *   chart: {
                 *     height: 'auto',
                 *     title: 'Energy Usage',
                 *   },
                 *   series: {
                 *     line: {
                 *       showDot: true,
                 *     },
                 *   },
                 * });
                 */
              }, {
                key: "updateOptions",
                value: function updateOptions(options2) {
                  this.resetSeries();
                  this.dispatchOptionsEvent("updateOptions", options2);
                }
                /**
                 * Show tooltip.
                 * @param {Object} seriesInfo - Information of the series for the tooltip to be displayed.
                 *      @param {number} seriesInfo.seriesIndex - Index of series.
                 *      @param {number} seriesInfo.index - Index of data within series.
                 *      @param {string} seriesInfo.chartType - Specify which chart to select.
                 * @api
                 * @example
                 * chart.showTooltip({index: 1, seriesIndex: 2, chartType: 'column'});
                 */
              }, {
                key: "showTooltip",
                value: function showTooltip(seriesInfo) {
                  this.eventBus.emit("showTooltip", columnLineChart_objectSpread({}, seriesInfo));
                }
                /**
                 * Hide tooltip.
                 * @api
                 * @example
                 * chart.hideTooltip();
                 */
              }, {
                key: "hideTooltip",
                value: function hideTooltip() {
                  this.eventBus.emit("hideTooltip");
                }
              }]);
              return ColumnLineChart2;
            }(Chart);
            ;
            function bubbleSeries_typeof(obj) {
              "@babel/helpers - typeof";
              if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                bubbleSeries_typeof = function _typeof2(obj2) {
                  return typeof obj2;
                };
              } else {
                bubbleSeries_typeof = function _typeof2(obj2) {
                  return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                };
              }
              return bubbleSeries_typeof(obj);
            }
            function bubbleSeries_ownKeys(object, enumerableOnly) {
              var keys = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object);
                if (enumerableOnly) {
                  symbols = symbols.filter(function(sym) {
                    return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                  });
                }
                keys.push.apply(keys, symbols);
              }
              return keys;
            }
            function bubbleSeries_objectSpread(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i] != null ? arguments[i] : {};
                if (i % 2) {
                  bubbleSeries_ownKeys(Object(source), true).forEach(function(key) {
                    bubbleSeries_defineProperty(target, key, source[key]);
                  });
                } else if (Object.getOwnPropertyDescriptors) {
                  Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                } else {
                  bubbleSeries_ownKeys(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  });
                }
              }
              return target;
            }
            function bubbleSeries_classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function bubbleSeries_defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            function bubbleSeries_createClass(Constructor, protoProps, staticProps) {
              if (protoProps)
                bubbleSeries_defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                bubbleSeries_defineProperties(Constructor, staticProps);
              return Constructor;
            }
            function bubbleSeries_inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function");
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
              if (superClass)
                bubbleSeries_setPrototypeOf(subClass, superClass);
            }
            function bubbleSeries_setPrototypeOf(o, p) {
              bubbleSeries_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
                o2.__proto__ = p2;
                return o2;
              };
              return bubbleSeries_setPrototypeOf(o, p);
            }
            function bubbleSeries_createSuper(Derived) {
              var hasNativeReflectConstruct = bubbleSeries_isNativeReflectConstruct();
              return function _createSuperInternal() {
                var Super = bubbleSeries_getPrototypeOf(Derived), result;
                if (hasNativeReflectConstruct) {
                  var NewTarget = bubbleSeries_getPrototypeOf(this).constructor;
                  result = Reflect.construct(Super, arguments, NewTarget);
                } else {
                  result = Super.apply(this, arguments);
                }
                return bubbleSeries_possibleConstructorReturn(this, result);
              };
            }
            function bubbleSeries_possibleConstructorReturn(self2, call) {
              if (call && (bubbleSeries_typeof(call) === "object" || typeof call === "function")) {
                return call;
              }
              return bubbleSeries_assertThisInitialized(self2);
            }
            function bubbleSeries_assertThisInitialized(self2) {
              if (self2 === void 0) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return self2;
            }
            function bubbleSeries_isNativeReflectConstruct() {
              if (typeof Reflect === "undefined" || !Reflect.construct)
                return false;
              if (Reflect.construct.sham)
                return false;
              if (typeof Proxy === "function")
                return true;
              try {
                Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                }));
                return true;
              } catch (e) {
                return false;
              }
            }
            function bubbleSeries_getPrototypeOf(o) {
              bubbleSeries_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
                return o2.__proto__ || Object.getPrototypeOf(o2);
              };
              return bubbleSeries_getPrototypeOf(o);
            }
            function bubbleSeries_defineProperty(obj, key, value) {
              if (key in obj) {
                Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
              } else {
                obj[key] = value;
              }
              return obj;
            }
            function bubbleSeries_toConsumableArray(arr) {
              return bubbleSeries_arrayWithoutHoles(arr) || bubbleSeries_iterableToArray(arr) || bubbleSeries_unsupportedIterableToArray(arr) || bubbleSeries_nonIterableSpread();
            }
            function bubbleSeries_nonIterableSpread() {
              throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            function bubbleSeries_unsupportedIterableToArray(o, minLen) {
              if (!o)
                return;
              if (typeof o === "string")
                return bubbleSeries_arrayLikeToArray(o, minLen);
              var n = Object.prototype.toString.call(o).slice(8, -1);
              if (n === "Object" && o.constructor)
                n = o.constructor.name;
              if (n === "Map" || n === "Set")
                return Array.from(o);
              if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                return bubbleSeries_arrayLikeToArray(o, minLen);
            }
            function bubbleSeries_iterableToArray(iter) {
              if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
                return Array.from(iter);
            }
            function bubbleSeries_arrayWithoutHoles(arr) {
              if (Array.isArray(arr))
                return bubbleSeries_arrayLikeToArray(arr);
            }
            function bubbleSeries_arrayLikeToArray(arr, len) {
              if (len == null || len > arr.length)
                len = arr.length;
              for (var i = 0, arr2 = new Array(len); i < len; i++) {
                arr2[i] = arr[i];
              }
              return arr2;
            }
            var bubbleSeries_MINIMUM_RADIUS = 0.5;
            var MINIMUM_DETECTING_AREA_RADIUS = 1;
            function getMaxRadius(bubbleData) {
              return bubbleData.reduce(function(acc, cur) {
                var NonNullData = cur.data.filter(function(datum) {
                  return !isNull(datum);
                });
                return Math.max.apply(Math, [acc].concat(bubbleSeries_toConsumableArray(NonNullData.map(function(_ref) {
                  var r = _ref.r;
                  return r;
                }))));
              }, 0);
            }
            var BubbleSeries = function(_Component) {
              bubbleSeries_inherits(BubbleSeries2, _Component);
              var _super = bubbleSeries_createSuper(BubbleSeries2);
              function BubbleSeries2() {
                var _this;
                bubbleSeries_classCallCheck(this, BubbleSeries2);
                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }
                _this = _super.call.apply(_super, [this].concat(args));
                bubbleSeries_defineProperty(bubbleSeries_assertThisInitialized(_this), "models", {
                  series: []
                });
                bubbleSeries_defineProperty(bubbleSeries_assertThisInitialized(_this), "drawModels", void 0);
                bubbleSeries_defineProperty(bubbleSeries_assertThisInitialized(_this), "responders", void 0);
                bubbleSeries_defineProperty(bubbleSeries_assertThisInitialized(_this), "activatedResponders", []);
                bubbleSeries_defineProperty(bubbleSeries_assertThisInitialized(_this), "theme", void 0);
                bubbleSeries_defineProperty(bubbleSeries_assertThisInitialized(_this), "rect", void 0);
                bubbleSeries_defineProperty(bubbleSeries_assertThisInitialized(_this), "maxRadius", -1);
                bubbleSeries_defineProperty(bubbleSeries_assertThisInitialized(_this), "maxValue", -1);
                bubbleSeries_defineProperty(bubbleSeries_assertThisInitialized(_this), "onMouseoutComponent", function() {
                  _this.eventBus.emit("seriesPointHovered", {
                    models: [],
                    name: _this.name
                  });
                  _this.eventBus.emit("renderHoveredSeries", {
                    models: [],
                    name: _this.name
                  });
                  _this.eventBus.emit("needDraw");
                });
                bubbleSeries_defineProperty(bubbleSeries_assertThisInitialized(_this), "selectSeries", function(_ref2) {
                  var index = _ref2.index, seriesIndex = _ref2.seriesIndex, state = _ref2.state;
                  if (!isNumber(index) || !isNumber(seriesIndex)) {
                    return;
                  }
                  var name = state.series.bubble.data[index].name;
                  var model = _this.responders.filter(function(_ref3) {
                    var dataName = _ref3.name;
                    return dataName === name;
                  })[seriesIndex];
                  if (!model) {
                    throw new Error(message.SELECT_SERIES_API_INDEX_ERROR);
                  }
                  var models = _this.getResponderAppliedTheme([model], "select");
                  _this.eventBus.emit("renderSelectedSeries", {
                    models,
                    name: _this.name
                  });
                  _this.eventBus.emit("needDraw");
                });
                bubbleSeries_defineProperty(bubbleSeries_assertThisInitialized(_this), "showTooltip", function(info) {
                  var index = info.index, seriesIndex = info.seriesIndex, state = info.state;
                  if (!isNumber(index) || !isNumber(seriesIndex)) {
                    return;
                  }
                  var name = state.series.bubble.data[seriesIndex].name;
                  var models = [_this.responders.filter(function(_ref4) {
                    var dataName = _ref4.name;
                    return dataName === name;
                  })[index]];
                  if (!models.length) {
                    return;
                  }
                  _this.eventBus.emit("renderHoveredSeries", {
                    models,
                    name: _this.name
                  });
                  _this.activatedResponders = models;
                  _this.eventBus.emit("seriesPointHovered", {
                    models: _this.activatedResponders,
                    name: _this.name
                  });
                  _this.eventBus.emit("needDraw");
                });
                return _this;
              }
              bubbleSeries_createClass(BubbleSeries2, [{
                key: "initialize",
                value: function initialize() {
                  this.type = "series";
                  this.name = "bubble";
                  this.eventBus.on("selectSeries", this.selectSeries);
                  this.eventBus.on("showTooltip", this.showTooltip);
                  this.eventBus.on("hideTooltip", this.onMouseoutComponent);
                }
              }, {
                key: "initUpdate",
                value: function initUpdate(delta) {
                  var _this2 = this;
                  this.drawModels.series.forEach(function(model, index) {
                    model.radius = _this2.models.series[index].radius * delta;
                  });
                }
              }, {
                key: "render",
                value: function render(chartState) {
                  var layout2 = chartState.layout, series = chartState.series, scale2 = chartState.scale, axes2 = chartState.axes, circleLegend2 = chartState.circleLegend, legend2 = chartState.legend, options2 = chartState.options, theme2 = chartState.theme;
                  var plot2 = layout2.plot;
                  if (!series.bubble) {
                    throw new Error(message.noDataError(this.name));
                  }
                  var xAxis = axes2.xAxis, yAxis = axes2.yAxis;
                  var bubbleData = series.bubble.data;
                  this.theme = theme2.series.bubble;
                  this.rect = plot2;
                  this.activeSeriesMap = getActiveSeriesMap(legend2);
                  this.selectable = this.getSelectableOption(options2);
                  var xAxisTickSize = this.rect.width / xAxis.tickCount;
                  var yAxisTickSize = this.rect.height / yAxis.tickCount;
                  this.maxRadius = circleLegend2.radius ? circleLegend2.radius : Math.min(xAxisTickSize, yAxisTickSize);
                  this.maxValue = getMaxRadius(bubbleData);
                  var seriesModel = this.renderBubblePointsModel(bubbleData, scale2);
                  var tooltipModel = this.makeTooltipModel(bubbleData);
                  this.models.series = seriesModel;
                  if (!this.drawModels) {
                    this.drawModels = deepCopy(this.models);
                  }
                  this.responders = seriesModel.map(function(m, index) {
                    return bubbleSeries_objectSpread(bubbleSeries_objectSpread({}, m), {}, {
                      type: "circle",
                      detectionSize: 0,
                      radius: m.radius + MINIMUM_DETECTING_AREA_RADIUS,
                      color: getRGBA(m.color, 0.85),
                      data: tooltipModel[index],
                      index
                    });
                  });
                }
              }, {
                key: "renderBubblePointsModel",
                value: function renderBubblePointsModel(seriesRawData, scale2) {
                  var _this3 = this;
                  var xAxisLimit = scale2.xAxis.limit;
                  var yAxisLimit = scale2.yAxis.limit;
                  var _this$theme = this.theme, borderWidth = _this$theme.borderWidth, borderColor = _this$theme.borderColor;
                  return seriesRawData.flatMap(function(_ref5, seriesIndex) {
                    var data = _ref5.data, name = _ref5.name, seriesColor = _ref5.color;
                    var circleModels = [];
                    var active = _this3.activeSeriesMap[name];
                    var color = getRGBA(seriesColor, active ? 0.8 : 0.1);
                    var nonNullData = data.filter(function(datum) {
                      return !isNull(datum);
                    });
                    nonNullData.forEach(function(datum) {
                      var rawXValue = getCoordinateXValue(datum);
                      var xValue = utils_isString(rawXValue) ? Number(new Date(rawXValue)) : Number(rawXValue);
                      var yValue = getCoordinateYValue(datum);
                      var xValueRatio = getValueRatio(xValue, xAxisLimit);
                      var yValueRatio = getValueRatio(yValue, yAxisLimit);
                      var x = xValueRatio * _this3.rect.width;
                      var y = (1 - yValueRatio) * _this3.rect.height;
                      var radius = Math.max(bubbleSeries_MINIMUM_RADIUS, datum.r / _this3.maxValue * _this3.maxRadius);
                      circleModels.push({
                        x,
                        y,
                        type: "circle",
                        radius,
                        color,
                        style: ["default"],
                        seriesIndex,
                        name,
                        borderWidth,
                        borderColor
                      });
                    });
                    return circleModels;
                  });
                }
              }, {
                key: "makeTooltipModel",
                value: function makeTooltipModel(circleData) {
                  return bubbleSeries_toConsumableArray(circleData).flatMap(function(_ref6) {
                    var data = _ref6.data, name = _ref6.name, color = _ref6.color;
                    var tooltipData = [];
                    var nonNullData = data.filter(function(datum) {
                      return !isNull(datum);
                    });
                    nonNullData.forEach(function(datum) {
                      var r = datum.r, label2 = datum.label;
                      tooltipData.push({
                        label: "".concat(name, "/").concat(label2),
                        color,
                        value: {
                          x: getCoordinateXValue(datum),
                          y: getCoordinateYValue(datum),
                          r
                        }
                      });
                    });
                    return tooltipData;
                  });
                }
              }, {
                key: "getResponderAppliedTheme",
                value: function getResponderAppliedTheme(responders, type) {
                  var _this4 = this;
                  return responders.map(function(responder) {
                    return deepMergedCopy(responder, _this4.theme[type]);
                  });
                }
              }, {
                key: "onMousemove",
                value: function onMousemove(_ref7) {
                  var responders = _ref7.responders, mousePosition = _ref7.mousePosition;
                  var closestResponder = getNearestResponder(responders, mousePosition, this.rect);
                  var responderWithTheme = this.getResponderAppliedTheme(closestResponder, "hover");
                  this.eventBus.emit("renderHoveredSeries", {
                    models: responderWithTheme,
                    name: this.name
                  });
                  this.activatedResponders = closestResponder;
                  this.eventBus.emit("seriesPointHovered", {
                    models: this.activatedResponders,
                    name: this.name
                  });
                  this.eventBus.emit("needDraw");
                }
              }, {
                key: "onClick",
                value: function onClick(_ref8) {
                  var responders = _ref8.responders, mousePosition = _ref8.mousePosition;
                  if (this.selectable) {
                    var closestResponder = getNearestResponder(responders, mousePosition, this.rect);
                    var responderWithTheme = this.getResponderAppliedTheme(closestResponder, "select");
                    this.eventBus.emit("renderSelectedSeries", {
                      models: responderWithTheme,
                      name: this.name
                    });
                    this.eventBus.emit("needDraw");
                  }
                }
              }]);
              return BubbleSeries2;
            }(Component);
            ;
            function circleLegend_typeof(obj) {
              "@babel/helpers - typeof";
              if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                circleLegend_typeof = function _typeof2(obj2) {
                  return typeof obj2;
                };
              } else {
                circleLegend_typeof = function _typeof2(obj2) {
                  return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                };
              }
              return circleLegend_typeof(obj);
            }
            function circleLegend_classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function circleLegend_defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            function circleLegend_createClass(Constructor, protoProps, staticProps) {
              if (protoProps)
                circleLegend_defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                circleLegend_defineProperties(Constructor, staticProps);
              return Constructor;
            }
            function circleLegend_inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function");
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
              if (superClass)
                circleLegend_setPrototypeOf(subClass, superClass);
            }
            function circleLegend_setPrototypeOf(o, p) {
              circleLegend_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
                o2.__proto__ = p2;
                return o2;
              };
              return circleLegend_setPrototypeOf(o, p);
            }
            function circleLegend_createSuper(Derived) {
              var hasNativeReflectConstruct = circleLegend_isNativeReflectConstruct();
              return function _createSuperInternal() {
                var Super = circleLegend_getPrototypeOf(Derived), result;
                if (hasNativeReflectConstruct) {
                  var NewTarget = circleLegend_getPrototypeOf(this).constructor;
                  result = Reflect.construct(Super, arguments, NewTarget);
                } else {
                  result = Super.apply(this, arguments);
                }
                return circleLegend_possibleConstructorReturn(this, result);
              };
            }
            function circleLegend_possibleConstructorReturn(self2, call) {
              if (call && (circleLegend_typeof(call) === "object" || typeof call === "function")) {
                return call;
              }
              return circleLegend_assertThisInitialized(self2);
            }
            function circleLegend_assertThisInitialized(self2) {
              if (self2 === void 0) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return self2;
            }
            function circleLegend_isNativeReflectConstruct() {
              if (typeof Reflect === "undefined" || !Reflect.construct)
                return false;
              if (Reflect.construct.sham)
                return false;
              if (typeof Proxy === "function")
                return true;
              try {
                Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                }));
                return true;
              } catch (e) {
                return false;
              }
            }
            function circleLegend_getPrototypeOf(o) {
              circleLegend_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
                return o2.__proto__ || Object.getPrototypeOf(o2);
              };
              return circleLegend_getPrototypeOf(o);
            }
            function circleLegend_defineProperty(obj, key, value) {
              if (key in obj) {
                Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
              } else {
                obj[key] = value;
              }
              return obj;
            }
            var CircleLegend = function(_Component) {
              circleLegend_inherits(CircleLegend2, _Component);
              var _super = circleLegend_createSuper(CircleLegend2);
              function CircleLegend2() {
                var _this;
                circleLegend_classCallCheck(this, CircleLegend2);
                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }
                _this = _super.call.apply(_super, [this].concat(args));
                circleLegend_defineProperty(circleLegend_assertThisInitialized(_this), "models", {
                  circleLegend: []
                });
                return _this;
              }
              circleLegend_createClass(CircleLegend2, [{
                key: "initialize",
                value: function initialize() {
                  this.type = "circleLegend";
                }
              }, {
                key: "render",
                value: function render(_ref) {
                  var layout2 = _ref.layout, series = _ref.series, circleLegend2 = _ref.circleLegend;
                  if (!series.bubble) {
                    throw new Error(message.CIRCLE_LEGEND_RENDER_ERROR);
                  }
                  this.isShow = circleLegend2.visible;
                  if (!this.isShow) {
                    return;
                  }
                  var bubbleData = series.bubble.data;
                  this.rect = layout2.circleLegend;
                  this.renderCircleLegend(bubbleData, circleLegend2);
                }
              }, {
                key: "renderCircleLegend",
                value: function renderCircleLegend(bubbleData, circleLegend2) {
                  var value = getMaxRadius(bubbleData);
                  var radius = circleLegend2.radius;
                  this.models.circleLegend = [{
                    type: "circleLegend",
                    radius,
                    value,
                    x: radius,
                    y: this.rect.height - radius
                  }];
                }
              }]);
              return CircleLegend2;
            }(Component);
            ;
            function circleLegend(ctx2, circleLegendModel) {
              var x = circleLegendModel.x, y = circleLegendModel.y, radius = circleLegendModel.radius, value = circleLegendModel.value;
              var ratioArray = [1, 0.5, 0.25];
              ratioArray.forEach(function(ratio, idx) {
                var circleRadius = ratio * radius;
                var circleY = y + (idx ? (1 - ratio) * radius : 0);
                circle(ctx2, {
                  type: "circle",
                  x,
                  y: circleY,
                  radius: circleRadius,
                  color: "#fff",
                  seriesIndex: 0,
                  style: ["default", {
                    strokeStyle: "#888",
                    lineWidth: 1
                  }]
                });
                label(ctx2, {
                  type: "label",
                  x,
                  y: circleY - circleRadius,
                  text: String(value * ratio),
                  style: ["default", {
                    textAlign: "center",
                    textBaseline: "bottom"
                  }]
                });
              });
            }
            ;
            function bubbleChart_typeof(obj) {
              "@babel/helpers - typeof";
              if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                bubbleChart_typeof = function _typeof2(obj2) {
                  return typeof obj2;
                };
              } else {
                bubbleChart_typeof = function _typeof2(obj2) {
                  return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                };
              }
              return bubbleChart_typeof(obj);
            }
            function bubbleChart_ownKeys(object, enumerableOnly) {
              var keys = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object);
                if (enumerableOnly) {
                  symbols = symbols.filter(function(sym) {
                    return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                  });
                }
                keys.push.apply(keys, symbols);
              }
              return keys;
            }
            function bubbleChart_objectSpread(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i] != null ? arguments[i] : {};
                if (i % 2) {
                  bubbleChart_ownKeys(Object(source), true).forEach(function(key) {
                    bubbleChart_defineProperty(target, key, source[key]);
                  });
                } else if (Object.getOwnPropertyDescriptors) {
                  Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                } else {
                  bubbleChart_ownKeys(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  });
                }
              }
              return target;
            }
            function bubbleChart_defineProperty(obj, key, value) {
              if (key in obj) {
                Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
              } else {
                obj[key] = value;
              }
              return obj;
            }
            function bubbleChart_classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function bubbleChart_defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            function bubbleChart_createClass(Constructor, protoProps, staticProps) {
              if (protoProps)
                bubbleChart_defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                bubbleChart_defineProperties(Constructor, staticProps);
              return Constructor;
            }
            function bubbleChart_get(target, property, receiver) {
              if (typeof Reflect !== "undefined" && Reflect.get) {
                bubbleChart_get = Reflect.get;
              } else {
                bubbleChart_get = function _get2(target2, property2, receiver2) {
                  var base = bubbleChart_superPropBase(target2, property2);
                  if (!base)
                    return;
                  var desc = Object.getOwnPropertyDescriptor(base, property2);
                  if (desc.get) {
                    return desc.get.call(receiver2);
                  }
                  return desc.value;
                };
              }
              return bubbleChart_get(target, property, receiver || target);
            }
            function bubbleChart_superPropBase(object, property) {
              while (!Object.prototype.hasOwnProperty.call(object, property)) {
                object = bubbleChart_getPrototypeOf(object);
                if (object === null)
                  break;
              }
              return object;
            }
            function bubbleChart_inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function");
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
              if (superClass)
                bubbleChart_setPrototypeOf(subClass, superClass);
            }
            function bubbleChart_setPrototypeOf(o, p) {
              bubbleChart_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
                o2.__proto__ = p2;
                return o2;
              };
              return bubbleChart_setPrototypeOf(o, p);
            }
            function bubbleChart_createSuper(Derived) {
              var hasNativeReflectConstruct = bubbleChart_isNativeReflectConstruct();
              return function _createSuperInternal() {
                var Super = bubbleChart_getPrototypeOf(Derived), result;
                if (hasNativeReflectConstruct) {
                  var NewTarget = bubbleChart_getPrototypeOf(this).constructor;
                  result = Reflect.construct(Super, arguments, NewTarget);
                } else {
                  result = Super.apply(this, arguments);
                }
                return bubbleChart_possibleConstructorReturn(this, result);
              };
            }
            function bubbleChart_possibleConstructorReturn(self2, call) {
              if (call && (bubbleChart_typeof(call) === "object" || typeof call === "function")) {
                return call;
              }
              return bubbleChart_assertThisInitialized(self2);
            }
            function bubbleChart_assertThisInitialized(self2) {
              if (self2 === void 0) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return self2;
            }
            function bubbleChart_isNativeReflectConstruct() {
              if (typeof Reflect === "undefined" || !Reflect.construct)
                return false;
              if (Reflect.construct.sham)
                return false;
              if (typeof Proxy === "function")
                return true;
              try {
                Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                }));
                return true;
              } catch (e) {
                return false;
              }
            }
            function bubbleChart_getPrototypeOf(o) {
              bubbleChart_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
                return o2.__proto__ || Object.getPrototypeOf(o2);
              };
              return bubbleChart_getPrototypeOf(o);
            }
            var BubbleChart = function(_Chart) {
              bubbleChart_inherits(BubbleChart2, _Chart);
              var _super = bubbleChart_createSuper(BubbleChart2);
              function BubbleChart2(props) {
                bubbleChart_classCallCheck(this, BubbleChart2);
                return _super.call(this, {
                  el: props.el,
                  options: props.options,
                  series: {
                    bubble: props.data.series
                  },
                  modules: [store_dataRange, store_scale, store_axes, store_plot]
                });
              }
              bubbleChart_createClass(BubbleChart2, [{
                key: "initialize",
                value: function initialize() {
                  bubbleChart_get(bubbleChart_getPrototypeOf(BubbleChart2.prototype), "initialize", this).call(this);
                  this.componentManager.add(Background);
                  this.componentManager.add(Title);
                  this.componentManager.add(Plot);
                  this.componentManager.add(Legend);
                  this.componentManager.add(BubbleSeries);
                  this.componentManager.add(Axis, {
                    name: "xAxis"
                  });
                  this.componentManager.add(Axis, {
                    name: "yAxis"
                  });
                  this.componentManager.add(AxisTitle, {
                    name: "xAxis"
                  });
                  this.componentManager.add(AxisTitle, {
                    name: "yAxis"
                  });
                  this.componentManager.add(ExportMenu, {
                    chartEl: this.el
                  });
                  this.componentManager.add(HoveredSeries);
                  this.componentManager.add(SelectedSeries);
                  this.componentManager.add(Tooltip, {
                    chartEl: this.el
                  });
                  this.componentManager.add(CircleLegend);
                  this.componentManager.add(NoDataText);
                  this.painter.addGroups([basic_namespaceObject, axis_namespaceObject, brushes_circleLegend_namespaceObject, legend_namespaceObject, label_namespaceObject, brushes_exportMenu_namespaceObject]);
                }
                /**
                 * Add data.
                 * @param {Array<Object>} data - Array of data to be added.
                 * @api
                 * @example
                 * chart.addData([
                 *   {x: 10, y: 20, r: 10, label: 'label1'},
                 *   {x: 30, y: 40, r: 10, label: 'label2'},
                 * ]);
                 */
              }, {
                key: "addData",
                value: function addData(data) {
                  this.animationControlFlag.updating = true;
                  this.resetSeries();
                  this.store.dispatch("addData", {
                    data
                  });
                }
                /**
                 * Add series.
                 * @param {Object} data - Data to be added.
                 *   @param {string} data.name - Series name.
                 *   @param {Array<Object>} data.data - Array of data to be added.
                 * @api
                 * @example
                 * chart.addSeries({
                 *   name: 'newSeries',
                 *   data: [
                 *     {x: 10, y: 20, r: 10, label: 'label1'},
                 *     {x: 30, y: 40, r: 10, label: 'label2'},
                 *   ],
                 * });
                 */
              }, {
                key: "addSeries",
                value: function addSeries(data) {
                  this.resetSeries();
                  this.store.dispatch("addSeries", {
                    data
                  });
                }
                /**
                 * Convert the chart data to new data.
                 * @param {Object} data - Data to be set.
                 * @api
                 * @example
                 * chart.setData({
                 *   series: [
                 *     {
                 *       name: 'name'
                 *       data: [
                 *         {x: 10, y: 20, r: 10, label: 'label1'},
                 *         {x: 30, y: 40, r: 10, label: 'label2'},
                 *       ]
                 *     }
                 *   ]
                 * });
                 */
              }, {
                key: "setData",
                value: function setData(data) {
                  this.resetSeries();
                  this.store.dispatch("setData", {
                    series: {
                      bubble: data.series
                    }
                  });
                }
                /**
                 * Convert the chart options to new options.
                 * @param {Object} options - Chart options.
                 * @api
                 * @example
                 * chart.setOptions({
                 *   chart: {
                 *     width: 500,
                 *     height: 'auto',
                 *     title: 'Energy Usage',
                 *   },
                 *   xAxis: {
                 *     title: 'Month',
                 *     date: { format: 'yy/MM' },
                 *   },
                 *   yAxis: {
                 *     title: 'Energy (kWh)',
                 *   },
                 *   series: {
                 *     selectable: true,
                 *   },
                 *   tooltip: {
                 *     formatter: (value) => `${value}kWh`,
                 *   },
                 * });
                 */
              }, {
                key: "setOptions",
                value: function setOptions(options2) {
                  this.resetSeries();
                  this.dispatchOptionsEvent("initOptions", options2);
                }
                /**
                 * Update chart options.
                 * @param {Object} options - Chart options.
                 * @api
                 * @example
                 * chart.updateOptions({
                 *   chart: {
                 *     height: 'auto',
                 *     title: 'Energy Usage',
                 *   },
                 *   tooltip: {
                 *     formatter: (value) => `${value}kWh`,
                 *   },
                 * });
                 */
              }, {
                key: "updateOptions",
                value: function updateOptions(options2) {
                  this.resetSeries();
                  this.dispatchOptionsEvent("updateOptions", options2);
                }
                /**
                 * Show tooltip.
                 * @param {Object} seriesInfo - Information of the series for the tooltip to be displayed.
                 *      @param {number} seriesInfo.seriesIndex - Index of series.
                 *      @param {number} seriesInfo.index - Index of data within series.
                 * @api
                 * @example
                 * chart.showTooltip({index: 1, seriesIndex: 2});
                 */
              }, {
                key: "showTooltip",
                value: function showTooltip(seriesInfo) {
                  this.eventBus.emit("showTooltip", bubbleChart_objectSpread(bubbleChart_objectSpread({}, seriesInfo), {}, {
                    state: this.store.state
                  }));
                }
                /**
                 * Hide tooltip.
                 * @api
                 * @example
                 * chart.hideTooltip();
                 */
              }, {
                key: "hideTooltip",
                value: function hideTooltip() {
                  this.eventBus.emit("hideTooltip");
                }
              }]);
              return BubbleChart2;
            }(Chart);
            ;
            function scatterChart_typeof(obj) {
              "@babel/helpers - typeof";
              if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                scatterChart_typeof = function _typeof2(obj2) {
                  return typeof obj2;
                };
              } else {
                scatterChart_typeof = function _typeof2(obj2) {
                  return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                };
              }
              return scatterChart_typeof(obj);
            }
            function scatterChart_classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function scatterChart_defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            function scatterChart_createClass(Constructor, protoProps, staticProps) {
              if (protoProps)
                scatterChart_defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                scatterChart_defineProperties(Constructor, staticProps);
              return Constructor;
            }
            function scatterChart_get(target, property, receiver) {
              if (typeof Reflect !== "undefined" && Reflect.get) {
                scatterChart_get = Reflect.get;
              } else {
                scatterChart_get = function _get2(target2, property2, receiver2) {
                  var base = scatterChart_superPropBase(target2, property2);
                  if (!base)
                    return;
                  var desc = Object.getOwnPropertyDescriptor(base, property2);
                  if (desc.get) {
                    return desc.get.call(receiver2);
                  }
                  return desc.value;
                };
              }
              return scatterChart_get(target, property, receiver || target);
            }
            function scatterChart_superPropBase(object, property) {
              while (!Object.prototype.hasOwnProperty.call(object, property)) {
                object = scatterChart_getPrototypeOf(object);
                if (object === null)
                  break;
              }
              return object;
            }
            function scatterChart_inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function");
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
              if (superClass)
                scatterChart_setPrototypeOf(subClass, superClass);
            }
            function scatterChart_setPrototypeOf(o, p) {
              scatterChart_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
                o2.__proto__ = p2;
                return o2;
              };
              return scatterChart_setPrototypeOf(o, p);
            }
            function scatterChart_createSuper(Derived) {
              var hasNativeReflectConstruct = scatterChart_isNativeReflectConstruct();
              return function _createSuperInternal() {
                var Super = scatterChart_getPrototypeOf(Derived), result;
                if (hasNativeReflectConstruct) {
                  var NewTarget = scatterChart_getPrototypeOf(this).constructor;
                  result = Reflect.construct(Super, arguments, NewTarget);
                } else {
                  result = Super.apply(this, arguments);
                }
                return scatterChart_possibleConstructorReturn(this, result);
              };
            }
            function scatterChart_possibleConstructorReturn(self2, call) {
              if (call && (scatterChart_typeof(call) === "object" || typeof call === "function")) {
                return call;
              }
              return scatterChart_assertThisInitialized(self2);
            }
            function scatterChart_assertThisInitialized(self2) {
              if (self2 === void 0) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return self2;
            }
            function scatterChart_isNativeReflectConstruct() {
              if (typeof Reflect === "undefined" || !Reflect.construct)
                return false;
              if (Reflect.construct.sham)
                return false;
              if (typeof Proxy === "function")
                return true;
              try {
                Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                }));
                return true;
              } catch (e) {
                return false;
              }
            }
            function scatterChart_getPrototypeOf(o) {
              scatterChart_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
                return o2.__proto__ || Object.getPrototypeOf(o2);
              };
              return scatterChart_getPrototypeOf(o);
            }
            function scatterChart_toConsumableArray(arr) {
              return scatterChart_arrayWithoutHoles(arr) || scatterChart_iterableToArray(arr) || scatterChart_unsupportedIterableToArray(arr) || scatterChart_nonIterableSpread();
            }
            function scatterChart_nonIterableSpread() {
              throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            function scatterChart_unsupportedIterableToArray(o, minLen) {
              if (!o)
                return;
              if (typeof o === "string")
                return scatterChart_arrayLikeToArray(o, minLen);
              var n = Object.prototype.toString.call(o).slice(8, -1);
              if (n === "Object" && o.constructor)
                n = o.constructor.name;
              if (n === "Map" || n === "Set")
                return Array.from(o);
              if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                return scatterChart_arrayLikeToArray(o, minLen);
            }
            function scatterChart_iterableToArray(iter) {
              if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
                return Array.from(iter);
            }
            function scatterChart_arrayWithoutHoles(arr) {
              if (Array.isArray(arr))
                return scatterChart_arrayLikeToArray(arr);
            }
            function scatterChart_arrayLikeToArray(arr, len) {
              if (len == null || len > arr.length)
                len = arr.length;
              for (var i = 0, arr2 = new Array(len); i < len; i++) {
                arr2[i] = arr[i];
              }
              return arr2;
            }
            function scatterChart_ownKeys(object, enumerableOnly) {
              var keys = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object);
                if (enumerableOnly) {
                  symbols = symbols.filter(function(sym) {
                    return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                  });
                }
                keys.push.apply(keys, symbols);
              }
              return keys;
            }
            function scatterChart_objectSpread(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i] != null ? arguments[i] : {};
                if (i % 2) {
                  scatterChart_ownKeys(Object(source), true).forEach(function(key) {
                    scatterChart_defineProperty(target, key, source[key]);
                  });
                } else if (Object.getOwnPropertyDescriptors) {
                  Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                } else {
                  scatterChart_ownKeys(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  });
                }
              }
              return target;
            }
            function scatterChart_defineProperty(obj, key, value) {
              if (key in obj) {
                Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
              } else {
                obj[key] = value;
              }
              return obj;
            }
            function clearUnnecessaryData(scatterSeries2) {
              return scatterSeries2.map(function(series) {
                var exist = {};
                return scatterChart_objectSpread(scatterChart_objectSpread({}, series), {}, {
                  data: series.data.filter(function(datum) {
                    return !isNull(datum);
                  }).reduce(function(acc, cur) {
                    var x = getCoordinateXValue(cur);
                    var y = getCoordinateYValue(cur);
                    var key = "".concat(x, "-").concat(y);
                    if (!exist[key]) {
                      exist[key] = true;
                      return [].concat(scatterChart_toConsumableArray(acc), [cur]);
                    }
                    return acc;
                  }, [])
                });
              });
            }
            var ScatterChart = function(_Chart) {
              scatterChart_inherits(ScatterChart2, _Chart);
              var _super = scatterChart_createSuper(ScatterChart2);
              function ScatterChart2(props) {
                var _props$data;
                scatterChart_classCallCheck(this, ScatterChart2);
                return _super.call(this, {
                  el: props.el,
                  options: props.options,
                  series: {
                    scatter: clearUnnecessaryData(props.data.series)
                  },
                  categories: (_props$data = props.data) === null || _props$data === void 0 ? void 0 : _props$data.categories,
                  modules: [store_dataRange, store_scale, store_axes, store_plot]
                });
              }
              scatterChart_createClass(ScatterChart2, [{
                key: "initialize",
                value: function initialize() {
                  scatterChart_get(scatterChart_getPrototypeOf(ScatterChart2.prototype), "initialize", this).call(this);
                  this.componentManager.add(Background);
                  this.componentManager.add(Title);
                  this.componentManager.add(Plot);
                  this.componentManager.add(Legend);
                  this.componentManager.add(ScatterSeries);
                  this.componentManager.add(Axis, {
                    name: "xAxis"
                  });
                  this.componentManager.add(Axis, {
                    name: "yAxis"
                  });
                  this.componentManager.add(AxisTitle, {
                    name: "xAxis"
                  });
                  this.componentManager.add(AxisTitle, {
                    name: "yAxis"
                  });
                  this.componentManager.add(ExportMenu, {
                    chartEl: this.el
                  });
                  this.componentManager.add(HoveredSeries);
                  this.componentManager.add(SelectedSeries);
                  this.componentManager.add(Tooltip, {
                    chartEl: this.el
                  });
                  this.componentManager.add(NoDataText);
                  this.painter.addGroups([basic_namespaceObject, axis_namespaceObject, legend_namespaceObject, label_namespaceObject, brushes_exportMenu_namespaceObject, scatterSeries_namespaceObject]);
                }
                /**
                 * Add data.
                 * @param {Array<Object>} data - Array of data to be added.
                 * @api
                 * @example
                 * chart.addData([
                 *   {x: 10, y: 20},
                 *   {x: 30, y: 40},
                 * ]);
                 */
              }, {
                key: "addData",
                value: function addData(data) {
                  this.animationControlFlag.updating = true;
                  this.resetSeries();
                  this.store.dispatch("addData", {
                    data
                  });
                }
                /**
                 * Add series.
                 * @param {Object} data - Data to be added.
                 *   @param {string} data.name - Series name.
                 *   @param {Array} data.data - Array of data to be added.
                 * @api
                 * @example
                 * chart.addSeries({
                 *   name: 'newSeries',
                 *   data: [
                 *     {x: 10, y: 20},
                 *     {x: 30, y: 40},
                 *   ],
                 * });
                 */
              }, {
                key: "addSeries",
                value: function addSeries(data) {
                  this.resetSeries();
                  this.store.dispatch("addSeries", {
                    data
                  });
                }
                /**
                 * Convert the chart data to new data.
                 * @param {Object} data - Data to be set.
                 * @api
                 * @example
                 * chart.setData({
                 *   series: [
                 *     {
                 *       name: 'name'
                 *       data: [
                 *         {x: 10, y: 20},
                 *         {x: 30, y: 40},
                 *       ]
                 *     }
                 *   ]
                 * });
                 */
              }, {
                key: "setData",
                value: function setData(data) {
                  var categories = data.categories, series = data.series;
                  this.resetSeries();
                  this.store.dispatch("setData", {
                    series: {
                      scatter: series
                    },
                    categories
                  });
                }
                /**
                 * Convert the chart options to new options.
                 * @param {Object} options - Chart options
                 * @api
                 * @example
                 * chart.setOptions({
                 *   chart: {
                 *     width: 500,
                 *     height: 'auto',
                 *     title: 'Energy Usage',
                 *   },
                 *   xAxis: {
                 *     title: 'Month',
                 *   },
                 *   yAxis: {
                 *     title: 'Energy (kWh)',
                 *   },
                 *   series: {
                 *     selectable: true,
                 *   },
                 *   tooltip: {
                 *     formatter: (value) => `${value}kWh`,
                 *   },
                 * });
                 */
              }, {
                key: "setOptions",
                value: function setOptions(options2) {
                  this.resetSeries();
                  this.dispatchOptionsEvent("initOptions", options2);
                }
                /**
                 * Update chart options.
                 * @param {Object} options - Chart options
                 * @api
                 * @example
                 * chart.updateOptions({
                 *   chart: {
                 *     height: 'auto',
                 *     title: 'Energy Usage',
                 *   },
                 *   tooltip: {
                 *     formatter: (value) => `${value}kWh`,
                 *   },
                 * });
                 */
              }, {
                key: "updateOptions",
                value: function updateOptions(options2) {
                  this.resetSeries();
                  this.dispatchOptionsEvent("updateOptions", options2);
                }
                /**
                 * Show tooltip.
                 * @param {Object} seriesInfo - Information of the series for the tooltip to be displayed.
                 *      @param {number} seriesInfo.seriesIndex - Index of series.
                 *      @param {number} seriesInfo.index - Index of data within series.
                 * @api
                 * @example
                 * chart.showTooltip({index: 1, seriesIndex: 2});
                 */
              }, {
                key: "showTooltip",
                value: function showTooltip(seriesInfo) {
                  this.eventBus.emit("showTooltip", scatterChart_objectSpread(scatterChart_objectSpread({}, seriesInfo), {}, {
                    state: this.store.state
                  }));
                }
                /**
                 * Hide tooltip.
                 * @api
                 * @example
                 * chart.hideTooltip();
                 */
              }, {
                key: "hideTooltip",
                value: function hideTooltip() {
                  this.eventBus.emit("hideTooltip");
                }
              }]);
              return ScatterChart2;
            }(Chart);
            ;
            function bulletSeries_typeof(obj) {
              "@babel/helpers - typeof";
              if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                bulletSeries_typeof = function _typeof2(obj2) {
                  return typeof obj2;
                };
              } else {
                bulletSeries_typeof = function _typeof2(obj2) {
                  return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                };
              }
              return bulletSeries_typeof(obj);
            }
            function bulletSeries_slicedToArray(arr, i) {
              return bulletSeries_arrayWithHoles(arr) || bulletSeries_iterableToArrayLimit(arr, i) || bulletSeries_unsupportedIterableToArray(arr, i) || bulletSeries_nonIterableRest();
            }
            function bulletSeries_nonIterableRest() {
              throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            function bulletSeries_iterableToArrayLimit(arr, i) {
              var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]);
              if (_i == null)
                return;
              var _arr = [];
              var _n = true;
              var _d = false;
              var _s, _e;
              try {
                for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
                  _arr.push(_s.value);
                  if (i && _arr.length === i)
                    break;
                }
              } catch (err) {
                _d = true;
                _e = err;
              } finally {
                try {
                  if (!_n && _i["return"] != null)
                    _i["return"]();
                } finally {
                  if (_d)
                    throw _e;
                }
              }
              return _arr;
            }
            function bulletSeries_arrayWithHoles(arr) {
              if (Array.isArray(arr))
                return arr;
            }
            function bulletSeries_classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function bulletSeries_defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            function bulletSeries_createClass(Constructor, protoProps, staticProps) {
              if (protoProps)
                bulletSeries_defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                bulletSeries_defineProperties(Constructor, staticProps);
              return Constructor;
            }
            function bulletSeries_inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function");
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
              if (superClass)
                bulletSeries_setPrototypeOf(subClass, superClass);
            }
            function bulletSeries_setPrototypeOf(o, p) {
              bulletSeries_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
                o2.__proto__ = p2;
                return o2;
              };
              return bulletSeries_setPrototypeOf(o, p);
            }
            function bulletSeries_createSuper(Derived) {
              var hasNativeReflectConstruct = bulletSeries_isNativeReflectConstruct();
              return function _createSuperInternal() {
                var Super = bulletSeries_getPrototypeOf(Derived), result;
                if (hasNativeReflectConstruct) {
                  var NewTarget = bulletSeries_getPrototypeOf(this).constructor;
                  result = Reflect.construct(Super, arguments, NewTarget);
                } else {
                  result = Super.apply(this, arguments);
                }
                return bulletSeries_possibleConstructorReturn(this, result);
              };
            }
            function bulletSeries_possibleConstructorReturn(self2, call) {
              if (call && (bulletSeries_typeof(call) === "object" || typeof call === "function")) {
                return call;
              }
              return bulletSeries_assertThisInitialized(self2);
            }
            function bulletSeries_assertThisInitialized(self2) {
              if (self2 === void 0) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return self2;
            }
            function bulletSeries_isNativeReflectConstruct() {
              if (typeof Reflect === "undefined" || !Reflect.construct)
                return false;
              if (Reflect.construct.sham)
                return false;
              if (typeof Proxy === "function")
                return true;
              try {
                Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                }));
                return true;
              } catch (e) {
                return false;
              }
            }
            function bulletSeries_getPrototypeOf(o) {
              bulletSeries_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
                return o2.__proto__ || Object.getPrototypeOf(o2);
              };
              return bulletSeries_getPrototypeOf(o);
            }
            function bulletSeries_ownKeys(object, enumerableOnly) {
              var keys = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object);
                if (enumerableOnly) {
                  symbols = symbols.filter(function(sym) {
                    return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                  });
                }
                keys.push.apply(keys, symbols);
              }
              return keys;
            }
            function bulletSeries_objectSpread(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i] != null ? arguments[i] : {};
                if (i % 2) {
                  bulletSeries_ownKeys(Object(source), true).forEach(function(key) {
                    bulletSeries_defineProperty(target, key, source[key]);
                  });
                } else if (Object.getOwnPropertyDescriptors) {
                  Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                } else {
                  bulletSeries_ownKeys(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  });
                }
              }
              return target;
            }
            function bulletSeries_defineProperty(obj, key, value) {
              if (key in obj) {
                Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
              } else {
                obj[key] = value;
              }
              return obj;
            }
            function bulletSeries_toConsumableArray(arr) {
              return bulletSeries_arrayWithoutHoles(arr) || bulletSeries_iterableToArray(arr) || bulletSeries_unsupportedIterableToArray(arr) || bulletSeries_nonIterableSpread();
            }
            function bulletSeries_nonIterableSpread() {
              throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            function bulletSeries_unsupportedIterableToArray(o, minLen) {
              if (!o)
                return;
              if (typeof o === "string")
                return bulletSeries_arrayLikeToArray(o, minLen);
              var n = Object.prototype.toString.call(o).slice(8, -1);
              if (n === "Object" && o.constructor)
                n = o.constructor.name;
              if (n === "Map" || n === "Set")
                return Array.from(o);
              if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                return bulletSeries_arrayLikeToArray(o, minLen);
            }
            function bulletSeries_iterableToArray(iter) {
              if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
                return Array.from(iter);
            }
            function bulletSeries_arrayWithoutHoles(arr) {
              if (Array.isArray(arr))
                return bulletSeries_arrayLikeToArray(arr);
            }
            function bulletSeries_arrayLikeToArray(arr, len) {
              if (len == null || len > arr.length)
                len = arr.length;
              for (var i = 0, arr2 = new Array(len); i < len; i++) {
                arr2[i] = arr[i];
              }
              return arr2;
            }
            var DEFAULT_WIDTH_RATIO = 0.6;
            var MARKER_LINE_DETECTION_SIZE = 5;
            function getRectSize(vertical, barWidth, barLength) {
              return {
                width: vertical ? barWidth : barLength,
                height: vertical ? barLength : barWidth
              };
            }
            function getStartX(seriesIndex, tickDistance, barWidth) {
              return seriesIndex * tickDistance + (tickDistance - barWidth) / 2;
            }
            function makeBulletResponderModel(models, tooltipData) {
              var range2 = models.range, marker = models.marker, bullet = models.bullet;
              var tooltipRange = tooltipData.range, tooltipMarker = tooltipData.marker, tooltipBullet = tooltipData.bullet;
              return [].concat(bulletSeries_toConsumableArray(range2.map(function(m, index) {
                return bulletSeries_objectSpread(bulletSeries_objectSpread({}, m), {}, {
                  data: tooltipRange[index]
                });
              })), bulletSeries_toConsumableArray(bullet.map(function(m, index) {
                return bulletSeries_objectSpread(bulletSeries_objectSpread({}, m), {}, {
                  data: tooltipBullet[index]
                });
              })), bulletSeries_toConsumableArray(marker.map(function(m, index) {
                return bulletSeries_objectSpread(bulletSeries_objectSpread({}, m), {}, {
                  detectionSize: MARKER_LINE_DETECTION_SIZE,
                  data: tooltipMarker[index]
                });
              })));
            }
            var BulletSeries = function(_Component) {
              bulletSeries_inherits(BulletSeries2, _Component);
              var _super = bulletSeries_createSuper(BulletSeries2);
              function BulletSeries2() {
                var _this;
                bulletSeries_classCallCheck(this, BulletSeries2);
                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }
                _this = _super.call.apply(_super, [this].concat(args));
                bulletSeries_defineProperty(bulletSeries_assertThisInitialized(_this), "models", {
                  range: [],
                  bullet: [],
                  marker: []
                });
                bulletSeries_defineProperty(bulletSeries_assertThisInitialized(_this), "drawModels", void 0);
                bulletSeries_defineProperty(bulletSeries_assertThisInitialized(_this), "responders", void 0);
                bulletSeries_defineProperty(bulletSeries_assertThisInitialized(_this), "activatedResponders", []);
                bulletSeries_defineProperty(bulletSeries_assertThisInitialized(_this), "theme", void 0);
                bulletSeries_defineProperty(bulletSeries_assertThisInitialized(_this), "eventDetectType", "point");
                bulletSeries_defineProperty(bulletSeries_assertThisInitialized(_this), "tooltipRectMap", void 0);
                bulletSeries_defineProperty(bulletSeries_assertThisInitialized(_this), "vertical", false);
                bulletSeries_defineProperty(bulletSeries_assertThisInitialized(_this), "basePosition", void 0);
                bulletSeries_defineProperty(bulletSeries_assertThisInitialized(_this), "onMouseoutComponent", function() {
                  _this.eventBus.emit("seriesPointHovered", {
                    models: [],
                    name: _this.name
                  });
                  _this.eventBus.emit("renderHoveredSeries", {
                    models: [],
                    name: _this.name
                  });
                  _this.eventBus.emit("needDraw");
                });
                bulletSeries_defineProperty(bulletSeries_assertThisInitialized(_this), "selectSeries", function(_ref) {
                  var _state$series$bullet;
                  var seriesIndex = _ref.seriesIndex, state = _ref.state;
                  if (!isNumber(seriesIndex)) {
                    return;
                  }
                  var _state$series$bullet$ = (_state$series$bullet = state.series.bullet) === null || _state$series$bullet === void 0 ? void 0 : _state$series$bullet[seriesIndex], name = _state$series$bullet$.name;
                  var model = _this.filterBulletResponder(_this.responders).filter(function(_ref2) {
                    var dataName = _ref2.name;
                    return dataName === name;
                  });
                  if (!model) {
                    throw new Error(message.SELECT_SERIES_API_INDEX_ERROR);
                  }
                  _this.eventBus.emit("renderSelectedSeries", {
                    models: _this.getRespondersWithTheme(model, "select"),
                    name: _this.name
                  });
                  _this.eventBus.emit("needDraw");
                });
                bulletSeries_defineProperty(bulletSeries_assertThisInitialized(_this), "showTooltip", function(_ref3) {
                  var _state$series$bullet2;
                  var seriesIndex = _ref3.seriesIndex, state = _ref3.state;
                  if (!isNumber(seriesIndex)) {
                    return;
                  }
                  var _state$series$bullet$2 = (_state$series$bullet2 = state.series.bullet) === null || _state$series$bullet2 === void 0 ? void 0 : _state$series$bullet2[seriesIndex], name = _state$series$bullet$2.name;
                  var models = _this.filterBulletResponder(_this.responders).filter(function(_ref4) {
                    var dataName = _ref4.name;
                    return dataName === name;
                  });
                  if (!models.length) {
                    return;
                  }
                  _this.onMousemove({
                    responders: models
                  });
                });
                return _this;
              }
              bulletSeries_createClass(BulletSeries2, [{
                key: "initialize",
                value: function initialize() {
                  this.type = "series";
                  this.name = "bullet";
                  this.eventBus.on("selectSeries", this.selectSeries);
                  this.eventBus.on("showTooltip", this.showTooltip);
                  this.eventBus.on("hideTooltip", this.onMouseoutComponent);
                }
              }, {
                key: "initUpdate",
                value: function initUpdate(delta) {
                  if (!this.drawModels) {
                    return;
                  }
                  var clipRect = this.drawModels.clipRect;
                  if (!clipRect) {
                    return;
                  }
                  var offsetKey = this.vertical ? "y" : "x";
                  var key = this.vertical ? "height" : "width";
                  var current = clipRect[0];
                  var target = this.models.clipRect[0];
                  var offsetSize = current[key] + (target[key] - current[key]) * delta;
                  current[key] = offsetSize;
                  current[offsetKey] = Math.max(this.basePosition - offsetSize * this.basePosition / target[key], 0);
                }
              }, {
                key: "render",
                value: function render(state) {
                  var _options$series;
                  var layout2 = state.layout, axes2 = state.axes, series = state.series, scale2 = state.scale, legend2 = state.legend, options2 = state.options, theme2 = state.theme, categories = state.categories;
                  if (!series.bullet) {
                    throw new Error(message.noDataError(this.name));
                  }
                  this.setEventDetectType(series, options2);
                  this.theme = theme2.series.bullet;
                  this.rect = layout2.plot;
                  this.activeSeriesMap = getActiveSeriesMap(legend2);
                  this.selectable = this.getSelectableOption(options2);
                  this.vertical = !!(options2 !== null && options2 !== void 0 && (_options$series = options2.series) !== null && _options$series !== void 0 && _options$series.vertical);
                  var labelAxisOnYAxis = isLabelAxisOnYAxis({
                    series,
                    options: options2
                  });
                  var _getAxisName = getAxisName(labelAxisOnYAxis, series), labelAxisName = _getAxisName.labelAxisName, valueAxisName = _getAxisName.valueAxisName;
                  var _getSizeKey = getSizeKey(labelAxisOnYAxis), valueSizeKey = _getSizeKey.valueSizeKey;
                  var tickDistance = axes2[labelAxisName].tickDistance;
                  var zeroPosition = axes2[valueAxisName].zeroPosition;
                  var _scale$valueAxisName$ = scale2[valueAxisName].limit, min = _scale$valueAxisName$.min, max2 = _scale$valueAxisName$.max;
                  var bulletData = series.bullet.data;
                  this.basePosition = zeroPosition !== null && zeroPosition !== void 0 ? zeroPosition : 0;
                  var renderOptions = bulletSeries_objectSpread({
                    ratio: this.rect[valueSizeKey] / (max2 - min),
                    tickDistance,
                    zeroPosition
                  }, this.getBulletBarWidths(tickDistance));
                  var rangeModels = this.renderRanges(bulletData, renderOptions);
                  var bulletModels = this.renderBullet(bulletData, renderOptions);
                  var markerModels = this.renderMarkers(bulletData, renderOptions);
                  var clipRect = this.renderClipRectArea();
                  this.models.clipRect = [clipRect];
                  this.models.range = rangeModels;
                  this.models.bullet = bulletModels;
                  this.models.marker = markerModels;
                  if (!this.drawModels) {
                    this.drawModels = {
                      clipRect: [this.makeInitialClipRectModel(clipRect)],
                      range: deepCopyArray(rangeModels),
                      bullet: deepCopyArray(bulletModels),
                      marker: deepCopyArray(markerModels)
                    };
                  }
                  var models = {
                    range: rangeModels,
                    bullet: bulletModels,
                    marker: markerModels
                  };
                  var tooltipData = this.makeTooltipModel(models);
                  this.tooltipRectMap = this.makeTooltipRectMap(models, tooltipData);
                  this.responders = this.getBulletSeriesResponders(models, tooltipData, axes2, categories);
                  if (getDataLabelsOptions(options2, this.name).visible) {
                    this.renderDataLabels(this.getDataLabels([].concat(bulletSeries_toConsumableArray(rangeModels), bulletSeries_toConsumableArray(bulletModels), bulletSeries_toConsumableArray(markerModels)), this.vertical, this.rect[valueSizeKey]));
                  }
                }
              }, {
                key: "renderClipRectArea",
                value: function renderClipRectArea() {
                  return {
                    type: "clipRectArea",
                    x: 0,
                    y: 0,
                    width: this.rect.width,
                    height: this.rect.height
                  };
                }
              }, {
                key: "makeInitialClipRectModel",
                value: function makeInitialClipRectModel(clipRect) {
                  var width = this.vertical ? clipRect.width : 0;
                  var height = this.vertical ? 0 : clipRect.height;
                  var x = this.vertical ? clipRect.x : 0;
                  var y = this.vertical ? 0 : clipRect.y;
                  return {
                    type: "clipRectArea",
                    width,
                    height,
                    x,
                    y
                  };
                }
              }, {
                key: "getDataLabels",
                value: function getDataLabels(seriesModels, vertical, size) {
                  var dataLabelTheme = this.theme.dataLabels;
                  var bulletLabelTheme = omit(dataLabelTheme, "marker");
                  var useSeriesColor = bulletLabelTheme.useSeriesColor, color = bulletLabelTheme.color;
                  var marker = dataLabelTheme.marker;
                  return seriesModels.filter(function(m) {
                    return m.type === "line" || m.modelType !== "range";
                  }).map(function(m) {
                    if (m.type === "line") {
                      return bulletSeries_objectSpread(bulletSeries_objectSpread({}, m), {}, {
                        x: vertical ? (m.x + m.x2) / 2 : m.x,
                        theme: bulletSeries_objectSpread(bulletSeries_objectSpread({}, marker), {}, {
                          color: marker.useSeriesColor ? m.strokeStyle : marker.color
                        })
                      });
                    }
                    var isValueNegative = isNumber(m.value) && (m === null || m === void 0 ? void 0 : m.value) < 0;
                    var direction = vertical ? "top" : "right";
                    if (isValueNegative) {
                      direction = vertical ? "bottom" : "left";
                    }
                    return bulletSeries_objectSpread(bulletSeries_objectSpread({}, m), {}, {
                      direction,
                      plot: {
                        x: 0,
                        y: 0,
                        size
                      },
                      theme: bulletSeries_objectSpread(bulletSeries_objectSpread({}, bulletLabelTheme), {}, {
                        color: useSeriesColor ? m.color : color
                      })
                    });
                  });
                }
              }, {
                key: "setEventDetectType",
                value: function setEventDetectType(series, options2) {
                  var _options$series2;
                  if (options2 !== null && options2 !== void 0 && (_options$series2 = options2.series) !== null && _options$series2 !== void 0 && _options$series2.eventDetectType) {
                    this.eventDetectType = options2.series.eventDetectType;
                  }
                }
              }, {
                key: "getBulletSeriesResponders",
                value: function getBulletSeriesResponders(models, tooltipData, axes2, categories) {
                  return this.eventDetectType === "grouped" ? makeRectResponderModel(this.rect, this.vertical ? axes2.xAxis : axes2.yAxis, categories, this.vertical) : makeBulletResponderModel(models, tooltipData);
                }
              }, {
                key: "makeTooltipRectMap",
                value: function makeTooltipRectMap(models, tooltipData) {
                  var result = {};
                  Object.keys(models).forEach(function(seriesType) {
                    models[seriesType].forEach(function(m, index) {
                      var label2 = m.name;
                      if (!result[label2]) {
                        result[label2] = [];
                      }
                      var tooltipModel = bulletSeries_objectSpread(bulletSeries_objectSpread({}, m), {}, {
                        data: tooltipData[seriesType][index]
                      });
                      result[label2].push(tooltipModel);
                    });
                  });
                  return result;
                }
              }, {
                key: "getBulletSeriesModelsFromRectResponders",
                value: function getBulletSeriesModelsFromRectResponders(responders) {
                  var _this$tooltipRectMap;
                  if (!responders.length) {
                    return [];
                  }
                  return (_this$tooltipRectMap = this.tooltipRectMap[responders[0].label]) !== null && _this$tooltipRectMap !== void 0 ? _this$tooltipRectMap : [];
                }
              }, {
                key: "getGroupedRect",
                value: function getGroupedRect(responders, type) {
                  var bulletSeriesModels = this.getBulletSeriesModelsFromRectResponders(responders);
                  var _ref5 = this.theme[type].groupedRect, color = _ref5.color, opacity = _ref5.opacity;
                  return bulletSeriesModels.length ? responders.map(function(m) {
                    return bulletSeries_objectSpread(bulletSeries_objectSpread({}, m), {}, {
                      color: getRGBA(color, opacity)
                    });
                  }) : [];
                }
              }, {
                key: "onMousemoveGroupedType",
                value: function onMousemoveGroupedType(responders) {
                  var bulletSeriesModels = this.getBulletSeriesModelsFromRectResponders(responders);
                  this.eventBus.emit("renderHoveredSeries", {
                    models: [].concat(bulletSeries_toConsumableArray(this.getGroupedRect(responders, "hover")), bulletSeries_toConsumableArray(this.getRespondersWithTheme(bulletSeriesModels, "hover"))),
                    name: this.name,
                    eventDetectType: this.eventDetectType
                  });
                  this.activatedResponders = bulletSeriesModels;
                }
              }, {
                key: "onMousemove",
                value: function onMousemove(_ref6) {
                  var responders = _ref6.responders;
                  if (this.eventDetectType === "grouped") {
                    this.onMousemoveGroupedType(responders);
                  } else {
                    this.eventBus.emit("renderHoveredSeries", {
                      models: this.getRespondersWithTheme(responders, "hover"),
                      name: this.name
                    });
                    this.activatedResponders = responders.length ? [responders[responders.length - 1]] : [];
                  }
                  this.eventBus.emit("seriesPointHovered", {
                    models: this.activatedResponders,
                    name: this.name
                  });
                  this.eventBus.emit("needDraw");
                }
              }, {
                key: "onClick",
                value: function onClick(_ref7) {
                  var responders = _ref7.responders;
                  if (this.selectable) {
                    var models = this.eventDetectType === "grouped" ? [].concat(bulletSeries_toConsumableArray(this.getGroupedRect(responders, "select")), bulletSeries_toConsumableArray(this.getRespondersWithTheme(this.getBulletSeriesModelsFromRectResponders(responders), "select"))) : this.getRespondersWithTheme(responders, "select");
                    this.eventBus.emit("renderSelectedSeries", {
                      models,
                      name: this.name,
                      eventDetectType: this.eventDetectType
                    });
                    this.eventBus.emit("needDraw");
                  }
                }
              }, {
                key: "filterBulletResponder",
                value: function filterBulletResponder(responders) {
                  return responders.filter(function(model) {
                    return (model === null || model === void 0 ? void 0 : model.modelType) === "bullet";
                  });
                }
              }, {
                key: "renderRanges",
                value: function renderRanges(bulletData, _ref8) {
                  var _this2 = this;
                  var tickDistance = _ref8.tickDistance, ratio = _ref8.ratio, zeroPosition = _ref8.zeroPosition, rangeWidth = _ref8.rangeWidth;
                  var rangeModels = [];
                  bulletData.forEach(function(_ref9, seriesIndex) {
                    var ranges = _ref9.ranges, color = _ref9.color, name = _ref9.name;
                    (ranges !== null && ranges !== void 0 ? ranges : []).forEach(function(range2, rangeIndex) {
                      if (!isNull(range2)) {
                        var _range = bulletSeries_slicedToArray(range2, 2), start = _range[0], end = _range[1];
                        var barLength = (end - start) * ratio;
                        var rangeStartX = getStartX(seriesIndex, tickDistance, rangeWidth);
                        rangeModels.push(bulletSeries_objectSpread(bulletSeries_objectSpread({
                          type: "rect",
                          name,
                          color: _this2.getRangeColor(getRGBA(color, _this2.getSeriesOpacity(name)), rangeIndex, name),
                          x: _this2.vertical ? rangeStartX : start * ratio + zeroPosition,
                          y: _this2.vertical ? zeroPosition - end * ratio : rangeStartX
                        }, getRectSize(_this2.vertical, rangeWidth, barLength)), {}, {
                          modelType: "range",
                          seriesColor: color,
                          tooltipColor: _this2.getRangeColor(color, rangeIndex, name, true),
                          value: range2
                        }));
                      }
                    });
                  });
                  return rangeModels;
                }
              }, {
                key: "renderBullet",
                value: function renderBullet(bulletData, _ref10) {
                  var _this3 = this;
                  var tickDistance = _ref10.tickDistance, ratio = _ref10.ratio, zeroPosition = _ref10.zeroPosition, bulletWidth = _ref10.bulletWidth;
                  var _this$theme = this.theme, borderColor = _this$theme.borderColor, thickness = _this$theme.borderWidth;
                  return bulletData.reduce(function(acc, _ref11, seriesIndex) {
                    var data = _ref11.data, color = _ref11.color, name = _ref11.name;
                    if (isNull(data)) {
                      return bulletSeries_toConsumableArray(acc);
                    }
                    var bulletLength = Math.max(Math.abs(data * ratio), 2);
                    var bulletStartX = getStartX(seriesIndex, tickDistance, bulletWidth);
                    var x = _this3.vertical ? bulletStartX : zeroPosition - (data < 0 ? bulletLength : 0);
                    var y = _this3.vertical ? zeroPosition - bulletLength + (data < 0 ? bulletLength : 0) : bulletStartX;
                    var bullet = bulletSeries_objectSpread({
                      type: "rect",
                      name,
                      color: getRGBA(color, _this3.getSeriesOpacity(name)),
                      x,
                      y,
                      thickness,
                      borderColor,
                      modelType: "bullet",
                      seriesColor: color,
                      tooltipColor: color,
                      value: data
                    }, getRectSize(_this3.vertical, bulletWidth, bulletLength));
                    return [].concat(bulletSeries_toConsumableArray(acc), [bullet]);
                  }, []);
                }
              }, {
                key: "renderMarkers",
                value: function renderMarkers(bulletData, _ref12) {
                  var _this4 = this;
                  var tickDistance = _ref12.tickDistance, ratio = _ref12.ratio, zeroPosition = _ref12.zeroPosition, markerWidth = _ref12.markerWidth;
                  var markerLineWidth = this.theme.markerLineWidth;
                  var markerModels = [];
                  bulletData.forEach(function(_ref13, seriesIndex) {
                    var markers = _ref13.markers, color = _ref13.color, name = _ref13.name;
                    var markerStartX = getStartX(seriesIndex, tickDistance, markerWidth);
                    (markers !== null && markers !== void 0 ? markers : []).forEach(function(marker) {
                      if (!isNull(marker)) {
                        var dataPosition = marker * ratio;
                        var x = _this4.vertical ? markerStartX : dataPosition + zeroPosition;
                        var y = _this4.vertical ? zeroPosition - dataPosition : markerStartX;
                        markerModels.push({
                          type: "line",
                          name,
                          x,
                          y,
                          x2: _this4.vertical ? x + markerWidth : x,
                          y2: _this4.vertical ? y : y + markerWidth,
                          strokeStyle: getRGBA(color, _this4.getSeriesOpacity(name)),
                          lineWidth: markerLineWidth,
                          seriesColor: color,
                          tooltipColor: color,
                          value: marker
                        });
                      }
                    });
                  });
                  return markerModels;
                }
              }, {
                key: "makeTooltipModel",
                value: function makeTooltipModel(seriesModels) {
                  var range2 = seriesModels.range, bullet = seriesModels.bullet, marker = seriesModels.marker;
                  return {
                    range: this.makeTooltipData(range2, "Range"),
                    bullet: this.makeTooltipData(bullet, "Actual"),
                    marker: this.makeTooltipData(marker, "Marker")
                  };
                }
              }, {
                key: "makeTooltipData",
                value: function makeTooltipData(data, title) {
                  return data.map(function(m) {
                    var name = m.name, seriesColor = m.seriesColor, tooltipColor = m.tooltipColor, value = m.value;
                    return {
                      label: name,
                      color: getRGBA(seriesColor, 1),
                      value: [{
                        title,
                        value,
                        color: tooltipColor
                      }],
                      templateType: "bullet"
                    };
                  });
                }
              }, {
                key: "getBulletBarWidths",
                value: function getBulletBarWidths(tickDistance) {
                  var _this$theme2 = this.theme, barThemeWidth = _this$theme2.barWidth, barWidthRatios = _this$theme2.barWidthRatios;
                  var rangeRatio = barWidthRatios.rangeRatio, bulletRatio = barWidthRatios.bulletRatio, markerRatio = barWidthRatios.markerRatio;
                  var barWidth = barThemeWidth ? calculateSizeWithPercentString(tickDistance, barThemeWidth) : tickDistance * DEFAULT_WIDTH_RATIO;
                  return {
                    rangeWidth: barWidth * rangeRatio,
                    bulletWidth: barWidth * bulletRatio,
                    markerWidth: barWidth * markerRatio
                  };
                }
              }, {
                key: "getRangeColor",
                value: function getRangeColor(seriesColor, rangeIndex, seriesName) {
                  var ignoreRestSeriesOpacity = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
                  var rangeColors = this.theme.rangeColors;
                  var hasThemeRangeColor = Array.isArray(rangeColors) && rangeColors[rangeIndex];
                  var color = hasThemeRangeColor ? rangeColors[rangeIndex] : seriesColor;
                  var opacity = hasThemeRangeColor ? getAlpha(rangeColors[rangeIndex]) : DEFAULT_BULLET_RANGE_OPACITY[rangeIndex];
                  return getRGBA(color, opacity * this.getSeriesOpacity(seriesName, ignoreRestSeriesOpacity));
                }
              }, {
                key: "getSeriesOpacity",
                value: function getSeriesOpacity(seriesName) {
                  var ignoreRestSeriesOpacity = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                  var _this$theme3 = this.theme, select = _this$theme3.select, areaOpacity = _this$theme3.areaOpacity;
                  var active = this.activeSeriesMap[seriesName];
                  var selected = Object.values(this.activeSeriesMap).some(function(elem) {
                    return !elem;
                  });
                  var restOpacity = ignoreRestSeriesOpacity ? areaOpacity : select.restSeries.areaOpacity;
                  var selectedOpacity = active ? select.areaOpacity : restOpacity;
                  return selected ? selectedOpacity : areaOpacity;
                }
              }, {
                key: "getRespondersWithTheme",
                value: function getRespondersWithTheme(responders, type) {
                  var _this5 = this;
                  var _this$theme$type = this.theme[type], color = _this$theme$type.color, borderColor = _this$theme$type.borderColor, thickness = _this$theme$type.borderWidth;
                  return this.filterBulletResponder(responders).map(function(model) {
                    return bulletSeries_objectSpread(bulletSeries_objectSpread({}, model), {}, {
                      color: color !== null && color !== void 0 ? color : model.tooltipColor,
                      thickness,
                      borderColor,
                      style: [bulletSeries_objectSpread({}, pick(_this5.theme[type], "shadowBlur", "shadowColor", "shadowOffsetX", "shadowOffsetY"))]
                    });
                  });
                }
              }]);
              return BulletSeries2;
            }(Component);
            ;
            function bulletChart_typeof(obj) {
              "@babel/helpers - typeof";
              if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                bulletChart_typeof = function _typeof2(obj2) {
                  return typeof obj2;
                };
              } else {
                bulletChart_typeof = function _typeof2(obj2) {
                  return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                };
              }
              return bulletChart_typeof(obj);
            }
            function bulletChart_ownKeys(object, enumerableOnly) {
              var keys = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object);
                if (enumerableOnly) {
                  symbols = symbols.filter(function(sym) {
                    return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                  });
                }
                keys.push.apply(keys, symbols);
              }
              return keys;
            }
            function bulletChart_objectSpread(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i] != null ? arguments[i] : {};
                if (i % 2) {
                  bulletChart_ownKeys(Object(source), true).forEach(function(key) {
                    bulletChart_defineProperty(target, key, source[key]);
                  });
                } else if (Object.getOwnPropertyDescriptors) {
                  Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                } else {
                  bulletChart_ownKeys(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  });
                }
              }
              return target;
            }
            function bulletChart_classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function bulletChart_defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            function bulletChart_createClass(Constructor, protoProps, staticProps) {
              if (protoProps)
                bulletChart_defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                bulletChart_defineProperties(Constructor, staticProps);
              return Constructor;
            }
            function bulletChart_get(target, property, receiver) {
              if (typeof Reflect !== "undefined" && Reflect.get) {
                bulletChart_get = Reflect.get;
              } else {
                bulletChart_get = function _get2(target2, property2, receiver2) {
                  var base = bulletChart_superPropBase(target2, property2);
                  if (!base)
                    return;
                  var desc = Object.getOwnPropertyDescriptor(base, property2);
                  if (desc.get) {
                    return desc.get.call(receiver2);
                  }
                  return desc.value;
                };
              }
              return bulletChart_get(target, property, receiver || target);
            }
            function bulletChart_superPropBase(object, property) {
              while (!Object.prototype.hasOwnProperty.call(object, property)) {
                object = bulletChart_getPrototypeOf(object);
                if (object === null)
                  break;
              }
              return object;
            }
            function bulletChart_inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function");
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
              if (superClass)
                bulletChart_setPrototypeOf(subClass, superClass);
            }
            function bulletChart_setPrototypeOf(o, p) {
              bulletChart_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
                o2.__proto__ = p2;
                return o2;
              };
              return bulletChart_setPrototypeOf(o, p);
            }
            function bulletChart_createSuper(Derived) {
              var hasNativeReflectConstruct = bulletChart_isNativeReflectConstruct();
              return function _createSuperInternal() {
                var Super = bulletChart_getPrototypeOf(Derived), result;
                if (hasNativeReflectConstruct) {
                  var NewTarget = bulletChart_getPrototypeOf(this).constructor;
                  result = Reflect.construct(Super, arguments, NewTarget);
                } else {
                  result = Super.apply(this, arguments);
                }
                return bulletChart_possibleConstructorReturn(this, result);
              };
            }
            function bulletChart_possibleConstructorReturn(self2, call) {
              if (call && (bulletChart_typeof(call) === "object" || typeof call === "function")) {
                return call;
              }
              return bulletChart_assertThisInitialized(self2);
            }
            function bulletChart_assertThisInitialized(self2) {
              if (self2 === void 0) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return self2;
            }
            function bulletChart_isNativeReflectConstruct() {
              if (typeof Reflect === "undefined" || !Reflect.construct)
                return false;
              if (Reflect.construct.sham)
                return false;
              if (typeof Proxy === "function")
                return true;
              try {
                Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                }));
                return true;
              } catch (e) {
                return false;
              }
            }
            function bulletChart_getPrototypeOf(o) {
              bulletChart_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
                return o2.__proto__ || Object.getPrototypeOf(o2);
              };
              return bulletChart_getPrototypeOf(o);
            }
            function bulletChart_defineProperty(obj, key, value) {
              if (key in obj) {
                Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
              } else {
                obj[key] = value;
              }
              return obj;
            }
            var BulletChart = function(_Chart) {
              bulletChart_inherits(BulletChart2, _Chart);
              var _super = bulletChart_createSuper(BulletChart2);
              function BulletChart2(_ref) {
                var _this;
                var el = _ref.el, options2 = _ref.options, series = _ref.data.series;
                bulletChart_classCallCheck(this, BulletChart2);
                _this = _super.call(this, {
                  el,
                  options: options2,
                  series: {
                    bullet: series
                  },
                  modules: [store_dataRange, store_scale, store_axes, store_plot]
                });
                bulletChart_defineProperty(bulletChart_assertThisInitialized(_this), "hideTooltip", function() {
                  _this.eventBus.emit("hideTooltip");
                });
                return _this;
              }
              bulletChart_createClass(BulletChart2, [{
                key: "initialize",
                value: function initialize() {
                  bulletChart_get(bulletChart_getPrototypeOf(BulletChart2.prototype), "initialize", this).call(this);
                  this.componentManager.add(Background);
                  this.componentManager.add(Title);
                  this.componentManager.add(Plot);
                  this.componentManager.add(Legend);
                  this.componentManager.add(BulletSeries);
                  this.componentManager.add(Axis, {
                    name: "yAxis"
                  });
                  this.componentManager.add(Axis, {
                    name: "xAxis"
                  });
                  this.componentManager.add(AxisTitle, {
                    name: "xAxis"
                  });
                  this.componentManager.add(AxisTitle, {
                    name: "yAxis"
                  });
                  this.componentManager.add(ExportMenu, {
                    chartEl: this.el
                  });
                  this.componentManager.add(HoveredSeries);
                  this.componentManager.add(SelectedSeries);
                  this.componentManager.add(DataLabels);
                  this.componentManager.add(Tooltip, {
                    chartEl: this.el
                  });
                  this.componentManager.add(NoDataText);
                  this.painter.addGroups([basic_namespaceObject, axis_namespaceObject, legend_namespaceObject, label_namespaceObject, brushes_exportMenu_namespaceObject, dataLabel_namespaceObject]);
                }
                /**
                 * Add series.
                 * @param {Object} data - Data to be added
                 *   @param {string} data.name - Series name
                 *   @param {Array<<Array<number>>} data.data - Array of data to be added
                 *   @param {Array<number>} data.markers - Series markers. It specifies the marker for comparing.
                 *   @param {Array<Array<number>>} data.ranges - Series ranges. It specifies the range of values that can be compared.
                 * @api
                 * @example
                 * chart.addSeries({
                 *   name: 'newSeries',
                 *   data: 20,
                 *   markers: [28, 2, 15],
                 *   ranges: [
                 *     [-1, 10],
                 *     [10, 20],
                 *     [20, 30],
                 *   ],
                 * });
                 */
              }, {
                key: "addSeries",
                value: function addSeries(data) {
                  this.resetSeries();
                  this.store.dispatch("addSeries", {
                    data
                  });
                }
                /**
                 * Convert the chart data to new data.
                 * @param {Object} data - Data to be set
                 * @api
                 * @example
                 * chart.setData({
                 *   series: [
                 *     {
                 *       name: 'newSeries',
                 *       data: 20,
                 *       markers: [28, 2, 15],
                 *       ranges: [
                 *         [-1, 10],
                 *         [10, 20],
                 *         [20, 30],
                 *       ],
                 *     }
                 *   ]
                 * });
                 */
              }, {
                key: "setData",
                value: function setData(data) {
                  this.resetSeries();
                  this.store.dispatch("setData", {
                    series: {
                      bullet: data.series
                    }
                  });
                }
                /**
                 * Hide series data label.
                 * @api
                 * @example
                 * chart.hideSeriesDataLabel();
                 */
              }, {
                key: "hideSeriesDataLabel",
                value: function hideSeriesDataLabel() {
                  this.store.dispatch("updateOptions", {
                    options: {
                      series: {
                        dataLabels: {
                          visible: false
                        }
                      }
                    }
                  });
                }
                /**
                 * Show series data label.
                 * @api
                 * @example
                 * chart.showSeriesDataLabel();
                 */
              }, {
                key: "showSeriesDataLabel",
                value: function showSeriesDataLabel() {
                  this.store.dispatch("updateOptions", {
                    options: {
                      series: {
                        dataLabels: {
                          visible: true
                        }
                      }
                    }
                  });
                }
                /**
                 * Convert the chart options to new options.
                 * @param {Object} options - Chart options
                 * @api
                 * @example
                 * chart.setOptions({
                 *   chart: {
                 *     width: 500,
                 *     height: 'auto',
                 *     title: 'Energy Usage',
                 *   },
                 *   xAxis: {
                 *     title: 'Month',
                 *   },
                 *   yAxis: {
                 *     title: 'Energy (kWh)',
                 *   },
                 *   series: {
                 *     selectable: true,
                 *   },
                 *   tooltip: {
                 *     formatter: (value) => `${value}kWh`,
                 *   },
                 * });
                 */
              }, {
                key: "setOptions",
                value: function setOptions(options2) {
                  this.resetSeries();
                  this.dispatchOptionsEvent("initOptions", options2);
                }
                /**
                 * Update chart options.
                 * @param {Object} options - Chart options
                 * @api
                 * @example
                 * chart.updateOptions({
                 *   chart: {
                 *     height: 'auto',
                 *     title: 'Energy Usage',
                 *   },
                 *   tooltip: {
                 *     formatter: (value) => `${value}kWh`,
                 *   },
                 * });
                 */
              }, {
                key: "updateOptions",
                value: function updateOptions(options2) {
                  this.resetSeries();
                  this.dispatchOptionsEvent("updateOptions", options2);
                }
                /**
                 * Show tooltip.
                 * @param {Object} seriesInfo - Information of the series for the tooltip to be displayed.
                 *      @param {number} seriesInfo.seriesIndex - Index of series.
                 * @api
                 * @example
                 * chart.showTooltip({seriesIndex: 1});
                 */
              }, {
                key: "showTooltip",
                value: function showTooltip(seriesInfo) {
                  this.eventBus.emit("showTooltip", bulletChart_objectSpread(bulletChart_objectSpread({}, seriesInfo), {}, {
                    state: this.store.state
                  }));
                }
                /**
                 * Hide tooltip.
                 * @api
                 * @example
                 * chart.hideTooltip();
                 */
              }]);
              return BulletChart2;
            }(Chart);
            ;
            function nestedPieSeriesData_ownKeys(object, enumerableOnly) {
              var keys = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object);
                if (enumerableOnly) {
                  symbols = symbols.filter(function(sym) {
                    return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                  });
                }
                keys.push.apply(keys, symbols);
              }
              return keys;
            }
            function nestedPieSeriesData_objectSpread(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i] != null ? arguments[i] : {};
                if (i % 2) {
                  nestedPieSeriesData_ownKeys(Object(source), true).forEach(function(key) {
                    nestedPieSeriesData_defineProperty(target, key, source[key]);
                  });
                } else if (Object.getOwnPropertyDescriptors) {
                  Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                } else {
                  nestedPieSeriesData_ownKeys(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  });
                }
              }
              return target;
            }
            function nestedPieSeriesData_defineProperty(obj, key, value) {
              if (key in obj) {
                Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
              } else {
                obj[key] = value;
              }
              return obj;
            }
            function findRootName(rawSeries, seriesIndex, parentName) {
              var _rawSeries$pie;
              var item = (_rawSeries$pie = rawSeries.pie) === null || _rawSeries$pie === void 0 ? void 0 : _rawSeries$pie[seriesIndex].data.find(function(_ref) {
                var name = _ref.name;
                return name === parentName;
              });
              return item !== null && item !== void 0 && item.parentName ? findRootName(rawSeries, seriesIndex - 1, item.parentName) : parentName;
            }
            var nestedPieSeriesData = {
              name: "seriesData",
              state: function state() {
                return {
                  nestedPieSeries: {}
                };
              },
              action: {
                setNestedPieSeriesData: function setNestedPieSeriesData(_ref2) {
                  var state = _ref2.state, initStoreState = _ref2.initStoreState;
                  var theme2 = state.theme, disabledSeries = state.disabledSeries;
                  var rawSeries = initStoreState.series;
                  var newSeriesData = {};
                  var colorMap2 = {};
                  rawSeries.pie.forEach(function(_ref3, seriesIndex) {
                    var alias = _ref3.name, data = _ref3.data;
                    var colors = theme2.series.pie[alias].colors;
                    var colorList = [];
                    var originSeriesData = data.map(function(m, index) {
                      var parentName = m.parentName, dataName = m.name;
                      var color = parentName && seriesIndex ? colorMap2[parentName] : colors === null || colors === void 0 ? void 0 : colors[index];
                      colorList.push(color);
                      colorMap2[dataName] = color;
                      var rootParentName = parentName && seriesIndex ? findRootName(rawSeries, seriesIndex - 1, parentName) : dataName;
                      return nestedPieSeriesData_objectSpread(nestedPieSeriesData_objectSpread({}, m), {}, {
                        data: m.data,
                        rootParentName,
                        color
                      });
                    });
                    newSeriesData[alias] = {
                      data: originSeriesData.filter(function(_ref4) {
                        var rootParentName = _ref4.rootParentName;
                        return !disabledSeries.includes(rootParentName);
                      }),
                      colors: colorList
                    };
                  });
                  state.nestedPieSeries = newSeriesData;
                  this.dispatch("updateNestedPieChartLegend");
                }
              },
              observe: {
                updateNestedPieSeriesData: function updateNestedPieSeriesData() {
                  this.dispatch("setNestedPieSeriesData");
                }
              }
            };
            var store_nestedPieSeriesData = nestedPieSeriesData;
            ;
            function nestedPieChart_typeof(obj) {
              "@babel/helpers - typeof";
              if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                nestedPieChart_typeof = function _typeof2(obj2) {
                  return typeof obj2;
                };
              } else {
                nestedPieChart_typeof = function _typeof2(obj2) {
                  return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                };
              }
              return nestedPieChart_typeof(obj);
            }
            function nestedPieChart_ownKeys(object, enumerableOnly) {
              var keys = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object);
                if (enumerableOnly) {
                  symbols = symbols.filter(function(sym) {
                    return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                  });
                }
                keys.push.apply(keys, symbols);
              }
              return keys;
            }
            function nestedPieChart_objectSpread(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i] != null ? arguments[i] : {};
                if (i % 2) {
                  nestedPieChart_ownKeys(Object(source), true).forEach(function(key) {
                    nestedPieChart_defineProperty(target, key, source[key]);
                  });
                } else if (Object.getOwnPropertyDescriptors) {
                  Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                } else {
                  nestedPieChart_ownKeys(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  });
                }
              }
              return target;
            }
            function nestedPieChart_defineProperty(obj, key, value) {
              if (key in obj) {
                Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
              } else {
                obj[key] = value;
              }
              return obj;
            }
            function nestedPieChart_classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function nestedPieChart_defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            function nestedPieChart_createClass(Constructor, protoProps, staticProps) {
              if (protoProps)
                nestedPieChart_defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                nestedPieChart_defineProperties(Constructor, staticProps);
              return Constructor;
            }
            function nestedPieChart_get(target, property, receiver) {
              if (typeof Reflect !== "undefined" && Reflect.get) {
                nestedPieChart_get = Reflect.get;
              } else {
                nestedPieChart_get = function _get2(target2, property2, receiver2) {
                  var base = nestedPieChart_superPropBase(target2, property2);
                  if (!base)
                    return;
                  var desc = Object.getOwnPropertyDescriptor(base, property2);
                  if (desc.get) {
                    return desc.get.call(receiver2);
                  }
                  return desc.value;
                };
              }
              return nestedPieChart_get(target, property, receiver || target);
            }
            function nestedPieChart_superPropBase(object, property) {
              while (!Object.prototype.hasOwnProperty.call(object, property)) {
                object = nestedPieChart_getPrototypeOf(object);
                if (object === null)
                  break;
              }
              return object;
            }
            function nestedPieChart_inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function");
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
              if (superClass)
                nestedPieChart_setPrototypeOf(subClass, superClass);
            }
            function nestedPieChart_setPrototypeOf(o, p) {
              nestedPieChart_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
                o2.__proto__ = p2;
                return o2;
              };
              return nestedPieChart_setPrototypeOf(o, p);
            }
            function nestedPieChart_createSuper(Derived) {
              var hasNativeReflectConstruct = nestedPieChart_isNativeReflectConstruct();
              return function _createSuperInternal() {
                var Super = nestedPieChart_getPrototypeOf(Derived), result;
                if (hasNativeReflectConstruct) {
                  var NewTarget = nestedPieChart_getPrototypeOf(this).constructor;
                  result = Reflect.construct(Super, arguments, NewTarget);
                } else {
                  result = Super.apply(this, arguments);
                }
                return nestedPieChart_possibleConstructorReturn(this, result);
              };
            }
            function nestedPieChart_possibleConstructorReturn(self2, call) {
              if (call && (nestedPieChart_typeof(call) === "object" || typeof call === "function")) {
                return call;
              }
              return nestedPieChart_assertThisInitialized(self2);
            }
            function nestedPieChart_assertThisInitialized(self2) {
              if (self2 === void 0) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return self2;
            }
            function nestedPieChart_isNativeReflectConstruct() {
              if (typeof Reflect === "undefined" || !Reflect.construct)
                return false;
              if (Reflect.construct.sham)
                return false;
              if (typeof Proxy === "function")
                return true;
              try {
                Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                }));
                return true;
              } catch (e) {
                return false;
              }
            }
            function nestedPieChart_getPrototypeOf(o) {
              nestedPieChart_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
                return o2.__proto__ || Object.getPrototypeOf(o2);
              };
              return nestedPieChart_getPrototypeOf(o);
            }
            var NestedPieChart = function(_Chart) {
              nestedPieChart_inherits(NestedPieChart2, _Chart);
              var _super = nestedPieChart_createSuper(NestedPieChart2);
              function NestedPieChart2(_ref) {
                var el = _ref.el, options2 = _ref.options, _ref$data = _ref.data, series = _ref$data.series, categories = _ref$data.categories;
                nestedPieChart_classCallCheck(this, NestedPieChart2);
                return _super.call(this, {
                  el,
                  options: options2,
                  series: {
                    pie: series
                  },
                  categories,
                  modules: [store_nestedPieSeriesData]
                });
              }
              nestedPieChart_createClass(NestedPieChart2, [{
                key: "initialize",
                value: function initialize() {
                  var _this$store$initStore, _this = this;
                  nestedPieChart_get(nestedPieChart_getPrototypeOf(NestedPieChart2.prototype), "initialize", this).call(this);
                  this.componentManager.add(Background);
                  this.componentManager.add(Title);
                  this.componentManager.add(Legend);
                  ((_this$store$initStore = this.store.initStoreState.series.pie) !== null && _this$store$initStore !== void 0 ? _this$store$initStore : []).forEach(function(_ref2) {
                    var name = _ref2.name;
                    _this.componentManager.add(PieSeries, {
                      alias: name
                    });
                  });
                  this.componentManager.add(ExportMenu, {
                    chartEl: this.el
                  });
                  this.componentManager.add(HoveredSeries);
                  this.componentManager.add(SelectedSeries);
                  this.componentManager.add(DataLabels);
                  this.componentManager.add(Tooltip, {
                    chartEl: this.el
                  });
                  this.componentManager.add(NoDataText);
                  this.painter.addGroups([basic_namespaceObject, legend_namespaceObject, label_namespaceObject, brushes_exportMenu_namespaceObject, brushes_sector_namespaceObject, dataLabel_namespaceObject]);
                }
                /**
                 * Add series.
                 * @param {Object} data - Data to be added.
                 *   @param {string} data.name - Series name.
                 *   @param {Array<Object>} data.data - Array of data to be added.
                 * @param {Object} dataInfo - Which name of chart to add.
                 *   @param {string} dataInfo.name - Chart series name.
                 * @api
                 * @example
                 * chart.addSeries(
                 *   {
                 *     name: 'newSeries',
                 *     data: [
                 *       { name: 'A', data: 10 },
                 *       { name: 'B', data: 20 },
                 *     ],
                 *   },
                 *   {
                 *     name: 'series name'
                 *   });
                 */
              }, {
                key: "addSeries",
                value: function addSeries(data, dataInfo) {
                  this.resetSeries();
                  this.store.dispatch("addSeries", nestedPieChart_objectSpread({
                    data
                  }, dataInfo));
                  this.componentManager.add(PieSeries, {
                    alias: data.name
                  });
                }
                /**
                 * Convert the chart data to new data.
                 * @param {Object} data - Data to be set
                 * @api
                 * @example
                 * chart.setData({
                 *   categories: ['A', 'B'],
                 *   series: [
                 *     {
                 *       name: 'browsers',
                 *       data: [
                 *         {
                 *           name: 'Chrome',
                 *           data: 50,
                 *         },
                 *         {
                 *           name: 'Safari',
                 *           data: 20,
                 *         },
                 *       ]
                 *     },
                 *     {
                 *       name: 'versions',
                 *       data: [
                 *         {
                 *           name: '1',
                 *           data: 50,
                 *         },
                 *         {
                 *           name: '2',
                 *           data: 20,
                 *         },
                 *       ]
                 *     }
                 *   ]
                 * });
                 */
              }, {
                key: "setData",
                value: function setData(data) {
                  var _this$store$initStore2, _this2 = this;
                  this.componentManager.remove(PieSeries);
                  this.resetSeries();
                  this.store.dispatch("setData", {
                    series: {
                      pie: data.series
                    }
                  });
                  ((_this$store$initStore2 = this.store.initStoreState.series.pie) !== null && _this$store$initStore2 !== void 0 ? _this$store$initStore2 : []).forEach(function(_ref3) {
                    var name = _ref3.name;
                    _this2.componentManager.add(PieSeries, {
                      alias: name
                    });
                  });
                }
                /**
                 * Hide series data label.
                 * @api
                 * @example
                 * chart.hideSeriesDataLabel();
                 */
              }, {
                key: "hideSeriesDataLabel",
                value: function hideSeriesDataLabel() {
                  this.store.dispatch("updateOptions", {
                    options: {
                      series: {
                        dataLabels: {
                          visible: false
                        }
                      }
                    }
                  });
                }
                /**
                 * Show series data label.
                 * @api
                 * @example
                 * chart.showSeriesDataLabel();
                 */
              }, {
                key: "showSeriesDataLabel",
                value: function showSeriesDataLabel() {
                  this.store.dispatch("updateOptions", {
                    options: {
                      series: {
                        dataLabels: {
                          visible: true
                        }
                      }
                    }
                  });
                }
                /**
                 * Convert the chart options to new options.
                 * @param {Object} options - Chart options.
                 * @api
                 * @example
                 * chart.setOptions({
                 *   chart: {
                 *     width: 500,
                 *     height: 'auto',
                 *     title: 'Energy Usage',
                 *   },
                 *   series: {
                 *     alias2: {
                 *       radiusRange: [20%, 50%],
                 *     },
                 *   },
                 *   tooltip: {
                 *     formatter: (value) => `${value}kWh`,
                 *   },
                 * });
                 */
              }, {
                key: "setOptions",
                value: function setOptions(options2) {
                  this.resetSeries();
                  this.dispatchOptionsEvent("initOptions", options2);
                }
                /**
                 * Update chart options.
                 * @param {Object} options - Chart options.
                 * @api
                 * @example
                 * chart.updateOptions({
                 *   chart: {
                 *     height: 'auto',
                 *     title: 'Energy Usage',
                 *   },
                 *   series: {
                 *     alias1: {
                 *       showDot: true,
                 *     },
                 *   },
                 * });
                 */
              }, {
                key: "updateOptions",
                value: function updateOptions(options2) {
                  this.resetSeries();
                  this.dispatchOptionsEvent("updateOptions", options2);
                }
                /**
                 * Show tooltip.
                 * @param {Object} seriesInfo - Information of the series for the tooltip to be displayed.
                 *      @param {number} seriesInfo.seriesIndex - Index of series.
                 *      @param {number} seriesInfo.alias - alias name.
                 * @api
                 * @example
                 * chart.showTooltip({seriesIndex: 1, alias: 'name'});
                 */
              }, {
                key: "showTooltip",
                value: function showTooltip(seriesInfo) {
                  this.eventBus.emit("showTooltip", nestedPieChart_objectSpread({}, seriesInfo));
                }
                /**
                 * Hide tooltip.
                 * @api
                 * @example
                 * chart.hideTooltip();
                 */
              }, {
                key: "hideTooltip",
                value: function hideTooltip() {
                  this.eventBus.emit("hideTooltip");
                }
              }]);
              return NestedPieChart2;
            }(Chart);
            ;
            function radarSeries_typeof(obj) {
              "@babel/helpers - typeof";
              if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                radarSeries_typeof = function _typeof2(obj2) {
                  return typeof obj2;
                };
              } else {
                radarSeries_typeof = function _typeof2(obj2) {
                  return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                };
              }
              return radarSeries_typeof(obj);
            }
            function radarSeries_toConsumableArray(arr) {
              return radarSeries_arrayWithoutHoles(arr) || radarSeries_iterableToArray(arr) || radarSeries_unsupportedIterableToArray(arr) || radarSeries_nonIterableSpread();
            }
            function radarSeries_nonIterableSpread() {
              throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            function radarSeries_unsupportedIterableToArray(o, minLen) {
              if (!o)
                return;
              if (typeof o === "string")
                return radarSeries_arrayLikeToArray(o, minLen);
              var n = Object.prototype.toString.call(o).slice(8, -1);
              if (n === "Object" && o.constructor)
                n = o.constructor.name;
              if (n === "Map" || n === "Set")
                return Array.from(o);
              if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                return radarSeries_arrayLikeToArray(o, minLen);
            }
            function radarSeries_iterableToArray(iter) {
              if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
                return Array.from(iter);
            }
            function radarSeries_arrayWithoutHoles(arr) {
              if (Array.isArray(arr))
                return radarSeries_arrayLikeToArray(arr);
            }
            function radarSeries_arrayLikeToArray(arr, len) {
              if (len == null || len > arr.length)
                len = arr.length;
              for (var i = 0, arr2 = new Array(len); i < len; i++) {
                arr2[i] = arr[i];
              }
              return arr2;
            }
            function radarSeries_ownKeys(object, enumerableOnly) {
              var keys = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object);
                if (enumerableOnly) {
                  symbols = symbols.filter(function(sym) {
                    return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                  });
                }
                keys.push.apply(keys, symbols);
              }
              return keys;
            }
            function radarSeries_objectSpread(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i] != null ? arguments[i] : {};
                if (i % 2) {
                  radarSeries_ownKeys(Object(source), true).forEach(function(key) {
                    radarSeries_defineProperty(target, key, source[key]);
                  });
                } else if (Object.getOwnPropertyDescriptors) {
                  Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                } else {
                  radarSeries_ownKeys(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  });
                }
              }
              return target;
            }
            function radarSeries_classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function radarSeries_defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            function radarSeries_createClass(Constructor, protoProps, staticProps) {
              if (protoProps)
                radarSeries_defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                radarSeries_defineProperties(Constructor, staticProps);
              return Constructor;
            }
            function radarSeries_inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function");
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
              if (superClass)
                radarSeries_setPrototypeOf(subClass, superClass);
            }
            function radarSeries_setPrototypeOf(o, p) {
              radarSeries_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
                o2.__proto__ = p2;
                return o2;
              };
              return radarSeries_setPrototypeOf(o, p);
            }
            function radarSeries_createSuper(Derived) {
              var hasNativeReflectConstruct = radarSeries_isNativeReflectConstruct();
              return function _createSuperInternal() {
                var Super = radarSeries_getPrototypeOf(Derived), result;
                if (hasNativeReflectConstruct) {
                  var NewTarget = radarSeries_getPrototypeOf(this).constructor;
                  result = Reflect.construct(Super, arguments, NewTarget);
                } else {
                  result = Super.apply(this, arguments);
                }
                return radarSeries_possibleConstructorReturn(this, result);
              };
            }
            function radarSeries_possibleConstructorReturn(self2, call) {
              if (call && (radarSeries_typeof(call) === "object" || typeof call === "function")) {
                return call;
              }
              return radarSeries_assertThisInitialized(self2);
            }
            function radarSeries_assertThisInitialized(self2) {
              if (self2 === void 0) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return self2;
            }
            function radarSeries_isNativeReflectConstruct() {
              if (typeof Reflect === "undefined" || !Reflect.construct)
                return false;
              if (Reflect.construct.sham)
                return false;
              if (typeof Proxy === "function")
                return true;
              try {
                Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                }));
                return true;
              } catch (e) {
                return false;
              }
            }
            function radarSeries_getPrototypeOf(o) {
              radarSeries_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
                return o2.__proto__ || Object.getPrototypeOf(o2);
              };
              return radarSeries_getPrototypeOf(o);
            }
            function radarSeries_defineProperty(obj, key, value) {
              if (key in obj) {
                Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
              } else {
                obj[key] = value;
              }
              return obj;
            }
            var NONE_AREA_OPACITY = 0;
            var radarSeries_seriesOpacity = {
              INACTIVE: 0.2,
              ACTIVE: 1
            };
            var RadarSeries = function(_Component) {
              radarSeries_inherits(RadarSeries2, _Component);
              var _super = radarSeries_createSuper(RadarSeries2);
              function RadarSeries2() {
                var _this;
                radarSeries_classCallCheck(this, RadarSeries2);
                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }
                _this = _super.call.apply(_super, [this].concat(args));
                radarSeries_defineProperty(radarSeries_assertThisInitialized(_this), "models", {
                  area: [],
                  line: [],
                  dot: []
                });
                radarSeries_defineProperty(radarSeries_assertThisInitialized(_this), "drawModels", void 0);
                radarSeries_defineProperty(radarSeries_assertThisInitialized(_this), "responders", void 0);
                radarSeries_defineProperty(radarSeries_assertThisInitialized(_this), "activatedResponders", []);
                radarSeries_defineProperty(radarSeries_assertThisInitialized(_this), "theme", void 0);
                radarSeries_defineProperty(radarSeries_assertThisInitialized(_this), "onMouseoutComponent", function() {
                  _this.eventBus.emit("seriesPointHovered", {
                    models: [],
                    name: _this.name
                  });
                  _this.eventBus.emit("renderHoveredSeries", {
                    models: [],
                    name: _this.name
                  });
                  _this.eventBus.emit("needDraw");
                });
                radarSeries_defineProperty(radarSeries_assertThisInitialized(_this), "selectSeries", function(_ref) {
                  var index = _ref.index, seriesIndex = _ref.seriesIndex, state = _ref.state;
                  if (!isNumber(index) || !isNumber(seriesIndex)) {
                    return;
                  }
                  var name = state.series.radar.data[seriesIndex].name;
                  var model = _this.responders.filter(function(_ref2) {
                    var dataName = _ref2.name;
                    return dataName === name;
                  })[index];
                  if (!model) {
                    throw new Error(message.SELECT_SERIES_API_INDEX_ERROR);
                  }
                  _this.eventBus.emit("renderSelectedSeries", {
                    models: _this.getRespondersWithTheme([model], "select"),
                    name: _this.name
                  });
                  _this.eventBus.emit("needDraw");
                });
                radarSeries_defineProperty(radarSeries_assertThisInitialized(_this), "showTooltip", function(_ref3) {
                  var index = _ref3.index, seriesIndex = _ref3.seriesIndex, state = _ref3.state;
                  if (!isNumber(index) || !isNumber(seriesIndex)) {
                    return;
                  }
                  var name = state.series.radar.data[seriesIndex].name;
                  var models = [_this.responders.filter(function(_ref4) {
                    var dataName = _ref4.name;
                    return dataName === name;
                  })[index]];
                  if (!models.length) {
                    return;
                  }
                  _this.eventBus.emit("renderHoveredSeries", {
                    models: _this.getRespondersWithTheme(models, "hover"),
                    name: _this.name
                  });
                  _this.activatedResponders = models;
                  _this.eventBus.emit("seriesPointHovered", {
                    models: _this.activatedResponders,
                    name: _this.name
                  });
                  _this.eventBus.emit("needDraw");
                });
                return _this;
              }
              radarSeries_createClass(RadarSeries2, [{
                key: "initialize",
                value: function initialize() {
                  this.type = "series";
                  this.name = "radar";
                  this.eventBus.on("selectSeries", this.selectSeries);
                  this.eventBus.on("showTooltip", this.showTooltip);
                  this.eventBus.on("hideTooltip", this.onMouseoutComponent);
                }
              }, {
                key: "render",
                value: function render(state) {
                  var _options$series$showA, _options$series, _series$radar, _options$series2, _options$series3;
                  var layout2 = state.layout, radialAxes2 = state.radialAxes, series = state.series, legend2 = state.legend, options2 = state.options, theme2 = state.theme, scale2 = state.scale;
                  if (!series.radar) {
                    throw new Error(message.noDataError(this.name));
                  }
                  this.theme = theme2.series.radar;
                  this.rect = layout2.plot;
                  this.activeSeriesMap = getActiveSeriesMap(legend2);
                  this.selectable = this.getSelectableOption(options2);
                  var categories = state.categories;
                  var _ref5 = radialAxes2.verticalAxis, axisSize = _ref5.axisSize, centerX = _ref5.centerX, centerY = _ref5.centerY;
                  var _ref6 = scale2.verticalAxis, limit = _ref6.limit, stepSize = _ref6.stepSize;
                  var labels = makeLabelsFromLimit(limit, stepSize);
                  var _getLimitOnAxis = getLimitOnAxis(labels), min = _getLimitOnAxis.min, max2 = _getLimitOnAxis.max;
                  var renderOptions = {
                    categories,
                    degree: DEGREE_360 / categories.length,
                    centerX,
                    centerY,
                    showArea: (_options$series$showA = options2 === null || options2 === void 0 ? void 0 : (_options$series = options2.series) === null || _options$series === void 0 ? void 0 : _options$series.showArea) !== null && _options$series$showA !== void 0 ? _options$series$showA : false,
                    ratio: axisSize / (max2 - min)
                  };
                  var radarData = (_series$radar = series.radar) === null || _series$radar === void 0 ? void 0 : _series$radar.data;
                  var radarPointsData = this.makeRadarPointsData(radarData, renderOptions);
                  var circleModel = this.renderDotModels(radarPointsData);
                  this.models.area = options2 !== null && options2 !== void 0 && (_options$series2 = options2.series) !== null && _options$series2 !== void 0 && _options$series2.showArea ? this.renderAreaModels(radarPointsData) : [];
                  this.models.line = this.renderLineModels(radarPointsData);
                  this.models.dot = options2 !== null && options2 !== void 0 && (_options$series3 = options2.series) !== null && _options$series3 !== void 0 && _options$series3.showDot ? circleModel : [];
                  if (!this.drawModels) {
                    this.drawModels = {
                      area: this.initDrawModels("area", centerX, centerY),
                      line: this.initDrawModels("line", centerX, centerY),
                      dot: this.models.dot.map(function(m) {
                        return radarSeries_objectSpread(radarSeries_objectSpread({}, m), {}, {
                          x: centerX,
                          y: centerY
                        });
                      })
                    };
                  }
                  var tooltipDataArr = this.makeTooltipModel(circleModel, categories);
                  this.responders = circleModel.map(function(m, index) {
                    return radarSeries_objectSpread(radarSeries_objectSpread({}, m), {}, {
                      data: tooltipDataArr[index],
                      color: getRGBA(m.color, 1)
                    });
                  });
                }
              }, {
                key: "initDrawModels",
                value: function initDrawModels(modelName, centerX, centerY) {
                  return this.models[modelName].map(function(m) {
                    var _m$distances;
                    return radarSeries_objectSpread(radarSeries_objectSpread({}, m), {}, {
                      distances: (_m$distances = m.distances) === null || _m$distances === void 0 ? void 0 : _m$distances.map(function() {
                        return 0;
                      }),
                      points: m.points.map(function() {
                        return {
                          x: centerX,
                          y: centerY
                        };
                      })
                    });
                  });
                }
              }, {
                key: "makeTooltipModel",
                value: function makeTooltipModel(circleModel, categories) {
                  return circleModel.map(function(_ref7) {
                    var name = _ref7.name, color = _ref7.color, value = _ref7.value, index = _ref7.index;
                    return {
                      label: name,
                      color,
                      value,
                      category: categories[index]
                    };
                  });
                }
              }, {
                key: "getRespondersWithTheme",
                value: function getRespondersWithTheme(responders, type) {
                  var _ref8 = this.theme[type].dot, radius = _ref8.radius, borderWidth = _ref8.borderWidth, borderColor = _ref8.borderColor, color = _ref8.color;
                  return responders.map(function(responder) {
                    var modelColor = color !== null && color !== void 0 ? color : responder.color;
                    return radarSeries_objectSpread(radarSeries_objectSpread({}, responder), {}, {
                      radius,
                      color: modelColor,
                      borderColor: borderColor !== null && borderColor !== void 0 ? borderColor : getRGBA(modelColor, 0.5),
                      borderWidth
                    });
                  });
                }
              }, {
                key: "onClick",
                value: function onClick(_ref9) {
                  var responders = _ref9.responders;
                  if (this.selectable) {
                    this.eventBus.emit("renderSelectedSeries", {
                      models: this.getRespondersWithTheme(responders, "select"),
                      name: this.name
                    });
                    this.eventBus.emit("needDraw");
                  }
                }
              }, {
                key: "onMousemove",
                value: function onMousemove(_ref10) {
                  var responders = _ref10.responders;
                  this.eventBus.emit("renderHoveredSeries", {
                    models: this.getRespondersWithTheme(responders, "hover"),
                    name: this.name
                  });
                  this.activatedResponders = responders;
                  this.eventBus.emit("seriesPointHovered", {
                    models: this.activatedResponders,
                    name: this.name
                  });
                  this.eventBus.emit("needDraw");
                }
              }, {
                key: "makeRadarPointsData",
                value: function makeRadarPointsData(seriesData2, renderOptions) {
                  var _this2 = this;
                  var centerX = renderOptions.centerX, centerY = renderOptions.centerY, degree = renderOptions.degree, ratio = renderOptions.ratio, showArea = renderOptions.showArea;
                  return seriesData2.map(function(_ref11) {
                    var data = _ref11.data, seriesColor = _ref11.color, name = _ref11.name;
                    var radarPoints = data.reduce(function(acc, value, index) {
                      if (isNull(value)) {
                        return {
                          distances: [].concat(radarSeries_toConsumableArray(acc.distances), [0]),
                          linePoints: [].concat(radarSeries_toConsumableArray(acc.linePoints), [null]),
                          areaPoints: [].concat(radarSeries_toConsumableArray(acc.areaPoints), [{
                            x: centerX,
                            y: centerY
                          }])
                        };
                      }
                      var distance = value * ratio;
                      var point = getRadialPosition(centerX, centerY, distance, calculateDegreeToRadian(degree * index));
                      return {
                        distances: [].concat(radarSeries_toConsumableArray(acc.distances), [distance]),
                        linePoints: [].concat(radarSeries_toConsumableArray(acc.linePoints), [point]),
                        areaPoints: [].concat(radarSeries_toConsumableArray(acc.areaPoints), [point])
                      };
                    }, {
                      linePoints: [],
                      distances: [],
                      areaPoints: []
                    });
                    if (!isNull(data[0]) && !isNull(data[data.length - 1])) {
                      radarPoints.linePoints.push(radarPoints.linePoints[0]);
                      radarPoints.areaPoints.push(radarPoints.areaPoints[0]);
                    }
                    return radarSeries_objectSpread(radarSeries_objectSpread({
                      name,
                      seriesColor,
                      data
                    }, radarPoints), _this2.getSeriesColor(showArea, seriesColor, name));
                  });
                }
              }, {
                key: "renderAreaModels",
                value: function renderAreaModels(radarPointsData) {
                  return radarPointsData.map(function(_ref12) {
                    var distances = _ref12.distances, areaPoints2 = _ref12.areaPoints, name = _ref12.name, fillColor = _ref12.fillColor, seriesColor = _ref12.seriesColor;
                    return {
                      type: "areaPoints",
                      name,
                      distances,
                      points: areaPoints2,
                      fillColor,
                      color: getRGBA(seriesColor, 0),
                      lineWidth: 0
                    };
                  });
                }
              }, {
                key: "renderLineModels",
                value: function renderLineModels(radarPointsData) {
                  var _this$theme = this.theme, lineWidth = _this$theme.lineWidth, dashSegments = _this$theme.dashSegments;
                  return radarPointsData.map(function(_ref13) {
                    var distances = _ref13.distances, linePoints2 = _ref13.linePoints, name = _ref13.name, lineColor = _ref13.lineColor;
                    return {
                      type: "linePoints",
                      lineWidth: lineWidth !== null && lineWidth !== void 0 ? lineWidth : radarDefault.LINE_WIDTH,
                      name,
                      distances,
                      points: linePoints2,
                      color: lineColor,
                      dashSegments
                    };
                  });
                }
              }, {
                key: "renderDotModels",
                value: function renderDotModels(radarPointsData) {
                  var _ref14 = this.theme.dot, radius = _ref14.radius, dotColor = _ref14.color;
                  var result = [];
                  radarPointsData.forEach(function(_ref15, seriesIndex) {
                    var linePoints2 = _ref15.linePoints, lineColor = _ref15.lineColor, name = _ref15.name, data = _ref15.data;
                    return linePoints2.slice(0, linePoints2.length - 1).forEach(function(point, index) {
                      if (!isNull(point)) {
                        result.push(radarSeries_objectSpread(radarSeries_objectSpread({
                          type: "circle"
                        }, point), {}, {
                          radius,
                          color: dotColor !== null && dotColor !== void 0 ? dotColor : lineColor,
                          style: [{
                            strokeStyle: "rgba(0, 0, 0, 0)"
                          }],
                          name,
                          seriesIndex,
                          index,
                          value: data === null || data === void 0 ? void 0 : data[index]
                        }));
                      }
                    });
                  });
                  return result;
                }
              }, {
                key: "getSeriesColor",
                value: function getSeriesColor(showArea, seriesColor, name) {
                  var active = this.activeSeriesMap[name];
                  var _this$theme2 = this.theme, select = _this$theme2.select, areaOpacity = _this$theme2.areaOpacity;
                  var selected = Object.values(this.activeSeriesMap).some(function(elem) {
                    return !elem;
                  });
                  var color = getRGBA(seriesColor, active ? radarSeries_seriesOpacity.ACTIVE : radarSeries_seriesOpacity.INACTIVE);
                  var fillOpacity = NONE_AREA_OPACITY;
                  if (showArea) {
                    var selectedAreaOpacity = active ? select.areaOpacity : select.restSeries.areaOpacity;
                    fillOpacity = selected ? selectedAreaOpacity : areaOpacity;
                  }
                  return {
                    lineColor: color,
                    fillColor: getRGBA(color, fillOpacity)
                  };
                }
              }]);
              return RadarSeries2;
            }(Component);
            ;
            function radialPlot_typeof(obj) {
              "@babel/helpers - typeof";
              if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                radialPlot_typeof = function _typeof2(obj2) {
                  return typeof obj2;
                };
              } else {
                radialPlot_typeof = function _typeof2(obj2) {
                  return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                };
              }
              return radialPlot_typeof(obj);
            }
            function radialPlot_toConsumableArray(arr) {
              return radialPlot_arrayWithoutHoles(arr) || radialPlot_iterableToArray(arr) || radialPlot_unsupportedIterableToArray(arr) || radialPlot_nonIterableSpread();
            }
            function radialPlot_nonIterableSpread() {
              throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            function radialPlot_unsupportedIterableToArray(o, minLen) {
              if (!o)
                return;
              if (typeof o === "string")
                return radialPlot_arrayLikeToArray(o, minLen);
              var n = Object.prototype.toString.call(o).slice(8, -1);
              if (n === "Object" && o.constructor)
                n = o.constructor.name;
              if (n === "Map" || n === "Set")
                return Array.from(o);
              if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                return radialPlot_arrayLikeToArray(o, minLen);
            }
            function radialPlot_iterableToArray(iter) {
              if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
                return Array.from(iter);
            }
            function radialPlot_arrayWithoutHoles(arr) {
              if (Array.isArray(arr))
                return radialPlot_arrayLikeToArray(arr);
            }
            function radialPlot_arrayLikeToArray(arr, len) {
              if (len == null || len > arr.length)
                len = arr.length;
              for (var i = 0, arr2 = new Array(len); i < len; i++) {
                arr2[i] = arr[i];
              }
              return arr2;
            }
            function radialPlot_classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function radialPlot_defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            function radialPlot_createClass(Constructor, protoProps, staticProps) {
              if (protoProps)
                radialPlot_defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                radialPlot_defineProperties(Constructor, staticProps);
              return Constructor;
            }
            function radialPlot_inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function");
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
              if (superClass)
                radialPlot_setPrototypeOf(subClass, superClass);
            }
            function radialPlot_setPrototypeOf(o, p) {
              radialPlot_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
                o2.__proto__ = p2;
                return o2;
              };
              return radialPlot_setPrototypeOf(o, p);
            }
            function radialPlot_createSuper(Derived) {
              var hasNativeReflectConstruct = radialPlot_isNativeReflectConstruct();
              return function _createSuperInternal() {
                var Super = radialPlot_getPrototypeOf(Derived), result;
                if (hasNativeReflectConstruct) {
                  var NewTarget = radialPlot_getPrototypeOf(this).constructor;
                  result = Reflect.construct(Super, arguments, NewTarget);
                } else {
                  result = Super.apply(this, arguments);
                }
                return radialPlot_possibleConstructorReturn(this, result);
              };
            }
            function radialPlot_possibleConstructorReturn(self2, call) {
              if (call && (radialPlot_typeof(call) === "object" || typeof call === "function")) {
                return call;
              }
              return radialPlot_assertThisInitialized(self2);
            }
            function radialPlot_assertThisInitialized(self2) {
              if (self2 === void 0) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return self2;
            }
            function radialPlot_isNativeReflectConstruct() {
              if (typeof Reflect === "undefined" || !Reflect.construct)
                return false;
              if (Reflect.construct.sham)
                return false;
              if (typeof Proxy === "function")
                return true;
              try {
                Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                }));
                return true;
              } catch (e) {
                return false;
              }
            }
            function radialPlot_getPrototypeOf(o) {
              radialPlot_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
                return o2.__proto__ || Object.getPrototypeOf(o2);
              };
              return radialPlot_getPrototypeOf(o);
            }
            function radialPlot_defineProperty(obj, key, value) {
              if (key in obj) {
                Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
              } else {
                obj[key] = value;
              }
              return obj;
            }
            function getScaleMaxLimitValue(scale2, totalAngle) {
              var max2 = scale2.limit.max, stepSize = scale2.stepSize;
              return max2 + (totalAngle < DEGREE_360 ? DEGREE_0 : stepSize);
            }
            function findCategoryIndex(categories, value) {
              return categories.findIndex(function(category2) {
                return category2 === value;
              });
            }
            var RadarPlot = function(_Component) {
              radialPlot_inherits(RadarPlot2, _Component);
              var _super = radialPlot_createSuper(RadarPlot2);
              function RadarPlot2() {
                var _this;
                radialPlot_classCallCheck(this, RadarPlot2);
                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }
                _this = _super.call.apply(_super, [this].concat(args));
                radialPlot_defineProperty(radialPlot_assertThisInitialized(_this), "models", {
                  plot: [],
                  line: [],
                  band: []
                });
                radialPlot_defineProperty(radialPlot_assertThisInitialized(_this), "circularAxisTheme", void 0);
                return _this;
              }
              radialPlot_createClass(RadarPlot2, [{
                key: "initialize",
                value: function initialize(initParam) {
                  var _initParam$name;
                  this.type = "plot";
                  this.name = (_initParam$name = initParam === null || initParam === void 0 ? void 0 : initParam.name) !== null && _initParam$name !== void 0 ? _initParam$name : "radialPlot";
                }
              }, {
                key: "render",
                value: function render(state) {
                  var _ref;
                  var layout2 = state.layout, radialAxes2 = state.radialAxes, options2 = state.options, series = state.series, theme2 = state.theme, scale2 = state.scale;
                  this.rect = layout2.plot;
                  this.circularAxisTheme = theme2.circularAxis;
                  var categories = (_ref = state.categories) !== null && _ref !== void 0 ? _ref : [];
                  if (this.name === "gauge") {
                    var _plot$bands, _plot;
                    var bandData = (_plot$bands = options2 === null || options2 === void 0 ? void 0 : (_plot = options2.plot) === null || _plot === void 0 ? void 0 : _plot.bands) !== null && _plot$bands !== void 0 ? _plot$bands : [];
                    var hasCategoryAxis = !isLabelAxisOnYAxis({
                      series,
                      categories
                    });
                    var renderOptions = this.makeRenderOptionsOnGauge(hasCategoryAxis, radialAxes2.circularAxis, categories, scale2);
                    this.models.band = this.renderBands(bandData, renderOptions, categories);
                  } else {
                    var _options$plot$type, _options$plot;
                    var isRadarChart = !!series.radar;
                    var plotType = (_options$plot$type = (_options$plot = options2.plot) === null || _options$plot === void 0 ? void 0 : _options$plot.type) !== null && _options$plot$type !== void 0 ? _options$plot$type : isRadarChart ? "spiderweb" : "circle";
                    var _renderOptions = this.makeRenderOptions(radialAxes2, plotType, categories);
                    this.models.plot = this.renderPlot(_renderOptions);
                    this.models.line = series.radialBar ? this.renderLine(_renderOptions) : [];
                  }
                }
              }, {
                key: "makeRenderOptionsOnGauge",
                value: function makeRenderOptionsOnGauge(hasCategoryAxis, circularAxis, categories, scale2) {
                  var _circularAxis$angle = circularAxis.angle, total = _circularAxis$angle.total, start = _circularAxis$angle.start, outer = circularAxis.radius.outer, clockwise = circularAxis.clockwise, centerX = circularAxis.centerX, centerY = circularAxis.centerY;
                  var _ref2 = circularAxis.band, bandWidth = _ref2.width, bandMargin = _ref2.margin;
                  return {
                    centerX,
                    centerY,
                    clockwise,
                    totalAngle: total,
                    scaleMaxLimitValue: hasCategoryAxis ? categories.length : getScaleMaxLimitValue(scale2.circularAxis, total),
                    startAngle: start,
                    outerRadius: outer,
                    bandWidth,
                    bandMargin,
                    hasCategoryAxis
                  };
                }
              }, {
                key: "makeRenderOptions",
                value: function makeRenderOptions(radialAxes2, type) {
                  var categories = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
                  var _ref3 = radialAxes2.verticalAxis, centerX = _ref3.centerX, centerY = _ref3.centerY, _ref3$radius = _ref3.radius, ranges = _ref3$radius.ranges, inner = _ref3$radius.inner, outer = _ref3$radius.outer;
                  var _radialAxes$circularA = radialAxes2.circularAxis, _radialAxes$circularA2 = _radialAxes$circularA.angle, central = _radialAxes$circularA2.central, total = _radialAxes$circularA2.total, start = _radialAxes$circularA2.start, end = _radialAxes$circularA2.end, drawingStart = _radialAxes$circularA2.drawingStart, labels = _radialAxes$circularA.label.labels, tickInterval = _radialAxes$circularA.tickInterval, clockwise = _radialAxes$circularA.clockwise;
                  var usingArcPlot = total !== DEGREE_360;
                  var lineCount = labels.length;
                  return {
                    type,
                    categories,
                    centralAngle: central,
                    centerX,
                    centerY,
                    initialRadius: inner,
                    radius: outer,
                    radiusRanges: ranges,
                    lineCount,
                    tickInterval,
                    drawingStartAngle: drawingStart,
                    usingArcPlot,
                    startAngle: start,
                    endAngle: end,
                    clockwise
                  };
                }
              }, {
                key: "renderPlot",
                value: function renderPlot(renderOptions) {
                  var type = renderOptions.type, usingArcPlot = renderOptions.usingArcPlot;
                  if (usingArcPlot) {
                    return this.makeArc(renderOptions);
                  }
                  if (type === "spiderweb") {
                    return this.makeSpiderwebPlot(renderOptions);
                  }
                  return this.makeCirclePlot(renderOptions);
                }
              }, {
                key: "makeSpiderwebPlot",
                value: function makeSpiderwebPlot(renderOptions) {
                  var centralAngle = renderOptions.centralAngle, centerX = renderOptions.centerX, centerY = renderOptions.centerY, categories = renderOptions.categories, radiusRanges = renderOptions.radiusRanges;
                  var _this$circularAxisThe = this.circularAxisTheme, strokeStyle = _this$circularAxisThe.strokeStyle, lineWidth = _this$circularAxisThe.lineWidth;
                  return radiusRanges.map(function(radius) {
                    var points = categories.map(function(_, index) {
                      return getRadialPosition(centerX, centerY, radius, calculateDegreeToRadian(centralAngle * index));
                    });
                    return {
                      type: "polygon",
                      color: strokeStyle,
                      lineWidth,
                      points
                    };
                  });
                }
              }, {
                key: "makeCirclePlot",
                value: function makeCirclePlot(renderOptions) {
                  var centerX = renderOptions.centerX, centerY = renderOptions.centerY, radiusRanges = renderOptions.radiusRanges;
                  var _this$circularAxisThe2 = this.circularAxisTheme, strokeStyle = _this$circularAxisThe2.strokeStyle, lineWidth = _this$circularAxisThe2.lineWidth;
                  return radiusRanges.map(function(radius) {
                    return {
                      type: "circle",
                      color: "rgba(0, 0, 0, 0)",
                      radius,
                      x: centerX,
                      y: centerY,
                      borderColor: strokeStyle,
                      borderWidth: lineWidth
                    };
                  });
                }
              }, {
                key: "makeArc",
                value: function makeArc(renderOptions) {
                  var centerX = renderOptions.centerX, centerY = renderOptions.centerY, radiusRanges = renderOptions.radiusRanges, startAngle = renderOptions.startAngle, endAngle = renderOptions.endAngle, clockwise = renderOptions.clockwise;
                  var _this$circularAxisThe3 = this.circularAxisTheme, strokeStyle = _this$circularAxisThe3.strokeStyle, lineWidth = _this$circularAxisThe3.lineWidth;
                  return radiusRanges.map(function(radius) {
                    return {
                      type: "arc",
                      borderWidth: lineWidth,
                      borderColor: strokeStyle,
                      x: centerX,
                      y: centerY,
                      angle: {
                        start: startAngle,
                        end: endAngle
                      },
                      drawingStartAngle: DEGREE_NEGATIVE_90,
                      radius,
                      clockwise
                    };
                  });
                }
              }, {
                key: "renderLine",
                value: function renderLine(renderOptions) {
                  var centerX = renderOptions.centerX, centerY = renderOptions.centerY, initialRadius = renderOptions.initialRadius, radius = renderOptions.radius, lineCount = renderOptions.lineCount, centralAngle = renderOptions.centralAngle, tickInterval = renderOptions.tickInterval, drawingStartAngle = renderOptions.drawingStartAngle, clockwise = renderOptions.clockwise;
                  var _this$circularAxisThe4 = this.circularAxisTheme, strokeStyle = _this$circularAxisThe4.strokeStyle, lineWidth = _this$circularAxisThe4.lineWidth;
                  return range(0, lineCount).reduce(function(acc, cur, index) {
                    var startDegree = drawingStartAngle + centralAngle * index * (clockwise ? 1 : -1);
                    var _getRadialPosition = getRadialPosition(centerX, centerY, initialRadius, calculateDegreeToRadian(startDegree)), x = _getRadialPosition.x, y = _getRadialPosition.y;
                    var _getRadialPosition2 = getRadialPosition(centerX, centerY, radius, calculateDegreeToRadian(startDegree)), x2 = _getRadialPosition2.x, y2 = _getRadialPosition2.y;
                    return index % tickInterval === 0 ? [].concat(radialPlot_toConsumableArray(acc), [{
                      type: "line",
                      x,
                      y,
                      x2,
                      y2,
                      strokeStyle,
                      lineWidth
                    }]) : acc;
                  }, []);
                }
              }, {
                key: "renderBands",
                value: function renderBands(bands, renderOptions, categories) {
                  var sectors = [];
                  var centerX = renderOptions.centerX, centerY = renderOptions.centerY, clockwise = renderOptions.clockwise, totalAngle = renderOptions.totalAngle, scaleMaxLimitValue = renderOptions.scaleMaxLimitValue, startAngle = renderOptions.startAngle, outerRadius = renderOptions.outerRadius, bandWidth = renderOptions.bandWidth, bandMargin = renderOptions.bandMargin, hasCategoryAxis = renderOptions.hasCategoryAxis;
                  bands.forEach(function(_ref4, index) {
                    var rangeData = _ref4.range, color = _ref4.color;
                    var value = hasCategoryAxis ? findCategoryIndex(categories, rangeData[1].toString()) - findCategoryIndex(categories, rangeData[0].toString()) : Number(rangeData[1]) - Number(rangeData[0]);
                    var degree = value / scaleMaxLimitValue * totalAngle * (clockwise ? 1 : -1);
                    var validDegree = calculateValidAngle(degree);
                    var prevModel = sectors[sectors.length - 1];
                    var startDegree = index && prevModel ? prevModel.degree.end : startAngle;
                    var endDegree = calculateValidAngle(startDegree + validDegree);
                    sectors.push({
                      type: "sector",
                      color,
                      x: centerX,
                      y: centerY,
                      clockwise,
                      degree: {
                        start: startDegree,
                        end: endDegree
                      },
                      radius: {
                        inner: outerRadius + bandMargin,
                        outer: outerRadius + bandWidth
                      }
                    });
                  });
                  return sectors;
                }
              }]);
              return RadarPlot2;
            }(Component);
            ;
            function radialAxis_typeof(obj) {
              "@babel/helpers - typeof";
              if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                radialAxis_typeof = function _typeof2(obj2) {
                  return typeof obj2;
                };
              } else {
                radialAxis_typeof = function _typeof2(obj2) {
                  return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                };
              }
              return radialAxis_typeof(obj);
            }
            function radialAxis_ownKeys(object, enumerableOnly) {
              var keys = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object);
                if (enumerableOnly) {
                  symbols = symbols.filter(function(sym) {
                    return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                  });
                }
                keys.push.apply(keys, symbols);
              }
              return keys;
            }
            function radialAxis_objectSpread(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i] != null ? arguments[i] : {};
                if (i % 2) {
                  radialAxis_ownKeys(Object(source), true).forEach(function(key) {
                    radialAxis_defineProperty(target, key, source[key]);
                  });
                } else if (Object.getOwnPropertyDescriptors) {
                  Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                } else {
                  radialAxis_ownKeys(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  });
                }
              }
              return target;
            }
            function radialAxis_toConsumableArray(arr) {
              return radialAxis_arrayWithoutHoles(arr) || radialAxis_iterableToArray(arr) || radialAxis_unsupportedIterableToArray(arr) || radialAxis_nonIterableSpread();
            }
            function radialAxis_nonIterableSpread() {
              throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            function radialAxis_unsupportedIterableToArray(o, minLen) {
              if (!o)
                return;
              if (typeof o === "string")
                return radialAxis_arrayLikeToArray(o, minLen);
              var n = Object.prototype.toString.call(o).slice(8, -1);
              if (n === "Object" && o.constructor)
                n = o.constructor.name;
              if (n === "Map" || n === "Set")
                return Array.from(o);
              if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                return radialAxis_arrayLikeToArray(o, minLen);
            }
            function radialAxis_iterableToArray(iter) {
              if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
                return Array.from(iter);
            }
            function radialAxis_arrayWithoutHoles(arr) {
              if (Array.isArray(arr))
                return radialAxis_arrayLikeToArray(arr);
            }
            function radialAxis_arrayLikeToArray(arr, len) {
              if (len == null || len > arr.length)
                len = arr.length;
              for (var i = 0, arr2 = new Array(len); i < len; i++) {
                arr2[i] = arr[i];
              }
              return arr2;
            }
            function radialAxis_classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function radialAxis_defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            function radialAxis_createClass(Constructor, protoProps, staticProps) {
              if (protoProps)
                radialAxis_defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                radialAxis_defineProperties(Constructor, staticProps);
              return Constructor;
            }
            function radialAxis_inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function");
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
              if (superClass)
                radialAxis_setPrototypeOf(subClass, superClass);
            }
            function radialAxis_setPrototypeOf(o, p) {
              radialAxis_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
                o2.__proto__ = p2;
                return o2;
              };
              return radialAxis_setPrototypeOf(o, p);
            }
            function radialAxis_createSuper(Derived) {
              var hasNativeReflectConstruct = radialAxis_isNativeReflectConstruct();
              return function _createSuperInternal() {
                var Super = radialAxis_getPrototypeOf(Derived), result;
                if (hasNativeReflectConstruct) {
                  var NewTarget = radialAxis_getPrototypeOf(this).constructor;
                  result = Reflect.construct(Super, arguments, NewTarget);
                } else {
                  result = Super.apply(this, arguments);
                }
                return radialAxis_possibleConstructorReturn(this, result);
              };
            }
            function radialAxis_possibleConstructorReturn(self2, call) {
              if (call && (radialAxis_typeof(call) === "object" || typeof call === "function")) {
                return call;
              }
              return radialAxis_assertThisInitialized(self2);
            }
            function radialAxis_assertThisInitialized(self2) {
              if (self2 === void 0) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return self2;
            }
            function radialAxis_isNativeReflectConstruct() {
              if (typeof Reflect === "undefined" || !Reflect.construct)
                return false;
              if (Reflect.construct.sham)
                return false;
              if (typeof Proxy === "function")
                return true;
              try {
                Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                }));
                return true;
              } catch (e) {
                return false;
              }
            }
            function radialAxis_getPrototypeOf(o) {
              radialAxis_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
                return o2.__proto__ || Object.getPrototypeOf(o2);
              };
              return radialAxis_getPrototypeOf(o);
            }
            function radialAxis_defineProperty(obj, key, value) {
              if (key in obj) {
                Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
              } else {
                obj[key] = value;
              }
              return obj;
            }
            var radialAxis_RECT_SIZE = 4;
            var HALF_TICK = 5;
            function hasNeedRender(index, pointOnColumn, labelInterval, innerRadius, outerRadius) {
              return !pointOnColumn && index === 0 ? false : !(index % labelInterval) && (pointOnColumn && innerRadius <= outerRadius || !pointOnColumn && innerRadius < outerRadius);
            }
            var RadialAxis = function(_Component) {
              radialAxis_inherits(RadialAxis2, _Component);
              var _super = radialAxis_createSuper(RadialAxis2);
              function RadialAxis2() {
                var _this;
                radialAxis_classCallCheck(this, RadialAxis2);
                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }
                _this = _super.call.apply(_super, [this].concat(args));
                radialAxis_defineProperty(radialAxis_assertThisInitialized(_this), "models", {
                  verticalAxisLabel: [],
                  circularAxisLabel: [],
                  dot: [],
                  line: [],
                  tick: []
                });
                radialAxis_defineProperty(radialAxis_assertThisInitialized(_this), "verticalAxisTheme", void 0);
                radialAxis_defineProperty(radialAxis_assertThisInitialized(_this), "circularAxisTheme", void 0);
                return _this;
              }
              radialAxis_createClass(RadialAxis2, [{
                key: "initialize",
                value: function initialize(initParam) {
                  var _initParam$name;
                  this.type = "axis";
                  this.name = (_initParam$name = initParam === null || initParam === void 0 ? void 0 : initParam.name) !== null && _initParam$name !== void 0 ? _initParam$name : "radial";
                }
              }, {
                key: "render",
                value: function render(_ref) {
                  var layout2 = _ref.layout, radialAxes2 = _ref.radialAxes, theme2 = _ref.theme, series = _ref.series;
                  this.isShow = !isNoData(series);
                  this.rect = layout2.plot;
                  if (!radialAxes2) {
                    return;
                  }
                  this.circularAxisTheme = theme2.circularAxis;
                  var circularAxis = radialAxes2.circularAxis, verticalAxis = radialAxes2.verticalAxis;
                  if (verticalAxis) {
                    this.verticalAxisTheme = theme2.verticalAxis;
                    this.models.verticalAxisLabel = this.renderVerticalAxisLabel(verticalAxis);
                  }
                  this.models.circularAxisLabel = this.renderCircularAxisLabel(circularAxis);
                  if (this.name === "gauge") {
                    this.models.line = this.renderArcLine(circularAxis);
                    this.models.tick = this.renderTick(circularAxis);
                  } else {
                    this.models.dot = this.renderDotModel(circularAxis);
                  }
                }
              }, {
                key: "getBubbleShadowStyle",
                value: function getBubbleShadowStyle() {
                  var _ref2 = this.verticalAxisTheme.label.textBubble, visible = _ref2.visible, shadowColor = _ref2.shadowColor, shadowOffsetX = _ref2.shadowOffsetX, shadowOffsetY = _ref2.shadowOffsetY, shadowBlur = _ref2.shadowBlur;
                  return visible && shadowColor ? [{
                    shadowColor,
                    shadowOffsetX,
                    shadowOffsetY,
                    shadowBlur
                  }] : null;
                }
              }, {
                key: "renderVerticalAxisLabel",
                value: function renderVerticalAxisLabel(verticalAxis) {
                  var _this2 = this;
                  var _verticalAxis$radius = verticalAxis.radius, ranges = _verticalAxis$radius.ranges, outer = _verticalAxis$radius.outer, _verticalAxis$label = verticalAxis.label, labels = _verticalAxis$label.labels, interval = _verticalAxis$label.interval, maxWidth = _verticalAxis$label.maxWidth, maxHeight = _verticalAxis$label.maxHeight, margin = _verticalAxis$label.margin, align = _verticalAxis$label.align, start = verticalAxis.angle.start, pointOnColumn = verticalAxis.pointOnColumn, centerX = verticalAxis.centerX, centerY = verticalAxis.centerY, tickDistance = verticalAxis.tickDistance;
                  var labelAdjustment = pointOnColumn ? tickDistance / 2 : 0;
                  var font = getTitleFontString(this.verticalAxisTheme.label);
                  var _ref3 = this.verticalAxisTheme.label.textBubble, textBubbleVisible = _ref3.visible, backgroundColor = _ref3.backgroundColor, borderRadius = _ref3.borderRadius, borderColor = _ref3.borderColor, borderWidth = _ref3.borderWidth, paddingX = _ref3.paddingX, paddingY = _ref3.paddingY;
                  var labelPaddingX = textBubbleVisible ? paddingX : 0;
                  var labelPaddingY = textBubbleVisible ? paddingY : 0;
                  var width = maxWidth + labelPaddingX * 2 - margin;
                  var height = maxHeight + labelPaddingY * 2;
                  var fontColor = this.verticalAxisTheme.label.color;
                  return ranges.reduce(function(acc, radius, index) {
                    var _getRadialPosition = getRadialPosition(centerX, centerY, radius - labelAdjustment, calculateDegreeToRadian(start)), x = _getRadialPosition.x, y = _getRadialPosition.y;
                    var needRender = hasNeedRender(index, pointOnColumn, interval, radius, outer);
                    var posX = x + margin;
                    var labelPosX = x + margin + labelPaddingX;
                    if (align === "center") {
                      posX = x - margin - width / 2;
                      labelPosX = x - margin;
                    } else if (includes(["right", "end"], align)) {
                      posX = x - margin - width;
                      labelPosX = x - margin - labelPaddingX;
                    }
                    return needRender ? [].concat(radialAxis_toConsumableArray(acc), [{
                      type: "bubbleLabel",
                      rotationPosition: {
                        x,
                        y
                      },
                      radian: calculateDegreeToRadian(start, 0),
                      bubble: {
                        x: posX,
                        y: y - height / 2,
                        width,
                        height,
                        align,
                        radius: borderRadius,
                        fill: backgroundColor,
                        lineWidth: borderWidth,
                        strokeStyle: borderColor,
                        style: _this2.getBubbleShadowStyle()
                      },
                      label: {
                        text: labels[index],
                        x: labelPosX,
                        y,
                        style: [{
                          font,
                          fillStyle: fontColor,
                          textAlign: align,
                          textBaseline: "middle"
                        }]
                      }
                    }]) : acc;
                  }, []);
                }
              }, {
                key: "renderDotModel",
                value: function renderDotModel(circularAxis) {
                  var _circularAxis$angle = circularAxis.angle, central = _circularAxis$angle.central, drawingStart = _circularAxis$angle.drawingStart, _circularAxis$label = circularAxis.label, labels = _circularAxis$label.labels, interval = _circularAxis$label.interval, outer = circularAxis.radius.outer, centerX = circularAxis.centerX, centerY = circularAxis.centerY, clockwise = circularAxis.clockwise;
                  var dotColor = this.circularAxisTheme.dotColor;
                  return labels.reduce(function(acc, cur, index) {
                    var startDegree = drawingStart + central * index * (clockwise ? 1 : -1);
                    var _getRadialPosition2 = getRadialPosition(centerX, centerY, outer, calculateDegreeToRadian(calculateValidAngle(startDegree))), x = _getRadialPosition2.x, y = _getRadialPosition2.y;
                    return index % interval === 0 ? [].concat(radialAxis_toConsumableArray(acc), [{
                      type: "rect",
                      color: dotColor,
                      width: radialAxis_RECT_SIZE,
                      height: radialAxis_RECT_SIZE,
                      x: x - radialAxis_RECT_SIZE / 2,
                      y: y - radialAxis_RECT_SIZE / 2
                    }]) : acc;
                  }, []);
                }
              }, {
                key: "renderCircularAxisLabel",
                value: function renderCircularAxisLabel(circularAxis) {
                  var centerX = circularAxis.centerX, centerY = circularAxis.centerY, clockwise = circularAxis.clockwise, _circularAxis$label2 = circularAxis.label, labels = _circularAxis$label2.labels, interval = _circularAxis$label2.interval, margin = _circularAxis$label2.margin, maxHeight = _circularAxis$label2.maxHeight, _circularAxis$angle2 = circularAxis.angle, drawingStart = _circularAxis$angle2.drawingStart, central = _circularAxis$angle2.central, outer = circularAxis.radius.outer;
                  var radius = outer + (margin + maxHeight / 2) * (this.name === "gauge" ? -1 : 1);
                  var labelTheme = this.circularAxisTheme.label;
                  var font = getTitleFontString(labelTheme);
                  var degree = central * (clockwise ? 1 : -1);
                  return labels.reduce(function(acc, text, index) {
                    var startDegree = drawingStart + degree * index;
                    var validStartAngle = calculateValidAngle(startDegree);
                    return index % interval === 0 ? [].concat(radialAxis_toConsumableArray(acc), [radialAxis_objectSpread({
                      type: "label",
                      style: [{
                        textAlign: "center",
                        textBaseline: "middle",
                        font,
                        fillStyle: labelTheme.color
                      }],
                      text
                    }, getRadialPosition(centerX, centerY, radius, calculateDegreeToRadian(validStartAngle)))]) : acc;
                  }, []);
                }
              }, {
                key: "renderTick",
                value: function renderTick(circularAxis) {
                  var centerX = circularAxis.centerX, centerY = circularAxis.centerY, tickInterval = circularAxis.tickInterval, clockwise = circularAxis.clockwise, _circularAxis$angle3 = circularAxis.angle, central = _circularAxis$angle3.central, drawingStart = _circularAxis$angle3.drawingStart, labels = circularAxis.label.labels, outer = circularAxis.radius.outer;
                  var _this$circularAxisThe = this.circularAxisTheme.tick, strokeStyle = _this$circularAxisThe.strokeStyle, lineWidth = _this$circularAxisThe.lineWidth;
                  return labels.reduce(function(acc, cur, index) {
                    var startDegree = drawingStart + central * index * (clockwise ? 1 : -1);
                    var _getRadialPosition3 = getRadialPosition(centerX, centerY, outer - HALF_TICK, calculateDegreeToRadian(calculateValidAngle(startDegree))), x = _getRadialPosition3.x, y = _getRadialPosition3.y;
                    var _getRadialPosition4 = getRadialPosition(centerX, centerY, outer + HALF_TICK, calculateDegreeToRadian(calculateValidAngle(startDegree))), x2 = _getRadialPosition4.x, y2 = _getRadialPosition4.y;
                    return index % tickInterval === 0 ? [].concat(radialAxis_toConsumableArray(acc), [{
                      type: "line",
                      lineWidth,
                      strokeStyle,
                      x,
                      y,
                      x2,
                      y2
                    }]) : acc;
                  }, []);
                }
              }, {
                key: "renderArcLine",
                value: function renderArcLine(circularAxis) {
                  var centerX = circularAxis.centerX, centerY = circularAxis.centerY, clockwise = circularAxis.clockwise, _circularAxis$angle4 = circularAxis.angle, start = _circularAxis$angle4.start, end = _circularAxis$angle4.end, total = _circularAxis$angle4.total, outer = circularAxis.radius.outer;
                  var _this$circularAxisThe2 = this.circularAxisTheme, strokeStyle = _this$circularAxisThe2.strokeStyle, lineWidth = _this$circularAxisThe2.lineWidth;
                  return total === DEGREE_360 ? [{
                    type: "circle",
                    x: centerX,
                    y: centerY,
                    radius: outer,
                    borderWidth: lineWidth,
                    borderColor: strokeStyle,
                    color: "rgba(0, 0, 0, 0)"
                  }] : [{
                    type: "arc",
                    borderWidth: lineWidth,
                    borderColor: strokeStyle,
                    x: centerX,
                    y: centerY,
                    angle: {
                      start,
                      end
                    },
                    drawingStartAngle: DEGREE_NEGATIVE_90,
                    radius: outer,
                    clockwise
                  }];
                }
              }]);
              return RadialAxis2;
            }(Component);
            ;
            function radarChart_typeof(obj) {
              "@babel/helpers - typeof";
              if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                radarChart_typeof = function _typeof2(obj2) {
                  return typeof obj2;
                };
              } else {
                radarChart_typeof = function _typeof2(obj2) {
                  return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                };
              }
              return radarChart_typeof(obj);
            }
            function radarChart_ownKeys(object, enumerableOnly) {
              var keys = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object);
                if (enumerableOnly) {
                  symbols = symbols.filter(function(sym) {
                    return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                  });
                }
                keys.push.apply(keys, symbols);
              }
              return keys;
            }
            function radarChart_objectSpread(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i] != null ? arguments[i] : {};
                if (i % 2) {
                  radarChart_ownKeys(Object(source), true).forEach(function(key) {
                    radarChart_defineProperty(target, key, source[key]);
                  });
                } else if (Object.getOwnPropertyDescriptors) {
                  Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                } else {
                  radarChart_ownKeys(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  });
                }
              }
              return target;
            }
            function radarChart_defineProperty(obj, key, value) {
              if (key in obj) {
                Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
              } else {
                obj[key] = value;
              }
              return obj;
            }
            function radarChart_classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function radarChart_defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            function radarChart_createClass(Constructor, protoProps, staticProps) {
              if (protoProps)
                radarChart_defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                radarChart_defineProperties(Constructor, staticProps);
              return Constructor;
            }
            function radarChart_get(target, property, receiver) {
              if (typeof Reflect !== "undefined" && Reflect.get) {
                radarChart_get = Reflect.get;
              } else {
                radarChart_get = function _get2(target2, property2, receiver2) {
                  var base = radarChart_superPropBase(target2, property2);
                  if (!base)
                    return;
                  var desc = Object.getOwnPropertyDescriptor(base, property2);
                  if (desc.get) {
                    return desc.get.call(receiver2);
                  }
                  return desc.value;
                };
              }
              return radarChart_get(target, property, receiver || target);
            }
            function radarChart_superPropBase(object, property) {
              while (!Object.prototype.hasOwnProperty.call(object, property)) {
                object = radarChart_getPrototypeOf(object);
                if (object === null)
                  break;
              }
              return object;
            }
            function radarChart_inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function");
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
              if (superClass)
                radarChart_setPrototypeOf(subClass, superClass);
            }
            function radarChart_setPrototypeOf(o, p) {
              radarChart_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
                o2.__proto__ = p2;
                return o2;
              };
              return radarChart_setPrototypeOf(o, p);
            }
            function radarChart_createSuper(Derived) {
              var hasNativeReflectConstruct = radarChart_isNativeReflectConstruct();
              return function _createSuperInternal() {
                var Super = radarChart_getPrototypeOf(Derived), result;
                if (hasNativeReflectConstruct) {
                  var NewTarget = radarChart_getPrototypeOf(this).constructor;
                  result = Reflect.construct(Super, arguments, NewTarget);
                } else {
                  result = Super.apply(this, arguments);
                }
                return radarChart_possibleConstructorReturn(this, result);
              };
            }
            function radarChart_possibleConstructorReturn(self2, call) {
              if (call && (radarChart_typeof(call) === "object" || typeof call === "function")) {
                return call;
              }
              return radarChart_assertThisInitialized(self2);
            }
            function radarChart_assertThisInitialized(self2) {
              if (self2 === void 0) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return self2;
            }
            function radarChart_isNativeReflectConstruct() {
              if (typeof Reflect === "undefined" || !Reflect.construct)
                return false;
              if (Reflect.construct.sham)
                return false;
              if (typeof Proxy === "function")
                return true;
              try {
                Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                }));
                return true;
              } catch (e) {
                return false;
              }
            }
            function radarChart_getPrototypeOf(o) {
              radarChart_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
                return o2.__proto__ || Object.getPrototypeOf(o2);
              };
              return radarChart_getPrototypeOf(o);
            }
            var RadarChart = function(_Chart) {
              radarChart_inherits(RadarChart2, _Chart);
              var _super = radarChart_createSuper(RadarChart2);
              function RadarChart2(_ref) {
                var el = _ref.el, options2 = _ref.options, data = _ref.data;
                radarChart_classCallCheck(this, RadarChart2);
                return _super.call(this, {
                  el,
                  options: options2,
                  series: {
                    radar: data.series
                  },
                  categories: data.categories,
                  modules: [store_dataRange, store_scale, radialAxes]
                });
              }
              radarChart_createClass(RadarChart2, [{
                key: "initialize",
                value: function initialize() {
                  radarChart_get(radarChart_getPrototypeOf(RadarChart2.prototype), "initialize", this).call(this);
                  this.componentManager.add(Background);
                  this.componentManager.add(Title);
                  this.componentManager.add(Legend);
                  this.componentManager.add(RadarPlot);
                  this.componentManager.add(RadialAxis);
                  this.componentManager.add(RadarSeries);
                  this.componentManager.add(ExportMenu, {
                    chartEl: this.el
                  });
                  this.componentManager.add(HoveredSeries);
                  this.componentManager.add(SelectedSeries);
                  this.componentManager.add(Tooltip, {
                    chartEl: this.el
                  });
                  this.componentManager.add(NoDataText);
                  this.painter.addGroups([basic_namespaceObject, legend_namespaceObject, label_namespaceObject, brushes_exportMenu_namespaceObject, polygon_namespaceObject, axis_namespaceObject, brushes_lineSeries_namespaceObject]);
                }
                /**
                 * Add data.
                 * @param {Array<number>} data - Array of data to be added.
                 * @param {string} category - Category to be added.
                 * @api
                 * @example
                 * chart.addData([10, 20], '6');
                 */
              }, {
                key: "addData",
                value: function addData(data, category2) {
                  this.animationControlFlag.updating = true;
                  this.resetSeries();
                  this.store.dispatch("addData", {
                    data,
                    category: category2
                  });
                }
                /**
                 * Add series.
                 * @param {Object} data - Data to be added.
                 *   @param {string} data.name - Series name.
                 *   @param {Array<number>} data.data - Array of data to be added.
                 * @api
                 * @example
                 * chart.addSeries({
                 *   name: 'newSeries',
                 *   data: [10, 100, 50, 40, 70, 55, 33, 70, 90, 110],
                 * });
                 */
              }, {
                key: "addSeries",
                value: function addSeries(data) {
                  this.resetSeries();
                  this.store.dispatch("addSeries", {
                    data
                  });
                }
                /**
                 * Convert the chart data to new data.
                 * @param {Object} data - Data to be set.
                 * @api
                 * @example
                 * chart.setData({
                 *   categories: ['1', '2', '3'],
                 *   series: [
                 *     {
                 *       name: 'new series',
                 *       data: [1, 2, 3],
                 *     },
                 *     {
                 *       name: 'new series2',
                 *       data: [4, 5, 6],
                 *     }
                 *   ]
                 * });
                 */
              }, {
                key: "setData",
                value: function setData(data) {
                  var categories = data.categories, series = data.series;
                  this.resetSeries();
                  this.store.dispatch("setData", {
                    series: {
                      radar: series
                    },
                    categories
                  });
                }
                /**
                 * Convert the chart options to new options.
                 * @param {Object} options - Chart options.
                 * @api
                 * @example
                 * chart.setOptions({
                 *   chart: {
                 *     width: 500,
                 *     height: 'auto',
                 *     title: 'Energy Usage',
                 *   },
                 *   series: {
                 *     selectable: true,
                 *   },
                 *   tooltip: {
                 *     formatter: (value) => `${value}kWh`,
                 *   },
                 * });
                 */
              }, {
                key: "setOptions",
                value: function setOptions(options2) {
                  this.dispatchOptionsEvent("initOptions", options2);
                }
                /**
                 * Update chart options.
                 * @param {Object} options - Chart options.
                 * @api
                 * @example
                 * chart.updateOptions({
                 *   chart: {
                 *     height: 'auto',
                 *     title: 'Energy Usage',
                 *   },
                 *   tooltip: {
                 *     formatter: (value) => `${value}kWh`,
                 *   },
                 * });
                 */
              }, {
                key: "updateOptions",
                value: function updateOptions(options2) {
                  this.resetSeries();
                  this.dispatchOptionsEvent("updateOptions", options2);
                }
                /**
                 * Show tooltip.
                 * @param {Object} seriesInfo - Information of the series for the tooltip to be displayed.
                 *      @param {number} seriesInfo.seriesIndex - Index of series.
                 *      @param {number} seriesInfo.index - Index of data within series.
                 * @api
                 * @example
                 * chart.showTooltip({index: 1, seriesIndex: 2});
                 */
              }, {
                key: "showTooltip",
                value: function showTooltip(seriesInfo) {
                  this.eventBus.emit("showTooltip", radarChart_objectSpread(radarChart_objectSpread({}, seriesInfo), {}, {
                    state: this.store.state
                  }));
                }
                /**
                 * Hide tooltip.
                 * @api
                 * @example
                 * chart.hideTooltip();
                 */
              }, {
                key: "hideTooltip",
                value: function hideTooltip() {
                  this.eventBus.emit("hideTooltip");
                }
              }]);
              return RadarChart2;
            }(Chart);
            ;
            function squarifier_toConsumableArray(arr) {
              return squarifier_arrayWithoutHoles(arr) || squarifier_iterableToArray(arr) || squarifier_unsupportedIterableToArray(arr) || squarifier_nonIterableSpread();
            }
            function squarifier_nonIterableSpread() {
              throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            function squarifier_unsupportedIterableToArray(o, minLen) {
              if (!o)
                return;
              if (typeof o === "string")
                return squarifier_arrayLikeToArray(o, minLen);
              var n = Object.prototype.toString.call(o).slice(8, -1);
              if (n === "Object" && o.constructor)
                n = o.constructor.name;
              if (n === "Map" || n === "Set")
                return Array.from(o);
              if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                return squarifier_arrayLikeToArray(o, minLen);
            }
            function squarifier_iterableToArray(iter) {
              if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
                return Array.from(iter);
            }
            function squarifier_arrayWithoutHoles(arr) {
              if (Array.isArray(arr))
                return squarifier_arrayLikeToArray(arr);
            }
            function squarifier_arrayLikeToArray(arr, len) {
              if (len == null || len > arr.length)
                len = arr.length;
              for (var i = 0, arr2 = new Array(len); i < len; i++) {
                arr2[i] = arr[i];
              }
              return arr2;
            }
            function calculateScale(values, width, height) {
              return width * height / calculator_sum(values);
            }
            function isVerticalStack(_ref) {
              var height = _ref.height, width = _ref.width;
              return height < width;
            }
            function selectBaseSize(baseBound) {
              return isVerticalStack(baseBound) ? baseBound.height : baseBound.width;
            }
            function makeBaseData(seriesItems, baseBound) {
              var width = baseBound.width, height = baseBound.height;
              var scale2 = calculateScale(pluck(seriesItems, "data"), width, height);
              return seriesItems.map(function(seriesItem) {
                return {
                  id: seriesItem.id,
                  weight: seriesItem.data * scale2
                };
              }).sort(function(a, b) {
                return b.weight - a.weight;
              });
            }
            function worst(total, min, max2, baseSize) {
              var sumSquare = total * total;
              var sizeSquare = baseSize * baseSize;
              return Math.max(sizeSquare * max2 / sumSquare, sumSquare / (sizeSquare * min));
            }
            function changedStackDirection(total, weights, baseSize, newWeight) {
              var minWeight = Math.min.apply(Math, squarifier_toConsumableArray(weights));
              var maxWeight = Math.max.apply(Math, squarifier_toConsumableArray(weights));
              var beforeWorst = worst(total, minWeight, maxWeight, baseSize);
              var newWorst = worst(total + newWeight, Math.min(minWeight, newWeight), Math.max(maxWeight, newWeight), baseSize);
              return newWorst >= beforeWorst;
            }
            function calculateFixedSize(baseSize, total, rows) {
              if (!total) {
                var weights = pluck(rows, "weight");
                total = calculator_sum(weights);
              }
              return total / baseSize;
            }
            function addBounds(startPosition, rows, fixedSize, callback) {
              rows.reduce(function(storedPosition, rowDatum) {
                var dynamicSize = rowDatum.weight / fixedSize;
                callback(dynamicSize, storedPosition, rowDatum.id);
                return storedPosition + dynamicSize;
              }, startPosition);
            }
            function addBound(boundMap, id, rect2) {
              boundMap[id] = rect2;
            }
            function addBoundsForVerticalStack(boundMap, rows, baseBound, baseSize, total) {
              var fixedWidth = calculateFixedSize(baseSize, total, rows);
              addBounds(baseBound.y, rows, fixedWidth, function(dynamicHeight, storedTop, id) {
                addBound(boundMap, id, {
                  x: baseBound.x,
                  y: storedTop,
                  width: fixedWidth,
                  height: dynamicHeight
                });
              });
              baseBound.x += fixedWidth;
              baseBound.width -= fixedWidth;
            }
            function addBoundsForHorizontalStack(boundMap, rows, baseBound, baseSize, total) {
              var fixedHeight = calculateFixedSize(baseSize, total, rows);
              addBounds(baseBound.x, rows, fixedHeight, function(dynamicWidth, storedLeft, id) {
                addBound(boundMap, id, {
                  x: storedLeft,
                  y: baseBound.y,
                  width: dynamicWidth,
                  height: fixedHeight
                });
              });
              baseBound.y += fixedHeight;
              baseBound.height -= fixedHeight;
            }
            function getAddingBoundsFunction(baseBound) {
              if (isVerticalStack(baseBound)) {
                return addBoundsForVerticalStack;
              }
              return addBoundsForHorizontalStack;
            }
            function squarify(layout2, seriesItems) {
              var baseBound = layout2;
              var baseData = makeBaseData(seriesItems, baseBound);
              var row = [];
              var baseSize, addBoundsFunc;
              var boundMap = {};
              baseData.forEach(function(datum) {
                var weights = pluck(row, "weight");
                var totalWeight = calculator_sum(weights);
                if (row.length && changedStackDirection(totalWeight, weights, baseSize, datum.weight)) {
                  addBoundsFunc(boundMap, row, baseBound, baseSize, totalWeight);
                  row = [];
                }
                if (!row.length) {
                  baseSize = selectBaseSize(baseBound);
                  addBoundsFunc = getAddingBoundsFunction(baseBound);
                }
                row.push(datum);
              });
              if (row.length) {
                addBoundsFunc(boundMap, row, baseBound, baseSize);
              }
              return boundMap;
            }
            ;
            function treemapSeries_typeof(obj) {
              "@babel/helpers - typeof";
              if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                treemapSeries_typeof = function _typeof2(obj2) {
                  return typeof obj2;
                };
              } else {
                treemapSeries_typeof = function _typeof2(obj2) {
                  return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                };
              }
              return treemapSeries_typeof(obj);
            }
            function treemapSeries_ownKeys(object, enumerableOnly) {
              var keys = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object);
                if (enumerableOnly) {
                  symbols = symbols.filter(function(sym) {
                    return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                  });
                }
                keys.push.apply(keys, symbols);
              }
              return keys;
            }
            function treemapSeries_objectSpread(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i] != null ? arguments[i] : {};
                if (i % 2) {
                  treemapSeries_ownKeys(Object(source), true).forEach(function(key) {
                    treemapSeries_defineProperty(target, key, source[key]);
                  });
                } else if (Object.getOwnPropertyDescriptors) {
                  Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                } else {
                  treemapSeries_ownKeys(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  });
                }
              }
              return target;
            }
            function treemapSeries_toConsumableArray(arr) {
              return treemapSeries_arrayWithoutHoles(arr) || treemapSeries_iterableToArray(arr) || treemapSeries_unsupportedIterableToArray(arr) || treemapSeries_nonIterableSpread();
            }
            function treemapSeries_nonIterableSpread() {
              throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            function treemapSeries_unsupportedIterableToArray(o, minLen) {
              if (!o)
                return;
              if (typeof o === "string")
                return treemapSeries_arrayLikeToArray(o, minLen);
              var n = Object.prototype.toString.call(o).slice(8, -1);
              if (n === "Object" && o.constructor)
                n = o.constructor.name;
              if (n === "Map" || n === "Set")
                return Array.from(o);
              if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                return treemapSeries_arrayLikeToArray(o, minLen);
            }
            function treemapSeries_iterableToArray(iter) {
              if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
                return Array.from(iter);
            }
            function treemapSeries_arrayWithoutHoles(arr) {
              if (Array.isArray(arr))
                return treemapSeries_arrayLikeToArray(arr);
            }
            function treemapSeries_arrayLikeToArray(arr, len) {
              if (len == null || len > arr.length)
                len = arr.length;
              for (var i = 0, arr2 = new Array(len); i < len; i++) {
                arr2[i] = arr[i];
              }
              return arr2;
            }
            function treemapSeries_classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function treemapSeries_defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            function treemapSeries_createClass(Constructor, protoProps, staticProps) {
              if (protoProps)
                treemapSeries_defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                treemapSeries_defineProperties(Constructor, staticProps);
              return Constructor;
            }
            function treemapSeries_inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function");
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
              if (superClass)
                treemapSeries_setPrototypeOf(subClass, superClass);
            }
            function treemapSeries_setPrototypeOf(o, p) {
              treemapSeries_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
                o2.__proto__ = p2;
                return o2;
              };
              return treemapSeries_setPrototypeOf(o, p);
            }
            function treemapSeries_createSuper(Derived) {
              var hasNativeReflectConstruct = treemapSeries_isNativeReflectConstruct();
              return function _createSuperInternal() {
                var Super = treemapSeries_getPrototypeOf(Derived), result;
                if (hasNativeReflectConstruct) {
                  var NewTarget = treemapSeries_getPrototypeOf(this).constructor;
                  result = Reflect.construct(Super, arguments, NewTarget);
                } else {
                  result = Super.apply(this, arguments);
                }
                return treemapSeries_possibleConstructorReturn(this, result);
              };
            }
            function treemapSeries_possibleConstructorReturn(self2, call) {
              if (call && (treemapSeries_typeof(call) === "object" || typeof call === "function")) {
                return call;
              }
              return treemapSeries_assertThisInitialized(self2);
            }
            function treemapSeries_assertThisInitialized(self2) {
              if (self2 === void 0) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return self2;
            }
            function treemapSeries_isNativeReflectConstruct() {
              if (typeof Reflect === "undefined" || !Reflect.construct)
                return false;
              if (Reflect.construct.sham)
                return false;
              if (typeof Proxy === "function")
                return true;
              try {
                Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                }));
                return true;
              } catch (e) {
                return false;
              }
            }
            function treemapSeries_getPrototypeOf(o) {
              treemapSeries_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
                return o2.__proto__ || Object.getPrototypeOf(o2);
              };
              return treemapSeries_getPrototypeOf(o);
            }
            function treemapSeries_defineProperty(obj, key, value) {
              if (key in obj) {
                Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
              } else {
                obj[key] = value;
              }
              return obj;
            }
            var TreemapSeries = function(_Component) {
              treemapSeries_inherits(TreemapSeries2, _Component);
              var _super = treemapSeries_createSuper(TreemapSeries2);
              function TreemapSeries2() {
                var _this;
                treemapSeries_classCallCheck(this, TreemapSeries2);
                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }
                _this = _super.call.apply(_super, [this].concat(args));
                treemapSeries_defineProperty(treemapSeries_assertThisInitialized(_this), "models", {
                  series: [],
                  layer: []
                });
                treemapSeries_defineProperty(treemapSeries_assertThisInitialized(_this), "responders", void 0);
                treemapSeries_defineProperty(treemapSeries_assertThisInitialized(_this), "theme", void 0);
                treemapSeries_defineProperty(treemapSeries_assertThisInitialized(_this), "activatedResponders", []);
                treemapSeries_defineProperty(treemapSeries_assertThisInitialized(_this), "zoomable", void 0);
                treemapSeries_defineProperty(treemapSeries_assertThisInitialized(_this), "onMouseoutComponent", function() {
                  _this.emitMouseEvent([]);
                });
                treemapSeries_defineProperty(treemapSeries_assertThisInitialized(_this), "selectSeries", function(_ref) {
                  var seriesIndex = _ref.seriesIndex;
                  if (!isNumber(seriesIndex)) {
                    return;
                  }
                  var model = _this.responders.find(function(_ref2) {
                    var indexes = _ref2.indexes;
                    return last(indexes) === seriesIndex;
                  });
                  if (!model) {
                    throw new Error(message.SELECT_SERIES_API_INDEX_ERROR);
                  }
                  var models = _this.getRespondersWithTheme([model], "select");
                  _this.eventBus.emit("renderSelectedSeries", {
                    models,
                    name: _this.name
                  });
                  _this.eventBus.emit("needDraw");
                });
                treemapSeries_defineProperty(treemapSeries_assertThisInitialized(_this), "showTooltip", function(_ref3) {
                  var seriesIndex = _ref3.seriesIndex;
                  if (!isNumber(seriesIndex)) {
                    return;
                  }
                  var model = _this.responders.find(function(_ref4) {
                    var indexes = _ref4.indexes;
                    return last(indexes) === seriesIndex;
                  });
                  if (model) {
                    _this.emitMouseEvent([model]);
                  }
                });
                return _this;
              }
              treemapSeries_createClass(TreemapSeries2, [{
                key: "initialize",
                value: function initialize() {
                  this.type = "series";
                  this.name = "treemap";
                  this.eventBus.on("selectSeries", this.selectSeries);
                  this.eventBus.on("showTooltip", this.showTooltip);
                  this.eventBus.on("hideTooltip", this.onMouseoutComponent);
                }
              }, {
                key: "getAllChildSeries",
                value: function getAllChildSeries(series, parentId) {
                  var _this2 = this;
                  var allChildSeries = [];
                  series.forEach(function(data) {
                    if (data.parentId === parentId) {
                      allChildSeries.push(data);
                      if (data.hasChild) {
                        var res = _this2.getAllChildSeries(series, data.id);
                        allChildSeries.push.apply(allChildSeries, treemapSeries_toConsumableArray(res));
                      }
                    }
                  });
                  return allChildSeries;
                }
              }, {
                key: "render",
                value: function render(chartState) {
                  var _options$series$zooma, _options$series;
                  var layout2 = chartState.layout, treemapSeries = chartState.treemapSeries, colorValueScale2 = chartState.colorValueScale, options2 = chartState.options, theme2 = chartState.theme, treemapZoomId = chartState.treemapZoomId;
                  if (!treemapSeries) {
                    throw new Error(message.noDataError(this.name));
                  }
                  var currentTreemapZoomId = treemapZoomId.cur;
                  var series = this.getAllChildSeries(treemapSeries, currentTreemapZoomId);
                  this.theme = theme2.series.treemap;
                  this.rect = layout2.plot;
                  this.selectable = this.getSelectableOption(options2);
                  this.models = this.renderTreemapSeries(series, options2, colorValueScale2, currentTreemapZoomId);
                  this.zoomable = (_options$series$zooma = (_options$series = options2.series) === null || _options$series === void 0 ? void 0 : _options$series.zoomable) !== null && _options$series$zooma !== void 0 ? _options$series$zooma : false;
                  if (getDataLabelsOptions(options2, this.name).visible) {
                    var _options$series$dataL, _options$series2, _options$series2$data;
                    var useTreemapLeaf = (_options$series$dataL = (_options$series2 = options2.series) === null || _options$series2 === void 0 ? void 0 : (_options$series2$data = _options$series2.dataLabels) === null || _options$series2$data === void 0 ? void 0 : _options$series2$data.useTreemapLeaf) !== null && _options$series$dataL !== void 0 ? _options$series$dataL : false;
                    var dataLabelModel = this.makeDataLabel(useTreemapLeaf, currentTreemapZoomId);
                    this.renderDataLabels(dataLabelModel);
                  }
                  this.responders = this.makeTreemapSeriesResponder(currentTreemapZoomId);
                }
              }, {
                key: "makeTreemapSeriesResponder",
                value: function makeTreemapSeriesResponder(treemapCurrentDepthParentId) {
                  var tooltipData = this.makeTooltipData();
                  var series = this.models.series;
                  if (this.zoomable) {
                    series = series.filter(function(_ref5) {
                      var parentId = _ref5.parentId;
                      return parentId === treemapCurrentDepthParentId;
                    });
                  }
                  return series.map(function(m, idx) {
                    return treemapSeries_objectSpread(treemapSeries_objectSpread({}, m), {}, {
                      data: tooltipData[idx],
                      thickness: boxDefault.HOVER_THICKNESS,
                      style: ["shadow"]
                    });
                  });
                }
              }, {
                key: "makeTooltipData",
                value: function makeTooltipData() {
                  return this.models.series.map(function(_ref6) {
                    var label2 = _ref6.label, data = _ref6.data, color = _ref6.color;
                    return {
                      label: label2,
                      color,
                      value: data
                    };
                  });
                }
              }, {
                key: "makeBoundMap",
                value: function makeBoundMap(series, parentId, layout2) {
                  var _this3 = this;
                  var boundMap = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
                  var seriesItems = series.filter(function(item) {
                    return item.parentId === parentId;
                  });
                  boundMap = treemapSeries_objectSpread(treemapSeries_objectSpread({}, boundMap), squarify(treemapSeries_objectSpread({}, layout2), seriesItems));
                  seriesItems.forEach(function(seriesItem) {
                    boundMap = _this3.makeBoundMap(series, seriesItem.id, boundMap[seriesItem.id], boundMap);
                  });
                  return boundMap;
                }
              }, {
                key: "makeDataLabel",
                value: function makeDataLabel(useTreemapLeaf, treemapCurrentDepthParentId) {
                  var series = useTreemapLeaf ? this.models.series.filter(function(_ref7) {
                    var hasChild = _ref7.hasChild;
                    return !hasChild;
                  }) : this.models.series.filter(function(_ref8) {
                    var parentId = _ref8.parentId;
                    return parentId === treemapCurrentDepthParentId;
                  });
                  var dataLabelTheme = this.theme.dataLabels;
                  return series.map(function(m) {
                    return treemapSeries_objectSpread(treemapSeries_objectSpread({}, m), {}, {
                      type: "treemapSeriesName",
                      value: m.label,
                      direction: "left",
                      plot: {
                        x: 0,
                        y: 0,
                        size: 0
                      },
                      theme: treemapSeries_objectSpread(treemapSeries_objectSpread({}, dataLabelTheme), {}, {
                        color: dataLabelTheme.useSeriesColor ? m.color : dataLabelTheme.color
                      })
                    });
                  });
                }
              }, {
                key: "getColor",
                value: function getColor(treemapSeries, colors) {
                  var indexes = treemapSeries.indexes;
                  var colorIdx = first(indexes);
                  return colors[colorIdx];
                }
              }, {
                key: "getOpacity",
                value: function getOpacity(treemapSeries) {
                  var indexes = treemapSeries.indexes, depth = treemapSeries.depth;
                  var idx = last(indexes);
                  return indexes.length === 1 ? 0 : Number((0.1 * depth + 0.05 * idx).toFixed(2));
                }
              }, {
                key: "renderTreemapSeries",
                value: function renderTreemapSeries(seriesData2, options2, colorValueScale2, treemapCurrentDepthParentId) {
                  var _options$series$useCo, _options$series3, _this4 = this, _options$series4;
                  var layer = [];
                  var boundMap = this.makeBoundMap(seriesData2, treemapCurrentDepthParentId, treemapSeries_objectSpread(treemapSeries_objectSpread({}, this.rect), {}, {
                    x: 0,
                    y: 0
                  }));
                  var _this$theme = this.theme, colors = _this$theme.colors, startColor = _this$theme.startColor, endColor = _this$theme.endColor, borderWidth = _this$theme.borderWidth, borderColor = _this$theme.borderColor;
                  var startRGB, distances;
                  var useColorValue = (_options$series$useCo = (_options$series3 = options2.series) === null || _options$series3 === void 0 ? void 0 : _options$series3.useColorValue) !== null && _options$series$useCo !== void 0 ? _options$series$useCo : false;
                  if (useColorValue && startColor && endColor) {
                    startRGB = hexToRGB(startColor);
                    distances = makeDistances(startRGB, hexToRGB(endColor));
                  }
                  var series = Object.keys(boundMap).map(function(id) {
                    var treemapSeries = seriesData2.find(function(item) {
                      return item.id === id;
                    });
                    var colorRatio;
                    if (useColorValue) {
                      colorRatio = getColorRatio(colorValueScale2.limit, treemapSeries.colorValue);
                    }
                    return treemapSeries_objectSpread(treemapSeries_objectSpread(treemapSeries_objectSpread({}, treemapSeries), boundMap[id]), {}, {
                      type: "rect",
                      colorRatio,
                      color: useColorValue ? getSpectrumColor(colorRatio, distances, startRGB) : _this4.getColor(treemapSeries, colors),
                      opacity: useColorValue ? 0 : _this4.getOpacity(treemapSeries),
                      thickness: borderWidth,
                      borderColor
                    });
                  });
                  if (!((_options$series4 = options2.series) !== null && _options$series4 !== void 0 && _options$series4.useColorValue)) {
                    layer = series.map(function(m) {
                      return treemapSeries_objectSpread(treemapSeries_objectSpread({}, m), {}, {
                        color: getRGBA("#000000", m.opacity)
                      });
                    });
                  }
                  return {
                    series,
                    layer
                  };
                }
              }, {
                key: "getRespondersWithTheme",
                value: function getRespondersWithTheme(responders, type) {
                  var _this5 = this;
                  return responders.map(function(responder) {
                    return deepMergedCopy(responder, treemapSeries_objectSpread(treemapSeries_objectSpread({}, _this5.theme[type]), {}, {
                      style: ["shadow"]
                    }));
                  });
                }
              }, {
                key: "onClick",
                value: function onClick(_ref9) {
                  var responders = _ref9.responders;
                  if (responders.length) {
                    if (this.zoomable) {
                      var _responders$ = responders[0], id = _responders$.id, hasChild = _responders$.hasChild;
                      if (hasChild) {
                        this.emitMouseEvent([]);
                        this.store.dispatch("setTreemapZoomId", id);
                        this.eventBus.emit("resetSelectedSeries");
                      } else if (this.selectable) {
                        this.eventBus.emit("renderSelectedSeries", {
                          models: this.getRespondersWithTheme(responders, "select"),
                          name: this.name
                        });
                      }
                    } else if (this.selectable) {
                      var deepestNode = getDeepestNode(responders);
                      this.eventBus.emit("renderSelectedSeries", {
                        models: this.getRespondersWithTheme(deepestNode, "select"),
                        name: this.name
                      });
                    }
                  }
                }
              }, {
                key: "onMousemove",
                value: function onMousemove(_ref10) {
                  var responders = _ref10.responders;
                  var deepestNode = getDeepestNode(responders);
                  this.activatedResponders = deepestNode;
                  this.emitMouseEvent(deepestNode);
                }
              }, {
                key: "emitMouseEvent",
                value: function emitMouseEvent(responders) {
                  this.eventBus.emit("renderHoveredSeries", {
                    models: this.getRespondersWithTheme(responders, "hover"),
                    name: this.name
                  });
                  this.eventBus.emit("seriesPointHovered", {
                    models: responders,
                    name: this.name
                  });
                  this.eventBus.emit("renderSpectrumTooltip", responders);
                  this.eventBus.emit("needDraw");
                }
              }]);
              return TreemapSeries2;
            }(Component);
            ;
            function backButton_typeof(obj) {
              "@babel/helpers - typeof";
              if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                backButton_typeof = function _typeof2(obj2) {
                  return typeof obj2;
                };
              } else {
                backButton_typeof = function _typeof2(obj2) {
                  return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                };
              }
              return backButton_typeof(obj);
            }
            function backButton_classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function backButton_defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            function backButton_createClass(Constructor, protoProps, staticProps) {
              if (protoProps)
                backButton_defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                backButton_defineProperties(Constructor, staticProps);
              return Constructor;
            }
            function backButton_inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function");
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
              if (superClass)
                backButton_setPrototypeOf(subClass, superClass);
            }
            function backButton_setPrototypeOf(o, p) {
              backButton_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
                o2.__proto__ = p2;
                return o2;
              };
              return backButton_setPrototypeOf(o, p);
            }
            function backButton_createSuper(Derived) {
              var hasNativeReflectConstruct = backButton_isNativeReflectConstruct();
              return function _createSuperInternal() {
                var Super = backButton_getPrototypeOf(Derived), result;
                if (hasNativeReflectConstruct) {
                  var NewTarget = backButton_getPrototypeOf(this).constructor;
                  result = Reflect.construct(Super, arguments, NewTarget);
                } else {
                  result = Super.apply(this, arguments);
                }
                return backButton_possibleConstructorReturn(this, result);
              };
            }
            function backButton_possibleConstructorReturn(self2, call) {
              if (call && (backButton_typeof(call) === "object" || typeof call === "function")) {
                return call;
              }
              return backButton_assertThisInitialized(self2);
            }
            function backButton_assertThisInitialized(self2) {
              if (self2 === void 0) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return self2;
            }
            function backButton_isNativeReflectConstruct() {
              if (typeof Reflect === "undefined" || !Reflect.construct)
                return false;
              if (Reflect.construct.sham)
                return false;
              if (typeof Proxy === "function")
                return true;
              try {
                Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                }));
                return true;
              } catch (e) {
                return false;
              }
            }
            function backButton_getPrototypeOf(o) {
              backButton_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
                return o2.__proto__ || Object.getPrototypeOf(o2);
              };
              return backButton_getPrototypeOf(o);
            }
            function backButton_defineProperty(obj, key, value) {
              if (key in obj) {
                Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
              } else {
                obj[key] = value;
              }
              return obj;
            }
            var BackButton = function(_Component) {
              backButton_inherits(BackButton2, _Component);
              var _super = backButton_createSuper(BackButton2);
              function BackButton2() {
                var _this;
                backButton_classCallCheck(this, BackButton2);
                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }
                _this = _super.call.apply(_super, [this].concat(args));
                backButton_defineProperty(backButton_assertThisInitialized(_this), "responders", void 0);
                backButton_defineProperty(backButton_assertThisInitialized(_this), "models", void 0);
                return _this;
              }
              backButton_createClass(BackButton2, [{
                key: "initialize",
                value: function initialize() {
                  this.type = "backButton";
                  this.name = "backButton";
                }
              }, {
                key: "onClick",
                value: function onClick(_ref) {
                  var responders = _ref.responders;
                  if (responders.length) {
                    this.store.dispatch("zoomBack");
                    this.eventBus.emit("resetSelectedSeries");
                  }
                }
              }, {
                key: "render",
                value: function render(_ref2, computed2) {
                  var options2 = _ref2.options, layout2 = _ref2.layout;
                  if (!isUsingResetButton(options2)) {
                    return;
                  }
                  this.rect = layout2.resetButton;
                  this.isShow = computed2.isTreemapSeriesZooming;
                  this.models = this.isShow ? [{
                    type: "backButton",
                    x: 0,
                    y: 0
                  }] : [];
                  this.responders = this.isShow ? [{
                    type: "rect",
                    x: 0,
                    y: 0,
                    width: BUTTON_RECT_SIZE,
                    height: BUTTON_RECT_SIZE
                  }] : [];
                }
              }]);
              return BackButton2;
            }(Component);
            ;
            function treemapChart_typeof(obj) {
              "@babel/helpers - typeof";
              if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                treemapChart_typeof = function _typeof2(obj2) {
                  return typeof obj2;
                };
              } else {
                treemapChart_typeof = function _typeof2(obj2) {
                  return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                };
              }
              return treemapChart_typeof(obj);
            }
            function treemapChart_ownKeys(object, enumerableOnly) {
              var keys = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object);
                if (enumerableOnly) {
                  symbols = symbols.filter(function(sym) {
                    return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                  });
                }
                keys.push.apply(keys, symbols);
              }
              return keys;
            }
            function treemapChart_objectSpread(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i] != null ? arguments[i] : {};
                if (i % 2) {
                  treemapChart_ownKeys(Object(source), true).forEach(function(key) {
                    treemapChart_defineProperty(target, key, source[key]);
                  });
                } else if (Object.getOwnPropertyDescriptors) {
                  Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                } else {
                  treemapChart_ownKeys(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  });
                }
              }
              return target;
            }
            function treemapChart_defineProperty(obj, key, value) {
              if (key in obj) {
                Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
              } else {
                obj[key] = value;
              }
              return obj;
            }
            function treemapChart_classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function treemapChart_defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            function treemapChart_createClass(Constructor, protoProps, staticProps) {
              if (protoProps)
                treemapChart_defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                treemapChart_defineProperties(Constructor, staticProps);
              return Constructor;
            }
            function treemapChart_get(target, property, receiver) {
              if (typeof Reflect !== "undefined" && Reflect.get) {
                treemapChart_get = Reflect.get;
              } else {
                treemapChart_get = function _get2(target2, property2, receiver2) {
                  var base = treemapChart_superPropBase(target2, property2);
                  if (!base)
                    return;
                  var desc = Object.getOwnPropertyDescriptor(base, property2);
                  if (desc.get) {
                    return desc.get.call(receiver2);
                  }
                  return desc.value;
                };
              }
              return treemapChart_get(target, property, receiver || target);
            }
            function treemapChart_superPropBase(object, property) {
              while (!Object.prototype.hasOwnProperty.call(object, property)) {
                object = treemapChart_getPrototypeOf(object);
                if (object === null)
                  break;
              }
              return object;
            }
            function treemapChart_inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function");
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
              if (superClass)
                treemapChart_setPrototypeOf(subClass, superClass);
            }
            function treemapChart_setPrototypeOf(o, p) {
              treemapChart_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
                o2.__proto__ = p2;
                return o2;
              };
              return treemapChart_setPrototypeOf(o, p);
            }
            function treemapChart_createSuper(Derived) {
              var hasNativeReflectConstruct = treemapChart_isNativeReflectConstruct();
              return function _createSuperInternal() {
                var Super = treemapChart_getPrototypeOf(Derived), result;
                if (hasNativeReflectConstruct) {
                  var NewTarget = treemapChart_getPrototypeOf(this).constructor;
                  result = Reflect.construct(Super, arguments, NewTarget);
                } else {
                  result = Super.apply(this, arguments);
                }
                return treemapChart_possibleConstructorReturn(this, result);
              };
            }
            function treemapChart_possibleConstructorReturn(self2, call) {
              if (call && (treemapChart_typeof(call) === "object" || typeof call === "function")) {
                return call;
              }
              return treemapChart_assertThisInitialized(self2);
            }
            function treemapChart_assertThisInitialized(self2) {
              if (self2 === void 0) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return self2;
            }
            function treemapChart_isNativeReflectConstruct() {
              if (typeof Reflect === "undefined" || !Reflect.construct)
                return false;
              if (Reflect.construct.sham)
                return false;
              if (typeof Proxy === "function")
                return true;
              try {
                Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                }));
                return true;
              } catch (e) {
                return false;
              }
            }
            function treemapChart_getPrototypeOf(o) {
              treemapChart_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
                return o2.__proto__ || Object.getPrototypeOf(o2);
              };
              return treemapChart_getPrototypeOf(o);
            }
            var TreemapChart = function(_Chart) {
              treemapChart_inherits(TreemapChart2, _Chart);
              var _super = treemapChart_createSuper(TreemapChart2);
              function TreemapChart2(props) {
                treemapChart_classCallCheck(this, TreemapChart2);
                return _super.call(this, {
                  el: props.el,
                  options: props.options,
                  series: {
                    treemap: props.data.series
                  },
                  modules: [store_treemapSeriesData, store_colorValueScale]
                });
              }
              treemapChart_createClass(TreemapChart2, [{
                key: "initialize",
                value: function initialize() {
                  treemapChart_get(treemapChart_getPrototypeOf(TreemapChart2.prototype), "initialize", this).call(this);
                  this.componentManager.add(Background);
                  this.componentManager.add(Title);
                  this.componentManager.add(SpectrumLegend);
                  this.componentManager.add(TreemapSeries);
                  this.componentManager.add(ExportMenu, {
                    chartEl: this.el
                  });
                  this.componentManager.add(HoveredSeries);
                  this.componentManager.add(SelectedSeries);
                  this.componentManager.add(DataLabels);
                  this.componentManager.add(Tooltip, {
                    chartEl: this.el
                  });
                  this.componentManager.add(BackButton);
                  this.componentManager.add(NoDataText);
                  this.painter.addGroups([basic_namespaceObject, legend_namespaceObject, label_namespaceObject, brushes_exportMenu_namespaceObject, dataLabel_namespaceObject, spectrumLegend_namespaceObject, brushes_resetButton_namespaceObject]);
                }
                /**
                 * Add series.
                 * @param {Object} data - Data to be added.
                 *   @param {string} data.name - Series name.
                 *   @param {Array<Object>} data.data - Array of data to be added.
                 * @api
                 * @example
                 * chart.addSeries({
                 *   label: 'Documents',
                 *   children: [
                 *     {label: 'A', data: 20},
                 *     {label: 'B', data: 40},
                 *   ],
                 * });
                 */
              }, {
                key: "addSeries",
                value: function addSeries(data, dataInfo) {
                  this.resetSeries();
                  this.store.dispatch("addTreemapSeries", treemapChart_objectSpread({
                    data
                  }, dataInfo));
                }
                /**
                 * Convert the chart data to new data.
                 * @param {Object} data - Data to be set.
                 * @api
                 * @example
                 * chart.setData(
                 *   series: [
                 *     {
                 *       label: 'Documents',
                 *       children: [
                 *         {label: 'A', data: 20},
                 *         {label: 'B', data: 40},
                 *       ],
                 *     },
                 *     {
                 *       label: 'Documents',
                 *       data: 30,
                 *     }
                 *   ]
                 * );
                 */
              }, {
                key: "setData",
                value: function setData(data) {
                  this.resetSeries();
                  this.store.dispatch("setData", {
                    series: {
                      treemap: data.series
                    }
                  });
                }
                /**
                 * Hide series data label.
                 * @api
                 * @example
                 * chart.hideSeriesDataLabel();
                 */
              }, {
                key: "hideSeriesDataLabel",
                value: function hideSeriesDataLabel() {
                  this.store.dispatch("updateOptions", {
                    options: {
                      series: {
                        dataLabels: {
                          visible: false
                        }
                      }
                    }
                  });
                }
                /**
                 * Show series data label.
                 * @api
                 * @example
                 * chart.showSeriesDataLabel();
                 */
              }, {
                key: "showSeriesDataLabel",
                value: function showSeriesDataLabel() {
                  this.store.dispatch("updateOptions", {
                    options: {
                      series: {
                        dataLabels: {
                          visible: true
                        }
                      }
                    }
                  });
                }
                /**
                 * Convert the chart options to new options.
                 * @param {Object} options - Chart options
                 * @api
                 * @example
                 * chart.setOptions({
                 *   chart: {
                 *     width: 500,
                 *     height: 'auto',
                 *     title: 'Energy Usage',
                 *   },
                 *   series: {
                 *     selectable: true,
                 *   },
                 *   tooltip: {
                 *     formatter: (value) => `${value}kWh`,
                 *   },
                 * });
                 */
              }, {
                key: "setOptions",
                value: function setOptions(options2) {
                  this.resetSeries();
                  this.dispatchOptionsEvent("initOptions", options2);
                }
                /**
                 * Update chart options.
                 * @param {Object} options - Chart options
                 * @api
                 * @example
                 * chart.updateOptions({
                 *   chart: {
                 *     height: 'auto',
                 *     title: 'Energy Usage',
                 *   },
                 *   tooltip: {
                 *     formatter: (value) => `${value}kWh`,
                 *   },
                 * });
                 */
              }, {
                key: "updateOptions",
                value: function updateOptions(options2) {
                  this.resetSeries();
                  this.dispatchOptionsEvent("updateOptions", options2);
                }
                /**
                 * Show tooltip.
                 * @param {Object} seriesInfo - Information of the series for the tooltip to be displayed.
                 *      @param {number} seriesInfo.seriesIndex - Index of series.
                 * @api
                 * @example
                 * chart.showTooltip({seriesIndex: 1});
                 */
              }, {
                key: "showTooltip",
                value: function showTooltip(seriesInfo) {
                  this.eventBus.emit("showTooltip", treemapChart_objectSpread(treemapChart_objectSpread({}, seriesInfo), {}, {
                    state: this.store.state
                  }));
                }
                /**
                 * Hide tooltip.
                 * @api
                 * @example
                 * chart.hideTooltip();
                 */
              }, {
                key: "hideTooltip",
                value: function hideTooltip() {
                  this.eventBus.emit("hideTooltip");
                }
              }]);
              return TreemapChart2;
            }(Chart);
            ;
            function boxPlotSeries_typeof(obj) {
              "@babel/helpers - typeof";
              if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                boxPlotSeries_typeof = function _typeof2(obj2) {
                  return typeof obj2;
                };
              } else {
                boxPlotSeries_typeof = function _typeof2(obj2) {
                  return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                };
              }
              return boxPlotSeries_typeof(obj);
            }
            function boxPlotSeries_toConsumableArray(arr) {
              return boxPlotSeries_arrayWithoutHoles(arr) || boxPlotSeries_iterableToArray(arr) || boxPlotSeries_unsupportedIterableToArray(arr) || boxPlotSeries_nonIterableSpread();
            }
            function boxPlotSeries_nonIterableSpread() {
              throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            function boxPlotSeries_iterableToArray(iter) {
              if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
                return Array.from(iter);
            }
            function boxPlotSeries_arrayWithoutHoles(arr) {
              if (Array.isArray(arr))
                return boxPlotSeries_arrayLikeToArray(arr);
            }
            function boxPlotSeries_slicedToArray(arr, i) {
              return boxPlotSeries_arrayWithHoles(arr) || boxPlotSeries_iterableToArrayLimit(arr, i) || boxPlotSeries_unsupportedIterableToArray(arr, i) || boxPlotSeries_nonIterableRest();
            }
            function boxPlotSeries_nonIterableRest() {
              throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            function boxPlotSeries_unsupportedIterableToArray(o, minLen) {
              if (!o)
                return;
              if (typeof o === "string")
                return boxPlotSeries_arrayLikeToArray(o, minLen);
              var n = Object.prototype.toString.call(o).slice(8, -1);
              if (n === "Object" && o.constructor)
                n = o.constructor.name;
              if (n === "Map" || n === "Set")
                return Array.from(o);
              if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                return boxPlotSeries_arrayLikeToArray(o, minLen);
            }
            function boxPlotSeries_arrayLikeToArray(arr, len) {
              if (len == null || len > arr.length)
                len = arr.length;
              for (var i = 0, arr2 = new Array(len); i < len; i++) {
                arr2[i] = arr[i];
              }
              return arr2;
            }
            function boxPlotSeries_iterableToArrayLimit(arr, i) {
              var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]);
              if (_i == null)
                return;
              var _arr = [];
              var _n = true;
              var _d = false;
              var _s, _e;
              try {
                for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
                  _arr.push(_s.value);
                  if (i && _arr.length === i)
                    break;
                }
              } catch (err) {
                _d = true;
                _e = err;
              } finally {
                try {
                  if (!_n && _i["return"] != null)
                    _i["return"]();
                } finally {
                  if (_d)
                    throw _e;
                }
              }
              return _arr;
            }
            function boxPlotSeries_arrayWithHoles(arr) {
              if (Array.isArray(arr))
                return arr;
            }
            function boxPlotSeries_ownKeys(object, enumerableOnly) {
              var keys = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object);
                if (enumerableOnly) {
                  symbols = symbols.filter(function(sym) {
                    return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                  });
                }
                keys.push.apply(keys, symbols);
              }
              return keys;
            }
            function boxPlotSeries_objectSpread(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i] != null ? arguments[i] : {};
                if (i % 2) {
                  boxPlotSeries_ownKeys(Object(source), true).forEach(function(key) {
                    boxPlotSeries_defineProperty(target, key, source[key]);
                  });
                } else if (Object.getOwnPropertyDescriptors) {
                  Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                } else {
                  boxPlotSeries_ownKeys(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  });
                }
              }
              return target;
            }
            function boxPlotSeries_classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function boxPlotSeries_defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            function boxPlotSeries_createClass(Constructor, protoProps, staticProps) {
              if (protoProps)
                boxPlotSeries_defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                boxPlotSeries_defineProperties(Constructor, staticProps);
              return Constructor;
            }
            function boxPlotSeries_inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function");
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
              if (superClass)
                boxPlotSeries_setPrototypeOf(subClass, superClass);
            }
            function boxPlotSeries_setPrototypeOf(o, p) {
              boxPlotSeries_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
                o2.__proto__ = p2;
                return o2;
              };
              return boxPlotSeries_setPrototypeOf(o, p);
            }
            function boxPlotSeries_createSuper(Derived) {
              var hasNativeReflectConstruct = boxPlotSeries_isNativeReflectConstruct();
              return function _createSuperInternal() {
                var Super = boxPlotSeries_getPrototypeOf(Derived), result;
                if (hasNativeReflectConstruct) {
                  var NewTarget = boxPlotSeries_getPrototypeOf(this).constructor;
                  result = Reflect.construct(Super, arguments, NewTarget);
                } else {
                  result = Super.apply(this, arguments);
                }
                return boxPlotSeries_possibleConstructorReturn(this, result);
              };
            }
            function boxPlotSeries_possibleConstructorReturn(self2, call) {
              if (call && (boxPlotSeries_typeof(call) === "object" || typeof call === "function")) {
                return call;
              }
              return boxPlotSeries_assertThisInitialized(self2);
            }
            function boxPlotSeries_assertThisInitialized(self2) {
              if (self2 === void 0) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return self2;
            }
            function boxPlotSeries_isNativeReflectConstruct() {
              if (typeof Reflect === "undefined" || !Reflect.construct)
                return false;
              if (Reflect.construct.sham)
                return false;
              if (typeof Proxy === "function")
                return true;
              try {
                Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                }));
                return true;
              } catch (e) {
                return false;
              }
            }
            function boxPlotSeries_getPrototypeOf(o) {
              boxPlotSeries_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
                return o2.__proto__ || Object.getPrototypeOf(o2);
              };
              return boxPlotSeries_getPrototypeOf(o);
            }
            function boxPlotSeries_defineProperty(obj, key, value) {
              if (key in obj) {
                Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
              } else {
                obj[key] = value;
              }
              return obj;
            }
            var MIN_BAR_WIDTH = 5;
            function getPadding(tickDistance, barWidth, seriesLength) {
              return (tickDistance - barWidth * seriesLength) / (seriesLength + 1);
            }
            function getDefaultColor(defaultColor, color) {
              return color !== null && color !== void 0 ? color : defaultColor;
            }
            var BoxPlotSeries = function(_Component) {
              boxPlotSeries_inherits(BoxPlotSeries2, _Component);
              var _super = boxPlotSeries_createSuper(BoxPlotSeries2);
              function BoxPlotSeries2() {
                var _this;
                boxPlotSeries_classCallCheck(this, BoxPlotSeries2);
                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }
                _this = _super.call.apply(_super, [this].concat(args));
                boxPlotSeries_defineProperty(boxPlotSeries_assertThisInitialized(_this), "models", {
                  rect: [],
                  line: [],
                  circle: []
                });
                boxPlotSeries_defineProperty(boxPlotSeries_assertThisInitialized(_this), "drawModels", void 0);
                boxPlotSeries_defineProperty(boxPlotSeries_assertThisInitialized(_this), "responders", void 0);
                boxPlotSeries_defineProperty(boxPlotSeries_assertThisInitialized(_this), "activatedResponders", []);
                boxPlotSeries_defineProperty(boxPlotSeries_assertThisInitialized(_this), "eventDetectType", "point");
                boxPlotSeries_defineProperty(boxPlotSeries_assertThisInitialized(_this), "tooltipRectMap", void 0);
                boxPlotSeries_defineProperty(boxPlotSeries_assertThisInitialized(_this), "theme", void 0);
                boxPlotSeries_defineProperty(boxPlotSeries_assertThisInitialized(_this), "onMouseoutComponent", function() {
                  _this.eventBus.emit("seriesPointHovered", {
                    models: [],
                    name: _this.name
                  });
                  _this.eventBus.emit("renderHoveredSeries", {
                    models: [],
                    name: _this.name,
                    eventDetectType: _this.eventDetectType
                  });
                  _this.eventBus.emit("needDraw");
                });
                boxPlotSeries_defineProperty(boxPlotSeries_assertThisInitialized(_this), "selectSeries", function(_ref) {
                  var index = _ref.index, seriesIndex = _ref.seriesIndex, state = _ref.state;
                  if (!isNumber(index) || !isNumber(seriesIndex)) {
                    return;
                  }
                  var name = state.series.boxPlot[seriesIndex].name;
                  var models = _this.getRespondersWithTheme(_this.tooltipRectMap["".concat(name, "-").concat(index)], "select");
                  _this.eventBus.emit("renderSelectedSeries", {
                    models,
                    name: _this.name,
                    eventDetectType: _this.eventDetectType
                  });
                  _this.eventBus.emit("needDraw");
                });
                boxPlotSeries_defineProperty(boxPlotSeries_assertThisInitialized(_this), "showTooltip", function(_ref2) {
                  var index = _ref2.index, seriesIndex = _ref2.seriesIndex, state = _ref2.state;
                  if (!isNumber(index) || !isNumber(seriesIndex)) {
                    return;
                  }
                  var name = state.series.boxPlot[seriesIndex].name;
                  var models = _this.getRespondersWithTheme(_this.tooltipRectMap["".concat(name, "-").concat(index)], "hover");
                  _this.eventBus.emit("renderHoveredSeries", {
                    models,
                    name: _this.name,
                    eventDetectType: _this.eventDetectType
                  });
                  _this.activatedResponders = models;
                  _this.eventBus.emit("seriesPointHovered", {
                    models: _this.activatedResponders,
                    name: _this.name
                  });
                  _this.eventBus.emit("needDraw");
                });
                return _this;
              }
              boxPlotSeries_createClass(BoxPlotSeries2, [{
                key: "initialize",
                value: function initialize() {
                  this.type = "series";
                  this.name = "boxPlot";
                  this.eventBus.on("selectSeries", this.selectSeries);
                  this.eventBus.on("showTooltip", this.showTooltip);
                  this.eventBus.on("hideTooltip", this.onMouseoutComponent);
                }
              }, {
                key: "render",
                value: function render(state) {
                  var _options$series;
                  var layout2 = state.layout, axes2 = state.axes, series = state.series, scale2 = state.scale, legend2 = state.legend, options2 = state.options, theme2 = state.theme;
                  if (!series.boxPlot) {
                    throw new Error(message.noDataError(this.name));
                  }
                  if (options2 !== null && options2 !== void 0 && (_options$series = options2.series) !== null && _options$series !== void 0 && _options$series.eventDetectType) {
                    this.eventDetectType = options2.series.eventDetectType;
                  }
                  this.theme = theme2.series.boxPlot;
                  this.rect = layout2.plot;
                  this.activeSeriesMap = getActiveSeriesMap(legend2);
                  this.selectable = this.getSelectableOption(options2);
                  var categories = state.categories;
                  var tickDistance = axes2.xAxis.tickDistance;
                  var _limit = scale2.yAxis.limit, min = _limit.min, max2 = _limit.max;
                  var boxPlotData = series.boxPlot.data;
                  var seriesLength = boxPlotData.length;
                  var renderOptions = boxPlotSeries_objectSpread({
                    ratio: this.rect.height / (max2 - min),
                    tickDistance
                  }, this.getBarWidths(tickDistance, seriesLength));
                  var boxPlotModelData = this.makeBoxPlots(boxPlotData, renderOptions);
                  var seriesModels = this.renderSeriesModels(boxPlotModelData);
                  this.models = seriesModels;
                  if (!this.drawModels) {
                    this.drawModels = {
                      rect: seriesModels.rect.map(function(m) {
                        return boxPlotSeries_objectSpread(boxPlotSeries_objectSpread({}, m), {}, {
                          y: m.y + m.height,
                          height: 0
                        });
                      }),
                      line: seriesModels.line,
                      circle: seriesModels.circle
                    };
                  }
                  var tooltipData = this.makeTooltipModel(boxPlotData, categories);
                  this.tooltipRectMap = this.makeTooltipRectMap(boxPlotModelData, tooltipData);
                  this.responders = this.eventDetectType === "grouped" ? this.makeGroupedResponderModel(boxPlotModelData) : this.makeDefaultResponderModel(boxPlotModelData, tooltipData);
                }
              }, {
                key: "makeTooltipRectMap",
                value: function makeTooltipRectMap(boxPlotModelData, tooltipData) {
                  var _this2 = this;
                  var result = {};
                  boxPlotModelData.forEach(function(m, tooltipIndex) {
                    if (!isNull(m)) {
                      var propName = "".concat(m.name, "-").concat(m.index);
                      if (!result[propName]) {
                        result[propName] = [];
                      }
                      result[propName].push(boxPlotSeries_objectSpread(boxPlotSeries_objectSpread({}, _this2.makeHoveredModel(m)), {}, {
                        data: tooltipData[tooltipIndex]
                      }));
                    }
                  });
                  return result;
                }
              }, {
                key: "makeGroupedResponderModel",
                value: function makeGroupedResponderModel(boxPlotModelData) {
                  var _this3 = this;
                  var result = [];
                  boxPlotModelData.forEach(function(m) {
                    var type = m.type, index = m.index, name = m.name;
                    var propName = "".concat(name, "-").concat(index);
                    if (type === "boxPlot" && !result[propName]) {
                      var _ref3 = m, boxPlotDetection = _ref3.boxPlotDetection;
                      result.push(boxPlotSeries_objectSpread(boxPlotSeries_objectSpread({
                        type: "rect",
                        name: propName
                      }, boxPlotDetection), {}, {
                        y: 0,
                        height: _this3.rect.height
                      }));
                    }
                  });
                  return result;
                }
              }, {
                key: "makeDefaultResponderModel",
                value: function makeDefaultResponderModel(boxPlotModelData, tooltipDataArr) {
                  var _this4 = this;
                  return boxPlotModelData.map(function(m, index) {
                    return boxPlotSeries_objectSpread(boxPlotSeries_objectSpread({}, _this4.makeHoveredModel(m)), {}, {
                      data: tooltipDataArr[index],
                      color: getRGBA(m.color, 1)
                    });
                  });
                }
              }, {
                key: "makeHoveredModel",
                value: function makeHoveredModel(model) {
                  var point = model.type === "boxPlot" && model.rect ? {
                    x: model.rect.x,
                    y: model.rect.y
                  } : {
                    x: model.x,
                    y: model.y
                  };
                  var hoveredModel = boxPlotSeries_objectSpread({}, model);
                  if (model.type === "boxPlot") {
                    ["lowerWhisker", "upperWhisker", "maximum", "minimum", "median"].forEach(function(prop) {
                      if (model[prop]) {
                        model[prop].detectionSize = 3;
                      }
                    });
                    model.color = getRGBA(hoveredModel.color, 1);
                  }
                  return boxPlotSeries_objectSpread(boxPlotSeries_objectSpread({}, hoveredModel), point);
                }
              }, {
                key: "getResponderModelFromMap",
                value: function getResponderModelFromMap(responders) {
                  if (!responders.length) {
                    return [];
                  }
                  var propName = responders[0].name;
                  return this.tooltipRectMap[propName];
                }
              }, {
                key: "onMousemove",
                value: function onMousemove(_ref4) {
                  var responders = _ref4.responders;
                  if (this.eventDetectType === "grouped") {
                    var models = this.getResponderModelFromMap(responders);
                    this.eventBus.emit("renderHoveredSeries", {
                      models: this.getRespondersWithTheme(models, "select"),
                      name: this.name,
                      eventDetectType: this.eventDetectType
                    });
                    this.activatedResponders = models;
                  } else {
                    this.eventBus.emit("renderHoveredSeries", {
                      models: this.getRespondersWithTheme(responders, "hover"),
                      name: this.name,
                      eventDetectType: this.eventDetectType
                    });
                    this.activatedResponders = responders;
                  }
                  this.eventBus.emit("seriesPointHovered", {
                    models: this.activatedResponders,
                    name: this.name
                  });
                  this.eventBus.emit("needDraw");
                }
              }, {
                key: "onClick",
                value: function onClick(_ref5) {
                  var responders = _ref5.responders;
                  if (this.selectable) {
                    var models;
                    if (this.eventDetectType === "grouped") {
                      models = this.getRespondersWithTheme(this.getResponderModelFromMap(responders), "select");
                    } else {
                      models = this.getRespondersWithTheme(responders, "select");
                    }
                    this.eventBus.emit("renderSelectedSeries", {
                      models,
                      name: this.name,
                      eventDetectType: this.eventDetectType
                    });
                    this.eventBus.emit("needDraw");
                  }
                }
              }, {
                key: "renderSeriesModels",
                value: function renderSeriesModels(boxPlots) {
                  return boxPlots.reduce(function(acc, cur) {
                    var type = cur.type, name = cur.name;
                    if (type === "boxPlot") {
                      acc.rect.push(boxPlotSeries_objectSpread({
                        name
                      }, cur.rect));
                      ["maximum", "minimum", "median", "upperWhisker", "lowerWhisker"].forEach(function(prop) {
                        acc.line.push(boxPlotSeries_objectSpread({
                          name
                        }, cur[prop]));
                      });
                    } else {
                      acc.circle.push(boxPlotSeries_objectSpread({}, cur));
                    }
                    return acc;
                  }, {
                    rect: [],
                    line: [],
                    circle: []
                  });
                }
              }, {
                key: "makeBoxPlots",
                value: function makeBoxPlots(seriesData2, renderOptions) {
                  var _this5 = this;
                  var ratio = renderOptions.ratio, barWidth = renderOptions.barWidth;
                  var boxPlotModels = [];
                  var seriesLength = seriesData2.length;
                  var dot = this.theme.dot;
                  seriesData2.forEach(function(_ref6, seriesIndex) {
                    var outliers = _ref6.outliers, data = _ref6.data, name = _ref6.name, color = _ref6.color;
                    var seriesColor = _this5.getSeriesColor(name, color);
                    (data !== null && data !== void 0 ? data : []).forEach(function(datum, dataIndex) {
                      if (!isNull(datum)) {
                        var startX = _this5.getStartX(seriesIndex, dataIndex, renderOptions, seriesLength);
                        var rect2 = _this5.getRect(datum, startX, seriesColor, renderOptions);
                        boxPlotModels.push(boxPlotSeries_objectSpread(boxPlotSeries_objectSpread({
                          type: "boxPlot",
                          color: seriesColor,
                          name,
                          rect: rect2,
                          median: _this5.getMedian(datum, startX, seriesColor, renderOptions),
                          minimum: _this5.getMinimum(datum, startX, seriesColor, renderOptions),
                          maximum: _this5.getMaximum(datum, startX, seriesColor, renderOptions)
                        }, _this5.getWhisker(datum, startX, seriesColor, renderOptions, rect2)), {}, {
                          index: dataIndex,
                          boxPlotDetection: {
                            x: startX,
                            width: barWidth
                          }
                        }));
                      }
                    });
                    var _ref7 = dot, dotColor = _ref7.color, radius = _ref7.radius, borderColor = _ref7.borderColor, borderWidth = _ref7.borderWidth, useSeriesColor = _ref7.useSeriesColor;
                    (outliers !== null && outliers !== void 0 ? outliers : []).forEach(function(datum) {
                      var _datum = boxPlotSeries_slicedToArray(datum, 2), dataIndex = _datum[0], value = _datum[1];
                      var startX = _this5.getStartX(seriesIndex, dataIndex, renderOptions, seriesLength);
                      boxPlotModels.push({
                        type: "circle",
                        name,
                        x: startX + barWidth / 2,
                        y: _this5.getYPos(value, ratio),
                        radius,
                        style: [{
                          strokeStyle: borderColor !== null && borderColor !== void 0 ? borderColor : seriesColor,
                          lineWidth: borderWidth
                        }],
                        color: useSeriesColor ? seriesColor : dotColor,
                        index: dataIndex
                      });
                    });
                  });
                  return boxPlotModels;
                }
              }, {
                key: "makeTooltipModel",
                value: function makeTooltipModel(seriesData2, categories) {
                  var tooltipData = [];
                  seriesData2.forEach(function(_ref8) {
                    var outliers = _ref8.outliers, data = _ref8.data, name = _ref8.name, color = _ref8.color;
                    (data !== null && data !== void 0 ? data : []).forEach(function(datum, dataIndex) {
                      if (!isNull(datum)) {
                        var boxPlotData = boxPlotSeries_toConsumableArray(datum).reverse();
                        tooltipData.push({
                          label: name,
                          color,
                          value: ["Maximum", "Upper Quartile", "Median", "Lower Quartile", "Minimum"].reduce(function(acc, title, index) {
                            var value = boxPlotData[index];
                            return isNull(value) ? acc : [].concat(boxPlotSeries_toConsumableArray(acc), [{
                              title,
                              value
                            }]);
                          }, []),
                          category: categories[dataIndex],
                          templateType: "boxPlot"
                        });
                      }
                    });
                    (outliers !== null && outliers !== void 0 ? outliers : []).forEach(function(datum) {
                      if (!isNull(datum)) {
                        var _datum2 = boxPlotSeries_slicedToArray(datum, 2), dataIndex = _datum2[0], dataValue = _datum2[1];
                        tooltipData.push({
                          label: name,
                          color,
                          value: [{
                            title: "Outlier",
                            value: dataValue
                          }],
                          category: categories[dataIndex],
                          templateType: "boxPlot"
                        });
                      }
                    });
                  });
                  return tooltipData;
                }
              }, {
                key: "getStartX",
                value: function getStartX2(seriesIndex, dataIndex, renderOptions, seriesLength) {
                  var tickDistance = renderOptions.tickDistance, barWidth = renderOptions.barWidth;
                  var padding2 = getPadding(tickDistance, barWidth, seriesLength);
                  return dataIndex * tickDistance + (seriesIndex + 1) * padding2 + barWidth * seriesIndex;
                }
              }, {
                key: "getYPos",
                value: function getYPos(value, ratio, lineWidth) {
                  return isNumber(lineWidth) ? crispPixel(this.rect.height - value * ratio, lineWidth) : this.rect.height - value * ratio;
                }
              }, {
                key: "getBarWidths",
                value: function getBarWidths(tickDistance, seriesLength) {
                  var _this$theme = this.theme, barThemeWidth = _this$theme.barWidth, barWidthRatios = _this$theme.barWidthRatios;
                  var barRatio = barWidthRatios.barRatio, minMaxBarRatio = barWidthRatios.minMaxBarRatio;
                  var defaultBarWidth = Math.max((tickDistance - getBoxTypeSeriesPadding(tickDistance) * (2 + (seriesLength - 1))) / seriesLength, MIN_BAR_WIDTH);
                  var barWidth = barThemeWidth ? calculateSizeWithPercentString(tickDistance / seriesLength, barThemeWidth) : defaultBarWidth;
                  return {
                    barWidth: barWidth * barRatio,
                    minMaxBarWidth: barWidth * minMaxBarRatio
                  };
                }
              }, {
                key: "getRespondersWithTheme",
                value: function getRespondersWithTheme(responders, type) {
                  var _this$theme$type = this.theme[type], color = _this$theme$type.color, rect2 = _this$theme$type.rect, dot = _this$theme$type.dot, line2 = _this$theme$type.line, shadowColor = _this$theme$type.shadowColor, shadowOffsetX = _this$theme$type.shadowOffsetX, shadowOffsetY = _this$theme$type.shadowOffsetY, shadowBlur = _this$theme$type.shadowBlur;
                  var _ref9 = line2, whisker = _ref9.whisker, median = _ref9.median, maximum = _ref9.maximum, minimum = _ref9.minimum;
                  var _ref10 = dot, dotColor = _ref10.color, radius = _ref10.radius, borderColor = _ref10.borderColor, borderWidth = _ref10.borderWidth, useSeriesColor = _ref10.useSeriesColor;
                  return responders.map(function(m) {
                    var modelType = m.type, data = m.data;
                    var seriesColor = m.color;
                    var model;
                    if (modelType === "circle") {
                      seriesColor = data.color;
                      model = boxPlotSeries_objectSpread(boxPlotSeries_objectSpread({}, m), {}, {
                        radius,
                        color: useSeriesColor ? seriesColor : dotColor,
                        style: [{
                          strokeStyle: getDefaultColor(seriesColor, borderColor),
                          lineWidth: borderWidth
                        }]
                      });
                    } else {
                      var _ref11 = m, seriesRect = _ref11.rect, upperWhisker = _ref11.upperWhisker, lowerWhisker = _ref11.lowerWhisker, seriesMedian = _ref11.median, seriesMaximum = _ref11.maximum, seriesMinimum = _ref11.minimum;
                      model = boxPlotSeries_objectSpread(boxPlotSeries_objectSpread({}, m), {}, {
                        rect: boxPlotSeries_objectSpread(boxPlotSeries_objectSpread({}, seriesRect), {}, {
                          color: color !== null && color !== void 0 ? color : getRGBA(seriesColor, 1),
                          thickness: rect2.borderWidth,
                          borderColor: rect2.borderColor,
                          style: [{
                            shadowColor,
                            shadowOffsetX,
                            shadowOffsetY,
                            shadowBlur
                          }]
                        }),
                        upperWhisker: boxPlotSeries_objectSpread(boxPlotSeries_objectSpread({}, upperWhisker), {}, {
                          strokeStyle: getDefaultColor(seriesColor, whisker.color),
                          lineWidth: whisker.lineWidth
                        }),
                        lowerWhisker: boxPlotSeries_objectSpread(boxPlotSeries_objectSpread({}, lowerWhisker), {}, {
                          strokeStyle: getDefaultColor(seriesColor, whisker.color),
                          lineWidth: whisker.lineWidth
                        }),
                        median: boxPlotSeries_objectSpread(boxPlotSeries_objectSpread({}, seriesMedian), {}, {
                          strokeStyle: getDefaultColor(seriesColor, median.color),
                          lineWidth: median.lineWidth
                        }),
                        maximum: boxPlotSeries_objectSpread(boxPlotSeries_objectSpread({}, seriesMaximum), {}, {
                          strokeStyle: getDefaultColor(seriesColor, maximum.color),
                          lineWidth: maximum.lineWidth
                        }),
                        minimum: boxPlotSeries_objectSpread(boxPlotSeries_objectSpread({}, seriesMinimum), {}, {
                          strokeStyle: getDefaultColor(seriesColor, minimum.color),
                          lineWidth: minimum.lineWidth
                        })
                      });
                    }
                    return model;
                  });
                }
              }, {
                key: "getRect",
                value: function getRect(datum, startX, seriesColor, _ref12) {
                  var barWidth = _ref12.barWidth, ratio = _ref12.ratio;
                  var rect2 = this.theme.rect;
                  var _datum3 = boxPlotSeries_slicedToArray(datum, 4), lowerQuartile = _datum3[1], highQuartile = _datum3[3];
                  return {
                    type: "rect",
                    x: startX,
                    y: this.getYPos(highQuartile, ratio),
                    width: barWidth,
                    height: (highQuartile - lowerQuartile) * ratio,
                    thickness: rect2.borderWidth,
                    borderColor: rect2.borderColor,
                    color: seriesColor
                  };
                }
              }, {
                key: "getWhisker",
                value: function getWhisker(datum, startX, seriesColor, _ref13, rect2) {
                  var barWidth = _ref13.barWidth, ratio = _ref13.ratio;
                  var _datum4 = boxPlotSeries_slicedToArray(datum, 5), minimum = _datum4[0], maximum = _datum4[4];
                  var _ref14 = this.theme.line.whisker, lineWidth = _ref14.lineWidth, color = _ref14.color;
                  var x = crispPixel(startX + barWidth / 2, lineWidth);
                  return {
                    upperWhisker: {
                      type: "line",
                      x,
                      y: this.getYPos(maximum, ratio, lineWidth),
                      x2: x,
                      y2: rect2.y,
                      strokeStyle: color !== null && color !== void 0 ? color : seriesColor,
                      lineWidth
                    },
                    lowerWhisker: {
                      type: "line",
                      x,
                      y: this.getYPos(minimum, ratio, lineWidth),
                      x2: x,
                      y2: crispPixel(rect2.y + rect2.height, lineWidth),
                      strokeStyle: color !== null && color !== void 0 ? color : seriesColor,
                      lineWidth
                    }
                  };
                }
              }, {
                key: "getMedian",
                value: function getMedian(datum, startX, seriesColor, _ref15) {
                  var barWidth = _ref15.barWidth, ratio = _ref15.ratio;
                  var median = datum[2];
                  var _ref16 = this.theme.line.median, lineWidth = _ref16.lineWidth, color = _ref16.color;
                  return {
                    type: "line",
                    x: crispPixel(startX, lineWidth),
                    y: this.getYPos(median, ratio, lineWidth),
                    x2: crispPixel(startX + barWidth, lineWidth),
                    y2: this.getYPos(median, ratio, lineWidth),
                    strokeStyle: color !== null && color !== void 0 ? color : seriesColor,
                    lineWidth
                  };
                }
              }, {
                key: "getMinimum",
                value: function getMinimum(datum, startX, seriesColor, _ref17) {
                  var barWidth = _ref17.barWidth, ratio = _ref17.ratio, minMaxBarWidth = _ref17.minMaxBarWidth;
                  var minimum = datum[0];
                  var _ref18 = this.theme.line.minimum, lineWidth = _ref18.lineWidth, color = _ref18.color;
                  return {
                    type: "line",
                    x: crispPixel(startX + (barWidth - minMaxBarWidth) / 2, lineWidth),
                    y: this.getYPos(minimum, ratio, lineWidth),
                    x2: crispPixel(startX + (barWidth - minMaxBarWidth) / 2 + minMaxBarWidth, lineWidth),
                    y2: this.getYPos(minimum, ratio, lineWidth),
                    strokeStyle: color !== null && color !== void 0 ? color : seriesColor,
                    lineWidth
                  };
                }
              }, {
                key: "getMaximum",
                value: function getMaximum(datum, startX, seriesColor, _ref19) {
                  var barWidth = _ref19.barWidth, ratio = _ref19.ratio, minMaxBarWidth = _ref19.minMaxBarWidth;
                  var maximum = datum[4];
                  var _ref20 = this.theme.line.maximum, lineWidth = _ref20.lineWidth, color = _ref20.color;
                  return {
                    type: "line",
                    x: crispPixel(startX + (barWidth - minMaxBarWidth) / 2, lineWidth),
                    y: this.getYPos(maximum, ratio, lineWidth),
                    x2: crispPixel(startX + (barWidth - minMaxBarWidth) / 2 + minMaxBarWidth, lineWidth),
                    y2: this.getYPos(maximum, ratio, lineWidth),
                    strokeStyle: color !== null && color !== void 0 ? color : seriesColor,
                    lineWidth
                  };
                }
              }, {
                key: "getSeriesColor",
                value: function getSeriesColor(seriesName, seriesColor) {
                  var _this$theme2 = this.theme, select = _this$theme2.select, areaOpacity = _this$theme2.areaOpacity;
                  var active = this.activeSeriesMap[seriesName];
                  var selected = Object.values(this.activeSeriesMap).some(function(elem) {
                    return !elem;
                  });
                  var selectedOpacity = active ? select.areaOpacity : select.restSeries.areaOpacity;
                  var opacity = selected ? selectedOpacity : areaOpacity;
                  return getRGBA(seriesColor, opacity);
                }
              }]);
              return BoxPlotSeries2;
            }(Component);
            ;
            function boxPlot_ownKeys(object, enumerableOnly) {
              var keys = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object);
                if (enumerableOnly) {
                  symbols = symbols.filter(function(sym) {
                    return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                  });
                }
                keys.push.apply(keys, symbols);
              }
              return keys;
            }
            function boxPlot_objectSpread(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i] != null ? arguments[i] : {};
                if (i % 2) {
                  boxPlot_ownKeys(Object(source), true).forEach(function(key) {
                    boxPlot_defineProperty(target, key, source[key]);
                  });
                } else if (Object.getOwnPropertyDescriptors) {
                  Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                } else {
                  boxPlot_ownKeys(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  });
                }
              }
              return target;
            }
            function boxPlot_defineProperty(obj, key, value) {
              if (key in obj) {
                Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
              } else {
                obj[key] = value;
              }
              return obj;
            }
            function boxPlot(ctx2, model) {
              var rectModel = model.rect, upperWhisker = model.upperWhisker, lowerWhisker = model.lowerWhisker, median = model.median, minimum = model.minimum, maximum = model.maximum;
              if (minimum) {
                line(ctx2, boxPlot_objectSpread({
                  type: "line"
                }, minimum));
              }
              if (lowerWhisker) {
                line(ctx2, boxPlot_objectSpread({
                  type: "line"
                }, lowerWhisker));
              }
              if (rectModel) {
                rect(ctx2, boxPlot_objectSpread({
                  type: "rect"
                }, rectModel));
              }
              if (upperWhisker) {
                line(ctx2, boxPlot_objectSpread({
                  type: "line"
                }, upperWhisker));
              }
              if (maximum) {
                line(ctx2, boxPlot_objectSpread({
                  type: "line"
                }, maximum));
              }
              if (median) {
                line(ctx2, boxPlot_objectSpread({
                  type: "line"
                }, median));
              }
            }
            ;
            function boxPlotChart_typeof(obj) {
              "@babel/helpers - typeof";
              if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                boxPlotChart_typeof = function _typeof2(obj2) {
                  return typeof obj2;
                };
              } else {
                boxPlotChart_typeof = function _typeof2(obj2) {
                  return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                };
              }
              return boxPlotChart_typeof(obj);
            }
            function boxPlotChart_ownKeys(object, enumerableOnly) {
              var keys = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object);
                if (enumerableOnly) {
                  symbols = symbols.filter(function(sym) {
                    return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                  });
                }
                keys.push.apply(keys, symbols);
              }
              return keys;
            }
            function boxPlotChart_objectSpread(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i] != null ? arguments[i] : {};
                if (i % 2) {
                  boxPlotChart_ownKeys(Object(source), true).forEach(function(key) {
                    boxPlotChart_defineProperty(target, key, source[key]);
                  });
                } else if (Object.getOwnPropertyDescriptors) {
                  Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                } else {
                  boxPlotChart_ownKeys(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  });
                }
              }
              return target;
            }
            function boxPlotChart_defineProperty(obj, key, value) {
              if (key in obj) {
                Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
              } else {
                obj[key] = value;
              }
              return obj;
            }
            function boxPlotChart_classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function boxPlotChart_defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            function boxPlotChart_createClass(Constructor, protoProps, staticProps) {
              if (protoProps)
                boxPlotChart_defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                boxPlotChart_defineProperties(Constructor, staticProps);
              return Constructor;
            }
            function boxPlotChart_get(target, property, receiver) {
              if (typeof Reflect !== "undefined" && Reflect.get) {
                boxPlotChart_get = Reflect.get;
              } else {
                boxPlotChart_get = function _get2(target2, property2, receiver2) {
                  var base = boxPlotChart_superPropBase(target2, property2);
                  if (!base)
                    return;
                  var desc = Object.getOwnPropertyDescriptor(base, property2);
                  if (desc.get) {
                    return desc.get.call(receiver2);
                  }
                  return desc.value;
                };
              }
              return boxPlotChart_get(target, property, receiver || target);
            }
            function boxPlotChart_superPropBase(object, property) {
              while (!Object.prototype.hasOwnProperty.call(object, property)) {
                object = boxPlotChart_getPrototypeOf(object);
                if (object === null)
                  break;
              }
              return object;
            }
            function boxPlotChart_inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function");
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
              if (superClass)
                boxPlotChart_setPrototypeOf(subClass, superClass);
            }
            function boxPlotChart_setPrototypeOf(o, p) {
              boxPlotChart_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
                o2.__proto__ = p2;
                return o2;
              };
              return boxPlotChart_setPrototypeOf(o, p);
            }
            function boxPlotChart_createSuper(Derived) {
              var hasNativeReflectConstruct = boxPlotChart_isNativeReflectConstruct();
              return function _createSuperInternal() {
                var Super = boxPlotChart_getPrototypeOf(Derived), result;
                if (hasNativeReflectConstruct) {
                  var NewTarget = boxPlotChart_getPrototypeOf(this).constructor;
                  result = Reflect.construct(Super, arguments, NewTarget);
                } else {
                  result = Super.apply(this, arguments);
                }
                return boxPlotChart_possibleConstructorReturn(this, result);
              };
            }
            function boxPlotChart_possibleConstructorReturn(self2, call) {
              if (call && (boxPlotChart_typeof(call) === "object" || typeof call === "function")) {
                return call;
              }
              return boxPlotChart_assertThisInitialized(self2);
            }
            function boxPlotChart_assertThisInitialized(self2) {
              if (self2 === void 0) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return self2;
            }
            function boxPlotChart_isNativeReflectConstruct() {
              if (typeof Reflect === "undefined" || !Reflect.construct)
                return false;
              if (Reflect.construct.sham)
                return false;
              if (typeof Proxy === "function")
                return true;
              try {
                Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                }));
                return true;
              } catch (e) {
                return false;
              }
            }
            function boxPlotChart_getPrototypeOf(o) {
              boxPlotChart_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
                return o2.__proto__ || Object.getPrototypeOf(o2);
              };
              return boxPlotChart_getPrototypeOf(o);
            }
            var BoxPlotChart = function(_Chart) {
              boxPlotChart_inherits(BoxPlotChart2, _Chart);
              var _super = boxPlotChart_createSuper(BoxPlotChart2);
              function BoxPlotChart2(_ref) {
                var el = _ref.el, options2 = _ref.options, _ref$data = _ref.data, series = _ref$data.series, categories = _ref$data.categories;
                boxPlotChart_classCallCheck(this, BoxPlotChart2);
                return _super.call(this, {
                  el,
                  options: options2,
                  series: {
                    boxPlot: series
                  },
                  categories,
                  modules: [store_dataRange, store_scale, store_axes, store_plot]
                });
              }
              boxPlotChart_createClass(BoxPlotChart2, [{
                key: "initialize",
                value: function initialize() {
                  boxPlotChart_get(boxPlotChart_getPrototypeOf(BoxPlotChart2.prototype), "initialize", this).call(this);
                  this.componentManager.add(Background);
                  this.componentManager.add(Title);
                  this.componentManager.add(Plot);
                  this.componentManager.add(Legend);
                  this.componentManager.add(BoxPlotSeries);
                  this.componentManager.add(Axis, {
                    name: "yAxis"
                  });
                  this.componentManager.add(Axis, {
                    name: "xAxis"
                  });
                  this.componentManager.add(AxisTitle, {
                    name: "xAxis"
                  });
                  this.componentManager.add(AxisTitle, {
                    name: "yAxis"
                  });
                  this.componentManager.add(ExportMenu, {
                    chartEl: this.el
                  });
                  this.componentManager.add(HoveredSeries);
                  this.componentManager.add(SelectedSeries);
                  this.componentManager.add(Tooltip, {
                    chartEl: this.el
                  });
                  this.componentManager.add(NoDataText);
                  this.painter.addGroups([basic_namespaceObject, axis_namespaceObject, boxPlot_namespaceObject, legend_namespaceObject, label_namespaceObject, brushes_exportMenu_namespaceObject]);
                }
                /**
                 * Add data.
                 * @param {Array<<Array<number>>} data - Array of data to be added.
                 * @param {string} category - Category to be added.
                 * @api
                 * @example
                 * chart.addData(
                    [
                       [3000, 4000, 4714, 6000, 7000],
                       [3000, 5750, 7571, 8250, 9000],
                    ],
                    'newCategory'
                  );
                 */
              }, {
                key: "addData",
                value: function addData(data, category2) {
                  this.animationControlFlag.updating = true;
                  this.resetSeries();
                  this.store.dispatch("addData", {
                    data,
                    category: category2
                  });
                }
                /**
                 * add outlier.
                 * @param {number} seriesIndex - Index of series.
                 * @param {number} outliers - Array of outlier.
                 * @api
                 * @example
                 * chart.addOutlier(1, [[1, 10000], [3, 12000]]);
                 */
              }, {
                key: "addOutlier",
                value: function addOutlier(seriesIndex, outliers) {
                  this.animationControlFlag.updating = true;
                  this.resetSeries();
                  this.store.dispatch("addOutlier", {
                    seriesIndex,
                    outliers
                  });
                }
                /**
                 * Add series.
                 * @param {Object} data - Data to be added.
                 *   @param {string} data.name - Series name.
                 *   @param {Array<Array<number>>} data.data - Array of data to be added.
                 *   @param {Array<Array<number>>} data.outliers - Series outliers data.
                 * @api
                 * @example
                 * chart.addSeries({
                 *   name: 'newSeries',
                 *   data: [
                 *     [10, 100, 50, 40, 70, 55, 33, 70, 90, 110],
                 *   ],
                 *   outliers: [
                 *     [0, 14000],
                 *     [2, 10000],
                 *   ]
                 * });
                 */
              }, {
                key: "addSeries",
                value: function addSeries(data) {
                  this.resetSeries();
                  this.store.dispatch("addSeries", {
                    data
                  });
                }
                /**
                 * Convert the chart data to new data.
                 * @param {Object} data - Data to be set.
                 * @api
                 * @example
                 * chart.setData({
                 *   categories: ['1', '2', '3'],
                 *   series: [
                 *     {
                 *       name: 'newSeries',
                 *       data: [
                 *         [10, 100, 50, 40, 70, 55, 33, 70, 90, 110],
                 *       ],
                 *       outliers: [
                 *         [0, 14000],
                 *         [2, 10000],
                 *       ]
                 *     }
                 *   ]
                 * });
                 */
              }, {
                key: "setData",
                value: function setData(data) {
                  var categories = data.categories, series = data.series;
                  this.resetSeries();
                  this.store.dispatch("setData", {
                    series: {
                      boxPlot: series
                    },
                    categories
                  });
                }
                /**
                 * Convert the chart options to new options.
                 * @param {Object} options - Chart options.
                 * @api
                 * @example
                 * chart.setOptions({
                 *   chart: {
                 *     width: 500,
                 *     height: 'auto',
                 *     title: 'Energy Usage',
                 *   },
                 *   xAxis: {
                 *     title: 'Month',
                 *     date: { format: 'yy/MM' },
                 *   },
                 *   yAxis: {
                 *     title: 'Energy (kWh)',
                 *   },
                 *   series: {
                 *     selectable: true,
                 *   },
                 *   tooltip: {
                 *     formatter: (value) => `${value}kWh`,
                 *   },
                 * });
                 */
              }, {
                key: "setOptions",
                value: function setOptions(options2) {
                  this.resetSeries();
                  this.dispatchOptionsEvent("initOptions", options2);
                }
                /**
                 * Update chart options.
                 * @param {Object} options - Chart options.
                 * @api
                 * @example
                 * chart.updateOptions({
                 *   chart: {
                 *     height: 'auto',
                 *     title: 'Energy Usage',
                 *   },
                 *   tooltip: {
                 *     formatter: (value) => `${value}kWh`,
                 *   },
                 * });
                 */
              }, {
                key: "updateOptions",
                value: function updateOptions(options2) {
                  this.resetSeries();
                  this.dispatchOptionsEvent("updateOptions", options2);
                }
                /**
                 * Show tooltip.
                 * @param {Object} seriesInfo - Information of the series for the tooltip to be displayed.
                 *      @param {number} seriesInfo.seriesIndex - Index of series.
                 *      @param {number} seriesInfo.index - Index of data within series.
                 * @api
                 * @example
                 * chart.showTooltip({index: 1, seriesIndex: 2});
                 */
              }, {
                key: "showTooltip",
                value: function showTooltip(seriesInfo) {
                  this.eventBus.emit("showTooltip", boxPlotChart_objectSpread(boxPlotChart_objectSpread({}, seriesInfo), {}, {
                    state: this.store.state
                  }));
                }
                /**
                 * Hide tooltip.
                 * @api
                 * @example
                 * chart.hideTooltip();
                 */
              }, {
                key: "hideTooltip",
                value: function hideTooltip() {
                  this.eventBus.emit("hideTooltip");
                }
              }]);
              return BoxPlotChart2;
            }(Chart);
            ;
            function radialBarSeries_typeof(obj) {
              "@babel/helpers - typeof";
              if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                radialBarSeries_typeof = function _typeof2(obj2) {
                  return typeof obj2;
                };
              } else {
                radialBarSeries_typeof = function _typeof2(obj2) {
                  return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                };
              }
              return radialBarSeries_typeof(obj);
            }
            function radialBarSeries_ownKeys(object, enumerableOnly) {
              var keys = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object);
                if (enumerableOnly) {
                  symbols = symbols.filter(function(sym) {
                    return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                  });
                }
                keys.push.apply(keys, symbols);
              }
              return keys;
            }
            function radialBarSeries_objectSpread(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i] != null ? arguments[i] : {};
                if (i % 2) {
                  radialBarSeries_ownKeys(Object(source), true).forEach(function(key) {
                    radialBarSeries_defineProperty(target, key, source[key]);
                  });
                } else if (Object.getOwnPropertyDescriptors) {
                  Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                } else {
                  radialBarSeries_ownKeys(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  });
                }
              }
              return target;
            }
            function radialBarSeries_toConsumableArray(arr) {
              return radialBarSeries_arrayWithoutHoles(arr) || radialBarSeries_iterableToArray(arr) || radialBarSeries_unsupportedIterableToArray(arr) || radialBarSeries_nonIterableSpread();
            }
            function radialBarSeries_nonIterableSpread() {
              throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            function radialBarSeries_unsupportedIterableToArray(o, minLen) {
              if (!o)
                return;
              if (typeof o === "string")
                return radialBarSeries_arrayLikeToArray(o, minLen);
              var n = Object.prototype.toString.call(o).slice(8, -1);
              if (n === "Object" && o.constructor)
                n = o.constructor.name;
              if (n === "Map" || n === "Set")
                return Array.from(o);
              if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                return radialBarSeries_arrayLikeToArray(o, minLen);
            }
            function radialBarSeries_iterableToArray(iter) {
              if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
                return Array.from(iter);
            }
            function radialBarSeries_arrayWithoutHoles(arr) {
              if (Array.isArray(arr))
                return radialBarSeries_arrayLikeToArray(arr);
            }
            function radialBarSeries_arrayLikeToArray(arr, len) {
              if (len == null || len > arr.length)
                len = arr.length;
              for (var i = 0, arr2 = new Array(len); i < len; i++) {
                arr2[i] = arr[i];
              }
              return arr2;
            }
            function radialBarSeries_classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function radialBarSeries_defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            function radialBarSeries_createClass(Constructor, protoProps, staticProps) {
              if (protoProps)
                radialBarSeries_defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                radialBarSeries_defineProperties(Constructor, staticProps);
              return Constructor;
            }
            function radialBarSeries_inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function");
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
              if (superClass)
                radialBarSeries_setPrototypeOf(subClass, superClass);
            }
            function radialBarSeries_setPrototypeOf(o, p) {
              radialBarSeries_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
                o2.__proto__ = p2;
                return o2;
              };
              return radialBarSeries_setPrototypeOf(o, p);
            }
            function radialBarSeries_createSuper(Derived) {
              var hasNativeReflectConstruct = radialBarSeries_isNativeReflectConstruct();
              return function _createSuperInternal() {
                var Super = radialBarSeries_getPrototypeOf(Derived), result;
                if (hasNativeReflectConstruct) {
                  var NewTarget = radialBarSeries_getPrototypeOf(this).constructor;
                  result = Reflect.construct(Super, arguments, NewTarget);
                } else {
                  result = Super.apply(this, arguments);
                }
                return radialBarSeries_possibleConstructorReturn(this, result);
              };
            }
            function radialBarSeries_possibleConstructorReturn(self2, call) {
              if (call && (radialBarSeries_typeof(call) === "object" || typeof call === "function")) {
                return call;
              }
              return radialBarSeries_assertThisInitialized(self2);
            }
            function radialBarSeries_assertThisInitialized(self2) {
              if (self2 === void 0) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return self2;
            }
            function radialBarSeries_isNativeReflectConstruct() {
              if (typeof Reflect === "undefined" || !Reflect.construct)
                return false;
              if (Reflect.construct.sham)
                return false;
              if (typeof Proxy === "function")
                return true;
              try {
                Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                }));
                return true;
              } catch (e) {
                return false;
              }
            }
            function radialBarSeries_getPrototypeOf(o) {
              radialBarSeries_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
                return o2.__proto__ || Object.getPrototypeOf(o2);
              };
              return radialBarSeries_getPrototypeOf(o);
            }
            function radialBarSeries_defineProperty(obj, key, value) {
              if (key in obj) {
                Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
              } else {
                obj[key] = value;
              }
              return obj;
            }
            var RadialBarSeries = function(_Component) {
              radialBarSeries_inherits(RadialBarSeries2, _Component);
              var _super = radialBarSeries_createSuper(RadialBarSeries2);
              function RadialBarSeries2() {
                var _this;
                radialBarSeries_classCallCheck(this, RadialBarSeries2);
                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }
                _this = _super.call.apply(_super, [this].concat(args));
                radialBarSeries_defineProperty(radialBarSeries_assertThisInitialized(_this), "models", {});
                radialBarSeries_defineProperty(radialBarSeries_assertThisInitialized(_this), "drawModels", void 0);
                radialBarSeries_defineProperty(radialBarSeries_assertThisInitialized(_this), "responders", void 0);
                radialBarSeries_defineProperty(radialBarSeries_assertThisInitialized(_this), "activatedResponders", []);
                radialBarSeries_defineProperty(radialBarSeries_assertThisInitialized(_this), "eventDetectType", "point");
                radialBarSeries_defineProperty(radialBarSeries_assertThisInitialized(_this), "tooltipSectorMap", void 0);
                radialBarSeries_defineProperty(radialBarSeries_assertThisInitialized(_this), "theme", void 0);
                radialBarSeries_defineProperty(radialBarSeries_assertThisInitialized(_this), "circularAxis", void 0);
                radialBarSeries_defineProperty(radialBarSeries_assertThisInitialized(_this), "onMouseoutComponent", function() {
                  _this.eventBus.emit("seriesPointHovered", {
                    models: [],
                    name: _this.name
                  });
                  _this.eventBus.emit("renderHoveredSeries", {
                    models: [],
                    name: _this.name
                  });
                  _this.eventBus.emit("needDraw");
                });
                radialBarSeries_defineProperty(radialBarSeries_assertThisInitialized(_this), "selectSeries", function(info) {
                  var _this$getResponderMod;
                  var index = info.index, seriesIndex = info.seriesIndex;
                  var isAvailable = isNumber(index) && (_this.eventDetectType === "grouped" || isNumber(seriesIndex));
                  if (!isAvailable) {
                    return;
                  }
                  var models = _this.eventDetectType === "grouped" ? [].concat(radialBarSeries_toConsumableArray(_this.getGroupedSector([_this.responders[index]], "select")), radialBarSeries_toConsumableArray(_this.getRadialBarSectorModelsFromResponders([_this.responders[index]]))) : (_this$getResponderMod = _this.getResponderModelsWithTheme([_this.tooltipSectorMap[index][seriesIndex]], "select")) !== null && _this$getResponderMod !== void 0 ? _this$getResponderMod : [];
                  if (!models.length) {
                    throw new Error(message.SELECT_SERIES_API_INDEX_ERROR);
                  }
                  _this.eventBus.emit("renderSelectedSeries", {
                    models,
                    name: _this.name,
                    eventDetectType: _this.eventDetectType
                  });
                  _this.eventBus.emit("needDraw");
                });
                radialBarSeries_defineProperty(radialBarSeries_assertThisInitialized(_this), "showTooltip", function(info) {
                  var index = info.index, seriesIndex = info.seriesIndex;
                  if (!isAvailableShowTooltipInfo(info, _this.eventDetectType, "radialBar")) {
                    return;
                  }
                  var models = _this.eventDetectType === "grouped" ? _this.getGroupedSector([_this.responders[index]], "hover") : _this.getResponderModelsWithTheme([_this.tooltipSectorMap[index][seriesIndex]], "hover");
                  if (!models.length) {
                    return;
                  }
                  _this.eventBus.emit("renderHoveredSeries", {
                    models,
                    name: _this.name,
                    eventDetectType: _this.eventDetectType
                  });
                  _this.activatedResponders = _this.eventDetectType === "grouped" ? _this.tooltipSectorMap[index] : models;
                  _this.eventBus.emit("seriesPointHovered", {
                    models: _this.activatedResponders,
                    name: _this.name
                  });
                  _this.eventBus.emit("needDraw");
                });
                return _this;
              }
              radialBarSeries_createClass(RadialBarSeries2, [{
                key: "initUpdate",
                value: function initUpdate(delta) {
                  var _this2 = this;
                  if (!this.drawModels) {
                    return;
                  }
                  var _this$circularAxis$an = this.circularAxis.angle, startAngle = _this$circularAxis$an.start, totalAngle = _this$circularAxis$an.total;
                  var currentDegree;
                  Object.keys(this.models).forEach(function(category2) {
                    var index = _this2.models[category2].findIndex(function(_ref) {
                      var clockwise = _ref.clockwise, _ref$degree = _ref.degree, start = _ref$degree.start, end = _ref$degree.end;
                      currentDegree = clockwise ? startAngle + totalAngle * delta : startAngle - totalAngle * delta;
                      return withinRadian(clockwise, start, end, currentDegree);
                    });
                    _this2.syncEndAngle(index < 0 ? _this2.models[category2].length : index, category2);
                    if (index !== -1) {
                      _this2.drawModels[category2][index].degree.end = currentDegree;
                    }
                  });
                }
              }, {
                key: "syncEndAngle",
                value: function syncEndAngle(index, category2) {
                  if (index < 1) {
                    return;
                  }
                  for (var i = 0; i < index; i += 1) {
                    var prevTargetEndDegree = this.models[category2][i].degree.end;
                    if (this.drawModels[category2][i].degree.end !== prevTargetEndDegree) {
                      this.drawModels[category2][i].degree.end = prevTargetEndDegree;
                    }
                  }
                }
              }, {
                key: "initialize",
                value: function initialize() {
                  this.type = "series";
                  this.name = "radialBar";
                  this.eventBus.on("selectSeries", this.selectSeries);
                  this.eventBus.on("showTooltip", this.showTooltip);
                  this.eventBus.on("hideTooltip", this.onMouseoutComponent);
                }
              }, {
                key: "render",
                value: function render(chartState) {
                  var _ref2, _this3 = this;
                  var layout2 = chartState.layout, series = chartState.series, legend2 = chartState.legend, options2 = chartState.options, theme2 = chartState.theme, stackSeries = chartState.stackSeries, scale2 = chartState.scale, radialAxes2 = chartState.radialAxes;
                  var categories = (_ref2 = chartState.categories) !== null && _ref2 !== void 0 ? _ref2 : [];
                  if (!series.radialBar || !stackSeries.radialBar) {
                    throw new Error(message.noDataError(this.name));
                  }
                  this.theme = theme2.series.radialBar;
                  this.rect = layout2.plot;
                  this.activeSeriesMap = getActiveSeriesMap(legend2);
                  this.selectable = this.getSelectableOption(options2);
                  this.setEventDetectType(options2);
                  var initialCategoryMap = categories.reduce(function(acc, category2) {
                    if (!acc[category2]) {
                      acc[category2] = [];
                    }
                    return acc;
                  }, {});
                  var seriesData2 = series.radialBar.data;
                  this.circularAxis = radialAxes2.circularAxis;
                  var verticalAxisData = radialAxes2.verticalAxis;
                  var renderOptions = this.makeRenderOptions(verticalAxisData, scale2.circularAxis, options2 === null || options2 === void 0 ? void 0 : options2.series);
                  var _this$makeSeriesModel = this.makeSeriesModelData(seriesData2, stackSeries.radialBar.stackData, renderOptions, initialCategoryMap), categoryMap = _this$makeSeriesModel.categoryMap, seriesModels = _this$makeSeriesModel.seriesModels;
                  var tooltipData = this.makeTooltipData(seriesModels, categories);
                  this.models = categoryMap;
                  if (!this.drawModels) {
                    this.initDrawModels(categoryMap);
                  }
                  if (getDataLabelsOptions(options2, this.name).visible) {
                    var dataLabelData = seriesModels.reduce(function(acc, data) {
                      return [].concat(radialBarSeries_toConsumableArray(acc), [radialBarSeries_objectSpread(radialBarSeries_objectSpread({}, data), {}, {
                        type: "sector",
                        theme: _this3.theme.dataLabels
                      })]);
                    }, []);
                    this.renderDataLabels(dataLabelData);
                  }
                  this.tooltipSectorMap = this.makeTooltipSectorMap(seriesModels, tooltipData);
                  this.responders = this.makeResponders(verticalAxisData.radius.ranges, seriesModels, renderOptions, categories, tooltipData);
                }
              }, {
                key: "initDrawModels",
                value: function initDrawModels(categoryMap) {
                  var _this4 = this;
                  this.drawModels = {};
                  Object.keys(categoryMap).forEach(function(category2) {
                    _this4.drawModels[category2] = categoryMap[category2].map(function(m) {
                      return radialBarSeries_objectSpread(radialBarSeries_objectSpread({}, m), {}, {
                        degree: radialBarSeries_objectSpread(radialBarSeries_objectSpread({}, m.degree), {}, {
                          end: m.degree.start
                        })
                      });
                    });
                  });
                }
              }, {
                key: "makeResponders",
                value: function makeResponders(radiusRanges, seriesModels, renderOptions, categories, tooltipData) {
                  return this.eventDetectType === "grouped" ? makeGroupedSectorResponderModel(radiusRanges, renderOptions, categories) : seriesModels.map(function(m, index) {
                    return radialBarSeries_objectSpread(radialBarSeries_objectSpread({}, m), {}, {
                      data: radialBarSeries_objectSpread({}, tooltipData[index])
                    });
                  });
                }
              }, {
                key: "makeTooltipSectorMap",
                value: function makeTooltipSectorMap(seriesModels, tooltipData) {
                  return seriesModels.reduce(function(acc, cur, index) {
                    var categoryIndex = cur.index;
                    if (!acc[categoryIndex]) {
                      acc[categoryIndex] = [];
                    }
                    acc[categoryIndex].push(radialBarSeries_objectSpread(radialBarSeries_objectSpread({}, cur), {}, {
                      data: radialBarSeries_objectSpread({}, tooltipData[index])
                    }));
                    return acc;
                  }, {});
                }
              }, {
                key: "setEventDetectType",
                value: function setEventDetectType(options2) {
                  var _options$series;
                  if (options2 !== null && options2 !== void 0 && (_options$series = options2.series) !== null && _options$series !== void 0 && _options$series.eventDetectType) {
                    this.eventDetectType = options2.series.eventDetectType;
                  }
                }
              }, {
                key: "getBarWidth",
                value: function getBarWidth(tickDistance, axisSize) {
                  var barWidth = this.theme.barWidth;
                  var DEFAULT_PADDING = 5;
                  return barWidth ? Math.min(tickDistance, calculateSizeWithPercentString(axisSize, barWidth)) : tickDistance - DEFAULT_PADDING * 2;
                }
              }, {
                key: "makeRenderOptions",
                value: function makeRenderOptions(_ref3, scale2, options2) {
                  var _options$clockwise;
                  var axisSize = _ref3.axisSize, centerX = _ref3.centerX, centerY = _ref3.centerY, tickDistance = _ref3.tickDistance, ranges = _ref3.radius.ranges, _ref3$angle = _ref3.angle, start = _ref3$angle.start, end = _ref3$angle.end;
                  var max2 = scale2.limit.max, stepSize = scale2.stepSize;
                  var clockwise = (_options$clockwise = options2 === null || options2 === void 0 ? void 0 : options2.clockwise) !== null && _options$clockwise !== void 0 ? _options$clockwise : true;
                  var totalAngle = getTotalAngle(clockwise, start, end);
                  var barWidth = this.getBarWidth(tickDistance, axisSize);
                  var padding2 = (tickDistance - barWidth) / 2;
                  var scaleMaxLimitValue = max2 + (totalAngle < DEGREE_360 ? DEGREE_0 : stepSize);
                  return {
                    clockwise,
                    centerX,
                    centerY,
                    radiusRanges: getRadiusRanges(ranges, padding2),
                    angleRange: {
                      start,
                      end
                    },
                    totalAngle,
                    scaleMaxLimitValue,
                    startAngle: start
                  };
                }
              }, {
                key: "makeSeriesModelData",
                value: function makeSeriesModelData(seriesData2, stackSeriesData2, renderOptions, initialCategoryMap) {
                  var _this5 = this;
                  var clockwise = renderOptions.clockwise, centerX = renderOptions.centerX, centerY = renderOptions.centerY, radiusRanges = renderOptions.radiusRanges, totalAngle = renderOptions.totalAngle, scaleMaxLimitValue = renderOptions.scaleMaxLimitValue, startAngle = renderOptions.startAngle;
                  var defaultStartDegree = startAngle;
                  var _this$theme = this.theme, lineWidth = _this$theme.lineWidth, strokeStyle = _this$theme.strokeStyle;
                  var sectorModels = [];
                  var categories = Object.keys(initialCategoryMap);
                  var categoryMap = deepCopy(initialCategoryMap);
                  stackSeriesData2.forEach(function(_ref4, categoryIndex) {
                    var values = _ref4.values;
                    var _radiusRanges$categor = radiusRanges[categoryIndex], inner = _radiusRanges$categor.inner, outer = _radiusRanges$categor.outer;
                    values.forEach(function(value, seriesIndex) {
                      if (!isNull(value)) {
                        var degree = Math.max(value / scaleMaxLimitValue * totalAngle, 1) * (clockwise ? 1 : -1);
                        var prevModel = sectorModels[sectorModels.length - 1];
                        var startDegree = seriesIndex && prevModel ? prevModel.degree.end : defaultStartDegree;
                        var endDegree = clockwise ? Math.min(startDegree + degree, DEGREE_360) : Math.max(startDegree + degree, DEGREE_0);
                        var _ref5 = seriesData2[seriesIndex], name = _ref5.name, seriesColor = _ref5.color;
                        var color = _this5.getSeriesColor(name, seriesColor);
                        var sectorModel = {
                          type: "sector",
                          name,
                          color,
                          x: centerX,
                          y: centerY,
                          degree: {
                            start: startDegree,
                            end: endDegree
                          },
                          radius: {
                            inner,
                            outer
                          },
                          value,
                          style: [{
                            strokeStyle
                          }],
                          lineWidth,
                          clockwise,
                          totalAngle,
                          seriesColor,
                          seriesIndex,
                          index: categoryIndex,
                          drawingStartAngle: DEGREE_NEGATIVE_90
                        };
                        categoryMap[categories[categoryIndex]].push(sectorModel);
                        sectorModels.push(sectorModel);
                      }
                    });
                  });
                  return {
                    seriesModels: sectorModels,
                    categoryMap
                  };
                }
              }, {
                key: "getSeriesColor",
                value: function getSeriesColor(name, color) {
                  var _this$theme2 = this.theme, select = _this$theme2.select, areaOpacity = _this$theme2.areaOpacity;
                  var active = this.activeSeriesMap[name];
                  var selected = Object.values(this.activeSeriesMap).some(function(elem) {
                    return !elem;
                  });
                  return selected ? getRGBA(color, active ? select.areaOpacity : select.restSeries.areaOpacity) : getRGBA(color, areaOpacity);
                }
              }, {
                key: "makeTooltipData",
                value: function makeTooltipData(seriesModels, categories) {
                  var tooltipData = [];
                  seriesModels.forEach(function(_ref6) {
                    var seriesColor = _ref6.seriesColor, name = _ref6.name, value = _ref6.value, index = _ref6.index;
                    if (!isNull(value)) {
                      tooltipData.push({
                        label: name,
                        color: seriesColor,
                        value,
                        category: isNumber(index) ? categories[index] : ""
                      });
                    }
                  });
                  return tooltipData;
                }
              }, {
                key: "makeTooltipResponder",
                value: function makeTooltipResponder(responders) {
                  var _this6 = this;
                  var categories = Object.keys(this.models);
                  return responders.map(function(responder) {
                    return radialBarSeries_objectSpread(radialBarSeries_objectSpread({}, responder), getRadialAnchorPosition(makeAnchorPositionParam("center", _this6.models[categories[responder.index]].find(function(_ref7) {
                      var name = _ref7.name;
                      return name === responder.name;
                    }))));
                  });
                }
              }, {
                key: "getRadialBarSectorModelsFromResponders",
                value: function getRadialBarSectorModelsFromResponders(responders) {
                  var _this$tooltipSectorMa;
                  if (!responders.length) {
                    return [];
                  }
                  return (_this$tooltipSectorMa = this.tooltipSectorMap[responders[0].index]) !== null && _this$tooltipSectorMa !== void 0 ? _this$tooltipSectorMa : [];
                }
              }, {
                key: "getGroupedSector",
                value: function getGroupedSector(responders, type) {
                  var RadialBarSectorModels = this.getRadialBarSectorModelsFromResponders(responders);
                  var _ref8 = this.theme[type].groupedSector, color = _ref8.color, opacity = _ref8.opacity;
                  return RadialBarSectorModels.length ? responders.map(function(m) {
                    return radialBarSeries_objectSpread(radialBarSeries_objectSpread({}, m), {}, {
                      color: getRGBA(color, opacity)
                    });
                  }) : [];
                }
              }, {
                key: "onMousemoveGroupedType",
                value: function onMousemoveGroupedType(responders) {
                  var RadialBarSectorModels = this.getRadialBarSectorModelsFromResponders(responders);
                  this.eventBus.emit("renderHoveredSeries", {
                    models: this.getGroupedSector(responders, "hover"),
                    name: this.name,
                    eventDetectType: this.eventDetectType
                  });
                  this.activatedResponders = RadialBarSectorModels;
                }
              }, {
                key: "onMousemove",
                value: function onMousemove(_ref9) {
                  var responders = _ref9.responders;
                  if (this.eventDetectType === "grouped") {
                    this.onMousemoveGroupedType(responders);
                  } else {
                    this.eventBus.emit("renderHoveredSeries", {
                      models: this.getResponderModelsWithTheme(responders, "hover"),
                      name: this.name
                    });
                    this.activatedResponders = this.makeTooltipResponder(responders);
                  }
                  this.eventBus.emit("seriesPointHovered", {
                    models: this.activatedResponders,
                    name: this.name,
                    eventDetectType: this.eventDetectType
                  });
                  this.eventBus.emit("needDraw");
                }
              }, {
                key: "onClick",
                value: function onClick(_ref10) {
                  var responders = _ref10.responders;
                  if (this.selectable) {
                    var models;
                    if (this.eventDetectType === "grouped") {
                      models = [].concat(radialBarSeries_toConsumableArray(this.getGroupedSector(responders, "select")), radialBarSeries_toConsumableArray(this.getRadialBarSectorModelsFromResponders(responders)));
                    } else {
                      models = this.getResponderModelsWithTheme(responders, "select");
                    }
                    this.eventBus.emit("renderSelectedSeries", {
                      models,
                      name: this.name,
                      eventDetectType: this.eventDetectType
                    });
                    this.eventBus.emit("needDraw");
                  }
                }
              }, {
                key: "getResponderModelsWithTheme",
                value: function getResponderModelsWithTheme(responders, type) {
                  var theme2 = this.theme[type];
                  var lineWidth = theme2.lineWidth;
                  var isSameLineWidth = this.theme.lineWidth === lineWidth;
                  var thickness = isSameLineWidth ? 0 : lineWidth * 0.5;
                  return responders.map(function(m) {
                    var _theme$color;
                    return radialBarSeries_objectSpread(radialBarSeries_objectSpread({}, m), {}, {
                      color: (_theme$color = theme2 === null || theme2 === void 0 ? void 0 : theme2.color) !== null && _theme$color !== void 0 ? _theme$color : m.color,
                      lineWidth,
                      style: [pick(theme2, "strokeStyle", "shadowBlur", "shadowColor", "shadowOffsetX", "shadowOffsetY")],
                      radius: {
                        inner: Math.max(m.radius.inner - thickness, 0),
                        outer: m.radius.outer + thickness
                      }
                    });
                  });
                }
              }]);
              return RadialBarSeries2;
            }(Component);
            ;
            function radialBarChart_typeof(obj) {
              "@babel/helpers - typeof";
              if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                radialBarChart_typeof = function _typeof2(obj2) {
                  return typeof obj2;
                };
              } else {
                radialBarChart_typeof = function _typeof2(obj2) {
                  return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                };
              }
              return radialBarChart_typeof(obj);
            }
            function radialBarChart_ownKeys(object, enumerableOnly) {
              var keys = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object);
                if (enumerableOnly) {
                  symbols = symbols.filter(function(sym) {
                    return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                  });
                }
                keys.push.apply(keys, symbols);
              }
              return keys;
            }
            function radialBarChart_objectSpread(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i] != null ? arguments[i] : {};
                if (i % 2) {
                  radialBarChart_ownKeys(Object(source), true).forEach(function(key) {
                    radialBarChart_defineProperty(target, key, source[key]);
                  });
                } else if (Object.getOwnPropertyDescriptors) {
                  Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                } else {
                  radialBarChart_ownKeys(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  });
                }
              }
              return target;
            }
            function radialBarChart_defineProperty(obj, key, value) {
              if (key in obj) {
                Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
              } else {
                obj[key] = value;
              }
              return obj;
            }
            function radialBarChart_classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function radialBarChart_defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            function radialBarChart_createClass(Constructor, protoProps, staticProps) {
              if (protoProps)
                radialBarChart_defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                radialBarChart_defineProperties(Constructor, staticProps);
              return Constructor;
            }
            function radialBarChart_get(target, property, receiver) {
              if (typeof Reflect !== "undefined" && Reflect.get) {
                radialBarChart_get = Reflect.get;
              } else {
                radialBarChart_get = function _get2(target2, property2, receiver2) {
                  var base = radialBarChart_superPropBase(target2, property2);
                  if (!base)
                    return;
                  var desc = Object.getOwnPropertyDescriptor(base, property2);
                  if (desc.get) {
                    return desc.get.call(receiver2);
                  }
                  return desc.value;
                };
              }
              return radialBarChart_get(target, property, receiver || target);
            }
            function radialBarChart_superPropBase(object, property) {
              while (!Object.prototype.hasOwnProperty.call(object, property)) {
                object = radialBarChart_getPrototypeOf(object);
                if (object === null)
                  break;
              }
              return object;
            }
            function radialBarChart_inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function");
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
              if (superClass)
                radialBarChart_setPrototypeOf(subClass, superClass);
            }
            function radialBarChart_setPrototypeOf(o, p) {
              radialBarChart_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
                o2.__proto__ = p2;
                return o2;
              };
              return radialBarChart_setPrototypeOf(o, p);
            }
            function radialBarChart_createSuper(Derived) {
              var hasNativeReflectConstruct = radialBarChart_isNativeReflectConstruct();
              return function _createSuperInternal() {
                var Super = radialBarChart_getPrototypeOf(Derived), result;
                if (hasNativeReflectConstruct) {
                  var NewTarget = radialBarChart_getPrototypeOf(this).constructor;
                  result = Reflect.construct(Super, arguments, NewTarget);
                } else {
                  result = Super.apply(this, arguments);
                }
                return radialBarChart_possibleConstructorReturn(this, result);
              };
            }
            function radialBarChart_possibleConstructorReturn(self2, call) {
              if (call && (radialBarChart_typeof(call) === "object" || typeof call === "function")) {
                return call;
              }
              return radialBarChart_assertThisInitialized(self2);
            }
            function radialBarChart_assertThisInitialized(self2) {
              if (self2 === void 0) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return self2;
            }
            function radialBarChart_isNativeReflectConstruct() {
              if (typeof Reflect === "undefined" || !Reflect.construct)
                return false;
              if (Reflect.construct.sham)
                return false;
              if (typeof Proxy === "function")
                return true;
              try {
                Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                }));
                return true;
              } catch (e) {
                return false;
              }
            }
            function radialBarChart_getPrototypeOf(o) {
              radialBarChart_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
                return o2.__proto__ || Object.getPrototypeOf(o2);
              };
              return radialBarChart_getPrototypeOf(o);
            }
            var RadialBarChart = function(_Chart) {
              radialBarChart_inherits(RadialBarChart2, _Chart);
              var _super = radialBarChart_createSuper(RadialBarChart2);
              function RadialBarChart2(_ref) {
                var el = _ref.el, options2 = _ref.options, data = _ref.data;
                radialBarChart_classCallCheck(this, RadialBarChart2);
                return _super.call(this, {
                  el,
                  options: options2,
                  series: {
                    radialBar: data.series
                  },
                  categories: data.categories,
                  modules: [store_stackSeriesData, store_dataRange, store_scale, radialAxes]
                });
              }
              radialBarChart_createClass(RadialBarChart2, [{
                key: "initialize",
                value: function initialize() {
                  radialBarChart_get(radialBarChart_getPrototypeOf(RadialBarChart2.prototype), "initialize", this).call(this);
                  this.componentManager.add(Background);
                  this.componentManager.add(Title);
                  this.componentManager.add(Legend);
                  this.componentManager.add(RadarPlot);
                  this.componentManager.add(RadialBarSeries);
                  this.componentManager.add(HoveredSeries);
                  this.componentManager.add(SelectedSeries);
                  this.componentManager.add(DataLabels);
                  this.componentManager.add(RadialAxis);
                  this.componentManager.add(ExportMenu, {
                    chartEl: this.el
                  });
                  this.componentManager.add(Tooltip, {
                    chartEl: this.el
                  });
                  this.componentManager.add(NoDataText);
                  this.painter.addGroups([basic_namespaceObject, legend_namespaceObject, label_namespaceObject, brushes_exportMenu_namespaceObject, brushes_sector_namespaceObject, dataLabel_namespaceObject, axis_namespaceObject]);
                }
                /**
                 * Add series.
                 * @param {Object} data - Data to be added.
                 *   @param {string} data.name - Series name.
                 *   @param {Array<number>} data.data - Array of data to be added.
                 * @api
                 * @example
                 * chart.addSeries({
                 *   name: 'newSeries',
                 *   data: [10, 20, 30, 40],
                 * });
                 */
              }, {
                key: "addSeries",
                value: function addSeries(data) {
                  this.resetSeries();
                  this.store.dispatch("addSeries", {
                    data
                  });
                }
                /**
                 * Convert the chart data to new data.
                 * @param {Object} data - Data to be set.
                 * @api
                 * @example
                 * chart.setData({
                 *   categories: ['1', '2', '3'],
                 *   series: [
                 *     {
                 *       name: 'new series',
                 *       data: [1, 2, 3],
                 *     },
                 *     {
                 *       name: 'new series2',
                 *       data: [4, 5, 6],
                 *     }
                 *   ]
                 * });
                 */
              }, {
                key: "setData",
                value: function setData(data) {
                  var categories = data.categories, series = data.series;
                  this.resetSeries();
                  this.store.dispatch("setData", {
                    series: {
                      radialBar: series
                    },
                    categories
                  });
                }
                /**
                 * Hide series data label.
                 * @api
                 * @example
                 * chart.hideSeriesDataLabel();
                 */
              }, {
                key: "hideSeriesDataLabel",
                value: function hideSeriesDataLabel() {
                  this.store.dispatch("updateOptions", {
                    options: {
                      series: {
                        dataLabels: {
                          visible: false
                        }
                      }
                    }
                  });
                }
                /**
                 * Show series data label.
                 * @api
                 * @example
                 * chart.showSeriesDataLabel();
                 */
              }, {
                key: "showSeriesDataLabel",
                value: function showSeriesDataLabel() {
                  this.store.dispatch("updateOptions", {
                    options: {
                      series: {
                        dataLabels: {
                          visible: true
                        }
                      }
                    }
                  });
                }
                /**
                 * Convert the chart options to new options.
                 * @param {Object} options - Chart options.
                 * @api
                 * @example
                 * chart.setOptions({
                 *   chart: {
                 *     width: 500,
                 *     height: 500,
                 *     title: 'Olympic Medals',
                 *   },
                 *   series: {
                 *     selectable: true
                 *   }
                 * });
                 */
              }, {
                key: "setOptions",
                value: function setOptions(options2) {
                  this.resetSeries();
                  this.dispatchOptionsEvent("initOptions", options2);
                }
                /**
                 * Update chart options.
                 * @param {Object} options - Chart options.
                 * @api
                 * @example
                 * chart.updateOptions({
                 *   chart: {
                 *     title: 'Olympic Medals',
                 *   },
                 *   series: {
                 *     eventDetectType: 'grouped'
                 *   }
                 * });
                 */
              }, {
                key: "updateOptions",
                value: function updateOptions(options2) {
                  this.resetSeries();
                  this.dispatchOptionsEvent("updateOptions", options2);
                }
                /**
                 * Show tooltip.
                 * @param {Object} seriesInfo - Information of the series for the tooltip to be displayed.
                 *      @param {number} seriesInfo.index - Index of data within series. If 'series.eventDetectType' is "grouped", only index is needed.
                 *      @param {number} [seriesInfo.seriesIndex] - Index of series
                 * @api
                 * @example
                 * // eventDetectType is 'grouped'
                 * chart.showTooltip({index: 1});
                 *
                 * // eventDetectType is 'point'
                 * chart.showTooltip({index: 1, seriesIndex: 2});
                 */
              }, {
                key: "showTooltip",
                value: function showTooltip(seriesInfo) {
                  this.eventBus.emit("showTooltip", radialBarChart_objectSpread(radialBarChart_objectSpread({}, seriesInfo), {}, {
                    state: this.store.state
                  }));
                }
                /**
                 * Hide tooltip.
                 * @api
                 * @example
                 * chart.hideTooltip();
                 */
              }, {
                key: "hideTooltip",
                value: function hideTooltip() {
                  this.eventBus.emit("hideTooltip");
                }
              }]);
              return RadialBarChart2;
            }(Chart);
            ;
            function gaugeAxes_toConsumableArray(arr) {
              return gaugeAxes_arrayWithoutHoles(arr) || gaugeAxes_iterableToArray(arr) || gaugeAxes_unsupportedIterableToArray(arr) || gaugeAxes_nonIterableSpread();
            }
            function gaugeAxes_nonIterableSpread() {
              throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            function gaugeAxes_unsupportedIterableToArray(o, minLen) {
              if (!o)
                return;
              if (typeof o === "string")
                return gaugeAxes_arrayLikeToArray(o, minLen);
              var n = Object.prototype.toString.call(o).slice(8, -1);
              if (n === "Object" && o.constructor)
                n = o.constructor.name;
              if (n === "Map" || n === "Set")
                return Array.from(o);
              if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                return gaugeAxes_arrayLikeToArray(o, minLen);
            }
            function gaugeAxes_iterableToArray(iter) {
              if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
                return Array.from(iter);
            }
            function gaugeAxes_arrayWithoutHoles(arr) {
              if (Array.isArray(arr))
                return gaugeAxes_arrayLikeToArray(arr);
            }
            function gaugeAxes_arrayLikeToArray(arr, len) {
              if (len == null || len > arr.length)
                len = arr.length;
              for (var i = 0, arr2 = new Array(len); i < len; i++) {
                arr2[i] = arr[i];
              }
              return arr2;
            }
            function gaugeAxes_ownKeys(object, enumerableOnly) {
              var keys = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object);
                if (enumerableOnly) {
                  symbols = symbols.filter(function(sym) {
                    return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                  });
                }
                keys.push.apply(keys, symbols);
              }
              return keys;
            }
            function gaugeAxes_objectSpread(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i] != null ? arguments[i] : {};
                if (i % 2) {
                  gaugeAxes_ownKeys(Object(source), true).forEach(function(key) {
                    gaugeAxes_defineProperty(target, key, source[key]);
                  });
                } else if (Object.getOwnPropertyDescriptors) {
                  Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                } else {
                  gaugeAxes_ownKeys(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  });
                }
              }
              return target;
            }
            function gaugeAxes_defineProperty(obj, key, value) {
              if (key in obj) {
                Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
              } else {
                obj[key] = value;
              }
              return obj;
            }
            var DEFAULT_LABEL_PADDING = 15;
            var RANGE_BAR_MARGIN = 10;
            var CLOCK_HAND_MARGIN = 10;
            var DATA_LABEL_MARGIN = 30;
            function makeSolidData(outerRadius, barWidth, solidOptions) {
              var initialSolidOptions = solidOptions !== null && solidOptions !== void 0 ? solidOptions : false;
              var solidBarWidth = calculateSizeWithPercentString(outerRadius, barWidth);
              var defaultSolidOptions = {
                visible: true,
                radiusRange: {
                  inner: outerRadius - solidBarWidth,
                  outer: outerRadius
                },
                barWidth: solidBarWidth,
                clockHand: false
              };
              if (!initialSolidOptions) {
                return gaugeAxes_objectSpread(gaugeAxes_objectSpread({}, defaultSolidOptions), {}, {
                  visible: false
                });
              }
              return isObject(initialSolidOptions) ? gaugeAxes_objectSpread(gaugeAxes_objectSpread({}, defaultSolidOptions), initialSolidOptions) : defaultSolidOptions;
            }
            function gaugeAxes_getCircularAxisData(_ref) {
              var _options$series, _options$circularAxis;
              var labels = _ref.labels, intervalData = _ref.intervalData, circularAxisLabelMargin = _ref.circularAxisLabelMargin, circularAxisLabelFont = _ref.circularAxisLabelFont, defaultAxisData = _ref.defaultAxisData, bandWidth = _ref.bandWidth, options2 = _ref.options, solidBarWidth = _ref.solidBarWidth;
              var _getMaxLabelSize = getMaxLabelSize(labels, circularAxisLabelMargin, circularAxisLabelFont), maxLabelWidth = _getMaxLabelSize.maxLabelWidth, maxLabelHeight = _getMaxLabelSize.maxLabelHeight;
              var totalAngle = defaultAxisData.totalAngle, axisSize = defaultAxisData.axisSize, centerX = defaultAxisData.centerX, centerY = defaultAxisData.centerY, startAngle = defaultAxisData.startAngle, endAngle = defaultAxisData.endAngle, drawingStartAngle = defaultAxisData.drawingStartAngle, clockwise = defaultAxisData.clockwise;
              var tickInterval = intervalData.tickInterval, labelInterval = intervalData.labelInterval;
              var outerRadius = axisSize - bandWidth - RANGE_BAR_MARGIN;
              var solidBarWidthValue = solidBarWidth !== null && solidBarWidth !== void 0 ? solidBarWidth : outerRadius * 0.1;
              var solidData = makeSolidData(outerRadius - circularAxisLabelMargin - maxLabelHeight - (circularAxisLabelMargin - 5), solidBarWidthValue, options2 === null || options2 === void 0 ? void 0 : (_options$series = options2.series) === null || _options$series === void 0 ? void 0 : _options$series.solid);
              var centralAngle = totalAngle / (labels.length + (totalAngle < DEGREE_360 ? -1 : DEGREE_0));
              var maxClockHandSize = outerRadius - circularAxisLabelMargin - maxLabelHeight - CLOCK_HAND_MARGIN + (solidData.visible ? -solidData.barWidth - CLOCK_HAND_MARGIN : 0);
              return {
                axisSize,
                centerX,
                centerY,
                label: {
                  labels,
                  interval: labelInterval,
                  margin: circularAxisLabelMargin,
                  maxWidth: maxLabelWidth,
                  maxHeight: maxLabelHeight
                },
                radius: {
                  inner: 0,
                  outer: outerRadius
                },
                angle: {
                  start: startAngle,
                  end: endAngle,
                  total: totalAngle,
                  central: centralAngle,
                  drawingStart: drawingStartAngle
                },
                band: {
                  width: bandWidth,
                  margin: RANGE_BAR_MARGIN
                },
                tickInterval,
                clockwise,
                maxClockHandSize,
                title: makeTitleOption(options2 === null || options2 === void 0 ? void 0 : (_options$circularAxis = options2.circularAxis) === null || _options$circularAxis === void 0 ? void 0 : _options$circularAxis.title),
                solidData
              };
            }
            function gaugeAxes_makeLabels(options2, rawLabels, axisName) {
              var _options$axisName$lab, _options$axisName, _options$axisName$lab2;
              var formatter = (_options$axisName$lab = (_options$axisName = options2[axisName]) === null || _options$axisName === void 0 ? void 0 : (_options$axisName$lab2 = _options$axisName.label) === null || _options$axisName$lab2 === void 0 ? void 0 : _options$axisName$lab2.formatter) !== null && _options$axisName$lab !== void 0 ? _options$axisName$lab : function(value) {
                return value;
              };
              return rawLabels.map(function(label2, index) {
                return formatter(label2, {
                  index,
                  labels: rawLabels,
                  axisName
                });
              });
            }
            function gaugeAxes_getAxisLabels(isLabelOnVerticalAxis, options2, categories, scale2) {
              var valueAxisName = isLabelOnVerticalAxis ? RadialAxisType.CIRCULAR : RadialAxisType.VERTICAL;
              var _ref2 = scale2[valueAxisName], limit = _ref2.limit, stepSize = _ref2.stepSize;
              var valueLabels = gaugeAxes_makeLabels(options2, makeLabelsFromLimit(limit, stepSize), valueAxisName);
              var categoryLabels = gaugeAxes_makeLabels(options2, categories, isLabelOnVerticalAxis ? RadialAxisType.VERTICAL : RadialAxisType.CIRCULAR);
              return isLabelOnVerticalAxis ? valueLabels : categoryLabels;
            }
            function gaugeAxes_getAxisLabelMargin(options2) {
              var _options$circularAxis2, _options$circularAxis3, _options$circularAxis4;
              return (_options$circularAxis2 = options2 === null || options2 === void 0 ? void 0 : (_options$circularAxis3 = options2.circularAxis) === null || _options$circularAxis3 === void 0 ? void 0 : (_options$circularAxis4 = _options$circularAxis3.label) === null || _options$circularAxis4 === void 0 ? void 0 : _options$circularAxis4.margin) !== null && _options$circularAxis2 !== void 0 ? _options$circularAxis2 : DEFAULT_LABEL_PADDING;
            }
            function gaugeAxes_hasAxesLayoutChanged(previousAxes, currentAxes) {
              var _previousAxes$label, _previousAxes$label2;
              var prevMaxWidth = previousAxes === null || previousAxes === void 0 ? void 0 : (_previousAxes$label = previousAxes.label) === null || _previousAxes$label === void 0 ? void 0 : _previousAxes$label.maxWidth;
              var prevMaxHeight = previousAxes === null || previousAxes === void 0 ? void 0 : (_previousAxes$label2 = previousAxes.label) === null || _previousAxes$label2 === void 0 ? void 0 : _previousAxes$label2.maxHeight;
              var curMaxWidth = currentAxes.label.maxWidth;
              var curMaxHeight = currentAxes.label.maxHeight;
              return prevMaxHeight !== curMaxHeight || prevMaxWidth !== curMaxWidth;
            }
            var gaugeAxes_axes = {
              name: "gaugeAxes",
              state: function state() {
                return {
                  radialAxes: {
                    circularAxis: {}
                  }
                };
              },
              action: {
                setCircularAxisData: function setCircularAxisData(_ref3) {
                  var _options$series$dataL, _options$series2, _options$series2$data, _plot, _plot$bands, _bands$barWidth, _theme$plot, _theme$plot$bands, _theme$series$gauge, _theme$series$gauge$s, _state$radialAxes;
                  var state = _ref3.state;
                  var series = state.series, layout2 = state.layout, scale2 = state.scale;
                  var categories = state.categories;
                  var plot2 = layout2.plot;
                  var isLabelOnVerticalAxis = isLabelAxisOnYAxis({
                    series,
                    categories
                  });
                  var options2 = state.options;
                  var theme2 = state.theme;
                  var circularAxisLabelFont = getTitleFontString(theme2.circularAxis.label);
                  var circularAxisLabelMargin = gaugeAxes_getAxisLabelMargin(options2);
                  var circularAxisLabels = gaugeAxes_getAxisLabels(isLabelOnVerticalAxis, options2, categories, scale2);
                  var _getMaxLabelSize2 = getMaxLabelSize(circularAxisLabels, circularAxisLabelMargin, circularAxisLabelFont), maxLabelWidth = _getMaxLabelSize2.maxLabelWidth, maxLabelHeight = _getMaxLabelSize2.maxLabelHeight;
                  var defaultAxisData = getDefaultRadialAxisData(options2, plot2, maxLabelWidth, maxLabelHeight, isLabelOnVerticalAxis);
                  var dataLabelHeight = getFontHeight(getTitleFontString(theme2.series.gauge.dataLabels));
                  var dataLabelOffsetY = (_options$series$dataL = options2 === null || options2 === void 0 ? void 0 : (_options$series2 = options2.series) === null || _options$series2 === void 0 ? void 0 : (_options$series2$data = _options$series2.dataLabels) === null || _options$series2$data === void 0 ? void 0 : _options$series2$data.offsetY) !== null && _options$series$dataL !== void 0 ? _options$series$dataL : DATA_LABEL_MARGIN;
                  if (defaultAxisData.isSemiCircular) {
                    defaultAxisData.centerY = defaultAxisData.centerY - (dataLabelOffsetY > 0 ? dataLabelOffsetY + dataLabelHeight : 0);
                    var diffHeight = defaultAxisData.centerY - defaultAxisData.axisSize;
                    defaultAxisData.axisSize += diffHeight < 0 ? diffHeight : 0;
                  }
                  var defualtBandWidth = options2 !== null && options2 !== void 0 && (_plot = options2.plot) !== null && _plot !== void 0 && (_plot$bands = _plot.bands) !== null && _plot$bands !== void 0 && _plot$bands.length ? defaultAxisData.axisSize / 2 - RANGE_BAR_MARGIN : 0;
                  var bandWidth = (_bands$barWidth = (_theme$plot = theme2.plot) === null || _theme$plot === void 0 ? void 0 : (_theme$plot$bands = _theme$plot.bands) === null || _theme$plot$bands === void 0 ? void 0 : _theme$plot$bands.barWidth) !== null && _bands$barWidth !== void 0 ? _bands$barWidth : defualtBandWidth;
                  var circularAxisData = gaugeAxes_getCircularAxisData({
                    labels: circularAxisLabels,
                    intervalData: getInitAxisIntervalData(true, {
                      axis: options2.circularAxis,
                      categories,
                      layout: layout2
                    }),
                    defaultAxisData,
                    circularAxisLabelMargin,
                    circularAxisLabelFont,
                    bandWidth,
                    options: options2,
                    solidBarWidth: (_theme$series$gauge = theme2.series.gauge) === null || _theme$series$gauge === void 0 ? void 0 : (_theme$series$gauge$s = _theme$series$gauge.solid) === null || _theme$series$gauge$s === void 0 ? void 0 : _theme$series$gauge$s.barWidth
                  });
                  if (gaugeAxes_hasAxesLayoutChanged((_state$radialAxes = state.radialAxes) === null || _state$radialAxes === void 0 ? void 0 : _state$radialAxes.circularAxis, circularAxisData)) {
                    this.notify(state, "layout");
                  }
                  state.radialAxes = {
                    circularAxis: circularAxisData
                  };
                },
                addGaugePlotBand: function addGaugePlotBand(_ref4, _ref5) {
                  var _plot$bands2, _state$options, _state$options$plot;
                  var state = _ref4.state;
                  var data = _ref5.data;
                  var bands = (_plot$bands2 = (_state$options = state.options) === null || _state$options === void 0 ? void 0 : (_state$options$plot = _state$options.plot) === null || _state$options$plot === void 0 ? void 0 : _state$options$plot.bands) !== null && _plot$bands2 !== void 0 ? _plot$bands2 : [];
                  if (!isExistPlotId(bands, data)) {
                    this.dispatch("updateOptions", {
                      options: {
                        plot: {
                          bands: [].concat(gaugeAxes_toConsumableArray(bands), [data])
                        }
                      }
                    });
                  }
                },
                removeGaugePlotBand: function removeGaugePlotBand(_ref6, _ref7) {
                  var _plot$bands3, _state$options2, _state$options2$plot;
                  var state = _ref6.state;
                  var id = _ref7.id;
                  var bands = ((_plot$bands3 = (_state$options2 = state.options) === null || _state$options2 === void 0 ? void 0 : (_state$options2$plot = _state$options2.plot) === null || _state$options2$plot === void 0 ? void 0 : _state$options2$plot.bands) !== null && _plot$bands3 !== void 0 ? _plot$bands3 : []).filter(function(_ref8) {
                    var bandId = _ref8.id;
                    return bandId !== id;
                  });
                  this.dispatch("updateOptions", {
                    options: {
                      plot: {
                        bands
                      }
                    }
                  });
                }
              },
              observe: {
                updateRadialAxes: function updateRadialAxes() {
                  this.dispatch("setCircularAxisData");
                }
              }
            };
            var gaugeAxes = gaugeAxes_axes;
            ;
            function gaugeSeries_typeof(obj) {
              "@babel/helpers - typeof";
              if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                gaugeSeries_typeof = function _typeof2(obj2) {
                  return typeof obj2;
                };
              } else {
                gaugeSeries_typeof = function _typeof2(obj2) {
                  return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                };
              }
              return gaugeSeries_typeof(obj);
            }
            function gaugeSeries_toConsumableArray(arr) {
              return gaugeSeries_arrayWithoutHoles(arr) || gaugeSeries_iterableToArray(arr) || gaugeSeries_unsupportedIterableToArray(arr) || gaugeSeries_nonIterableSpread();
            }
            function gaugeSeries_nonIterableSpread() {
              throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            function gaugeSeries_unsupportedIterableToArray(o, minLen) {
              if (!o)
                return;
              if (typeof o === "string")
                return gaugeSeries_arrayLikeToArray(o, minLen);
              var n = Object.prototype.toString.call(o).slice(8, -1);
              if (n === "Object" && o.constructor)
                n = o.constructor.name;
              if (n === "Map" || n === "Set")
                return Array.from(o);
              if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                return gaugeSeries_arrayLikeToArray(o, minLen);
            }
            function gaugeSeries_iterableToArray(iter) {
              if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
                return Array.from(iter);
            }
            function gaugeSeries_arrayWithoutHoles(arr) {
              if (Array.isArray(arr))
                return gaugeSeries_arrayLikeToArray(arr);
            }
            function gaugeSeries_arrayLikeToArray(arr, len) {
              if (len == null || len > arr.length)
                len = arr.length;
              for (var i = 0, arr2 = new Array(len); i < len; i++) {
                arr2[i] = arr[i];
              }
              return arr2;
            }
            function gaugeSeries_ownKeys(object, enumerableOnly) {
              var keys = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object);
                if (enumerableOnly) {
                  symbols = symbols.filter(function(sym) {
                    return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                  });
                }
                keys.push.apply(keys, symbols);
              }
              return keys;
            }
            function gaugeSeries_objectSpread(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i] != null ? arguments[i] : {};
                if (i % 2) {
                  gaugeSeries_ownKeys(Object(source), true).forEach(function(key) {
                    gaugeSeries_defineProperty(target, key, source[key]);
                  });
                } else if (Object.getOwnPropertyDescriptors) {
                  Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                } else {
                  gaugeSeries_ownKeys(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  });
                }
              }
              return target;
            }
            function gaugeSeries_classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function gaugeSeries_defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            function gaugeSeries_createClass(Constructor, protoProps, staticProps) {
              if (protoProps)
                gaugeSeries_defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                gaugeSeries_defineProperties(Constructor, staticProps);
              return Constructor;
            }
            function gaugeSeries_inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function");
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
              if (superClass)
                gaugeSeries_setPrototypeOf(subClass, superClass);
            }
            function gaugeSeries_setPrototypeOf(o, p) {
              gaugeSeries_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
                o2.__proto__ = p2;
                return o2;
              };
              return gaugeSeries_setPrototypeOf(o, p);
            }
            function gaugeSeries_createSuper(Derived) {
              var hasNativeReflectConstruct = gaugeSeries_isNativeReflectConstruct();
              return function _createSuperInternal() {
                var Super = gaugeSeries_getPrototypeOf(Derived), result;
                if (hasNativeReflectConstruct) {
                  var NewTarget = gaugeSeries_getPrototypeOf(this).constructor;
                  result = Reflect.construct(Super, arguments, NewTarget);
                } else {
                  result = Super.apply(this, arguments);
                }
                return gaugeSeries_possibleConstructorReturn(this, result);
              };
            }
            function gaugeSeries_possibleConstructorReturn(self2, call) {
              if (call && (gaugeSeries_typeof(call) === "object" || typeof call === "function")) {
                return call;
              }
              return gaugeSeries_assertThisInitialized(self2);
            }
            function gaugeSeries_assertThisInitialized(self2) {
              if (self2 === void 0) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return self2;
            }
            function gaugeSeries_isNativeReflectConstruct() {
              if (typeof Reflect === "undefined" || !Reflect.construct)
                return false;
              if (Reflect.construct.sham)
                return false;
              if (typeof Proxy === "function")
                return true;
              try {
                Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                }));
                return true;
              } catch (e) {
                return false;
              }
            }
            function gaugeSeries_getPrototypeOf(o) {
              gaugeSeries_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
                return o2.__proto__ || Object.getPrototypeOf(o2);
              };
              return gaugeSeries_getPrototypeOf(o);
            }
            function gaugeSeries_defineProperty(obj, key, value) {
              if (key in obj) {
                Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
              } else {
                obj[key] = value;
              }
              return obj;
            }
            var DETECTION_SIZE_MARGIN = 3;
            var GaugeSeries = function(_Component) {
              gaugeSeries_inherits(GaugeSeries2, _Component);
              var _super = gaugeSeries_createSuper(GaugeSeries2);
              function GaugeSeries2() {
                var _this;
                gaugeSeries_classCallCheck(this, GaugeSeries2);
                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }
                _this = _super.call.apply(_super, [this].concat(args));
                gaugeSeries_defineProperty(gaugeSeries_assertThisInitialized(_this), "models", {
                  clockHand: [],
                  solid: [],
                  backgroundSolid: []
                });
                gaugeSeries_defineProperty(gaugeSeries_assertThisInitialized(_this), "drawModels", void 0);
                gaugeSeries_defineProperty(gaugeSeries_assertThisInitialized(_this), "responders", void 0);
                gaugeSeries_defineProperty(gaugeSeries_assertThisInitialized(_this), "activatedResponders", []);
                gaugeSeries_defineProperty(gaugeSeries_assertThisInitialized(_this), "tooltipMap", void 0);
                gaugeSeries_defineProperty(gaugeSeries_assertThisInitialized(_this), "theme", void 0);
                gaugeSeries_defineProperty(gaugeSeries_assertThisInitialized(_this), "circularAxis", void 0);
                gaugeSeries_defineProperty(gaugeSeries_assertThisInitialized(_this), "onMouseoutComponent", function() {
                  _this.eventBus.emit("seriesPointHovered", {
                    models: [],
                    name: _this.name
                  });
                  _this.eventBus.emit("renderHoveredSeries", {
                    models: [],
                    name: _this.name
                  });
                  _this.eventBus.emit("needDraw");
                });
                gaugeSeries_defineProperty(gaugeSeries_assertThisInitialized(_this), "selectSeries", function(info) {
                  var _this$tooltipMap$cloc;
                  var index = info.index;
                  if (!isNumber(index)) {
                    return;
                  }
                  var model = (_this$tooltipMap$cloc = _this.tooltipMap.clockHand[index]) !== null && _this$tooltipMap$cloc !== void 0 ? _this$tooltipMap$cloc : _this.tooltipMap.solid[index];
                  if (!model) {
                    return;
                  }
                  var models = _this.getResponderModelsWithTheme(_this.getResponderModels([model]), "select");
                  if (!models.length) {
                    throw new Error(message.SELECT_SERIES_API_INDEX_ERROR);
                  }
                  _this.eventBus.emit("renderSelectedSeries", {
                    models,
                    name: _this.name
                  });
                  _this.eventBus.emit("needDraw");
                });
                gaugeSeries_defineProperty(gaugeSeries_assertThisInitialized(_this), "showTooltip", function(info) {
                  var index = info.index;
                  var models = _this.getResponderModelsWithTheme([_this.tooltipMap.clockHand[index]], "hover");
                  if (!models.length) {
                    return;
                  }
                  _this.eventBus.emit("renderHoveredSeries", {
                    models,
                    name: _this.name
                  });
                  _this.activatedResponders = models;
                  _this.eventBus.emit("seriesPointHovered", {
                    models: _this.activatedResponders,
                    name: _this.name
                  });
                  _this.eventBus.emit("needDraw");
                });
                return _this;
              }
              gaugeSeries_createClass(GaugeSeries2, [{
                key: "initialize",
                value: function initialize() {
                  this.type = "series";
                  this.name = "gauge";
                  this.eventBus.on("selectSeries", this.selectSeries);
                  this.eventBus.on("showTooltip", this.showTooltip);
                  this.eventBus.on("hideTooltip", this.onMouseoutComponent);
                }
              }, {
                key: "initUpdate",
                value: function initUpdate(delta) {
                  var _this2 = this;
                  if (!this.drawModels) {
                    return;
                  }
                  var _this$circularAxis = this.circularAxis, _this$circularAxis$an = _this$circularAxis.angle, startAngle = _this$circularAxis$an.start, totalAngle = _this$circularAxis$an.total, clockwise = _this$circularAxis.clockwise;
                  var currentDegree = clockwise ? startAngle + totalAngle * delta : startAngle - totalAngle * delta;
                  this.models.clockHand.forEach(function(model, index) {
                    var x = model.x, y = model.y, animationDegree = model.animationDegree, handSize = model.handSize;
                    if (clockwise && animationDegree < currentDegree || !clockwise && animationDegree > currentDegree) {
                      _this2.syncEndAngle(index);
                      return;
                    }
                    var _getRadialPosition = getRadialPosition(x, y, handSize, calculateDegreeToRadian(calculateValidAngle(currentDegree))), x2 = _getRadialPosition.x, y2 = _getRadialPosition.y;
                    _this2.drawModels.clockHand[index].x2 = x2;
                    _this2.drawModels.clockHand[index].y2 = y2;
                  });
                  this.models.solid.forEach(function() {
                    var index = _this2.models.solid.findIndex(function(_ref) {
                      var animationDegree = _ref.animationDegree;
                      var _ref2 = animationDegree, start = _ref2.start, end = _ref2.end;
                      return withinRadian(clockwise, start, end, currentDegree);
                    });
                    _this2.syncSectorEndAngle(index < 0 ? _this2.models.solid.length : index);
                    if (index !== -1) {
                      _this2.drawModels.solid[index].degree.end = calculateValidAngle(currentDegree);
                    }
                  });
                }
              }, {
                key: "updateModels",
                value: function updateModels(current, target, delta) {
                  var total = this.circularAxis.angle.total;
                  Object.keys(current).forEach(function(key) {
                    if (!current || !target) {
                      return;
                    }
                    if (key[0] !== "_") {
                      if (isNumber(current[key])) {
                        current[key] = current[key] + (target[key] - current[key]) * delta;
                      } else if (key === "degree") {
                        if (total < DEGREE_360 && current.degree.end < DEGREE_90) {
                          current[key].end = DEGREE_360 + current[key].end - (DEGREE_360 - target[key].end + current[key].end) * delta;
                        } else {
                          current[key].end = current[key].end + (target[key].end - current[key].end) * delta;
                        }
                      } else {
                        current[key] = target[key];
                      }
                    }
                  });
                }
              }, {
                key: "update",
                value: function update(delta) {
                  var _this3 = this;
                  this.models.clockHand.forEach(function(model, index) {
                    _this3.updateModels(_this3.drawModels.clockHand[index], model, delta);
                  });
                  this.models.solid.forEach(function(model, index) {
                    _this3.updateModels(_this3.drawModels.solid[index], model, delta);
                  });
                }
              }, {
                key: "syncEndAngle",
                value: function syncEndAngle(index) {
                  var model = this.models.clockHand[index];
                  var drawModel = this.drawModels.clockHand[index];
                  if (model.x2 !== drawModel.x2 || model.y2 !== drawModel.y2) {
                    drawModel.x2 = model.x2;
                    drawModel.y2 = model.y2;
                  }
                }
              }, {
                key: "syncSectorEndAngle",
                value: function syncSectorEndAngle(index) {
                  if (!index) {
                    return;
                  }
                  for (var i = 0; i < index; i += 1) {
                    var prevTargetEndDegree = this.models.solid[i].degree.end;
                    if (this.drawModels.solid[i].degree.end !== prevTargetEndDegree) {
                      this.drawModels.solid[i].degree.end = prevTargetEndDegree;
                    }
                  }
                }
              }, {
                key: "render",
                value: function render(chartState) {
                  var _ref3;
                  var layout2 = chartState.layout, series = chartState.series, legend2 = chartState.legend, options2 = chartState.options, theme2 = chartState.theme, scale2 = chartState.scale, radialAxes2 = chartState.radialAxes;
                  var categories = (_ref3 = chartState.categories) !== null && _ref3 !== void 0 ? _ref3 : [];
                  if (!series.gauge) {
                    throw new Error(message.noDataError(this.name));
                  }
                  this.theme = theme2.series.gauge;
                  this.rect = layout2.plot;
                  this.circularAxis = radialAxes2.circularAxis;
                  this.activeSeriesMap = getActiveSeriesMap(legend2);
                  this.selectable = this.getSelectableOption(options2);
                  var seriesData2 = series.gauge.data;
                  var hasCategoryAxis = !isLabelAxisOnYAxis({
                    series,
                    categories
                  });
                  var renderOptions = this.makeRenderOptions(hasCategoryAxis, categories, scale2, options2 === null || options2 === void 0 ? void 0 : options2.series);
                  var clockHandModels = this.renderClockHands(seriesData2, renderOptions);
                  this.models.clockHand = renderOptions.useClockHand ? clockHandModels : [];
                  var solidModels = this.renderSolidModels(seriesData2, clockHandModels, renderOptions);
                  var tooltipData = this.makeTooltipData(clockHandModels);
                  if (!this.drawModels) {
                    this.initDrawModels();
                  }
                  if (getDataLabelsOptions(options2, this.name).visible) {
                    var _clockHandModels$ = clockHandModels[0], value = _clockHandModels$.value, name = _clockHandModels$.name, x = _clockHandModels$.x, y = _clockHandModels$.y, data = _clockHandModels$.seriesData;
                    this.renderDataLabels([{
                      type: "point",
                      theme: this.theme.dataLabels,
                      value,
                      name,
                      x,
                      y: y + DATA_LABEL_MARGIN,
                      data
                    }]);
                  }
                  this.tooltipMap = this.makeTooltipMap(tooltipData, renderOptions);
                  this.responders = this.getResponders(clockHandModels, solidModels, tooltipData, renderOptions.useClockHand);
                }
              }, {
                key: "renderSolidModels",
                value: function renderSolidModels(seriesData2, clockHandModels, renderOptions) {
                  var solidModels = [];
                  this.models.clockHand = renderOptions.useClockHand ? clockHandModels : [];
                  if (renderOptions.solidData.visible) {
                    solidModels = this.renderSectors(seriesData2, renderOptions);
                    this.models.backgroundSolid = this.renderBackgroundSolid(renderOptions);
                    this.models.solid = solidModels;
                  }
                  return solidModels;
                }
              }, {
                key: "initDrawModels",
                value: function initDrawModels() {
                  var start = this.circularAxis.angle.start;
                  this.drawModels = {
                    clockHand: this.models.clockHand.map(function(m) {
                      var _getRadialPosition2 = getRadialPosition(m.x, m.y, m.handSize, calculateDegreeToRadian(start)), x2 = _getRadialPosition2.x, y2 = _getRadialPosition2.y;
                      return gaugeSeries_objectSpread(gaugeSeries_objectSpread({}, m), {}, {
                        x2,
                        y2,
                        testDegree: 0
                      });
                    }),
                    backgroundSolid: this.models.backgroundSolid,
                    solid: this.models.solid.map(function(m) {
                      return gaugeSeries_objectSpread(gaugeSeries_objectSpread({}, m), {}, {
                        degree: gaugeSeries_objectSpread(gaugeSeries_objectSpread({}, m.degree), {}, {
                          end: m.degree.start
                        })
                      });
                    })
                  };
                }
              }, {
                key: "getResponders",
                value: function getResponders(clockHandModels, sectorModels, tooltipData) {
                  var useClockHand = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
                  var clockHandResponders = !useClockHand ? [] : clockHandModels.map(function(m, index) {
                    return gaugeSeries_objectSpread(gaugeSeries_objectSpread({}, m), {}, {
                      detectionSize: m.baseLine + DETECTION_SIZE_MARGIN,
                      data: gaugeSeries_objectSpread({}, tooltipData[index])
                    });
                  });
                  return sectorModels.length ? [].concat(gaugeSeries_toConsumableArray(sectorModels.map(function(m, index) {
                    return gaugeSeries_objectSpread(gaugeSeries_objectSpread({}, m), {}, {
                      data: gaugeSeries_objectSpread({}, tooltipData[index])
                    });
                  })), gaugeSeries_toConsumableArray(clockHandResponders)) : clockHandResponders;
                }
              }, {
                key: "getHandSize",
                value: function getHandSize(size) {
                  var index = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
                  var maxClockHandSize = this.circularAxis.maxClockHandSize;
                  if (size) {
                    return Array.isArray(size) ? calculateSizeWithPercentString(maxClockHandSize, size[index]) : calculateSizeWithPercentString(maxClockHandSize, size);
                  }
                  return maxClockHandSize;
                }
              }, {
                key: "renderClockHands",
                value: function renderClockHands(seriesData2, renderOptions) {
                  var _this4 = this;
                  var centerX = renderOptions.centerX, centerY = renderOptions.centerY, totalAngle = renderOptions.totalAngle, clockwise = renderOptions.clockwise, scaleMaxLimitValue = renderOptions.scaleMaxLimitValue, categories = renderOptions.categories, drawingStartAngle = renderOptions.drawingStartAngle;
                  var seriesModels = [];
                  var _this$theme$clockHand = this.theme.clockHand, size = _this$theme$clockHand.size, baseLine = _this$theme$clockHand.baseLine, clockHandColor = _this$theme$clockHand.color;
                  var _this$theme$pin = this.theme.pin, radius = _this$theme$pin.radius, pinColor = _this$theme$pin.color, borderWidth = _this$theme$pin.borderWidth, borderColor = _this$theme$pin.borderColor;
                  seriesData2.forEach(function(_ref4, seriesIndex) {
                    var name = _ref4.name, data = _ref4.data, color = _ref4.color;
                    var seriesColor = _this4.getSeriesColor(name, color);
                    data.forEach(function(value, index) {
                      var val = utils_isString(value) ? categories.findIndex(function(category2) {
                        return category2 === value;
                      }) : value;
                      var degree = drawingStartAngle + val / scaleMaxLimitValue * totalAngle * (clockwise ? 1 : -1);
                      var validDegree = calculateValidAngle(degree);
                      var handSize = _this4.getHandSize(size, index);
                      var _getRadialPosition3 = getRadialPosition(centerX, centerY, handSize, calculateDegreeToRadian(validDegree)), x2 = _getRadialPosition3.x, y2 = _getRadialPosition3.y;
                      seriesModels.push({
                        type: "clockHand",
                        color: clockHandColor !== null && clockHandColor !== void 0 ? clockHandColor : seriesColor,
                        name,
                        value,
                        x: centerX,
                        y: centerY,
                        x2,
                        y2,
                        pin: {
                          radius,
                          color: pinColor !== null && pinColor !== void 0 ? pinColor : seriesColor,
                          style: [{
                            strokeStyle: borderColor !== null && borderColor !== void 0 ? borderColor : getRGBA(seriesColor, 0.1),
                            lineWidth: borderWidth ? borderWidth + radius : 0
                          }]
                        },
                        degree: validDegree,
                        animationDegree: degree,
                        baseLine,
                        handSize,
                        seriesData: data,
                        index,
                        seriesIndex
                      });
                    });
                  });
                  return seriesModels;
                }
              }, {
                key: "renderBackgroundSolid",
                value: function renderBackgroundSolid(renderOptions) {
                  var centerX = renderOptions.centerX, centerY = renderOptions.centerY, startAngle = renderOptions.startAngle, totalAngle = renderOptions.totalAngle, clockwise = renderOptions.clockwise, solidData = renderOptions.solidData;
                  var _ref5 = this.theme.solid.backgroundSolid, color = _ref5.color;
                  return [{
                    type: "sector",
                    color,
                    x: centerX,
                    y: centerY,
                    clockwise,
                    degree: {
                      start: startAngle,
                      end: startAngle + totalAngle
                    },
                    radius: solidData.radiusRange
                  }];
                }
              }, {
                key: "renderSectors",
                value: function renderSectors(seriesData2, renderOptions) {
                  var _this5 = this;
                  var sectors = [];
                  var centerX = renderOptions.centerX, centerY = renderOptions.centerY, clockwise = renderOptions.clockwise, totalAngle = renderOptions.totalAngle, scaleMaxLimitValue = renderOptions.scaleMaxLimitValue, startAngle = renderOptions.startAngle, categories = renderOptions.categories, solidData = renderOptions.solidData;
                  var radiusRange = solidData.radiusRange;
                  var _ref6 = this.theme.solid, lineWidth = _ref6.lineWidth, strokeStyle = _ref6.strokeStyle;
                  seriesData2.forEach(function(_ref7, index) {
                    var name = _ref7.name, data = _ref7.data, color = _ref7.color;
                    var seriesColor = _this5.getSeriesColor(name, color);
                    var value = data[0];
                    var val = utils_isString(value) ? categories.findIndex(function(category2) {
                      return category2 === value;
                    }) : value;
                    var degree = val / scaleMaxLimitValue * totalAngle * (clockwise ? 1 : -1);
                    var validDegree = calculateValidAngle(degree);
                    var startDegree = startAngle;
                    var endDegree = startDegree + degree;
                    var animationStartDegree = startAngle;
                    var animationEndDegree = animationStartDegree + validDegree;
                    sectors.push({
                      type: "sector",
                      color: seriesColor,
                      x: centerX,
                      y: centerY,
                      clockwise,
                      degree: {
                        start: startDegree,
                        end: endDegree
                      },
                      radius: radiusRange,
                      animationDegree: {
                        start: animationStartDegree,
                        end: animationEndDegree
                      },
                      drawingStartAngle: DEGREE_NEGATIVE_90,
                      style: [{
                        strokeStyle
                      }],
                      lineWidth,
                      index
                    });
                  });
                  return sectors;
                }
              }, {
                key: "makeTooltipMap",
                value: function makeTooltipMap(tooltipData, renderOptions) {
                  var _this$models = this.models, clockHand2 = _this$models.clockHand, solid = _this$models.solid;
                  var useClockHand = renderOptions.useClockHand;
                  return tooltipData.reduce(function(acc, data, index) {
                    if (useClockHand) {
                      acc.clockHand.push(gaugeSeries_objectSpread(gaugeSeries_objectSpread({}, clockHand2[index]), {}, {
                        detectionSize: clockHand2[index].baseLine + 3,
                        data
                      }));
                    }
                    if (solid[index]) {
                      acc.solid.push(gaugeSeries_objectSpread(gaugeSeries_objectSpread({}, solid[index]), {}, {
                        data
                      }));
                    }
                    return acc;
                  }, {
                    solid: [],
                    clockHand: []
                  });
                }
              }, {
                key: "makeRenderOptions",
                value: function makeRenderOptions(hasCategoryAxis, categories, scale2, options2) {
                  var _options$clockwise;
                  var _this$circularAxis2 = this.circularAxis, centerX = _this$circularAxis2.centerX, centerY = _this$circularAxis2.centerY, solidData = _this$circularAxis2.solidData, _this$circularAxis2$a = _this$circularAxis2.angle, start = _this$circularAxis2$a.start, end = _this$circularAxis2$a.end, drawingStart = _this$circularAxis2$a.drawingStart, outer = _this$circularAxis2.radius.outer;
                  var solid = this.circularAxis.solidData;
                  var clockwise = (_options$clockwise = options2 === null || options2 === void 0 ? void 0 : options2.clockwise) !== null && _options$clockwise !== void 0 ? _options$clockwise : true;
                  var totalAngle = getTotalAngle(clockwise, start, end);
                  return {
                    clockwise,
                    centerX,
                    centerY,
                    angleRange: {
                      start,
                      end
                    },
                    totalAngle,
                    scaleMaxLimitValue: hasCategoryAxis ? categories.length : getScaleMaxLimitValue(scale2.circularAxis, totalAngle),
                    startAngle: start,
                    categories,
                    drawingStartAngle: drawingStart,
                    outerRadius: outer,
                    useClockHand: solid.visible ? solid.clockHand : true,
                    solidData
                  };
                }
              }, {
                key: "getSeriesColor",
                value: function getSeriesColor(name, color) {
                  var _this$theme = this.theme, select = _this$theme.select, areaOpacity = _this$theme.areaOpacity;
                  var active = this.activeSeriesMap[name];
                  var selected = Object.values(this.activeSeriesMap).some(function(elem) {
                    return !elem;
                  });
                  return selected ? getRGBA(color, active ? select.areaOpacity : select.restSeries.areaOpacity) : getRGBA(color, areaOpacity);
                }
              }, {
                key: "makeTooltipData",
                value: function makeTooltipData(seriesModels) {
                  return seriesModels.reduce(function(acc, _ref8) {
                    var color = _ref8.color, name = _ref8.name, value = _ref8.value, index = _ref8.index, seriesIndex = _ref8.seriesIndex;
                    return isNull(value) ? acc : [].concat(gaugeSeries_toConsumableArray(acc), [{
                      label: name,
                      color,
                      value,
                      index,
                      seriesIndex
                    }]);
                  }, []);
                }
              }, {
                key: "onMousemove",
                value: function onMousemove(_ref9) {
                  var responders = _ref9.responders;
                  this.eventBus.emit("renderHoveredSeries", {
                    models: this.getResponderModelsWithTheme(this.getResponderModels(responders), "hover"),
                    name: this.name
                  });
                  this.activatedResponders = responders.map(function(responder) {
                    return gaugeSeries_objectSpread({}, responder);
                  });
                  this.eventBus.emit("seriesPointHovered", {
                    models: this.activatedResponders,
                    name: this.name
                  });
                  this.eventBus.emit("needDraw");
                }
              }, {
                key: "getResponderModels",
                value: function getResponderModels(responders) {
                  var _this$tooltipMap = this.tooltipMap, clockHand2 = _this$tooltipMap.clockHand, solid = _this$tooltipMap.solid;
                  return responders.reduce(function(acc, responder) {
                    var index = responder.index;
                    var clockHandModel = clockHand2[index] ? [clockHand2[index]] : [];
                    var solidModel = solid[index] ? [solid[index]] : [];
                    return [].concat(gaugeSeries_toConsumableArray(acc), clockHandModel, solidModel);
                  }, []);
                }
              }, {
                key: "onClick",
                value: function onClick(_ref10) {
                  var responders = _ref10.responders;
                  if (this.selectable) {
                    var models = this.getResponderModelsWithTheme(this.getResponderModels(responders), "select");
                    this.eventBus.emit("renderSelectedSeries", {
                      models,
                      name: this.name
                    });
                    this.eventBus.emit("needDraw");
                  }
                }
              }, {
                key: "getResponderModelsWithSolidTheme",
                value: function getResponderModelsWithSolidTheme(responder, type) {
                  var _solidTheme$color;
                  var solidTheme = this.theme[type].solid;
                  var lineWidth = solidTheme.lineWidth;
                  var isSameLineWidth = this.theme.solid === lineWidth;
                  var thickness = isSameLineWidth ? 0 : lineWidth * 0.5;
                  return gaugeSeries_objectSpread(gaugeSeries_objectSpread({}, responder), {}, {
                    color: (_solidTheme$color = solidTheme.color) !== null && _solidTheme$color !== void 0 ? _solidTheme$color : responder.color,
                    lineWidth,
                    style: [pick(solidTheme, "strokeStyle", "shadowBlur", "shadowColor", "shadowOffsetX", "shadowOffsetY")],
                    radius: {
                      inner: Math.max(responder.radius.inner - thickness, 0),
                      outer: responder.radius.outer + thickness
                    }
                  });
                }
              }, {
                key: "getResponderWithClockHandTheme",
                value: function getResponderWithClockHandTheme(responder, type) {
                  var _this$theme$type = this.theme[type], clockHand2 = _this$theme$type.clockHand, pin = _this$theme$type.pin;
                  var _ref11 = clockHand2, size = _ref11.size, baseLine = _ref11.baseLine, clockHandColor = _ref11.color;
                  var _ref12 = pin, radius = _ref12.radius, pinColor = _ref12.color, borderWidth = _ref12.borderWidth, borderColor = _ref12.borderColor;
                  var pinRadius = radius !== null && radius !== void 0 ? radius : responder.pin.radius;
                  var pinStyle = [{
                    strokeStyle: borderColor !== null && borderColor !== void 0 ? borderColor : getRGBA(responder.pin.style[0].strokeStyle, 0.3),
                    lineWidth: borderWidth ? borderWidth + pinRadius : 0
                  }];
                  return gaugeSeries_objectSpread(gaugeSeries_objectSpread({}, responder), {}, {
                    color: clockHandColor !== null && clockHandColor !== void 0 ? clockHandColor : responder.color,
                    pin: {
                      radius: pinRadius,
                      color: pinColor !== null && pinColor !== void 0 ? pinColor : responder.pin.color,
                      style: pinStyle
                    },
                    baseLine: baseLine !== null && baseLine !== void 0 ? baseLine : responder.baseLine,
                    handSize: size ? this.getHandSize(size, responder.index) : responder.handSize
                  });
                }
              }, {
                key: "getResponderModelsWithTheme",
                value: function getResponderModelsWithTheme(responders, type) {
                  var _this6 = this;
                  return responders.map(function(m) {
                    return (m === null || m === void 0 ? void 0 : m.type) === "sector" ? _this6.getResponderModelsWithSolidTheme(m, type) : _this6.getResponderWithClockHandTheme(m, type);
                  });
                }
              }]);
              return GaugeSeries2;
            }(Component);
            ;
            function getClockHandPoints(model) {
              var x = model.x, y = model.y, x2 = model.x2, y2 = model.y2, degree = model.degree, baseLine = model.baseLine;
              var halfBaseLine = baseLine / 2;
              var startPoint, endPoint;
              if (x === x2) {
                startPoint = {
                  x: x - halfBaseLine,
                  y
                };
                endPoint = {
                  x: x + halfBaseLine,
                  y
                };
              } else if (y === y2) {
                startPoint = {
                  x,
                  y: y - halfBaseLine
                };
                endPoint = {
                  x,
                  y: y + halfBaseLine
                };
              } else {
                startPoint = getRadialPosition(x, y, halfBaseLine, calculateDegreeToRadian(calculateValidAngle(degree + DEGREE_90)));
                endPoint = getRadialPosition(x, y, halfBaseLine, calculateDegreeToRadian(calculateValidAngle(degree - DEGREE_90)));
              }
              return [startPoint, {
                x: x2,
                y: y2
              }, endPoint];
            }
            function clockHand(ctx2, model) {
              var color = model.color, x = model.x, y = model.y, _model$pin = model.pin, pinColor = _model$pin.color, radius = _model$pin.radius, style = _model$pin.style;
              circle(ctx2, {
                type: "circle",
                x,
                y,
                radius,
                color: pinColor,
                style
              });
              polygon(ctx2, {
                type: "polygon",
                color,
                lineWidth: 1,
                fillColor: color,
                points: getClockHandPoints(model)
              });
            }
            ;
            function gaugeChart_typeof(obj) {
              "@babel/helpers - typeof";
              if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
                gaugeChart_typeof = function _typeof2(obj2) {
                  return typeof obj2;
                };
              } else {
                gaugeChart_typeof = function _typeof2(obj2) {
                  return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                };
              }
              return gaugeChart_typeof(obj);
            }
            function gaugeChart_ownKeys(object, enumerableOnly) {
              var keys = Object.keys(object);
              if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object);
                if (enumerableOnly) {
                  symbols = symbols.filter(function(sym) {
                    return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                  });
                }
                keys.push.apply(keys, symbols);
              }
              return keys;
            }
            function gaugeChart_objectSpread(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i] != null ? arguments[i] : {};
                if (i % 2) {
                  gaugeChart_ownKeys(Object(source), true).forEach(function(key) {
                    gaugeChart_defineProperty(target, key, source[key]);
                  });
                } else if (Object.getOwnPropertyDescriptors) {
                  Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                } else {
                  gaugeChart_ownKeys(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                  });
                }
              }
              return target;
            }
            function gaugeChart_defineProperty(obj, key, value) {
              if (key in obj) {
                Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
              } else {
                obj[key] = value;
              }
              return obj;
            }
            function gaugeChart_classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function gaugeChart_defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                  descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            function gaugeChart_createClass(Constructor, protoProps, staticProps) {
              if (protoProps)
                gaugeChart_defineProperties(Constructor.prototype, protoProps);
              if (staticProps)
                gaugeChart_defineProperties(Constructor, staticProps);
              return Constructor;
            }
            function gaugeChart_get(target, property, receiver) {
              if (typeof Reflect !== "undefined" && Reflect.get) {
                gaugeChart_get = Reflect.get;
              } else {
                gaugeChart_get = function _get2(target2, property2, receiver2) {
                  var base = gaugeChart_superPropBase(target2, property2);
                  if (!base)
                    return;
                  var desc = Object.getOwnPropertyDescriptor(base, property2);
                  if (desc.get) {
                    return desc.get.call(receiver2);
                  }
                  return desc.value;
                };
              }
              return gaugeChart_get(target, property, receiver || target);
            }
            function gaugeChart_superPropBase(object, property) {
              while (!Object.prototype.hasOwnProperty.call(object, property)) {
                object = gaugeChart_getPrototypeOf(object);
                if (object === null)
                  break;
              }
              return object;
            }
            function gaugeChart_inherits(subClass, superClass) {
              if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function");
              }
              subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
              if (superClass)
                gaugeChart_setPrototypeOf(subClass, superClass);
            }
            function gaugeChart_setPrototypeOf(o, p) {
              gaugeChart_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
                o2.__proto__ = p2;
                return o2;
              };
              return gaugeChart_setPrototypeOf(o, p);
            }
            function gaugeChart_createSuper(Derived) {
              var hasNativeReflectConstruct = gaugeChart_isNativeReflectConstruct();
              return function _createSuperInternal() {
                var Super = gaugeChart_getPrototypeOf(Derived), result;
                if (hasNativeReflectConstruct) {
                  var NewTarget = gaugeChart_getPrototypeOf(this).constructor;
                  result = Reflect.construct(Super, arguments, NewTarget);
                } else {
                  result = Super.apply(this, arguments);
                }
                return gaugeChart_possibleConstructorReturn(this, result);
              };
            }
            function gaugeChart_possibleConstructorReturn(self2, call) {
              if (call && (gaugeChart_typeof(call) === "object" || typeof call === "function")) {
                return call;
              }
              return gaugeChart_assertThisInitialized(self2);
            }
            function gaugeChart_assertThisInitialized(self2) {
              if (self2 === void 0) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              }
              return self2;
            }
            function gaugeChart_isNativeReflectConstruct() {
              if (typeof Reflect === "undefined" || !Reflect.construct)
                return false;
              if (Reflect.construct.sham)
                return false;
              if (typeof Proxy === "function")
                return true;
              try {
                Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                }));
                return true;
              } catch (e) {
                return false;
              }
            }
            function gaugeChart_getPrototypeOf(o) {
              gaugeChart_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
                return o2.__proto__ || Object.getPrototypeOf(o2);
              };
              return gaugeChart_getPrototypeOf(o);
            }
            var GaugeChart = function(_Chart) {
              gaugeChart_inherits(GaugeChart2, _Chart);
              var _super = gaugeChart_createSuper(GaugeChart2);
              function GaugeChart2(_ref) {
                var el = _ref.el, options2 = _ref.options, data = _ref.data;
                gaugeChart_classCallCheck(this, GaugeChart2);
                return _super.call(this, {
                  el,
                  options: options2,
                  series: {
                    gauge: data.series
                  },
                  categories: data.categories,
                  modules: [store_dataRange, store_scale, gaugeAxes]
                });
              }
              gaugeChart_createClass(GaugeChart2, [{
                key: "initialize",
                value: function initialize() {
                  gaugeChart_get(gaugeChart_getPrototypeOf(GaugeChart2.prototype), "initialize", this).call(this);
                  this.componentManager.add(Background);
                  this.componentManager.add(Title);
                  this.componentManager.add(RadarPlot, {
                    name: "gauge"
                  });
                  this.componentManager.add(RadialAxis, {
                    name: "gauge"
                  });
                  this.componentManager.add(AxisTitle, {
                    name: "circularAxis"
                  });
                  this.componentManager.add(GaugeSeries);
                  this.componentManager.add(HoveredSeries);
                  this.componentManager.add(SelectedSeries);
                  this.componentManager.add(DataLabels);
                  this.componentManager.add(ExportMenu, {
                    chartEl: this.el
                  });
                  this.componentManager.add(Tooltip, {
                    chartEl: this.el
                  });
                  this.componentManager.add(NoDataText);
                  this.painter.addGroups([basic_namespaceObject, legend_namespaceObject, label_namespaceObject, brushes_exportMenu_namespaceObject, brushes_sector_namespaceObject, dataLabel_namespaceObject, axis_namespaceObject, gauge_namespaceObject]);
                }
                /**
                 * Add series.
                 * @param {Object} data - Data to be added.
                 *   @param {string} data.name - Series name.
                 *   @param {Array<number|Array<number>>} data.data - Array of data to be added.
                 * @api
                 * @example
                 * chart.addSeries({
                 *   name: 'newSeries',
                 *   data: [10, 20],
                 * });
                 */
              }, {
                key: "addSeries",
                value: function addSeries(data) {
                  this.resetSeries();
                  this.store.dispatch("addSeries", {
                    data
                  });
                }
                /**
                 * Add data.
                 * @param {Array} data - Array of data to be added.
                 * @param {string} [category] - Category to be added.
                 * @api
                 * @example
                 * // without categories
                 * chart.addData([10], '6');
                 *
                 * // with categories
                 * chart.addData([10], '6');
                 */
              }, {
                key: "addData",
                value: function addData(data, category2) {
                  this.resetSeries();
                  this.animationControlFlag.updating = true;
                  this.store.dispatch("addData", {
                    data,
                    category: category2
                  });
                }
                /**
                 * Convert the chart data to new data.
                 * @param {Object} data - Data to be set.
                 * @api
                 * @example
                 * chart.setData({
                 *   categories: ['1', '2', '3'],
                 *   series: [
                 *     {
                 *       name: 'new series',
                 *       data: [1, 2, 3],
                 *     },
                 *     {
                 *       name: 'new series2',
                 *       data: [4, 5, 6],
                 *     }
                 *   ]
                 * });
                 */
              }, {
                key: "setData",
                value: function setData(data) {
                  var categories = data.categories, series = data.series;
                  this.resetSeries();
                  this.store.dispatch("setData", {
                    series: {
                      gauge: series
                    },
                    categories
                  });
                }
                /**
                 * Hide series data label.
                 * @api
                 * @example
                 * chart.hideSeriesDataLabel();
                 */
              }, {
                key: "hideSeriesDataLabel",
                value: function hideSeriesDataLabel() {
                  this.store.dispatch("updateOptions", {
                    options: {
                      series: {
                        dataLabels: {
                          visible: false
                        }
                      }
                    }
                  });
                }
                /**
                 * Show series data label.
                 * @api
                 * @example
                 * chart.showSeriesDataLabel();
                 */
              }, {
                key: "showSeriesDataLabel",
                value: function showSeriesDataLabel() {
                  this.store.dispatch("updateOptions", {
                    options: {
                      series: {
                        dataLabels: {
                          visible: true
                        }
                      }
                    }
                  });
                }
                /**
                 * Convert the chart options to new options.
                 * @param {Object} options - Chart options.
                 * @api
                 * @example
                 * chart.setOptions({
                 *   chart: {
                 *     width: 500,
                 *     height: 500,
                 *     title: 'Olympic Medals',
                 *   },
                 *   series: {
                 *     selectable: true
                 *   }
                 * });
                 */
              }, {
                key: "setOptions",
                value: function setOptions(options2) {
                  this.resetSeries();
                  this.dispatchOptionsEvent("initOptions", options2);
                }
                /**
                 * Update chart options.
                 * @param {Object} options - Chart options.
                 * @api
                 * @example
                 * chart.updateOptions({
                 *   chart: {
                 *     title: 'Olympic Medals',
                 *   }
                 * });
                 */
              }, {
                key: "updateOptions",
                value: function updateOptions(options2) {
                  this.resetSeries();
                  this.dispatchOptionsEvent("updateOptions", options2);
                }
                /**
                 * Show tooltip.
                 * @param {Object} seriesInfo - Information of the series for the tooltip to be displayed.
                 *      @param {number} seriesInfo.index - Index of data within series.
                 * @api
                 * @example
                 * chart.showTooltip({index: 1});
                 */
              }, {
                key: "showTooltip",
                value: function showTooltip(seriesInfo) {
                  this.eventBus.emit("showTooltip", gaugeChart_objectSpread(gaugeChart_objectSpread({}, seriesInfo), {}, {
                    state: this.store.state
                  }));
                }
                /**
                 * Hide tooltip.
                 * @api
                 * @example
                 * chart.hideTooltip();
                 */
              }, {
                key: "hideTooltip",
                value: function hideTooltip() {
                  this.eventBus.emit("hideTooltip");
                }
                /**
                 * Add plot band.
                 * @param {Object} data - Plot info.
                 *   @param {Array<string|number>} data.range - The range to be drawn.
                 *   @param {string} data.color - Plot band color.
                 *   @param {string} [data.id] - Plot id. The value on which the removePlotBand is based.
                 * @api
                 * @example
                 * chart.addPlotBand({
                 *   range: [10, 20],
                 *   color: '#00ff22',
                 *   id: 'plot-1',
                 * });
                 */
              }, {
                key: "addPlotBand",
                value: function addPlotBand(data) {
                  this.store.dispatch("addGaugePlotBand", {
                    data
                  });
                }
                /**
                 * Remove plot band with id.
                 * @param {string} id - id of the plot band to be removed
                 * @api
                 * @example
                 * chart.removePlotBand('plot-1');
                 */
              }, {
                key: "removePlotBand",
                value: function removePlotBand(id) {
                  this.store.dispatch("removeGaugePlotBand", {
                    id
                  });
                }
              }]);
              return GaugeChart2;
            }(Chart);
            ;
            function src_classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            function src_defineProperty(obj, key, value) {
              if (key in obj) {
                Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
              } else {
                obj[key] = value;
              }
              return obj;
            }
            var src_Chart = function Chart2() {
              src_classCallCheck(this, Chart2);
            };
            src_defineProperty(src_Chart, "lineChart", function(props) {
              return new LineChart(props);
            });
            src_defineProperty(src_Chart, "areaChart", function(props) {
              return new AreaChart(props);
            });
            src_defineProperty(src_Chart, "barChart", function(props) {
              return new BarChart(props);
            });
            src_defineProperty(src_Chart, "boxPlotChart", function(props) {
              return new BoxPlotChart(props);
            });
            src_defineProperty(src_Chart, "columnChart", function(props) {
              return new ColumnChart(props);
            });
            src_defineProperty(src_Chart, "pieChart", function(props) {
              return new PieChart(props);
            });
            src_defineProperty(src_Chart, "heatmapChart", function(props) {
              return new HeatmapChart(props);
            });
            src_defineProperty(src_Chart, "bubbleChart", function(props) {
              return new BubbleChart(props);
            });
            src_defineProperty(src_Chart, "scatterChart", function(props) {
              return new ScatterChart(props);
            });
            src_defineProperty(src_Chart, "bulletChart", function(props) {
              return new BulletChart(props);
            });
            src_defineProperty(src_Chart, "radarChart", function(props) {
              return new RadarChart(props);
            });
            src_defineProperty(src_Chart, "treemapChart", function(props) {
              return new TreemapChart(props);
            });
            src_defineProperty(src_Chart, "nestedPieChart", function(props) {
              return new NestedPieChart(props);
            });
            src_defineProperty(src_Chart, "lineAreaChart", function(props) {
              return new LineAreaChart(props);
            });
            src_defineProperty(src_Chart, "lineScatterChart", function(props) {
              return new LineScatterChart(props);
            });
            src_defineProperty(src_Chart, "columnLineChart", function(props) {
              return new ColumnLineChart(props);
            });
            src_defineProperty(src_Chart, "radialBarChart", function(props) {
              return new RadialBarChart(props);
            });
            src_defineProperty(src_Chart, "gaugeChart", function(props) {
              return new GaugeChart(props);
            });
          }();
          __webpack_exports__ = __webpack_exports__.default;
          return __webpack_exports__;
        }()
      );
    });
  }
});

// node_modules/@toast-ui/editor-plugin-chart/dist/toastui-editor-plugin-chart.js
var require_toastui_editor_plugin_chart = __commonJS({
  "node_modules/@toast-ui/editor-plugin-chart/dist/toastui-editor-plugin-chart.js"(exports, module) {
    (function webpackUniversalModuleDefinition(root, factory) {
      if (typeof exports === "object" && typeof module === "object")
        module.exports = factory(require_toastui_chart());
      else if (typeof define === "function" && define.amd)
        define(["@toast-ui/chart"], factory);
      else if (typeof exports === "object")
        exports["toastui"] = factory(require_toastui_chart());
      else
        root["toastui"] = root["toastui"] || {}, root["toastui"]["Editor"] = root["toastui"]["Editor"] || {}, root["toastui"]["Editor"]["plugin"] = root["toastui"]["Editor"]["plugin"] || {}, root["toastui"]["Editor"]["plugin"]["chart"] = factory(root["toastui"]["Chart"]);
    })(self, function(__WEBPACK_EXTERNAL_MODULE__203__) {
      return (
        /******/
        function() {
          var __webpack_modules__ = {
            /***/
            72: (
              /***/
              function(__unused_webpack_module, exports2) {
                "use strict";
                exports2.byteLength = byteLength;
                exports2.toByteArray = toByteArray;
                exports2.fromByteArray = fromByteArray;
                var lookup = [];
                var revLookup = [];
                var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
                var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
                for (var i = 0, len = code.length; i < len; ++i) {
                  lookup[i] = code[i];
                  revLookup[code.charCodeAt(i)] = i;
                }
                revLookup["-".charCodeAt(0)] = 62;
                revLookup["_".charCodeAt(0)] = 63;
                function getLens(b64) {
                  var len2 = b64.length;
                  if (len2 % 4 > 0) {
                    throw new Error("Invalid string. Length must be a multiple of 4");
                  }
                  var validLen = b64.indexOf("=");
                  if (validLen === -1)
                    validLen = len2;
                  var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
                  return [validLen, placeHoldersLen];
                }
                function byteLength(b64) {
                  var lens = getLens(b64);
                  var validLen = lens[0];
                  var placeHoldersLen = lens[1];
                  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
                }
                function _byteLength(b64, validLen, placeHoldersLen) {
                  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
                }
                function toByteArray(b64) {
                  var tmp;
                  var lens = getLens(b64);
                  var validLen = lens[0];
                  var placeHoldersLen = lens[1];
                  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
                  var curByte = 0;
                  var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
                  var i2;
                  for (i2 = 0; i2 < len2; i2 += 4) {
                    tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
                    arr[curByte++] = tmp >> 16 & 255;
                    arr[curByte++] = tmp >> 8 & 255;
                    arr[curByte++] = tmp & 255;
                  }
                  if (placeHoldersLen === 2) {
                    tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
                    arr[curByte++] = tmp & 255;
                  }
                  if (placeHoldersLen === 1) {
                    tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
                    arr[curByte++] = tmp >> 8 & 255;
                    arr[curByte++] = tmp & 255;
                  }
                  return arr;
                }
                function tripletToBase64(num) {
                  return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
                }
                function encodeChunk(uint8, start, end) {
                  var tmp;
                  var output = [];
                  for (var i2 = start; i2 < end; i2 += 3) {
                    tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
                    output.push(tripletToBase64(tmp));
                  }
                  return output.join("");
                }
                function fromByteArray(uint8) {
                  var tmp;
                  var len2 = uint8.length;
                  var extraBytes = len2 % 3;
                  var parts = [];
                  var maxChunkLength = 16383;
                  for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
                    parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
                  }
                  if (extraBytes === 1) {
                    tmp = uint8[len2 - 1];
                    parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "==");
                  } else if (extraBytes === 2) {
                    tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
                    parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "=");
                  }
                  return parts.join("");
                }
              }
            ),
            /***/
            636: (
              /***/
              function(__unused_webpack_module, exports2, __webpack_require__2) {
                "use strict";
                var base64 = __webpack_require__2(72);
                var ieee754 = __webpack_require__2(74);
                var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
                exports2.Buffer = Buffer;
                exports2.SlowBuffer = SlowBuffer;
                exports2.INSPECT_MAX_BYTES = 50;
                var K_MAX_LENGTH = 2147483647;
                exports2.kMaxLength = K_MAX_LENGTH;
                Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();
                if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
                  console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
                }
                function typedArraySupport() {
                  try {
                    var arr = new Uint8Array(1);
                    var proto = { foo: function() {
                      return 42;
                    } };
                    Object.setPrototypeOf(proto, Uint8Array.prototype);
                    Object.setPrototypeOf(arr, proto);
                    return arr.foo() === 42;
                  } catch (e) {
                    return false;
                  }
                }
                Object.defineProperty(Buffer.prototype, "parent", {
                  enumerable: true,
                  get: function() {
                    if (!Buffer.isBuffer(this))
                      return void 0;
                    return this.buffer;
                  }
                });
                Object.defineProperty(Buffer.prototype, "offset", {
                  enumerable: true,
                  get: function() {
                    if (!Buffer.isBuffer(this))
                      return void 0;
                    return this.byteOffset;
                  }
                });
                function createBuffer(length) {
                  if (length > K_MAX_LENGTH) {
                    throw new RangeError('The value "' + length + '" is invalid for option "size"');
                  }
                  var buf = new Uint8Array(length);
                  Object.setPrototypeOf(buf, Buffer.prototype);
                  return buf;
                }
                function Buffer(arg, encodingOrOffset, length) {
                  if (typeof arg === "number") {
                    if (typeof encodingOrOffset === "string") {
                      throw new TypeError('The "string" argument must be of type string. Received type number');
                    }
                    return allocUnsafe(arg);
                  }
                  return from(arg, encodingOrOffset, length);
                }
                Buffer.poolSize = 8192;
                function from(value, encodingOrOffset, length) {
                  if (typeof value === "string") {
                    return fromString(value, encodingOrOffset);
                  }
                  if (ArrayBuffer.isView(value)) {
                    return fromArrayView(value);
                  }
                  if (value == null) {
                    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
                  }
                  if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
                    return fromArrayBuffer(value, encodingOrOffset, length);
                  }
                  if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
                    return fromArrayBuffer(value, encodingOrOffset, length);
                  }
                  if (typeof value === "number") {
                    throw new TypeError('The "value" argument must not be of type number. Received type number');
                  }
                  var valueOf = value.valueOf && value.valueOf();
                  if (valueOf != null && valueOf !== value) {
                    return Buffer.from(valueOf, encodingOrOffset, length);
                  }
                  var b = fromObject(value);
                  if (b)
                    return b;
                  if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
                    return Buffer.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
                  }
                  throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
                }
                Buffer.from = function(value, encodingOrOffset, length) {
                  return from(value, encodingOrOffset, length);
                };
                Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
                Object.setPrototypeOf(Buffer, Uint8Array);
                function assertSize(size) {
                  if (typeof size !== "number") {
                    throw new TypeError('"size" argument must be of type number');
                  } else if (size < 0) {
                    throw new RangeError('The value "' + size + '" is invalid for option "size"');
                  }
                }
                function alloc(size, fill, encoding) {
                  assertSize(size);
                  if (size <= 0) {
                    return createBuffer(size);
                  }
                  if (fill !== void 0) {
                    return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
                  }
                  return createBuffer(size);
                }
                Buffer.alloc = function(size, fill, encoding) {
                  return alloc(size, fill, encoding);
                };
                function allocUnsafe(size) {
                  assertSize(size);
                  return createBuffer(size < 0 ? 0 : checked(size) | 0);
                }
                Buffer.allocUnsafe = function(size) {
                  return allocUnsafe(size);
                };
                Buffer.allocUnsafeSlow = function(size) {
                  return allocUnsafe(size);
                };
                function fromString(string, encoding) {
                  if (typeof encoding !== "string" || encoding === "") {
                    encoding = "utf8";
                  }
                  if (!Buffer.isEncoding(encoding)) {
                    throw new TypeError("Unknown encoding: " + encoding);
                  }
                  var length = byteLength(string, encoding) | 0;
                  var buf = createBuffer(length);
                  var actual = buf.write(string, encoding);
                  if (actual !== length) {
                    buf = buf.slice(0, actual);
                  }
                  return buf;
                }
                function fromArrayLike(array) {
                  var length = array.length < 0 ? 0 : checked(array.length) | 0;
                  var buf = createBuffer(length);
                  for (var i = 0; i < length; i += 1) {
                    buf[i] = array[i] & 255;
                  }
                  return buf;
                }
                function fromArrayView(arrayView) {
                  if (isInstance(arrayView, Uint8Array)) {
                    var copy = new Uint8Array(arrayView);
                    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
                  }
                  return fromArrayLike(arrayView);
                }
                function fromArrayBuffer(array, byteOffset, length) {
                  if (byteOffset < 0 || array.byteLength < byteOffset) {
                    throw new RangeError('"offset" is outside of buffer bounds');
                  }
                  if (array.byteLength < byteOffset + (length || 0)) {
                    throw new RangeError('"length" is outside of buffer bounds');
                  }
                  var buf;
                  if (byteOffset === void 0 && length === void 0) {
                    buf = new Uint8Array(array);
                  } else if (length === void 0) {
                    buf = new Uint8Array(array, byteOffset);
                  } else {
                    buf = new Uint8Array(array, byteOffset, length);
                  }
                  Object.setPrototypeOf(buf, Buffer.prototype);
                  return buf;
                }
                function fromObject(obj) {
                  if (Buffer.isBuffer(obj)) {
                    var len = checked(obj.length) | 0;
                    var buf = createBuffer(len);
                    if (buf.length === 0) {
                      return buf;
                    }
                    obj.copy(buf, 0, 0, len);
                    return buf;
                  }
                  if (obj.length !== void 0) {
                    if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
                      return createBuffer(0);
                    }
                    return fromArrayLike(obj);
                  }
                  if (obj.type === "Buffer" && Array.isArray(obj.data)) {
                    return fromArrayLike(obj.data);
                  }
                }
                function checked(length) {
                  if (length >= K_MAX_LENGTH) {
                    throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
                  }
                  return length | 0;
                }
                function SlowBuffer(length) {
                  if (+length != length) {
                    length = 0;
                  }
                  return Buffer.alloc(+length);
                }
                Buffer.isBuffer = function isBuffer(b) {
                  return b != null && b._isBuffer === true && b !== Buffer.prototype;
                };
                Buffer.compare = function compare(a, b) {
                  if (isInstance(a, Uint8Array))
                    a = Buffer.from(a, a.offset, a.byteLength);
                  if (isInstance(b, Uint8Array))
                    b = Buffer.from(b, b.offset, b.byteLength);
                  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
                    throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
                  }
                  if (a === b)
                    return 0;
                  var x = a.length;
                  var y = b.length;
                  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
                    if (a[i] !== b[i]) {
                      x = a[i];
                      y = b[i];
                      break;
                    }
                  }
                  if (x < y)
                    return -1;
                  if (y < x)
                    return 1;
                  return 0;
                };
                Buffer.isEncoding = function isEncoding(encoding) {
                  switch (String(encoding).toLowerCase()) {
                    case "hex":
                    case "utf8":
                    case "utf-8":
                    case "ascii":
                    case "latin1":
                    case "binary":
                    case "base64":
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                      return true;
                    default:
                      return false;
                  }
                };
                Buffer.concat = function concat(list, length) {
                  if (!Array.isArray(list)) {
                    throw new TypeError('"list" argument must be an Array of Buffers');
                  }
                  if (list.length === 0) {
                    return Buffer.alloc(0);
                  }
                  var i;
                  if (length === void 0) {
                    length = 0;
                    for (i = 0; i < list.length; ++i) {
                      length += list[i].length;
                    }
                  }
                  var buffer = Buffer.allocUnsafe(length);
                  var pos = 0;
                  for (i = 0; i < list.length; ++i) {
                    var buf = list[i];
                    if (isInstance(buf, Uint8Array)) {
                      if (pos + buf.length > buffer.length) {
                        Buffer.from(buf).copy(buffer, pos);
                      } else {
                        Uint8Array.prototype.set.call(buffer, buf, pos);
                      }
                    } else if (!Buffer.isBuffer(buf)) {
                      throw new TypeError('"list" argument must be an Array of Buffers');
                    } else {
                      buf.copy(buffer, pos);
                    }
                    pos += buf.length;
                  }
                  return buffer;
                };
                function byteLength(string, encoding) {
                  if (Buffer.isBuffer(string)) {
                    return string.length;
                  }
                  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
                    return string.byteLength;
                  }
                  if (typeof string !== "string") {
                    throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string);
                  }
                  var len = string.length;
                  var mustMatch = arguments.length > 2 && arguments[2] === true;
                  if (!mustMatch && len === 0)
                    return 0;
                  var loweredCase = false;
                  for (; ; ) {
                    switch (encoding) {
                      case "ascii":
                      case "latin1":
                      case "binary":
                        return len;
                      case "utf8":
                      case "utf-8":
                        return utf8ToBytes(string).length;
                      case "ucs2":
                      case "ucs-2":
                      case "utf16le":
                      case "utf-16le":
                        return len * 2;
                      case "hex":
                        return len >>> 1;
                      case "base64":
                        return base64ToBytes(string).length;
                      default:
                        if (loweredCase) {
                          return mustMatch ? -1 : utf8ToBytes(string).length;
                        }
                        encoding = ("" + encoding).toLowerCase();
                        loweredCase = true;
                    }
                  }
                }
                Buffer.byteLength = byteLength;
                function slowToString(encoding, start, end) {
                  var loweredCase = false;
                  if (start === void 0 || start < 0) {
                    start = 0;
                  }
                  if (start > this.length) {
                    return "";
                  }
                  if (end === void 0 || end > this.length) {
                    end = this.length;
                  }
                  if (end <= 0) {
                    return "";
                  }
                  end >>>= 0;
                  start >>>= 0;
                  if (end <= start) {
                    return "";
                  }
                  if (!encoding)
                    encoding = "utf8";
                  while (true) {
                    switch (encoding) {
                      case "hex":
                        return hexSlice(this, start, end);
                      case "utf8":
                      case "utf-8":
                        return utf8Slice(this, start, end);
                      case "ascii":
                        return asciiSlice(this, start, end);
                      case "latin1":
                      case "binary":
                        return latin1Slice(this, start, end);
                      case "base64":
                        return base64Slice(this, start, end);
                      case "ucs2":
                      case "ucs-2":
                      case "utf16le":
                      case "utf-16le":
                        return utf16leSlice(this, start, end);
                      default:
                        if (loweredCase)
                          throw new TypeError("Unknown encoding: " + encoding);
                        encoding = (encoding + "").toLowerCase();
                        loweredCase = true;
                    }
                  }
                }
                Buffer.prototype._isBuffer = true;
                function swap(b, n, m) {
                  var i = b[n];
                  b[n] = b[m];
                  b[m] = i;
                }
                Buffer.prototype.swap16 = function swap16() {
                  var len = this.length;
                  if (len % 2 !== 0) {
                    throw new RangeError("Buffer size must be a multiple of 16-bits");
                  }
                  for (var i = 0; i < len; i += 2) {
                    swap(this, i, i + 1);
                  }
                  return this;
                };
                Buffer.prototype.swap32 = function swap32() {
                  var len = this.length;
                  if (len % 4 !== 0) {
                    throw new RangeError("Buffer size must be a multiple of 32-bits");
                  }
                  for (var i = 0; i < len; i += 4) {
                    swap(this, i, i + 3);
                    swap(this, i + 1, i + 2);
                  }
                  return this;
                };
                Buffer.prototype.swap64 = function swap64() {
                  var len = this.length;
                  if (len % 8 !== 0) {
                    throw new RangeError("Buffer size must be a multiple of 64-bits");
                  }
                  for (var i = 0; i < len; i += 8) {
                    swap(this, i, i + 7);
                    swap(this, i + 1, i + 6);
                    swap(this, i + 2, i + 5);
                    swap(this, i + 3, i + 4);
                  }
                  return this;
                };
                Buffer.prototype.toString = function toString() {
                  var length = this.length;
                  if (length === 0)
                    return "";
                  if (arguments.length === 0)
                    return utf8Slice(this, 0, length);
                  return slowToString.apply(this, arguments);
                };
                Buffer.prototype.toLocaleString = Buffer.prototype.toString;
                Buffer.prototype.equals = function equals(b) {
                  if (!Buffer.isBuffer(b))
                    throw new TypeError("Argument must be a Buffer");
                  if (this === b)
                    return true;
                  return Buffer.compare(this, b) === 0;
                };
                Buffer.prototype.inspect = function inspect() {
                  var str = "";
                  var max = exports2.INSPECT_MAX_BYTES;
                  str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
                  if (this.length > max)
                    str += " ... ";
                  return "<Buffer " + str + ">";
                };
                if (customInspectSymbol) {
                  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;
                }
                Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
                  if (isInstance(target, Uint8Array)) {
                    target = Buffer.from(target, target.offset, target.byteLength);
                  }
                  if (!Buffer.isBuffer(target)) {
                    throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
                  }
                  if (start === void 0) {
                    start = 0;
                  }
                  if (end === void 0) {
                    end = target ? target.length : 0;
                  }
                  if (thisStart === void 0) {
                    thisStart = 0;
                  }
                  if (thisEnd === void 0) {
                    thisEnd = this.length;
                  }
                  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
                    throw new RangeError("out of range index");
                  }
                  if (thisStart >= thisEnd && start >= end) {
                    return 0;
                  }
                  if (thisStart >= thisEnd) {
                    return -1;
                  }
                  if (start >= end) {
                    return 1;
                  }
                  start >>>= 0;
                  end >>>= 0;
                  thisStart >>>= 0;
                  thisEnd >>>= 0;
                  if (this === target)
                    return 0;
                  var x = thisEnd - thisStart;
                  var y = end - start;
                  var len = Math.min(x, y);
                  var thisCopy = this.slice(thisStart, thisEnd);
                  var targetCopy = target.slice(start, end);
                  for (var i = 0; i < len; ++i) {
                    if (thisCopy[i] !== targetCopy[i]) {
                      x = thisCopy[i];
                      y = targetCopy[i];
                      break;
                    }
                  }
                  if (x < y)
                    return -1;
                  if (y < x)
                    return 1;
                  return 0;
                };
                function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
                  if (buffer.length === 0)
                    return -1;
                  if (typeof byteOffset === "string") {
                    encoding = byteOffset;
                    byteOffset = 0;
                  } else if (byteOffset > 2147483647) {
                    byteOffset = 2147483647;
                  } else if (byteOffset < -2147483648) {
                    byteOffset = -2147483648;
                  }
                  byteOffset = +byteOffset;
                  if (numberIsNaN(byteOffset)) {
                    byteOffset = dir ? 0 : buffer.length - 1;
                  }
                  if (byteOffset < 0)
                    byteOffset = buffer.length + byteOffset;
                  if (byteOffset >= buffer.length) {
                    if (dir)
                      return -1;
                    else
                      byteOffset = buffer.length - 1;
                  } else if (byteOffset < 0) {
                    if (dir)
                      byteOffset = 0;
                    else
                      return -1;
                  }
                  if (typeof val === "string") {
                    val = Buffer.from(val, encoding);
                  }
                  if (Buffer.isBuffer(val)) {
                    if (val.length === 0) {
                      return -1;
                    }
                    return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
                  } else if (typeof val === "number") {
                    val = val & 255;
                    if (typeof Uint8Array.prototype.indexOf === "function") {
                      if (dir) {
                        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
                      } else {
                        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
                      }
                    }
                    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
                  }
                  throw new TypeError("val must be string, number or Buffer");
                }
                function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
                  var indexSize = 1;
                  var arrLength = arr.length;
                  var valLength = val.length;
                  if (encoding !== void 0) {
                    encoding = String(encoding).toLowerCase();
                    if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
                      if (arr.length < 2 || val.length < 2) {
                        return -1;
                      }
                      indexSize = 2;
                      arrLength /= 2;
                      valLength /= 2;
                      byteOffset /= 2;
                    }
                  }
                  function read(buf, i2) {
                    if (indexSize === 1) {
                      return buf[i2];
                    } else {
                      return buf.readUInt16BE(i2 * indexSize);
                    }
                  }
                  var i;
                  if (dir) {
                    var foundIndex = -1;
                    for (i = byteOffset; i < arrLength; i++) {
                      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
                        if (foundIndex === -1)
                          foundIndex = i;
                        if (i - foundIndex + 1 === valLength)
                          return foundIndex * indexSize;
                      } else {
                        if (foundIndex !== -1)
                          i -= i - foundIndex;
                        foundIndex = -1;
                      }
                    }
                  } else {
                    if (byteOffset + valLength > arrLength)
                      byteOffset = arrLength - valLength;
                    for (i = byteOffset; i >= 0; i--) {
                      var found = true;
                      for (var j = 0; j < valLength; j++) {
                        if (read(arr, i + j) !== read(val, j)) {
                          found = false;
                          break;
                        }
                      }
                      if (found)
                        return i;
                    }
                  }
                  return -1;
                }
                Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
                  return this.indexOf(val, byteOffset, encoding) !== -1;
                };
                Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
                  return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
                };
                Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
                  return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
                };
                function hexWrite(buf, string, offset, length) {
                  offset = Number(offset) || 0;
                  var remaining = buf.length - offset;
                  if (!length) {
                    length = remaining;
                  } else {
                    length = Number(length);
                    if (length > remaining) {
                      length = remaining;
                    }
                  }
                  var strLen = string.length;
                  if (length > strLen / 2) {
                    length = strLen / 2;
                  }
                  for (var i = 0; i < length; ++i) {
                    var parsed = parseInt(string.substr(i * 2, 2), 16);
                    if (numberIsNaN(parsed))
                      return i;
                    buf[offset + i] = parsed;
                  }
                  return i;
                }
                function utf8Write(buf, string, offset, length) {
                  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
                }
                function asciiWrite(buf, string, offset, length) {
                  return blitBuffer(asciiToBytes(string), buf, offset, length);
                }
                function base64Write(buf, string, offset, length) {
                  return blitBuffer(base64ToBytes(string), buf, offset, length);
                }
                function ucs2Write(buf, string, offset, length) {
                  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
                }
                Buffer.prototype.write = function write(string, offset, length, encoding) {
                  if (offset === void 0) {
                    encoding = "utf8";
                    length = this.length;
                    offset = 0;
                  } else if (length === void 0 && typeof offset === "string") {
                    encoding = offset;
                    length = this.length;
                    offset = 0;
                  } else if (isFinite(offset)) {
                    offset = offset >>> 0;
                    if (isFinite(length)) {
                      length = length >>> 0;
                      if (encoding === void 0)
                        encoding = "utf8";
                    } else {
                      encoding = length;
                      length = void 0;
                    }
                  } else {
                    throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
                  }
                  var remaining = this.length - offset;
                  if (length === void 0 || length > remaining)
                    length = remaining;
                  if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
                    throw new RangeError("Attempt to write outside buffer bounds");
                  }
                  if (!encoding)
                    encoding = "utf8";
                  var loweredCase = false;
                  for (; ; ) {
                    switch (encoding) {
                      case "hex":
                        return hexWrite(this, string, offset, length);
                      case "utf8":
                      case "utf-8":
                        return utf8Write(this, string, offset, length);
                      case "ascii":
                      case "latin1":
                      case "binary":
                        return asciiWrite(this, string, offset, length);
                      case "base64":
                        return base64Write(this, string, offset, length);
                      case "ucs2":
                      case "ucs-2":
                      case "utf16le":
                      case "utf-16le":
                        return ucs2Write(this, string, offset, length);
                      default:
                        if (loweredCase)
                          throw new TypeError("Unknown encoding: " + encoding);
                        encoding = ("" + encoding).toLowerCase();
                        loweredCase = true;
                    }
                  }
                };
                Buffer.prototype.toJSON = function toJSON() {
                  return {
                    type: "Buffer",
                    data: Array.prototype.slice.call(this._arr || this, 0)
                  };
                };
                function base64Slice(buf, start, end) {
                  if (start === 0 && end === buf.length) {
                    return base64.fromByteArray(buf);
                  } else {
                    return base64.fromByteArray(buf.slice(start, end));
                  }
                }
                function utf8Slice(buf, start, end) {
                  end = Math.min(buf.length, end);
                  var res = [];
                  var i = start;
                  while (i < end) {
                    var firstByte = buf[i];
                    var codePoint = null;
                    var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
                    if (i + bytesPerSequence <= end) {
                      var secondByte, thirdByte, fourthByte, tempCodePoint;
                      switch (bytesPerSequence) {
                        case 1:
                          if (firstByte < 128) {
                            codePoint = firstByte;
                          }
                          break;
                        case 2:
                          secondByte = buf[i + 1];
                          if ((secondByte & 192) === 128) {
                            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                            if (tempCodePoint > 127) {
                              codePoint = tempCodePoint;
                            }
                          }
                          break;
                        case 3:
                          secondByte = buf[i + 1];
                          thirdByte = buf[i + 2];
                          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                              codePoint = tempCodePoint;
                            }
                          }
                          break;
                        case 4:
                          secondByte = buf[i + 1];
                          thirdByte = buf[i + 2];
                          fourthByte = buf[i + 3];
                          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                              codePoint = tempCodePoint;
                            }
                          }
                      }
                    }
                    if (codePoint === null) {
                      codePoint = 65533;
                      bytesPerSequence = 1;
                    } else if (codePoint > 65535) {
                      codePoint -= 65536;
                      res.push(codePoint >>> 10 & 1023 | 55296);
                      codePoint = 56320 | codePoint & 1023;
                    }
                    res.push(codePoint);
                    i += bytesPerSequence;
                  }
                  return decodeCodePointsArray(res);
                }
                var MAX_ARGUMENTS_LENGTH = 4096;
                function decodeCodePointsArray(codePoints) {
                  var len = codePoints.length;
                  if (len <= MAX_ARGUMENTS_LENGTH) {
                    return String.fromCharCode.apply(String, codePoints);
                  }
                  var res = "";
                  var i = 0;
                  while (i < len) {
                    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
                  }
                  return res;
                }
                function asciiSlice(buf, start, end) {
                  var ret = "";
                  end = Math.min(buf.length, end);
                  for (var i = start; i < end; ++i) {
                    ret += String.fromCharCode(buf[i] & 127);
                  }
                  return ret;
                }
                function latin1Slice(buf, start, end) {
                  var ret = "";
                  end = Math.min(buf.length, end);
                  for (var i = start; i < end; ++i) {
                    ret += String.fromCharCode(buf[i]);
                  }
                  return ret;
                }
                function hexSlice(buf, start, end) {
                  var len = buf.length;
                  if (!start || start < 0)
                    start = 0;
                  if (!end || end < 0 || end > len)
                    end = len;
                  var out = "";
                  for (var i = start; i < end; ++i) {
                    out += hexSliceLookupTable[buf[i]];
                  }
                  return out;
                }
                function utf16leSlice(buf, start, end) {
                  var bytes = buf.slice(start, end);
                  var res = "";
                  for (var i = 0; i < bytes.length - 1; i += 2) {
                    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
                  }
                  return res;
                }
                Buffer.prototype.slice = function slice(start, end) {
                  var len = this.length;
                  start = ~~start;
                  end = end === void 0 ? len : ~~end;
                  if (start < 0) {
                    start += len;
                    if (start < 0)
                      start = 0;
                  } else if (start > len) {
                    start = len;
                  }
                  if (end < 0) {
                    end += len;
                    if (end < 0)
                      end = 0;
                  } else if (end > len) {
                    end = len;
                  }
                  if (end < start)
                    end = start;
                  var newBuf = this.subarray(start, end);
                  Object.setPrototypeOf(newBuf, Buffer.prototype);
                  return newBuf;
                };
                function checkOffset(offset, ext, length) {
                  if (offset % 1 !== 0 || offset < 0)
                    throw new RangeError("offset is not uint");
                  if (offset + ext > length)
                    throw new RangeError("Trying to access beyond buffer length");
                }
                Buffer.prototype.readUintLE = Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
                  offset = offset >>> 0;
                  byteLength2 = byteLength2 >>> 0;
                  if (!noAssert)
                    checkOffset(offset, byteLength2, this.length);
                  var val = this[offset];
                  var mul = 1;
                  var i = 0;
                  while (++i < byteLength2 && (mul *= 256)) {
                    val += this[offset + i] * mul;
                  }
                  return val;
                };
                Buffer.prototype.readUintBE = Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
                  offset = offset >>> 0;
                  byteLength2 = byteLength2 >>> 0;
                  if (!noAssert) {
                    checkOffset(offset, byteLength2, this.length);
                  }
                  var val = this[offset + --byteLength2];
                  var mul = 1;
                  while (byteLength2 > 0 && (mul *= 256)) {
                    val += this[offset + --byteLength2] * mul;
                  }
                  return val;
                };
                Buffer.prototype.readUint8 = Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
                  offset = offset >>> 0;
                  if (!noAssert)
                    checkOffset(offset, 1, this.length);
                  return this[offset];
                };
                Buffer.prototype.readUint16LE = Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
                  offset = offset >>> 0;
                  if (!noAssert)
                    checkOffset(offset, 2, this.length);
                  return this[offset] | this[offset + 1] << 8;
                };
                Buffer.prototype.readUint16BE = Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
                  offset = offset >>> 0;
                  if (!noAssert)
                    checkOffset(offset, 2, this.length);
                  return this[offset] << 8 | this[offset + 1];
                };
                Buffer.prototype.readUint32LE = Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
                  offset = offset >>> 0;
                  if (!noAssert)
                    checkOffset(offset, 4, this.length);
                  return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
                };
                Buffer.prototype.readUint32BE = Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
                  offset = offset >>> 0;
                  if (!noAssert)
                    checkOffset(offset, 4, this.length);
                  return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
                };
                Buffer.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
                  offset = offset >>> 0;
                  byteLength2 = byteLength2 >>> 0;
                  if (!noAssert)
                    checkOffset(offset, byteLength2, this.length);
                  var val = this[offset];
                  var mul = 1;
                  var i = 0;
                  while (++i < byteLength2 && (mul *= 256)) {
                    val += this[offset + i] * mul;
                  }
                  mul *= 128;
                  if (val >= mul)
                    val -= Math.pow(2, 8 * byteLength2);
                  return val;
                };
                Buffer.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
                  offset = offset >>> 0;
                  byteLength2 = byteLength2 >>> 0;
                  if (!noAssert)
                    checkOffset(offset, byteLength2, this.length);
                  var i = byteLength2;
                  var mul = 1;
                  var val = this[offset + --i];
                  while (i > 0 && (mul *= 256)) {
                    val += this[offset + --i] * mul;
                  }
                  mul *= 128;
                  if (val >= mul)
                    val -= Math.pow(2, 8 * byteLength2);
                  return val;
                };
                Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
                  offset = offset >>> 0;
                  if (!noAssert)
                    checkOffset(offset, 1, this.length);
                  if (!(this[offset] & 128))
                    return this[offset];
                  return (255 - this[offset] + 1) * -1;
                };
                Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
                  offset = offset >>> 0;
                  if (!noAssert)
                    checkOffset(offset, 2, this.length);
                  var val = this[offset] | this[offset + 1] << 8;
                  return val & 32768 ? val | 4294901760 : val;
                };
                Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
                  offset = offset >>> 0;
                  if (!noAssert)
                    checkOffset(offset, 2, this.length);
                  var val = this[offset + 1] | this[offset] << 8;
                  return val & 32768 ? val | 4294901760 : val;
                };
                Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
                  offset = offset >>> 0;
                  if (!noAssert)
                    checkOffset(offset, 4, this.length);
                  return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
                };
                Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
                  offset = offset >>> 0;
                  if (!noAssert)
                    checkOffset(offset, 4, this.length);
                  return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
                };
                Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
                  offset = offset >>> 0;
                  if (!noAssert)
                    checkOffset(offset, 4, this.length);
                  return ieee754.read(this, offset, true, 23, 4);
                };
                Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
                  offset = offset >>> 0;
                  if (!noAssert)
                    checkOffset(offset, 4, this.length);
                  return ieee754.read(this, offset, false, 23, 4);
                };
                Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
                  offset = offset >>> 0;
                  if (!noAssert)
                    checkOffset(offset, 8, this.length);
                  return ieee754.read(this, offset, true, 52, 8);
                };
                Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
                  offset = offset >>> 0;
                  if (!noAssert)
                    checkOffset(offset, 8, this.length);
                  return ieee754.read(this, offset, false, 52, 8);
                };
                function checkInt(buf, value, offset, ext, max, min) {
                  if (!Buffer.isBuffer(buf))
                    throw new TypeError('"buffer" argument must be a Buffer instance');
                  if (value > max || value < min)
                    throw new RangeError('"value" argument is out of bounds');
                  if (offset + ext > buf.length)
                    throw new RangeError("Index out of range");
                }
                Buffer.prototype.writeUintLE = Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
                  value = +value;
                  offset = offset >>> 0;
                  byteLength2 = byteLength2 >>> 0;
                  if (!noAssert) {
                    var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
                    checkInt(this, value, offset, byteLength2, maxBytes, 0);
                  }
                  var mul = 1;
                  var i = 0;
                  this[offset] = value & 255;
                  while (++i < byteLength2 && (mul *= 256)) {
                    this[offset + i] = value / mul & 255;
                  }
                  return offset + byteLength2;
                };
                Buffer.prototype.writeUintBE = Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
                  value = +value;
                  offset = offset >>> 0;
                  byteLength2 = byteLength2 >>> 0;
                  if (!noAssert) {
                    var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
                    checkInt(this, value, offset, byteLength2, maxBytes, 0);
                  }
                  var i = byteLength2 - 1;
                  var mul = 1;
                  this[offset + i] = value & 255;
                  while (--i >= 0 && (mul *= 256)) {
                    this[offset + i] = value / mul & 255;
                  }
                  return offset + byteLength2;
                };
                Buffer.prototype.writeUint8 = Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
                  value = +value;
                  offset = offset >>> 0;
                  if (!noAssert)
                    checkInt(this, value, offset, 1, 255, 0);
                  this[offset] = value & 255;
                  return offset + 1;
                };
                Buffer.prototype.writeUint16LE = Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
                  value = +value;
                  offset = offset >>> 0;
                  if (!noAssert)
                    checkInt(this, value, offset, 2, 65535, 0);
                  this[offset] = value & 255;
                  this[offset + 1] = value >>> 8;
                  return offset + 2;
                };
                Buffer.prototype.writeUint16BE = Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
                  value = +value;
                  offset = offset >>> 0;
                  if (!noAssert)
                    checkInt(this, value, offset, 2, 65535, 0);
                  this[offset] = value >>> 8;
                  this[offset + 1] = value & 255;
                  return offset + 2;
                };
                Buffer.prototype.writeUint32LE = Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
                  value = +value;
                  offset = offset >>> 0;
                  if (!noAssert)
                    checkInt(this, value, offset, 4, 4294967295, 0);
                  this[offset + 3] = value >>> 24;
                  this[offset + 2] = value >>> 16;
                  this[offset + 1] = value >>> 8;
                  this[offset] = value & 255;
                  return offset + 4;
                };
                Buffer.prototype.writeUint32BE = Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
                  value = +value;
                  offset = offset >>> 0;
                  if (!noAssert)
                    checkInt(this, value, offset, 4, 4294967295, 0);
                  this[offset] = value >>> 24;
                  this[offset + 1] = value >>> 16;
                  this[offset + 2] = value >>> 8;
                  this[offset + 3] = value & 255;
                  return offset + 4;
                };
                Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
                  value = +value;
                  offset = offset >>> 0;
                  if (!noAssert) {
                    var limit = Math.pow(2, 8 * byteLength2 - 1);
                    checkInt(this, value, offset, byteLength2, limit - 1, -limit);
                  }
                  var i = 0;
                  var mul = 1;
                  var sub = 0;
                  this[offset] = value & 255;
                  while (++i < byteLength2 && (mul *= 256)) {
                    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
                      sub = 1;
                    }
                    this[offset + i] = (value / mul >> 0) - sub & 255;
                  }
                  return offset + byteLength2;
                };
                Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
                  value = +value;
                  offset = offset >>> 0;
                  if (!noAssert) {
                    var limit = Math.pow(2, 8 * byteLength2 - 1);
                    checkInt(this, value, offset, byteLength2, limit - 1, -limit);
                  }
                  var i = byteLength2 - 1;
                  var mul = 1;
                  var sub = 0;
                  this[offset + i] = value & 255;
                  while (--i >= 0 && (mul *= 256)) {
                    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
                      sub = 1;
                    }
                    this[offset + i] = (value / mul >> 0) - sub & 255;
                  }
                  return offset + byteLength2;
                };
                Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
                  value = +value;
                  offset = offset >>> 0;
                  if (!noAssert)
                    checkInt(this, value, offset, 1, 127, -128);
                  if (value < 0)
                    value = 255 + value + 1;
                  this[offset] = value & 255;
                  return offset + 1;
                };
                Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
                  value = +value;
                  offset = offset >>> 0;
                  if (!noAssert)
                    checkInt(this, value, offset, 2, 32767, -32768);
                  this[offset] = value & 255;
                  this[offset + 1] = value >>> 8;
                  return offset + 2;
                };
                Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
                  value = +value;
                  offset = offset >>> 0;
                  if (!noAssert)
                    checkInt(this, value, offset, 2, 32767, -32768);
                  this[offset] = value >>> 8;
                  this[offset + 1] = value & 255;
                  return offset + 2;
                };
                Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
                  value = +value;
                  offset = offset >>> 0;
                  if (!noAssert)
                    checkInt(this, value, offset, 4, 2147483647, -2147483648);
                  this[offset] = value & 255;
                  this[offset + 1] = value >>> 8;
                  this[offset + 2] = value >>> 16;
                  this[offset + 3] = value >>> 24;
                  return offset + 4;
                };
                Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
                  value = +value;
                  offset = offset >>> 0;
                  if (!noAssert)
                    checkInt(this, value, offset, 4, 2147483647, -2147483648);
                  if (value < 0)
                    value = 4294967295 + value + 1;
                  this[offset] = value >>> 24;
                  this[offset + 1] = value >>> 16;
                  this[offset + 2] = value >>> 8;
                  this[offset + 3] = value & 255;
                  return offset + 4;
                };
                function checkIEEE754(buf, value, offset, ext, max, min) {
                  if (offset + ext > buf.length)
                    throw new RangeError("Index out of range");
                  if (offset < 0)
                    throw new RangeError("Index out of range");
                }
                function writeFloat(buf, value, offset, littleEndian, noAssert) {
                  value = +value;
                  offset = offset >>> 0;
                  if (!noAssert) {
                    checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
                  }
                  ieee754.write(buf, value, offset, littleEndian, 23, 4);
                  return offset + 4;
                }
                Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
                  return writeFloat(this, value, offset, true, noAssert);
                };
                Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
                  return writeFloat(this, value, offset, false, noAssert);
                };
                function writeDouble(buf, value, offset, littleEndian, noAssert) {
                  value = +value;
                  offset = offset >>> 0;
                  if (!noAssert) {
                    checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
                  }
                  ieee754.write(buf, value, offset, littleEndian, 52, 8);
                  return offset + 8;
                }
                Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
                  return writeDouble(this, value, offset, true, noAssert);
                };
                Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
                  return writeDouble(this, value, offset, false, noAssert);
                };
                Buffer.prototype.copy = function copy(target, targetStart, start, end) {
                  if (!Buffer.isBuffer(target))
                    throw new TypeError("argument should be a Buffer");
                  if (!start)
                    start = 0;
                  if (!end && end !== 0)
                    end = this.length;
                  if (targetStart >= target.length)
                    targetStart = target.length;
                  if (!targetStart)
                    targetStart = 0;
                  if (end > 0 && end < start)
                    end = start;
                  if (end === start)
                    return 0;
                  if (target.length === 0 || this.length === 0)
                    return 0;
                  if (targetStart < 0) {
                    throw new RangeError("targetStart out of bounds");
                  }
                  if (start < 0 || start >= this.length)
                    throw new RangeError("Index out of range");
                  if (end < 0)
                    throw new RangeError("sourceEnd out of bounds");
                  if (end > this.length)
                    end = this.length;
                  if (target.length - targetStart < end - start) {
                    end = target.length - targetStart + start;
                  }
                  var len = end - start;
                  if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
                    this.copyWithin(targetStart, start, end);
                  } else {
                    Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
                  }
                  return len;
                };
                Buffer.prototype.fill = function fill(val, start, end, encoding) {
                  if (typeof val === "string") {
                    if (typeof start === "string") {
                      encoding = start;
                      start = 0;
                      end = this.length;
                    } else if (typeof end === "string") {
                      encoding = end;
                      end = this.length;
                    }
                    if (encoding !== void 0 && typeof encoding !== "string") {
                      throw new TypeError("encoding must be a string");
                    }
                    if (typeof encoding === "string" && !Buffer.isEncoding(encoding)) {
                      throw new TypeError("Unknown encoding: " + encoding);
                    }
                    if (val.length === 1) {
                      var code = val.charCodeAt(0);
                      if (encoding === "utf8" && code < 128 || encoding === "latin1") {
                        val = code;
                      }
                    }
                  } else if (typeof val === "number") {
                    val = val & 255;
                  } else if (typeof val === "boolean") {
                    val = Number(val);
                  }
                  if (start < 0 || this.length < start || this.length < end) {
                    throw new RangeError("Out of range index");
                  }
                  if (end <= start) {
                    return this;
                  }
                  start = start >>> 0;
                  end = end === void 0 ? this.length : end >>> 0;
                  if (!val)
                    val = 0;
                  var i;
                  if (typeof val === "number") {
                    for (i = start; i < end; ++i) {
                      this[i] = val;
                    }
                  } else {
                    var bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);
                    var len = bytes.length;
                    if (len === 0) {
                      throw new TypeError('The value "' + val + '" is invalid for argument "value"');
                    }
                    for (i = 0; i < end - start; ++i) {
                      this[i + start] = bytes[i % len];
                    }
                  }
                  return this;
                };
                var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
                function base64clean(str) {
                  str = str.split("=")[0];
                  str = str.trim().replace(INVALID_BASE64_RE, "");
                  if (str.length < 2)
                    return "";
                  while (str.length % 4 !== 0) {
                    str = str + "=";
                  }
                  return str;
                }
                function utf8ToBytes(string, units) {
                  units = units || Infinity;
                  var codePoint;
                  var length = string.length;
                  var leadSurrogate = null;
                  var bytes = [];
                  for (var i = 0; i < length; ++i) {
                    codePoint = string.charCodeAt(i);
                    if (codePoint > 55295 && codePoint < 57344) {
                      if (!leadSurrogate) {
                        if (codePoint > 56319) {
                          if ((units -= 3) > -1)
                            bytes.push(239, 191, 189);
                          continue;
                        } else if (i + 1 === length) {
                          if ((units -= 3) > -1)
                            bytes.push(239, 191, 189);
                          continue;
                        }
                        leadSurrogate = codePoint;
                        continue;
                      }
                      if (codePoint < 56320) {
                        if ((units -= 3) > -1)
                          bytes.push(239, 191, 189);
                        leadSurrogate = codePoint;
                        continue;
                      }
                      codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
                    } else if (leadSurrogate) {
                      if ((units -= 3) > -1)
                        bytes.push(239, 191, 189);
                    }
                    leadSurrogate = null;
                    if (codePoint < 128) {
                      if ((units -= 1) < 0)
                        break;
                      bytes.push(codePoint);
                    } else if (codePoint < 2048) {
                      if ((units -= 2) < 0)
                        break;
                      bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
                    } else if (codePoint < 65536) {
                      if ((units -= 3) < 0)
                        break;
                      bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
                    } else if (codePoint < 1114112) {
                      if ((units -= 4) < 0)
                        break;
                      bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
                    } else {
                      throw new Error("Invalid code point");
                    }
                  }
                  return bytes;
                }
                function asciiToBytes(str) {
                  var byteArray = [];
                  for (var i = 0; i < str.length; ++i) {
                    byteArray.push(str.charCodeAt(i) & 255);
                  }
                  return byteArray;
                }
                function utf16leToBytes(str, units) {
                  var c, hi, lo;
                  var byteArray = [];
                  for (var i = 0; i < str.length; ++i) {
                    if ((units -= 2) < 0)
                      break;
                    c = str.charCodeAt(i);
                    hi = c >> 8;
                    lo = c % 256;
                    byteArray.push(lo);
                    byteArray.push(hi);
                  }
                  return byteArray;
                }
                function base64ToBytes(str) {
                  return base64.toByteArray(base64clean(str));
                }
                function blitBuffer(src, dst, offset, length) {
                  for (var i = 0; i < length; ++i) {
                    if (i + offset >= dst.length || i >= src.length)
                      break;
                    dst[i + offset] = src[i];
                  }
                  return i;
                }
                function isInstance(obj, type) {
                  return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
                }
                function numberIsNaN(obj) {
                  return obj !== obj;
                }
                var hexSliceLookupTable = function() {
                  var alphabet = "0123456789abcdef";
                  var table = new Array(256);
                  for (var i = 0; i < 16; ++i) {
                    var i16 = i * 16;
                    for (var j = 0; j < 16; ++j) {
                      table[i16 + j] = alphabet[i] + alphabet[j];
                    }
                  }
                  return table;
                }();
              }
            ),
            /***/
            722: (
              /***/
              function(module2) {
                "use strict";
                var R = typeof Reflect === "object" ? Reflect : null;
                var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply2(target, receiver, args) {
                  return Function.prototype.apply.call(target, receiver, args);
                };
                var ReflectOwnKeys;
                if (R && typeof R.ownKeys === "function") {
                  ReflectOwnKeys = R.ownKeys;
                } else if (Object.getOwnPropertySymbols) {
                  ReflectOwnKeys = function ReflectOwnKeys2(target) {
                    return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
                  };
                } else {
                  ReflectOwnKeys = function ReflectOwnKeys2(target) {
                    return Object.getOwnPropertyNames(target);
                  };
                }
                function ProcessEmitWarning(warning) {
                  if (console && console.warn)
                    console.warn(warning);
                }
                var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
                  return value !== value;
                };
                function EventEmitter() {
                  EventEmitter.init.call(this);
                }
                module2.exports = EventEmitter;
                module2.exports.once = once;
                EventEmitter.EventEmitter = EventEmitter;
                EventEmitter.prototype._events = void 0;
                EventEmitter.prototype._eventsCount = 0;
                EventEmitter.prototype._maxListeners = void 0;
                var defaultMaxListeners = 10;
                function checkListener(listener) {
                  if (typeof listener !== "function") {
                    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
                  }
                }
                Object.defineProperty(EventEmitter, "defaultMaxListeners", {
                  enumerable: true,
                  get: function() {
                    return defaultMaxListeners;
                  },
                  set: function(arg) {
                    if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
                      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
                    }
                    defaultMaxListeners = arg;
                  }
                });
                EventEmitter.init = function() {
                  if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
                    this._events = /* @__PURE__ */ Object.create(null);
                    this._eventsCount = 0;
                  }
                  this._maxListeners = this._maxListeners || void 0;
                };
                EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
                  if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) {
                    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
                  }
                  this._maxListeners = n;
                  return this;
                };
                function _getMaxListeners(that) {
                  if (that._maxListeners === void 0)
                    return EventEmitter.defaultMaxListeners;
                  return that._maxListeners;
                }
                EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
                  return _getMaxListeners(this);
                };
                EventEmitter.prototype.emit = function emit(type) {
                  var args = [];
                  for (var i = 1; i < arguments.length; i++)
                    args.push(arguments[i]);
                  var doError = type === "error";
                  var events = this._events;
                  if (events !== void 0)
                    doError = doError && events.error === void 0;
                  else if (!doError)
                    return false;
                  if (doError) {
                    var er;
                    if (args.length > 0)
                      er = args[0];
                    if (er instanceof Error) {
                      throw er;
                    }
                    var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
                    err.context = er;
                    throw err;
                  }
                  var handler = events[type];
                  if (handler === void 0)
                    return false;
                  if (typeof handler === "function") {
                    ReflectApply(handler, this, args);
                  } else {
                    var len = handler.length;
                    var listeners = arrayClone(handler, len);
                    for (var i = 0; i < len; ++i)
                      ReflectApply(listeners[i], this, args);
                  }
                  return true;
                };
                function _addListener(target, type, listener, prepend) {
                  var m;
                  var events;
                  var existing;
                  checkListener(listener);
                  events = target._events;
                  if (events === void 0) {
                    events = target._events = /* @__PURE__ */ Object.create(null);
                    target._eventsCount = 0;
                  } else {
                    if (events.newListener !== void 0) {
                      target.emit("newListener", type, listener.listener ? listener.listener : listener);
                      events = target._events;
                    }
                    existing = events[type];
                  }
                  if (existing === void 0) {
                    existing = events[type] = listener;
                    ++target._eventsCount;
                  } else {
                    if (typeof existing === "function") {
                      existing = events[type] = prepend ? [listener, existing] : [existing, listener];
                    } else if (prepend) {
                      existing.unshift(listener);
                    } else {
                      existing.push(listener);
                    }
                    m = _getMaxListeners(target);
                    if (m > 0 && existing.length > m && !existing.warned) {
                      existing.warned = true;
                      var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
                      w.name = "MaxListenersExceededWarning";
                      w.emitter = target;
                      w.type = type;
                      w.count = existing.length;
                      ProcessEmitWarning(w);
                    }
                  }
                  return target;
                }
                EventEmitter.prototype.addListener = function addListener(type, listener) {
                  return _addListener(this, type, listener, false);
                };
                EventEmitter.prototype.on = EventEmitter.prototype.addListener;
                EventEmitter.prototype.prependListener = function prependListener(type, listener) {
                  return _addListener(this, type, listener, true);
                };
                function onceWrapper() {
                  if (!this.fired) {
                    this.target.removeListener(this.type, this.wrapFn);
                    this.fired = true;
                    if (arguments.length === 0)
                      return this.listener.call(this.target);
                    return this.listener.apply(this.target, arguments);
                  }
                }
                function _onceWrap(target, type, listener) {
                  var state = { fired: false, wrapFn: void 0, target, type, listener };
                  var wrapped = onceWrapper.bind(state);
                  wrapped.listener = listener;
                  state.wrapFn = wrapped;
                  return wrapped;
                }
                EventEmitter.prototype.once = function once2(type, listener) {
                  checkListener(listener);
                  this.on(type, _onceWrap(this, type, listener));
                  return this;
                };
                EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
                  checkListener(listener);
                  this.prependListener(type, _onceWrap(this, type, listener));
                  return this;
                };
                EventEmitter.prototype.removeListener = function removeListener(type, listener) {
                  var list, events, position, i, originalListener;
                  checkListener(listener);
                  events = this._events;
                  if (events === void 0)
                    return this;
                  list = events[type];
                  if (list === void 0)
                    return this;
                  if (list === listener || list.listener === listener) {
                    if (--this._eventsCount === 0)
                      this._events = /* @__PURE__ */ Object.create(null);
                    else {
                      delete events[type];
                      if (events.removeListener)
                        this.emit("removeListener", type, list.listener || listener);
                    }
                  } else if (typeof list !== "function") {
                    position = -1;
                    for (i = list.length - 1; i >= 0; i--) {
                      if (list[i] === listener || list[i].listener === listener) {
                        originalListener = list[i].listener;
                        position = i;
                        break;
                      }
                    }
                    if (position < 0)
                      return this;
                    if (position === 0)
                      list.shift();
                    else {
                      spliceOne(list, position);
                    }
                    if (list.length === 1)
                      events[type] = list[0];
                    if (events.removeListener !== void 0)
                      this.emit("removeListener", type, originalListener || listener);
                  }
                  return this;
                };
                EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
                EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
                  var listeners, events, i;
                  events = this._events;
                  if (events === void 0)
                    return this;
                  if (events.removeListener === void 0) {
                    if (arguments.length === 0) {
                      this._events = /* @__PURE__ */ Object.create(null);
                      this._eventsCount = 0;
                    } else if (events[type] !== void 0) {
                      if (--this._eventsCount === 0)
                        this._events = /* @__PURE__ */ Object.create(null);
                      else
                        delete events[type];
                    }
                    return this;
                  }
                  if (arguments.length === 0) {
                    var keys = Object.keys(events);
                    var key;
                    for (i = 0; i < keys.length; ++i) {
                      key = keys[i];
                      if (key === "removeListener")
                        continue;
                      this.removeAllListeners(key);
                    }
                    this.removeAllListeners("removeListener");
                    this._events = /* @__PURE__ */ Object.create(null);
                    this._eventsCount = 0;
                    return this;
                  }
                  listeners = events[type];
                  if (typeof listeners === "function") {
                    this.removeListener(type, listeners);
                  } else if (listeners !== void 0) {
                    for (i = listeners.length - 1; i >= 0; i--) {
                      this.removeListener(type, listeners[i]);
                    }
                  }
                  return this;
                };
                function _listeners(target, type, unwrap) {
                  var events = target._events;
                  if (events === void 0)
                    return [];
                  var evlistener = events[type];
                  if (evlistener === void 0)
                    return [];
                  if (typeof evlistener === "function")
                    return unwrap ? [evlistener.listener || evlistener] : [evlistener];
                  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
                }
                EventEmitter.prototype.listeners = function listeners(type) {
                  return _listeners(this, type, true);
                };
                EventEmitter.prototype.rawListeners = function rawListeners(type) {
                  return _listeners(this, type, false);
                };
                EventEmitter.listenerCount = function(emitter, type) {
                  if (typeof emitter.listenerCount === "function") {
                    return emitter.listenerCount(type);
                  } else {
                    return listenerCount.call(emitter, type);
                  }
                };
                EventEmitter.prototype.listenerCount = listenerCount;
                function listenerCount(type) {
                  var events = this._events;
                  if (events !== void 0) {
                    var evlistener = events[type];
                    if (typeof evlistener === "function") {
                      return 1;
                    } else if (evlistener !== void 0) {
                      return evlistener.length;
                    }
                  }
                  return 0;
                }
                EventEmitter.prototype.eventNames = function eventNames() {
                  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
                };
                function arrayClone(arr, n) {
                  var copy = new Array(n);
                  for (var i = 0; i < n; ++i)
                    copy[i] = arr[i];
                  return copy;
                }
                function spliceOne(list, index) {
                  for (; index + 1 < list.length; index++)
                    list[index] = list[index + 1];
                  list.pop();
                }
                function unwrapListeners(arr) {
                  var ret = new Array(arr.length);
                  for (var i = 0; i < ret.length; ++i) {
                    ret[i] = arr[i].listener || arr[i];
                  }
                  return ret;
                }
                function once(emitter, name) {
                  return new Promise(function(resolve, reject) {
                    function errorListener(err) {
                      emitter.removeListener(name, resolver);
                      reject(err);
                    }
                    function resolver() {
                      if (typeof emitter.removeListener === "function") {
                        emitter.removeListener("error", errorListener);
                      }
                      resolve([].slice.call(arguments));
                    }
                    ;
                    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
                    if (name !== "error") {
                      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
                    }
                  });
                }
                function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
                  if (typeof emitter.on === "function") {
                    eventTargetAgnosticAddListener(emitter, "error", handler, flags);
                  }
                }
                function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
                  if (typeof emitter.on === "function") {
                    if (flags.once) {
                      emitter.once(name, listener);
                    } else {
                      emitter.on(name, listener);
                    }
                  } else if (typeof emitter.addEventListener === "function") {
                    emitter.addEventListener(name, function wrapListener(arg) {
                      if (flags.once) {
                        emitter.removeEventListener(name, wrapListener);
                      }
                      listener(arg);
                    });
                  } else {
                    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
                  }
                }
              }
            ),
            /***/
            74: (
              /***/
              function(__unused_webpack_module, exports2) {
                "use strict";
                exports2.read = function(buffer, offset, isLE, mLen, nBytes) {
                  var e, m;
                  var eLen = nBytes * 8 - mLen - 1;
                  var eMax = (1 << eLen) - 1;
                  var eBias = eMax >> 1;
                  var nBits = -7;
                  var i = isLE ? nBytes - 1 : 0;
                  var d = isLE ? -1 : 1;
                  var s = buffer[offset + i];
                  i += d;
                  e = s & (1 << -nBits) - 1;
                  s >>= -nBits;
                  nBits += eLen;
                  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
                  }
                  m = e & (1 << -nBits) - 1;
                  e >>= -nBits;
                  nBits += mLen;
                  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
                  }
                  if (e === 0) {
                    e = 1 - eBias;
                  } else if (e === eMax) {
                    return m ? NaN : (s ? -1 : 1) * Infinity;
                  } else {
                    m = m + Math.pow(2, mLen);
                    e = e - eBias;
                  }
                  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
                };
                exports2.write = function(buffer, value, offset, isLE, mLen, nBytes) {
                  var e, m, c;
                  var eLen = nBytes * 8 - mLen - 1;
                  var eMax = (1 << eLen) - 1;
                  var eBias = eMax >> 1;
                  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
                  var i = isLE ? 0 : nBytes - 1;
                  var d = isLE ? 1 : -1;
                  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
                  value = Math.abs(value);
                  if (isNaN(value) || value === Infinity) {
                    m = isNaN(value) ? 1 : 0;
                    e = eMax;
                  } else {
                    e = Math.floor(Math.log(value) / Math.LN2);
                    if (value * (c = Math.pow(2, -e)) < 1) {
                      e--;
                      c *= 2;
                    }
                    if (e + eBias >= 1) {
                      value += rt / c;
                    } else {
                      value += rt * Math.pow(2, 1 - eBias);
                    }
                    if (value * c >= 2) {
                      e++;
                      c /= 2;
                    }
                    if (e + eBias >= eMax) {
                      m = 0;
                      e = eMax;
                    } else if (e + eBias >= 1) {
                      m = (value * c - 1) * Math.pow(2, mLen);
                      e = e + eBias;
                    } else {
                      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
                      e = 0;
                    }
                  }
                  for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
                  }
                  e = e << mLen | m;
                  eLen += mLen;
                  for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
                  }
                  buffer[offset + i - d] |= s * 128;
                };
              }
            ),
            /***/
            409: (
              /***/
              function(module2) {
                "use strict";
                if (typeof Object.create === "function") {
                  module2.exports = function inherits(ctor, superCtor) {
                    if (superCtor) {
                      ctor.super_ = superCtor;
                      ctor.prototype = Object.create(superCtor.prototype, {
                        constructor: {
                          value: ctor,
                          enumerable: false,
                          writable: true,
                          configurable: true
                        }
                      });
                    }
                  };
                } else {
                  module2.exports = function inherits(ctor, superCtor) {
                    if (superCtor) {
                      ctor.super_ = superCtor;
                      var TempCtor = function() {
                      };
                      TempCtor.prototype = superCtor.prototype;
                      ctor.prototype = new TempCtor();
                      ctor.prototype.constructor = ctor;
                    }
                  };
                }
              }
            ),
            /***/
            983: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                module2.exports = __webpack_require__2(983);
              }
            ),
            /***/
            50: (
              /***/
              function(module2) {
                "use strict";
                function _inheritsLoose(subClass, superClass) {
                  subClass.prototype = Object.create(superClass.prototype);
                  subClass.prototype.constructor = subClass;
                  subClass.__proto__ = superClass;
                }
                var codes = {};
                function createErrorType(code, message, Base) {
                  if (!Base) {
                    Base = Error;
                  }
                  function getMessage(arg1, arg2, arg3) {
                    if (typeof message === "string") {
                      return message;
                    } else {
                      return message(arg1, arg2, arg3);
                    }
                  }
                  var NodeError = function(_Base) {
                    _inheritsLoose(NodeError2, _Base);
                    function NodeError2(arg1, arg2, arg3) {
                      return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
                    }
                    return NodeError2;
                  }(Base);
                  NodeError.prototype.name = Base.name;
                  NodeError.prototype.code = code;
                  codes[code] = NodeError;
                }
                function oneOf(expected, thing) {
                  if (Array.isArray(expected)) {
                    var len = expected.length;
                    expected = expected.map(function(i) {
                      return String(i);
                    });
                    if (len > 2) {
                      return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
                    } else if (len === 2) {
                      return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
                    } else {
                      return "of ".concat(thing, " ").concat(expected[0]);
                    }
                  } else {
                    return "of ".concat(thing, " ").concat(String(expected));
                  }
                }
                function startsWith(str, search, pos) {
                  return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
                }
                function endsWith(str, search, this_len) {
                  if (this_len === void 0 || this_len > str.length) {
                    this_len = str.length;
                  }
                  return str.substring(this_len - search.length, this_len) === search;
                }
                function includes(str, search, start) {
                  if (typeof start !== "number") {
                    start = 0;
                  }
                  if (start + search.length > str.length) {
                    return false;
                  } else {
                    return str.indexOf(search, start) !== -1;
                  }
                }
                createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
                  return 'The value "' + value + '" is invalid for option "' + name + '"';
                }, TypeError);
                createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
                  var determiner;
                  if (typeof expected === "string" && startsWith(expected, "not ")) {
                    determiner = "must not be";
                    expected = expected.replace(/^not /, "");
                  } else {
                    determiner = "must be";
                  }
                  var msg;
                  if (endsWith(name, " argument")) {
                    msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
                  } else {
                    var type = includes(name, ".") ? "property" : "argument";
                    msg = 'The "'.concat(name, '" ').concat(type, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
                  }
                  msg += ". Received type ".concat(typeof actual);
                  return msg;
                }, TypeError);
                createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
                createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
                  return "The " + name + " method is not implemented";
                });
                createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
                createErrorType("ERR_STREAM_DESTROYED", function(name) {
                  return "Cannot call " + name + " after a stream was destroyed";
                });
                createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
                createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
                createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
                createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
                createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
                  return "Unknown encoding: " + arg;
                }, TypeError);
                createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
                module2.exports.q = codes;
              }
            ),
            /***/
            298: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var objectKeys = Object.keys || function(obj) {
                  var keys2 = [];
                  for (var key in obj) {
                    keys2.push(key);
                  }
                  return keys2;
                };
                module2.exports = Duplex;
                var Readable = __webpack_require__2(58);
                var Writable = __webpack_require__2(880);
                __webpack_require__2(409)(Duplex, Readable);
                {
                  var keys = objectKeys(Writable.prototype);
                  for (var v = 0; v < keys.length; v++) {
                    var method = keys[v];
                    if (!Duplex.prototype[method])
                      Duplex.prototype[method] = Writable.prototype[method];
                  }
                }
                function Duplex(options) {
                  if (!(this instanceof Duplex))
                    return new Duplex(options);
                  Readable.call(this, options);
                  Writable.call(this, options);
                  this.allowHalfOpen = true;
                  if (options) {
                    if (options.readable === false)
                      this.readable = false;
                    if (options.writable === false)
                      this.writable = false;
                    if (options.allowHalfOpen === false) {
                      this.allowHalfOpen = false;
                      this.once("end", onend);
                    }
                  }
                }
                Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
                  // making it explicit this property is not enumerable
                  // because otherwise some prototype manipulation in
                  // userland will fail
                  enumerable: false,
                  get: function get() {
                    return this._writableState.highWaterMark;
                  }
                });
                Object.defineProperty(Duplex.prototype, "writableBuffer", {
                  // making it explicit this property is not enumerable
                  // because otherwise some prototype manipulation in
                  // userland will fail
                  enumerable: false,
                  get: function get() {
                    return this._writableState && this._writableState.getBuffer();
                  }
                });
                Object.defineProperty(Duplex.prototype, "writableLength", {
                  // making it explicit this property is not enumerable
                  // because otherwise some prototype manipulation in
                  // userland will fail
                  enumerable: false,
                  get: function get() {
                    return this._writableState.length;
                  }
                });
                function onend() {
                  if (this._writableState.ended)
                    return;
                  process.nextTick(onEndNT, this);
                }
                function onEndNT(self2) {
                  self2.end();
                }
                Object.defineProperty(Duplex.prototype, "destroyed", {
                  // making it explicit this property is not enumerable
                  // because otherwise some prototype manipulation in
                  // userland will fail
                  enumerable: false,
                  get: function get() {
                    if (this._readableState === void 0 || this._writableState === void 0) {
                      return false;
                    }
                    return this._readableState.destroyed && this._writableState.destroyed;
                  },
                  set: function set(value) {
                    if (this._readableState === void 0 || this._writableState === void 0) {
                      return;
                    }
                    this._readableState.destroyed = value;
                    this._writableState.destroyed = value;
                  }
                });
              }
            ),
            /***/
            4: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                module2.exports = PassThrough;
                var Transform = __webpack_require__2(969);
                __webpack_require__2(409)(PassThrough, Transform);
                function PassThrough(options) {
                  if (!(this instanceof PassThrough))
                    return new PassThrough(options);
                  Transform.call(this, options);
                }
                PassThrough.prototype._transform = function(chunk, encoding, cb) {
                  cb(null, chunk);
                };
              }
            ),
            /***/
            58: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                module2.exports = Readable;
                var Duplex;
                Readable.ReadableState = ReadableState;
                var EE = __webpack_require__2(722).EventEmitter;
                var EElistenerCount = function EElistenerCount2(emitter, type) {
                  return emitter.listeners(type).length;
                };
                var Stream = __webpack_require__2(786);
                var Buffer = __webpack_require__2(636).Buffer;
                var OurUint8Array = __webpack_require__2.g.Uint8Array || function() {
                };
                function _uint8ArrayToBuffer(chunk) {
                  return Buffer.from(chunk);
                }
                function _isUint8Array(obj) {
                  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
                }
                var debugUtil = __webpack_require__2(602);
                var debug;
                if (debugUtil && debugUtil.debuglog) {
                  debug = debugUtil.debuglog("stream");
                } else {
                  debug = function debug2() {
                  };
                }
                var BufferList = __webpack_require__2(346);
                var destroyImpl = __webpack_require__2(974);
                var _require = __webpack_require__2(754), getHighWaterMark = _require.getHighWaterMark;
                var _require$codes = __webpack_require__2(50).q, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
                var StringDecoder;
                var createReadableStreamAsyncIterator;
                var from;
                __webpack_require__2(409)(Readable, Stream);
                var errorOrDestroy = destroyImpl.errorOrDestroy;
                var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
                function prependListener(emitter, event, fn) {
                  if (typeof emitter.prependListener === "function")
                    return emitter.prependListener(event, fn);
                  if (!emitter._events || !emitter._events[event])
                    emitter.on(event, fn);
                  else if (Array.isArray(emitter._events[event]))
                    emitter._events[event].unshift(fn);
                  else
                    emitter._events[event] = [fn, emitter._events[event]];
                }
                function ReadableState(options, stream, isDuplex) {
                  Duplex = Duplex || __webpack_require__2(298);
                  options = options || {};
                  if (typeof isDuplex !== "boolean")
                    isDuplex = stream instanceof Duplex;
                  this.objectMode = !!options.objectMode;
                  if (isDuplex)
                    this.objectMode = this.objectMode || !!options.readableObjectMode;
                  this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
                  this.buffer = new BufferList();
                  this.length = 0;
                  this.pipes = null;
                  this.pipesCount = 0;
                  this.flowing = null;
                  this.ended = false;
                  this.endEmitted = false;
                  this.reading = false;
                  this.sync = true;
                  this.needReadable = false;
                  this.emittedReadable = false;
                  this.readableListening = false;
                  this.resumeScheduled = false;
                  this.paused = true;
                  this.emitClose = options.emitClose !== false;
                  this.autoDestroy = !!options.autoDestroy;
                  this.destroyed = false;
                  this.defaultEncoding = options.defaultEncoding || "utf8";
                  this.awaitDrain = 0;
                  this.readingMore = false;
                  this.decoder = null;
                  this.encoding = null;
                  if (options.encoding) {
                    if (!StringDecoder)
                      StringDecoder = __webpack_require__2(183).s;
                    this.decoder = new StringDecoder(options.encoding);
                    this.encoding = options.encoding;
                  }
                }
                function Readable(options) {
                  Duplex = Duplex || __webpack_require__2(298);
                  if (!(this instanceof Readable))
                    return new Readable(options);
                  var isDuplex = this instanceof Duplex;
                  this._readableState = new ReadableState(options, this, isDuplex);
                  this.readable = true;
                  if (options) {
                    if (typeof options.read === "function")
                      this._read = options.read;
                    if (typeof options.destroy === "function")
                      this._destroy = options.destroy;
                  }
                  Stream.call(this);
                }
                Object.defineProperty(Readable.prototype, "destroyed", {
                  // making it explicit this property is not enumerable
                  // because otherwise some prototype manipulation in
                  // userland will fail
                  enumerable: false,
                  get: function get() {
                    if (this._readableState === void 0) {
                      return false;
                    }
                    return this._readableState.destroyed;
                  },
                  set: function set(value) {
                    if (!this._readableState) {
                      return;
                    }
                    this._readableState.destroyed = value;
                  }
                });
                Readable.prototype.destroy = destroyImpl.destroy;
                Readable.prototype._undestroy = destroyImpl.undestroy;
                Readable.prototype._destroy = function(err, cb) {
                  cb(err);
                };
                Readable.prototype.push = function(chunk, encoding) {
                  var state = this._readableState;
                  var skipChunkCheck;
                  if (!state.objectMode) {
                    if (typeof chunk === "string") {
                      encoding = encoding || state.defaultEncoding;
                      if (encoding !== state.encoding) {
                        chunk = Buffer.from(chunk, encoding);
                        encoding = "";
                      }
                      skipChunkCheck = true;
                    }
                  } else {
                    skipChunkCheck = true;
                  }
                  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
                };
                Readable.prototype.unshift = function(chunk) {
                  return readableAddChunk(this, chunk, null, true, false);
                };
                function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
                  debug("readableAddChunk", chunk);
                  var state = stream._readableState;
                  if (chunk === null) {
                    state.reading = false;
                    onEofChunk(stream, state);
                  } else {
                    var er;
                    if (!skipChunkCheck)
                      er = chunkInvalid(state, chunk);
                    if (er) {
                      errorOrDestroy(stream, er);
                    } else if (state.objectMode || chunk && chunk.length > 0) {
                      if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
                        chunk = _uint8ArrayToBuffer(chunk);
                      }
                      if (addToFront) {
                        if (state.endEmitted)
                          errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
                        else
                          addChunk(stream, state, chunk, true);
                      } else if (state.ended) {
                        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
                      } else if (state.destroyed) {
                        return false;
                      } else {
                        state.reading = false;
                        if (state.decoder && !encoding) {
                          chunk = state.decoder.write(chunk);
                          if (state.objectMode || chunk.length !== 0)
                            addChunk(stream, state, chunk, false);
                          else
                            maybeReadMore(stream, state);
                        } else {
                          addChunk(stream, state, chunk, false);
                        }
                      }
                    } else if (!addToFront) {
                      state.reading = false;
                      maybeReadMore(stream, state);
                    }
                  }
                  return !state.ended && (state.length < state.highWaterMark || state.length === 0);
                }
                function addChunk(stream, state, chunk, addToFront) {
                  if (state.flowing && state.length === 0 && !state.sync) {
                    state.awaitDrain = 0;
                    stream.emit("data", chunk);
                  } else {
                    state.length += state.objectMode ? 1 : chunk.length;
                    if (addToFront)
                      state.buffer.unshift(chunk);
                    else
                      state.buffer.push(chunk);
                    if (state.needReadable)
                      emitReadable(stream);
                  }
                  maybeReadMore(stream, state);
                }
                function chunkInvalid(state, chunk) {
                  var er;
                  if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
                    er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
                  }
                  return er;
                }
                Readable.prototype.isPaused = function() {
                  return this._readableState.flowing === false;
                };
                Readable.prototype.setEncoding = function(enc) {
                  if (!StringDecoder)
                    StringDecoder = __webpack_require__2(183).s;
                  var decoder = new StringDecoder(enc);
                  this._readableState.decoder = decoder;
                  this._readableState.encoding = this._readableState.decoder.encoding;
                  var p = this._readableState.buffer.head;
                  var content = "";
                  while (p !== null) {
                    content += decoder.write(p.data);
                    p = p.next;
                  }
                  this._readableState.buffer.clear();
                  if (content !== "")
                    this._readableState.buffer.push(content);
                  this._readableState.length = content.length;
                  return this;
                };
                var MAX_HWM = 1073741824;
                function computeNewHighWaterMark(n) {
                  if (n >= MAX_HWM) {
                    n = MAX_HWM;
                  } else {
                    n--;
                    n |= n >>> 1;
                    n |= n >>> 2;
                    n |= n >>> 4;
                    n |= n >>> 8;
                    n |= n >>> 16;
                    n++;
                  }
                  return n;
                }
                function howMuchToRead(n, state) {
                  if (n <= 0 || state.length === 0 && state.ended)
                    return 0;
                  if (state.objectMode)
                    return 1;
                  if (n !== n) {
                    if (state.flowing && state.length)
                      return state.buffer.head.data.length;
                    else
                      return state.length;
                  }
                  if (n > state.highWaterMark)
                    state.highWaterMark = computeNewHighWaterMark(n);
                  if (n <= state.length)
                    return n;
                  if (!state.ended) {
                    state.needReadable = true;
                    return 0;
                  }
                  return state.length;
                }
                Readable.prototype.read = function(n) {
                  debug("read", n);
                  n = parseInt(n, 10);
                  var state = this._readableState;
                  var nOrig = n;
                  if (n !== 0)
                    state.emittedReadable = false;
                  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
                    debug("read: emitReadable", state.length, state.ended);
                    if (state.length === 0 && state.ended)
                      endReadable(this);
                    else
                      emitReadable(this);
                    return null;
                  }
                  n = howMuchToRead(n, state);
                  if (n === 0 && state.ended) {
                    if (state.length === 0)
                      endReadable(this);
                    return null;
                  }
                  var doRead = state.needReadable;
                  debug("need readable", doRead);
                  if (state.length === 0 || state.length - n < state.highWaterMark) {
                    doRead = true;
                    debug("length less than watermark", doRead);
                  }
                  if (state.ended || state.reading) {
                    doRead = false;
                    debug("reading or ended", doRead);
                  } else if (doRead) {
                    debug("do read");
                    state.reading = true;
                    state.sync = true;
                    if (state.length === 0)
                      state.needReadable = true;
                    this._read(state.highWaterMark);
                    state.sync = false;
                    if (!state.reading)
                      n = howMuchToRead(nOrig, state);
                  }
                  var ret;
                  if (n > 0)
                    ret = fromList(n, state);
                  else
                    ret = null;
                  if (ret === null) {
                    state.needReadable = state.length <= state.highWaterMark;
                    n = 0;
                  } else {
                    state.length -= n;
                    state.awaitDrain = 0;
                  }
                  if (state.length === 0) {
                    if (!state.ended)
                      state.needReadable = true;
                    if (nOrig !== n && state.ended)
                      endReadable(this);
                  }
                  if (ret !== null)
                    this.emit("data", ret);
                  return ret;
                };
                function onEofChunk(stream, state) {
                  debug("onEofChunk");
                  if (state.ended)
                    return;
                  if (state.decoder) {
                    var chunk = state.decoder.end();
                    if (chunk && chunk.length) {
                      state.buffer.push(chunk);
                      state.length += state.objectMode ? 1 : chunk.length;
                    }
                  }
                  state.ended = true;
                  if (state.sync) {
                    emitReadable(stream);
                  } else {
                    state.needReadable = false;
                    if (!state.emittedReadable) {
                      state.emittedReadable = true;
                      emitReadable_(stream);
                    }
                  }
                }
                function emitReadable(stream) {
                  var state = stream._readableState;
                  debug("emitReadable", state.needReadable, state.emittedReadable);
                  state.needReadable = false;
                  if (!state.emittedReadable) {
                    debug("emitReadable", state.flowing);
                    state.emittedReadable = true;
                    process.nextTick(emitReadable_, stream);
                  }
                }
                function emitReadable_(stream) {
                  var state = stream._readableState;
                  debug("emitReadable_", state.destroyed, state.length, state.ended);
                  if (!state.destroyed && (state.length || state.ended)) {
                    stream.emit("readable");
                    state.emittedReadable = false;
                  }
                  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
                  flow(stream);
                }
                function maybeReadMore(stream, state) {
                  if (!state.readingMore) {
                    state.readingMore = true;
                    process.nextTick(maybeReadMore_, stream, state);
                  }
                }
                function maybeReadMore_(stream, state) {
                  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
                    var len = state.length;
                    debug("maybeReadMore read 0");
                    stream.read(0);
                    if (len === state.length)
                      break;
                  }
                  state.readingMore = false;
                }
                Readable.prototype._read = function(n) {
                  errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
                };
                Readable.prototype.pipe = function(dest, pipeOpts) {
                  var src = this;
                  var state = this._readableState;
                  switch (state.pipesCount) {
                    case 0:
                      state.pipes = dest;
                      break;
                    case 1:
                      state.pipes = [state.pipes, dest];
                      break;
                    default:
                      state.pipes.push(dest);
                      break;
                  }
                  state.pipesCount += 1;
                  debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
                  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
                  var endFn = doEnd ? onend : unpipe;
                  if (state.endEmitted)
                    process.nextTick(endFn);
                  else
                    src.once("end", endFn);
                  dest.on("unpipe", onunpipe);
                  function onunpipe(readable, unpipeInfo) {
                    debug("onunpipe");
                    if (readable === src) {
                      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
                        unpipeInfo.hasUnpiped = true;
                        cleanup();
                      }
                    }
                  }
                  function onend() {
                    debug("onend");
                    dest.end();
                  }
                  var ondrain = pipeOnDrain(src);
                  dest.on("drain", ondrain);
                  var cleanedUp = false;
                  function cleanup() {
                    debug("cleanup");
                    dest.removeListener("close", onclose);
                    dest.removeListener("finish", onfinish);
                    dest.removeListener("drain", ondrain);
                    dest.removeListener("error", onerror);
                    dest.removeListener("unpipe", onunpipe);
                    src.removeListener("end", onend);
                    src.removeListener("end", unpipe);
                    src.removeListener("data", ondata);
                    cleanedUp = true;
                    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
                      ondrain();
                  }
                  src.on("data", ondata);
                  function ondata(chunk) {
                    debug("ondata");
                    var ret = dest.write(chunk);
                    debug("dest.write", ret);
                    if (ret === false) {
                      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
                        debug("false write response, pause", state.awaitDrain);
                        state.awaitDrain++;
                      }
                      src.pause();
                    }
                  }
                  function onerror(er) {
                    debug("onerror", er);
                    unpipe();
                    dest.removeListener("error", onerror);
                    if (EElistenerCount(dest, "error") === 0)
                      errorOrDestroy(dest, er);
                  }
                  prependListener(dest, "error", onerror);
                  function onclose() {
                    dest.removeListener("finish", onfinish);
                    unpipe();
                  }
                  dest.once("close", onclose);
                  function onfinish() {
                    debug("onfinish");
                    dest.removeListener("close", onclose);
                    unpipe();
                  }
                  dest.once("finish", onfinish);
                  function unpipe() {
                    debug("unpipe");
                    src.unpipe(dest);
                  }
                  dest.emit("pipe", src);
                  if (!state.flowing) {
                    debug("pipe resume");
                    src.resume();
                  }
                  return dest;
                };
                function pipeOnDrain(src) {
                  return function pipeOnDrainFunctionResult() {
                    var state = src._readableState;
                    debug("pipeOnDrain", state.awaitDrain);
                    if (state.awaitDrain)
                      state.awaitDrain--;
                    if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
                      state.flowing = true;
                      flow(src);
                    }
                  };
                }
                Readable.prototype.unpipe = function(dest) {
                  var state = this._readableState;
                  var unpipeInfo = {
                    hasUnpiped: false
                  };
                  if (state.pipesCount === 0)
                    return this;
                  if (state.pipesCount === 1) {
                    if (dest && dest !== state.pipes)
                      return this;
                    if (!dest)
                      dest = state.pipes;
                    state.pipes = null;
                    state.pipesCount = 0;
                    state.flowing = false;
                    if (dest)
                      dest.emit("unpipe", this, unpipeInfo);
                    return this;
                  }
                  if (!dest) {
                    var dests = state.pipes;
                    var len = state.pipesCount;
                    state.pipes = null;
                    state.pipesCount = 0;
                    state.flowing = false;
                    for (var i = 0; i < len; i++) {
                      dests[i].emit("unpipe", this, {
                        hasUnpiped: false
                      });
                    }
                    return this;
                  }
                  var index = indexOf(state.pipes, dest);
                  if (index === -1)
                    return this;
                  state.pipes.splice(index, 1);
                  state.pipesCount -= 1;
                  if (state.pipesCount === 1)
                    state.pipes = state.pipes[0];
                  dest.emit("unpipe", this, unpipeInfo);
                  return this;
                };
                Readable.prototype.on = function(ev, fn) {
                  var res = Stream.prototype.on.call(this, ev, fn);
                  var state = this._readableState;
                  if (ev === "data") {
                    state.readableListening = this.listenerCount("readable") > 0;
                    if (state.flowing !== false)
                      this.resume();
                  } else if (ev === "readable") {
                    if (!state.endEmitted && !state.readableListening) {
                      state.readableListening = state.needReadable = true;
                      state.flowing = false;
                      state.emittedReadable = false;
                      debug("on readable", state.length, state.reading);
                      if (state.length) {
                        emitReadable(this);
                      } else if (!state.reading) {
                        process.nextTick(nReadingNextTick, this);
                      }
                    }
                  }
                  return res;
                };
                Readable.prototype.addListener = Readable.prototype.on;
                Readable.prototype.removeListener = function(ev, fn) {
                  var res = Stream.prototype.removeListener.call(this, ev, fn);
                  if (ev === "readable") {
                    process.nextTick(updateReadableListening, this);
                  }
                  return res;
                };
                Readable.prototype.removeAllListeners = function(ev) {
                  var res = Stream.prototype.removeAllListeners.apply(this, arguments);
                  if (ev === "readable" || ev === void 0) {
                    process.nextTick(updateReadableListening, this);
                  }
                  return res;
                };
                function updateReadableListening(self2) {
                  var state = self2._readableState;
                  state.readableListening = self2.listenerCount("readable") > 0;
                  if (state.resumeScheduled && !state.paused) {
                    state.flowing = true;
                  } else if (self2.listenerCount("data") > 0) {
                    self2.resume();
                  }
                }
                function nReadingNextTick(self2) {
                  debug("readable nexttick read 0");
                  self2.read(0);
                }
                Readable.prototype.resume = function() {
                  var state = this._readableState;
                  if (!state.flowing) {
                    debug("resume");
                    state.flowing = !state.readableListening;
                    resume(this, state);
                  }
                  state.paused = false;
                  return this;
                };
                function resume(stream, state) {
                  if (!state.resumeScheduled) {
                    state.resumeScheduled = true;
                    process.nextTick(resume_, stream, state);
                  }
                }
                function resume_(stream, state) {
                  debug("resume", state.reading);
                  if (!state.reading) {
                    stream.read(0);
                  }
                  state.resumeScheduled = false;
                  stream.emit("resume");
                  flow(stream);
                  if (state.flowing && !state.reading)
                    stream.read(0);
                }
                Readable.prototype.pause = function() {
                  debug("call pause flowing=%j", this._readableState.flowing);
                  if (this._readableState.flowing !== false) {
                    debug("pause");
                    this._readableState.flowing = false;
                    this.emit("pause");
                  }
                  this._readableState.paused = true;
                  return this;
                };
                function flow(stream) {
                  var state = stream._readableState;
                  debug("flow", state.flowing);
                  while (state.flowing && stream.read() !== null) {
                    ;
                  }
                }
                Readable.prototype.wrap = function(stream) {
                  var _this = this;
                  var state = this._readableState;
                  var paused = false;
                  stream.on("end", function() {
                    debug("wrapped end");
                    if (state.decoder && !state.ended) {
                      var chunk = state.decoder.end();
                      if (chunk && chunk.length)
                        _this.push(chunk);
                    }
                    _this.push(null);
                  });
                  stream.on("data", function(chunk) {
                    debug("wrapped data");
                    if (state.decoder)
                      chunk = state.decoder.write(chunk);
                    if (state.objectMode && (chunk === null || chunk === void 0))
                      return;
                    else if (!state.objectMode && (!chunk || !chunk.length))
                      return;
                    var ret = _this.push(chunk);
                    if (!ret) {
                      paused = true;
                      stream.pause();
                    }
                  });
                  for (var i in stream) {
                    if (this[i] === void 0 && typeof stream[i] === "function") {
                      this[i] = function methodWrap(method) {
                        return function methodWrapReturnFunction() {
                          return stream[method].apply(stream, arguments);
                        };
                      }(i);
                    }
                  }
                  for (var n = 0; n < kProxyEvents.length; n++) {
                    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
                  }
                  this._read = function(n2) {
                    debug("wrapped _read", n2);
                    if (paused) {
                      paused = false;
                      stream.resume();
                    }
                  };
                  return this;
                };
                if (typeof Symbol === "function") {
                  Readable.prototype[Symbol.asyncIterator] = function() {
                    if (createReadableStreamAsyncIterator === void 0) {
                      createReadableStreamAsyncIterator = __webpack_require__2(262);
                    }
                    return createReadableStreamAsyncIterator(this);
                  };
                }
                Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
                  // making it explicit this property is not enumerable
                  // because otherwise some prototype manipulation in
                  // userland will fail
                  enumerable: false,
                  get: function get() {
                    return this._readableState.highWaterMark;
                  }
                });
                Object.defineProperty(Readable.prototype, "readableBuffer", {
                  // making it explicit this property is not enumerable
                  // because otherwise some prototype manipulation in
                  // userland will fail
                  enumerable: false,
                  get: function get() {
                    return this._readableState && this._readableState.buffer;
                  }
                });
                Object.defineProperty(Readable.prototype, "readableFlowing", {
                  // making it explicit this property is not enumerable
                  // because otherwise some prototype manipulation in
                  // userland will fail
                  enumerable: false,
                  get: function get() {
                    return this._readableState.flowing;
                  },
                  set: function set(state) {
                    if (this._readableState) {
                      this._readableState.flowing = state;
                    }
                  }
                });
                Readable._fromList = fromList;
                Object.defineProperty(Readable.prototype, "readableLength", {
                  // making it explicit this property is not enumerable
                  // because otherwise some prototype manipulation in
                  // userland will fail
                  enumerable: false,
                  get: function get() {
                    return this._readableState.length;
                  }
                });
                function fromList(n, state) {
                  if (state.length === 0)
                    return null;
                  var ret;
                  if (state.objectMode)
                    ret = state.buffer.shift();
                  else if (!n || n >= state.length) {
                    if (state.decoder)
                      ret = state.buffer.join("");
                    else if (state.buffer.length === 1)
                      ret = state.buffer.first();
                    else
                      ret = state.buffer.concat(state.length);
                    state.buffer.clear();
                  } else {
                    ret = state.buffer.consume(n, state.decoder);
                  }
                  return ret;
                }
                function endReadable(stream) {
                  var state = stream._readableState;
                  debug("endReadable", state.endEmitted);
                  if (!state.endEmitted) {
                    state.ended = true;
                    process.nextTick(endReadableNT, state, stream);
                  }
                }
                function endReadableNT(state, stream) {
                  debug("endReadableNT", state.endEmitted, state.length);
                  if (!state.endEmitted && state.length === 0) {
                    state.endEmitted = true;
                    stream.readable = false;
                    stream.emit("end");
                    if (state.autoDestroy) {
                      var wState = stream._writableState;
                      if (!wState || wState.autoDestroy && wState.finished) {
                        stream.destroy();
                      }
                    }
                  }
                }
                if (typeof Symbol === "function") {
                  Readable.from = function(iterable, opts) {
                    if (from === void 0) {
                      from = __webpack_require__2(260);
                    }
                    return from(Readable, iterable, opts);
                  };
                }
                function indexOf(xs, x) {
                  for (var i = 0, l = xs.length; i < l; i++) {
                    if (xs[i] === x)
                      return i;
                  }
                  return -1;
                }
              }
            ),
            /***/
            969: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                module2.exports = Transform;
                var _require$codes = __webpack_require__2(50).q, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING, ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
                var Duplex = __webpack_require__2(298);
                __webpack_require__2(409)(Transform, Duplex);
                function afterTransform(er, data) {
                  var ts = this._transformState;
                  ts.transforming = false;
                  var cb = ts.writecb;
                  if (cb === null) {
                    return this.emit("error", new ERR_MULTIPLE_CALLBACK());
                  }
                  ts.writechunk = null;
                  ts.writecb = null;
                  if (data != null)
                    this.push(data);
                  cb(er);
                  var rs = this._readableState;
                  rs.reading = false;
                  if (rs.needReadable || rs.length < rs.highWaterMark) {
                    this._read(rs.highWaterMark);
                  }
                }
                function Transform(options) {
                  if (!(this instanceof Transform))
                    return new Transform(options);
                  Duplex.call(this, options);
                  this._transformState = {
                    afterTransform: afterTransform.bind(this),
                    needTransform: false,
                    transforming: false,
                    writecb: null,
                    writechunk: null,
                    writeencoding: null
                  };
                  this._readableState.needReadable = true;
                  this._readableState.sync = false;
                  if (options) {
                    if (typeof options.transform === "function")
                      this._transform = options.transform;
                    if (typeof options.flush === "function")
                      this._flush = options.flush;
                  }
                  this.on("prefinish", prefinish);
                }
                function prefinish() {
                  var _this = this;
                  if (typeof this._flush === "function" && !this._readableState.destroyed) {
                    this._flush(function(er, data) {
                      done(_this, er, data);
                    });
                  } else {
                    done(this, null, null);
                  }
                }
                Transform.prototype.push = function(chunk, encoding) {
                  this._transformState.needTransform = false;
                  return Duplex.prototype.push.call(this, chunk, encoding);
                };
                Transform.prototype._transform = function(chunk, encoding, cb) {
                  cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
                };
                Transform.prototype._write = function(chunk, encoding, cb) {
                  var ts = this._transformState;
                  ts.writecb = cb;
                  ts.writechunk = chunk;
                  ts.writeencoding = encoding;
                  if (!ts.transforming) {
                    var rs = this._readableState;
                    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
                      this._read(rs.highWaterMark);
                  }
                };
                Transform.prototype._read = function(n) {
                  var ts = this._transformState;
                  if (ts.writechunk !== null && !ts.transforming) {
                    ts.transforming = true;
                    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
                  } else {
                    ts.needTransform = true;
                  }
                };
                Transform.prototype._destroy = function(err, cb) {
                  Duplex.prototype._destroy.call(this, err, function(err2) {
                    cb(err2);
                  });
                };
                function done(stream, er, data) {
                  if (er)
                    return stream.emit("error", er);
                  if (data != null)
                    stream.push(data);
                  if (stream._writableState.length)
                    throw new ERR_TRANSFORM_WITH_LENGTH_0();
                  if (stream._transformState.transforming)
                    throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
                  return stream.push(null);
                }
              }
            ),
            /***/
            880: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                module2.exports = Writable;
                function WriteReq(chunk, encoding, cb) {
                  this.chunk = chunk;
                  this.encoding = encoding;
                  this.callback = cb;
                  this.next = null;
                }
                function CorkedRequest(state) {
                  var _this = this;
                  this.next = null;
                  this.entry = null;
                  this.finish = function() {
                    onCorkedFinish(_this, state);
                  };
                }
                var Duplex;
                Writable.WritableState = WritableState;
                var internalUtil = {
                  deprecate: __webpack_require__2(485)
                };
                var Stream = __webpack_require__2(786);
                var Buffer = __webpack_require__2(636).Buffer;
                var OurUint8Array = __webpack_require__2.g.Uint8Array || function() {
                };
                function _uint8ArrayToBuffer(chunk) {
                  return Buffer.from(chunk);
                }
                function _isUint8Array(obj) {
                  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
                }
                var destroyImpl = __webpack_require__2(974);
                var _require = __webpack_require__2(754), getHighWaterMark = _require.getHighWaterMark;
                var _require$codes = __webpack_require__2(50).q, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED, ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES, ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END, ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
                var errorOrDestroy = destroyImpl.errorOrDestroy;
                __webpack_require__2(409)(Writable, Stream);
                function nop() {
                }
                function WritableState(options, stream, isDuplex) {
                  Duplex = Duplex || __webpack_require__2(298);
                  options = options || {};
                  if (typeof isDuplex !== "boolean")
                    isDuplex = stream instanceof Duplex;
                  this.objectMode = !!options.objectMode;
                  if (isDuplex)
                    this.objectMode = this.objectMode || !!options.writableObjectMode;
                  this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
                  this.finalCalled = false;
                  this.needDrain = false;
                  this.ending = false;
                  this.ended = false;
                  this.finished = false;
                  this.destroyed = false;
                  var noDecode = options.decodeStrings === false;
                  this.decodeStrings = !noDecode;
                  this.defaultEncoding = options.defaultEncoding || "utf8";
                  this.length = 0;
                  this.writing = false;
                  this.corked = 0;
                  this.sync = true;
                  this.bufferProcessing = false;
                  this.onwrite = function(er) {
                    onwrite(stream, er);
                  };
                  this.writecb = null;
                  this.writelen = 0;
                  this.bufferedRequest = null;
                  this.lastBufferedRequest = null;
                  this.pendingcb = 0;
                  this.prefinished = false;
                  this.errorEmitted = false;
                  this.emitClose = options.emitClose !== false;
                  this.autoDestroy = !!options.autoDestroy;
                  this.bufferedRequestCount = 0;
                  this.corkedRequestsFree = new CorkedRequest(this);
                }
                WritableState.prototype.getBuffer = function getBuffer() {
                  var current = this.bufferedRequest;
                  var out = [];
                  while (current) {
                    out.push(current);
                    current = current.next;
                  }
                  return out;
                };
                (function() {
                  try {
                    Object.defineProperty(WritableState.prototype, "buffer", {
                      get: internalUtil.deprecate(function writableStateBufferGetter() {
                        return this.getBuffer();
                      }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
                    });
                  } catch (_) {
                  }
                })();
                var realHasInstance;
                if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
                  realHasInstance = Function.prototype[Symbol.hasInstance];
                  Object.defineProperty(Writable, Symbol.hasInstance, {
                    value: function value(object) {
                      if (realHasInstance.call(this, object))
                        return true;
                      if (this !== Writable)
                        return false;
                      return object && object._writableState instanceof WritableState;
                    }
                  });
                } else {
                  realHasInstance = function realHasInstance2(object) {
                    return object instanceof this;
                  };
                }
                function Writable(options) {
                  Duplex = Duplex || __webpack_require__2(298);
                  var isDuplex = this instanceof Duplex;
                  if (!isDuplex && !realHasInstance.call(Writable, this))
                    return new Writable(options);
                  this._writableState = new WritableState(options, this, isDuplex);
                  this.writable = true;
                  if (options) {
                    if (typeof options.write === "function")
                      this._write = options.write;
                    if (typeof options.writev === "function")
                      this._writev = options.writev;
                    if (typeof options.destroy === "function")
                      this._destroy = options.destroy;
                    if (typeof options.final === "function")
                      this._final = options.final;
                  }
                  Stream.call(this);
                }
                Writable.prototype.pipe = function() {
                  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
                };
                function writeAfterEnd(stream, cb) {
                  var er = new ERR_STREAM_WRITE_AFTER_END();
                  errorOrDestroy(stream, er);
                  process.nextTick(cb, er);
                }
                function validChunk(stream, state, chunk, cb) {
                  var er;
                  if (chunk === null) {
                    er = new ERR_STREAM_NULL_VALUES();
                  } else if (typeof chunk !== "string" && !state.objectMode) {
                    er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
                  }
                  if (er) {
                    errorOrDestroy(stream, er);
                    process.nextTick(cb, er);
                    return false;
                  }
                  return true;
                }
                Writable.prototype.write = function(chunk, encoding, cb) {
                  var state = this._writableState;
                  var ret = false;
                  var isBuf = !state.objectMode && _isUint8Array(chunk);
                  if (isBuf && !Buffer.isBuffer(chunk)) {
                    chunk = _uint8ArrayToBuffer(chunk);
                  }
                  if (typeof encoding === "function") {
                    cb = encoding;
                    encoding = null;
                  }
                  if (isBuf)
                    encoding = "buffer";
                  else if (!encoding)
                    encoding = state.defaultEncoding;
                  if (typeof cb !== "function")
                    cb = nop;
                  if (state.ending)
                    writeAfterEnd(this, cb);
                  else if (isBuf || validChunk(this, state, chunk, cb)) {
                    state.pendingcb++;
                    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
                  }
                  return ret;
                };
                Writable.prototype.cork = function() {
                  this._writableState.corked++;
                };
                Writable.prototype.uncork = function() {
                  var state = this._writableState;
                  if (state.corked) {
                    state.corked--;
                    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
                      clearBuffer(this, state);
                  }
                };
                Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
                  if (typeof encoding === "string")
                    encoding = encoding.toLowerCase();
                  if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
                    throw new ERR_UNKNOWN_ENCODING(encoding);
                  this._writableState.defaultEncoding = encoding;
                  return this;
                };
                Object.defineProperty(Writable.prototype, "writableBuffer", {
                  // making it explicit this property is not enumerable
                  // because otherwise some prototype manipulation in
                  // userland will fail
                  enumerable: false,
                  get: function get() {
                    return this._writableState && this._writableState.getBuffer();
                  }
                });
                function decodeChunk(state, chunk, encoding) {
                  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
                    chunk = Buffer.from(chunk, encoding);
                  }
                  return chunk;
                }
                Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
                  // making it explicit this property is not enumerable
                  // because otherwise some prototype manipulation in
                  // userland will fail
                  enumerable: false,
                  get: function get() {
                    return this._writableState.highWaterMark;
                  }
                });
                function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
                  if (!isBuf) {
                    var newChunk = decodeChunk(state, chunk, encoding);
                    if (chunk !== newChunk) {
                      isBuf = true;
                      encoding = "buffer";
                      chunk = newChunk;
                    }
                  }
                  var len = state.objectMode ? 1 : chunk.length;
                  state.length += len;
                  var ret = state.length < state.highWaterMark;
                  if (!ret)
                    state.needDrain = true;
                  if (state.writing || state.corked) {
                    var last = state.lastBufferedRequest;
                    state.lastBufferedRequest = {
                      chunk,
                      encoding,
                      isBuf,
                      callback: cb,
                      next: null
                    };
                    if (last) {
                      last.next = state.lastBufferedRequest;
                    } else {
                      state.bufferedRequest = state.lastBufferedRequest;
                    }
                    state.bufferedRequestCount += 1;
                  } else {
                    doWrite(stream, state, false, len, chunk, encoding, cb);
                  }
                  return ret;
                }
                function doWrite(stream, state, writev, len, chunk, encoding, cb) {
                  state.writelen = len;
                  state.writecb = cb;
                  state.writing = true;
                  state.sync = true;
                  if (state.destroyed)
                    state.onwrite(new ERR_STREAM_DESTROYED("write"));
                  else if (writev)
                    stream._writev(chunk, state.onwrite);
                  else
                    stream._write(chunk, encoding, state.onwrite);
                  state.sync = false;
                }
                function onwriteError(stream, state, sync, er, cb) {
                  --state.pendingcb;
                  if (sync) {
                    process.nextTick(cb, er);
                    process.nextTick(finishMaybe, stream, state);
                    stream._writableState.errorEmitted = true;
                    errorOrDestroy(stream, er);
                  } else {
                    cb(er);
                    stream._writableState.errorEmitted = true;
                    errorOrDestroy(stream, er);
                    finishMaybe(stream, state);
                  }
                }
                function onwriteStateUpdate(state) {
                  state.writing = false;
                  state.writecb = null;
                  state.length -= state.writelen;
                  state.writelen = 0;
                }
                function onwrite(stream, er) {
                  var state = stream._writableState;
                  var sync = state.sync;
                  var cb = state.writecb;
                  if (typeof cb !== "function")
                    throw new ERR_MULTIPLE_CALLBACK();
                  onwriteStateUpdate(state);
                  if (er)
                    onwriteError(stream, state, sync, er, cb);
                  else {
                    var finished = needFinish(state) || stream.destroyed;
                    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
                      clearBuffer(stream, state);
                    }
                    if (sync) {
                      process.nextTick(afterWrite, stream, state, finished, cb);
                    } else {
                      afterWrite(stream, state, finished, cb);
                    }
                  }
                }
                function afterWrite(stream, state, finished, cb) {
                  if (!finished)
                    onwriteDrain(stream, state);
                  state.pendingcb--;
                  cb();
                  finishMaybe(stream, state);
                }
                function onwriteDrain(stream, state) {
                  if (state.length === 0 && state.needDrain) {
                    state.needDrain = false;
                    stream.emit("drain");
                  }
                }
                function clearBuffer(stream, state) {
                  state.bufferProcessing = true;
                  var entry = state.bufferedRequest;
                  if (stream._writev && entry && entry.next) {
                    var l = state.bufferedRequestCount;
                    var buffer = new Array(l);
                    var holder = state.corkedRequestsFree;
                    holder.entry = entry;
                    var count = 0;
                    var allBuffers = true;
                    while (entry) {
                      buffer[count] = entry;
                      if (!entry.isBuf)
                        allBuffers = false;
                      entry = entry.next;
                      count += 1;
                    }
                    buffer.allBuffers = allBuffers;
                    doWrite(stream, state, true, state.length, buffer, "", holder.finish);
                    state.pendingcb++;
                    state.lastBufferedRequest = null;
                    if (holder.next) {
                      state.corkedRequestsFree = holder.next;
                      holder.next = null;
                    } else {
                      state.corkedRequestsFree = new CorkedRequest(state);
                    }
                    state.bufferedRequestCount = 0;
                  } else {
                    while (entry) {
                      var chunk = entry.chunk;
                      var encoding = entry.encoding;
                      var cb = entry.callback;
                      var len = state.objectMode ? 1 : chunk.length;
                      doWrite(stream, state, false, len, chunk, encoding, cb);
                      entry = entry.next;
                      state.bufferedRequestCount--;
                      if (state.writing) {
                        break;
                      }
                    }
                    if (entry === null)
                      state.lastBufferedRequest = null;
                  }
                  state.bufferedRequest = entry;
                  state.bufferProcessing = false;
                }
                Writable.prototype._write = function(chunk, encoding, cb) {
                  cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
                };
                Writable.prototype._writev = null;
                Writable.prototype.end = function(chunk, encoding, cb) {
                  var state = this._writableState;
                  if (typeof chunk === "function") {
                    cb = chunk;
                    chunk = null;
                    encoding = null;
                  } else if (typeof encoding === "function") {
                    cb = encoding;
                    encoding = null;
                  }
                  if (chunk !== null && chunk !== void 0)
                    this.write(chunk, encoding);
                  if (state.corked) {
                    state.corked = 1;
                    this.uncork();
                  }
                  if (!state.ending)
                    endWritable(this, state, cb);
                  return this;
                };
                Object.defineProperty(Writable.prototype, "writableLength", {
                  // making it explicit this property is not enumerable
                  // because otherwise some prototype manipulation in
                  // userland will fail
                  enumerable: false,
                  get: function get() {
                    return this._writableState.length;
                  }
                });
                function needFinish(state) {
                  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
                }
                function callFinal(stream, state) {
                  stream._final(function(err) {
                    state.pendingcb--;
                    if (err) {
                      errorOrDestroy(stream, err);
                    }
                    state.prefinished = true;
                    stream.emit("prefinish");
                    finishMaybe(stream, state);
                  });
                }
                function prefinish(stream, state) {
                  if (!state.prefinished && !state.finalCalled) {
                    if (typeof stream._final === "function" && !state.destroyed) {
                      state.pendingcb++;
                      state.finalCalled = true;
                      process.nextTick(callFinal, stream, state);
                    } else {
                      state.prefinished = true;
                      stream.emit("prefinish");
                    }
                  }
                }
                function finishMaybe(stream, state) {
                  var need = needFinish(state);
                  if (need) {
                    prefinish(stream, state);
                    if (state.pendingcb === 0) {
                      state.finished = true;
                      stream.emit("finish");
                      if (state.autoDestroy) {
                        var rState = stream._readableState;
                        if (!rState || rState.autoDestroy && rState.endEmitted) {
                          stream.destroy();
                        }
                      }
                    }
                  }
                  return need;
                }
                function endWritable(stream, state, cb) {
                  state.ending = true;
                  finishMaybe(stream, state);
                  if (cb) {
                    if (state.finished)
                      process.nextTick(cb);
                    else
                      stream.once("finish", cb);
                  }
                  state.ended = true;
                  stream.writable = false;
                }
                function onCorkedFinish(corkReq, state, err) {
                  var entry = corkReq.entry;
                  corkReq.entry = null;
                  while (entry) {
                    var cb = entry.callback;
                    state.pendingcb--;
                    cb(err);
                    entry = entry.next;
                  }
                  state.corkedRequestsFree.next = corkReq;
                }
                Object.defineProperty(Writable.prototype, "destroyed", {
                  // making it explicit this property is not enumerable
                  // because otherwise some prototype manipulation in
                  // userland will fail
                  enumerable: false,
                  get: function get() {
                    if (this._writableState === void 0) {
                      return false;
                    }
                    return this._writableState.destroyed;
                  },
                  set: function set(value) {
                    if (!this._writableState) {
                      return;
                    }
                    this._writableState.destroyed = value;
                  }
                });
                Writable.prototype.destroy = destroyImpl.destroy;
                Writable.prototype._undestroy = destroyImpl.undestroy;
                Writable.prototype._destroy = function(err, cb) {
                  cb(err);
                };
              }
            ),
            /***/
            262: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var _Object$setPrototypeO;
                function _defineProperty(obj, key, value) {
                  if (key in obj) {
                    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
                  } else {
                    obj[key] = value;
                  }
                  return obj;
                }
                var finished = __webpack_require__2(678);
                var kLastResolve = Symbol("lastResolve");
                var kLastReject = Symbol("lastReject");
                var kError = Symbol("error");
                var kEnded = Symbol("ended");
                var kLastPromise = Symbol("lastPromise");
                var kHandlePromise = Symbol("handlePromise");
                var kStream = Symbol("stream");
                function createIterResult(value, done) {
                  return {
                    value,
                    done
                  };
                }
                function readAndResolve(iter) {
                  var resolve = iter[kLastResolve];
                  if (resolve !== null) {
                    var data = iter[kStream].read();
                    if (data !== null) {
                      iter[kLastPromise] = null;
                      iter[kLastResolve] = null;
                      iter[kLastReject] = null;
                      resolve(createIterResult(data, false));
                    }
                  }
                }
                function onReadable(iter) {
                  process.nextTick(readAndResolve, iter);
                }
                function wrapForNext(lastPromise, iter) {
                  return function(resolve, reject) {
                    lastPromise.then(function() {
                      if (iter[kEnded]) {
                        resolve(createIterResult(void 0, true));
                        return;
                      }
                      iter[kHandlePromise](resolve, reject);
                    }, reject);
                  };
                }
                var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
                });
                var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
                  get stream() {
                    return this[kStream];
                  },
                  next: function next() {
                    var _this = this;
                    var error = this[kError];
                    if (error !== null) {
                      return Promise.reject(error);
                    }
                    if (this[kEnded]) {
                      return Promise.resolve(createIterResult(void 0, true));
                    }
                    if (this[kStream].destroyed) {
                      return new Promise(function(resolve, reject) {
                        process.nextTick(function() {
                          if (_this[kError]) {
                            reject(_this[kError]);
                          } else {
                            resolve(createIterResult(void 0, true));
                          }
                        });
                      });
                    }
                    var lastPromise = this[kLastPromise];
                    var promise;
                    if (lastPromise) {
                      promise = new Promise(wrapForNext(lastPromise, this));
                    } else {
                      var data = this[kStream].read();
                      if (data !== null) {
                        return Promise.resolve(createIterResult(data, false));
                      }
                      promise = new Promise(this[kHandlePromise]);
                    }
                    this[kLastPromise] = promise;
                    return promise;
                  }
                }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
                  return this;
                }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
                  var _this2 = this;
                  return new Promise(function(resolve, reject) {
                    _this2[kStream].destroy(null, function(err) {
                      if (err) {
                        reject(err);
                        return;
                      }
                      resolve(createIterResult(void 0, true));
                    });
                  });
                }), _Object$setPrototypeO), AsyncIteratorPrototype);
                var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
                  var _Object$create;
                  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
                    value: stream,
                    writable: true
                  }), _defineProperty(_Object$create, kLastResolve, {
                    value: null,
                    writable: true
                  }), _defineProperty(_Object$create, kLastReject, {
                    value: null,
                    writable: true
                  }), _defineProperty(_Object$create, kError, {
                    value: null,
                    writable: true
                  }), _defineProperty(_Object$create, kEnded, {
                    value: stream._readableState.endEmitted,
                    writable: true
                  }), _defineProperty(_Object$create, kHandlePromise, {
                    value: function value(resolve, reject) {
                      var data = iterator[kStream].read();
                      if (data) {
                        iterator[kLastPromise] = null;
                        iterator[kLastResolve] = null;
                        iterator[kLastReject] = null;
                        resolve(createIterResult(data, false));
                      } else {
                        iterator[kLastResolve] = resolve;
                        iterator[kLastReject] = reject;
                      }
                    },
                    writable: true
                  }), _Object$create));
                  iterator[kLastPromise] = null;
                  finished(stream, function(err) {
                    if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
                      var reject = iterator[kLastReject];
                      if (reject !== null) {
                        iterator[kLastPromise] = null;
                        iterator[kLastResolve] = null;
                        iterator[kLastReject] = null;
                        reject(err);
                      }
                      iterator[kError] = err;
                      return;
                    }
                    var resolve = iterator[kLastResolve];
                    if (resolve !== null) {
                      iterator[kLastPromise] = null;
                      iterator[kLastResolve] = null;
                      iterator[kLastReject] = null;
                      resolve(createIterResult(void 0, true));
                    }
                    iterator[kEnded] = true;
                  });
                  stream.on("readable", onReadable.bind(null, iterator));
                  return iterator;
                };
                module2.exports = createReadableStreamAsyncIterator;
              }
            ),
            /***/
            346: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                function ownKeys(object, enumerableOnly) {
                  var keys = Object.keys(object);
                  if (Object.getOwnPropertySymbols) {
                    var symbols = Object.getOwnPropertySymbols(object);
                    if (enumerableOnly)
                      symbols = symbols.filter(function(sym) {
                        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                      });
                    keys.push.apply(keys, symbols);
                  }
                  return keys;
                }
                function _objectSpread(target) {
                  for (var i = 1; i < arguments.length; i++) {
                    var source = arguments[i] != null ? arguments[i] : {};
                    if (i % 2) {
                      ownKeys(Object(source), true).forEach(function(key) {
                        _defineProperty(target, key, source[key]);
                      });
                    } else if (Object.getOwnPropertyDescriptors) {
                      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
                    } else {
                      ownKeys(Object(source)).forEach(function(key) {
                        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                      });
                    }
                  }
                  return target;
                }
                function _defineProperty(obj, key, value) {
                  if (key in obj) {
                    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
                  } else {
                    obj[key] = value;
                  }
                  return obj;
                }
                function _classCallCheck(instance, Constructor) {
                  if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                  }
                }
                function _defineProperties(target, props) {
                  for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor)
                      descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                  }
                }
                function _createClass(Constructor, protoProps, staticProps) {
                  if (protoProps)
                    _defineProperties(Constructor.prototype, protoProps);
                  if (staticProps)
                    _defineProperties(Constructor, staticProps);
                  return Constructor;
                }
                var _require = __webpack_require__2(636), Buffer = _require.Buffer;
                var _require2 = __webpack_require__2(854), inspect = _require2.inspect;
                var custom = inspect && inspect.custom || "inspect";
                function copyBuffer(src, target, offset) {
                  Buffer.prototype.copy.call(src, target, offset);
                }
                module2.exports = function() {
                  function BufferList() {
                    _classCallCheck(this, BufferList);
                    this.head = null;
                    this.tail = null;
                    this.length = 0;
                  }
                  _createClass(BufferList, [{
                    key: "push",
                    value: function push(v) {
                      var entry = {
                        data: v,
                        next: null
                      };
                      if (this.length > 0)
                        this.tail.next = entry;
                      else
                        this.head = entry;
                      this.tail = entry;
                      ++this.length;
                    }
                  }, {
                    key: "unshift",
                    value: function unshift(v) {
                      var entry = {
                        data: v,
                        next: this.head
                      };
                      if (this.length === 0)
                        this.tail = entry;
                      this.head = entry;
                      ++this.length;
                    }
                  }, {
                    key: "shift",
                    value: function shift() {
                      if (this.length === 0)
                        return;
                      var ret = this.head.data;
                      if (this.length === 1)
                        this.head = this.tail = null;
                      else
                        this.head = this.head.next;
                      --this.length;
                      return ret;
                    }
                  }, {
                    key: "clear",
                    value: function clear() {
                      this.head = this.tail = null;
                      this.length = 0;
                    }
                  }, {
                    key: "join",
                    value: function join(s) {
                      if (this.length === 0)
                        return "";
                      var p = this.head;
                      var ret = "" + p.data;
                      while (p = p.next) {
                        ret += s + p.data;
                      }
                      return ret;
                    }
                  }, {
                    key: "concat",
                    value: function concat(n) {
                      if (this.length === 0)
                        return Buffer.alloc(0);
                      var ret = Buffer.allocUnsafe(n >>> 0);
                      var p = this.head;
                      var i = 0;
                      while (p) {
                        copyBuffer(p.data, ret, i);
                        i += p.data.length;
                        p = p.next;
                      }
                      return ret;
                    }
                    // Consumes a specified amount of bytes or characters from the buffered data.
                  }, {
                    key: "consume",
                    value: function consume(n, hasStrings) {
                      var ret;
                      if (n < this.head.data.length) {
                        ret = this.head.data.slice(0, n);
                        this.head.data = this.head.data.slice(n);
                      } else if (n === this.head.data.length) {
                        ret = this.shift();
                      } else {
                        ret = hasStrings ? this._getString(n) : this._getBuffer(n);
                      }
                      return ret;
                    }
                  }, {
                    key: "first",
                    value: function first() {
                      return this.head.data;
                    }
                    // Consumes a specified amount of characters from the buffered data.
                  }, {
                    key: "_getString",
                    value: function _getString(n) {
                      var p = this.head;
                      var c = 1;
                      var ret = p.data;
                      n -= ret.length;
                      while (p = p.next) {
                        var str = p.data;
                        var nb = n > str.length ? str.length : n;
                        if (nb === str.length)
                          ret += str;
                        else
                          ret += str.slice(0, n);
                        n -= nb;
                        if (n === 0) {
                          if (nb === str.length) {
                            ++c;
                            if (p.next)
                              this.head = p.next;
                            else
                              this.head = this.tail = null;
                          } else {
                            this.head = p;
                            p.data = str.slice(nb);
                          }
                          break;
                        }
                        ++c;
                      }
                      this.length -= c;
                      return ret;
                    }
                    // Consumes a specified amount of bytes from the buffered data.
                  }, {
                    key: "_getBuffer",
                    value: function _getBuffer(n) {
                      var ret = Buffer.allocUnsafe(n);
                      var p = this.head;
                      var c = 1;
                      p.data.copy(ret);
                      n -= p.data.length;
                      while (p = p.next) {
                        var buf = p.data;
                        var nb = n > buf.length ? buf.length : n;
                        buf.copy(ret, ret.length - n, 0, nb);
                        n -= nb;
                        if (n === 0) {
                          if (nb === buf.length) {
                            ++c;
                            if (p.next)
                              this.head = p.next;
                            else
                              this.head = this.tail = null;
                          } else {
                            this.head = p;
                            p.data = buf.slice(nb);
                          }
                          break;
                        }
                        ++c;
                      }
                      this.length -= c;
                      return ret;
                    }
                    // Make sure the linked list only shows the minimal necessary information.
                  }, {
                    key: custom,
                    value: function value(_, options) {
                      return inspect(this, _objectSpread({}, options, {
                        // Only inspect one level.
                        depth: 0,
                        // It should not recurse.
                        customInspect: false
                      }));
                    }
                  }]);
                  return BufferList;
                }();
              }
            ),
            /***/
            974: (
              /***/
              function(module2) {
                "use strict";
                function destroy(err, cb) {
                  var _this = this;
                  var readableDestroyed = this._readableState && this._readableState.destroyed;
                  var writableDestroyed = this._writableState && this._writableState.destroyed;
                  if (readableDestroyed || writableDestroyed) {
                    if (cb) {
                      cb(err);
                    } else if (err) {
                      if (!this._writableState) {
                        process.nextTick(emitErrorNT, this, err);
                      } else if (!this._writableState.errorEmitted) {
                        this._writableState.errorEmitted = true;
                        process.nextTick(emitErrorNT, this, err);
                      }
                    }
                    return this;
                  }
                  if (this._readableState) {
                    this._readableState.destroyed = true;
                  }
                  if (this._writableState) {
                    this._writableState.destroyed = true;
                  }
                  this._destroy(err || null, function(err2) {
                    if (!cb && err2) {
                      if (!_this._writableState) {
                        process.nextTick(emitErrorAndCloseNT, _this, err2);
                      } else if (!_this._writableState.errorEmitted) {
                        _this._writableState.errorEmitted = true;
                        process.nextTick(emitErrorAndCloseNT, _this, err2);
                      } else {
                        process.nextTick(emitCloseNT, _this);
                      }
                    } else if (cb) {
                      process.nextTick(emitCloseNT, _this);
                      cb(err2);
                    } else {
                      process.nextTick(emitCloseNT, _this);
                    }
                  });
                  return this;
                }
                function emitErrorAndCloseNT(self2, err) {
                  emitErrorNT(self2, err);
                  emitCloseNT(self2);
                }
                function emitCloseNT(self2) {
                  if (self2._writableState && !self2._writableState.emitClose)
                    return;
                  if (self2._readableState && !self2._readableState.emitClose)
                    return;
                  self2.emit("close");
                }
                function undestroy() {
                  if (this._readableState) {
                    this._readableState.destroyed = false;
                    this._readableState.reading = false;
                    this._readableState.ended = false;
                    this._readableState.endEmitted = false;
                  }
                  if (this._writableState) {
                    this._writableState.destroyed = false;
                    this._writableState.ended = false;
                    this._writableState.ending = false;
                    this._writableState.finalCalled = false;
                    this._writableState.prefinished = false;
                    this._writableState.finished = false;
                    this._writableState.errorEmitted = false;
                  }
                }
                function emitErrorNT(self2, err) {
                  self2.emit("error", err);
                }
                function errorOrDestroy(stream, err) {
                  var rState = stream._readableState;
                  var wState = stream._writableState;
                  if (rState && rState.autoDestroy || wState && wState.autoDestroy)
                    stream.destroy(err);
                  else
                    stream.emit("error", err);
                }
                module2.exports = {
                  destroy,
                  undestroy,
                  errorOrDestroy
                };
              }
            ),
            /***/
            678: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var ERR_STREAM_PREMATURE_CLOSE = __webpack_require__2(50).q.ERR_STREAM_PREMATURE_CLOSE;
                function once(callback) {
                  var called = false;
                  return function() {
                    if (called)
                      return;
                    called = true;
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                      args[_key] = arguments[_key];
                    }
                    callback.apply(this, args);
                  };
                }
                function noop() {
                }
                function isRequest(stream) {
                  return stream.setHeader && typeof stream.abort === "function";
                }
                function eos(stream, opts, callback) {
                  if (typeof opts === "function")
                    return eos(stream, null, opts);
                  if (!opts)
                    opts = {};
                  callback = once(callback || noop);
                  var readable = opts.readable || opts.readable !== false && stream.readable;
                  var writable = opts.writable || opts.writable !== false && stream.writable;
                  var onlegacyfinish = function onlegacyfinish2() {
                    if (!stream.writable)
                      onfinish();
                  };
                  var writableEnded = stream._writableState && stream._writableState.finished;
                  var onfinish = function onfinish2() {
                    writable = false;
                    writableEnded = true;
                    if (!readable)
                      callback.call(stream);
                  };
                  var readableEnded = stream._readableState && stream._readableState.endEmitted;
                  var onend = function onend2() {
                    readable = false;
                    readableEnded = true;
                    if (!writable)
                      callback.call(stream);
                  };
                  var onerror = function onerror2(err) {
                    callback.call(stream, err);
                  };
                  var onclose = function onclose2() {
                    var err;
                    if (readable && !readableEnded) {
                      if (!stream._readableState || !stream._readableState.ended)
                        err = new ERR_STREAM_PREMATURE_CLOSE();
                      return callback.call(stream, err);
                    }
                    if (writable && !writableEnded) {
                      if (!stream._writableState || !stream._writableState.ended)
                        err = new ERR_STREAM_PREMATURE_CLOSE();
                      return callback.call(stream, err);
                    }
                  };
                  var onrequest = function onrequest2() {
                    stream.req.on("finish", onfinish);
                  };
                  if (isRequest(stream)) {
                    stream.on("complete", onfinish);
                    stream.on("abort", onclose);
                    if (stream.req)
                      onrequest();
                    else
                      stream.on("request", onrequest);
                  } else if (writable && !stream._writableState) {
                    stream.on("end", onlegacyfinish);
                    stream.on("close", onlegacyfinish);
                  }
                  stream.on("end", onend);
                  stream.on("finish", onfinish);
                  if (opts.error !== false)
                    stream.on("error", onerror);
                  stream.on("close", onclose);
                  return function() {
                    stream.removeListener("complete", onfinish);
                    stream.removeListener("abort", onclose);
                    stream.removeListener("request", onrequest);
                    if (stream.req)
                      stream.req.removeListener("finish", onfinish);
                    stream.removeListener("end", onlegacyfinish);
                    stream.removeListener("close", onlegacyfinish);
                    stream.removeListener("finish", onfinish);
                    stream.removeListener("end", onend);
                    stream.removeListener("error", onerror);
                    stream.removeListener("close", onclose);
                  };
                }
                module2.exports = eos;
              }
            ),
            /***/
            260: (
              /***/
              function(module2) {
                "use strict";
                module2.exports = function() {
                  throw new Error("Readable.from is not available in the browser");
                };
              }
            ),
            /***/
            732: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var eos;
                function once(callback) {
                  var called = false;
                  return function() {
                    if (called)
                      return;
                    called = true;
                    callback.apply(void 0, arguments);
                  };
                }
                var _require$codes = __webpack_require__2(50).q, ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
                function noop(err) {
                  if (err)
                    throw err;
                }
                function isRequest(stream) {
                  return stream.setHeader && typeof stream.abort === "function";
                }
                function destroyer(stream, reading, writing, callback) {
                  callback = once(callback);
                  var closed = false;
                  stream.on("close", function() {
                    closed = true;
                  });
                  if (eos === void 0)
                    eos = __webpack_require__2(678);
                  eos(stream, {
                    readable: reading,
                    writable: writing
                  }, function(err) {
                    if (err)
                      return callback(err);
                    closed = true;
                    callback();
                  });
                  var destroyed = false;
                  return function(err) {
                    if (closed)
                      return;
                    if (destroyed)
                      return;
                    destroyed = true;
                    if (isRequest(stream))
                      return stream.abort();
                    if (typeof stream.destroy === "function")
                      return stream.destroy();
                    callback(err || new ERR_STREAM_DESTROYED("pipe"));
                  };
                }
                function call(fn) {
                  fn();
                }
                function pipe(from, to) {
                  return from.pipe(to);
                }
                function popCallback(streams) {
                  if (!streams.length)
                    return noop;
                  if (typeof streams[streams.length - 1] !== "function")
                    return noop;
                  return streams.pop();
                }
                function pipeline() {
                  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
                    streams[_key] = arguments[_key];
                  }
                  var callback = popCallback(streams);
                  if (Array.isArray(streams[0]))
                    streams = streams[0];
                  if (streams.length < 2) {
                    throw new ERR_MISSING_ARGS("streams");
                  }
                  var error;
                  var destroys = streams.map(function(stream, i) {
                    var reading = i < streams.length - 1;
                    var writing = i > 0;
                    return destroyer(stream, reading, writing, function(err) {
                      if (!error)
                        error = err;
                      if (err)
                        destroys.forEach(call);
                      if (reading)
                        return;
                      destroys.forEach(call);
                      callback(error);
                    });
                  });
                  return streams.reduce(pipe);
                }
                module2.exports = pipeline;
              }
            ),
            /***/
            754: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var ERR_INVALID_OPT_VALUE = __webpack_require__2(50).q.ERR_INVALID_OPT_VALUE;
                function highWaterMarkFrom(options, isDuplex, duplexKey) {
                  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
                }
                function getHighWaterMark(state, options, duplexKey, isDuplex) {
                  var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
                  if (hwm != null) {
                    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
                      var name = isDuplex ? duplexKey : "highWaterMark";
                      throw new ERR_INVALID_OPT_VALUE(name, hwm);
                    }
                    return Math.floor(hwm);
                  }
                  return state.objectMode ? 16 : 16 * 1024;
                }
                module2.exports = {
                  getHighWaterMark
                };
              }
            ),
            /***/
            786: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                module2.exports = __webpack_require__2(722).EventEmitter;
              }
            ),
            /***/
            769: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                module2.exports = Stream;
                var EE = __webpack_require__2(722).EventEmitter;
                var inherits = __webpack_require__2(409);
                inherits(Stream, EE);
                Stream.Readable = __webpack_require__2(58);
                Stream.Writable = __webpack_require__2(880);
                Stream.Duplex = __webpack_require__2(298);
                Stream.Transform = __webpack_require__2(969);
                Stream.PassThrough = __webpack_require__2(4);
                Stream.finished = __webpack_require__2(678);
                Stream.pipeline = __webpack_require__2(732);
                Stream.Stream = Stream;
                function Stream() {
                  EE.call(this);
                }
                Stream.prototype.pipe = function(dest, options) {
                  var source = this;
                  function ondata(chunk) {
                    if (dest.writable) {
                      if (false === dest.write(chunk) && source.pause) {
                        source.pause();
                      }
                    }
                  }
                  source.on("data", ondata);
                  function ondrain() {
                    if (source.readable && source.resume) {
                      source.resume();
                    }
                  }
                  dest.on("drain", ondrain);
                  if (!dest._isStdio && (!options || options.end !== false)) {
                    source.on("end", onend);
                    source.on("close", onclose);
                  }
                  var didOnEnd = false;
                  function onend() {
                    if (didOnEnd)
                      return;
                    didOnEnd = true;
                    dest.end();
                  }
                  function onclose() {
                    if (didOnEnd)
                      return;
                    didOnEnd = true;
                    if (typeof dest.destroy === "function")
                      dest.destroy();
                  }
                  function onerror(er) {
                    cleanup();
                    if (EE.listenerCount(this, "error") === 0) {
                      throw er;
                    }
                  }
                  source.on("error", onerror);
                  dest.on("error", onerror);
                  function cleanup() {
                    source.removeListener("data", ondata);
                    dest.removeListener("drain", ondrain);
                    source.removeListener("end", onend);
                    source.removeListener("close", onclose);
                    source.removeListener("error", onerror);
                    dest.removeListener("error", onerror);
                    source.removeListener("end", cleanup);
                    source.removeListener("close", cleanup);
                    dest.removeListener("close", cleanup);
                  }
                  source.on("end", cleanup);
                  source.on("close", cleanup);
                  dest.on("close", cleanup);
                  dest.emit("pipe", source);
                  return dest;
                };
              }
            ),
            /***/
            183: (
              /***/
              function(__unused_webpack_module, exports2, __webpack_require__2) {
                "use strict";
                var Buffer = __webpack_require__2(805).Buffer;
                var isEncoding = Buffer.isEncoding || function(encoding) {
                  encoding = "" + encoding;
                  switch (encoding && encoding.toLowerCase()) {
                    case "hex":
                    case "utf8":
                    case "utf-8":
                    case "ascii":
                    case "binary":
                    case "base64":
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                    case "raw":
                      return true;
                    default:
                      return false;
                  }
                };
                function _normalizeEncoding(enc) {
                  if (!enc)
                    return "utf8";
                  var retried;
                  while (true) {
                    switch (enc) {
                      case "utf8":
                      case "utf-8":
                        return "utf8";
                      case "ucs2":
                      case "ucs-2":
                      case "utf16le":
                      case "utf-16le":
                        return "utf16le";
                      case "latin1":
                      case "binary":
                        return "latin1";
                      case "base64":
                      case "ascii":
                      case "hex":
                        return enc;
                      default:
                        if (retried)
                          return;
                        enc = ("" + enc).toLowerCase();
                        retried = true;
                    }
                  }
                }
                ;
                function normalizeEncoding(enc) {
                  var nenc = _normalizeEncoding(enc);
                  if (typeof nenc !== "string" && (Buffer.isEncoding === isEncoding || !isEncoding(enc)))
                    throw new Error("Unknown encoding: " + enc);
                  return nenc || enc;
                }
                exports2.s = StringDecoder;
                function StringDecoder(encoding) {
                  this.encoding = normalizeEncoding(encoding);
                  var nb;
                  switch (this.encoding) {
                    case "utf16le":
                      this.text = utf16Text;
                      this.end = utf16End;
                      nb = 4;
                      break;
                    case "utf8":
                      this.fillLast = utf8FillLast;
                      nb = 4;
                      break;
                    case "base64":
                      this.text = base64Text;
                      this.end = base64End;
                      nb = 3;
                      break;
                    default:
                      this.write = simpleWrite;
                      this.end = simpleEnd;
                      return;
                  }
                  this.lastNeed = 0;
                  this.lastTotal = 0;
                  this.lastChar = Buffer.allocUnsafe(nb);
                }
                StringDecoder.prototype.write = function(buf) {
                  if (buf.length === 0)
                    return "";
                  var r;
                  var i;
                  if (this.lastNeed) {
                    r = this.fillLast(buf);
                    if (r === void 0)
                      return "";
                    i = this.lastNeed;
                    this.lastNeed = 0;
                  } else {
                    i = 0;
                  }
                  if (i < buf.length)
                    return r ? r + this.text(buf, i) : this.text(buf, i);
                  return r || "";
                };
                StringDecoder.prototype.end = utf8End;
                StringDecoder.prototype.text = utf8Text;
                StringDecoder.prototype.fillLast = function(buf) {
                  if (this.lastNeed <= buf.length) {
                    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
                    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
                  }
                  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
                  this.lastNeed -= buf.length;
                };
                function utf8CheckByte(byte) {
                  if (byte <= 127)
                    return 0;
                  else if (byte >> 5 === 6)
                    return 2;
                  else if (byte >> 4 === 14)
                    return 3;
                  else if (byte >> 3 === 30)
                    return 4;
                  return byte >> 6 === 2 ? -1 : -2;
                }
                function utf8CheckIncomplete(self2, buf, i) {
                  var j = buf.length - 1;
                  if (j < i)
                    return 0;
                  var nb = utf8CheckByte(buf[j]);
                  if (nb >= 0) {
                    if (nb > 0)
                      self2.lastNeed = nb - 1;
                    return nb;
                  }
                  if (--j < i || nb === -2)
                    return 0;
                  nb = utf8CheckByte(buf[j]);
                  if (nb >= 0) {
                    if (nb > 0)
                      self2.lastNeed = nb - 2;
                    return nb;
                  }
                  if (--j < i || nb === -2)
                    return 0;
                  nb = utf8CheckByte(buf[j]);
                  if (nb >= 0) {
                    if (nb > 0) {
                      if (nb === 2)
                        nb = 0;
                      else
                        self2.lastNeed = nb - 3;
                    }
                    return nb;
                  }
                  return 0;
                }
                function utf8CheckExtraBytes(self2, buf, p) {
                  if ((buf[0] & 192) !== 128) {
                    self2.lastNeed = 0;
                    return "";
                  }
                  if (self2.lastNeed > 1 && buf.length > 1) {
                    if ((buf[1] & 192) !== 128) {
                      self2.lastNeed = 1;
                      return "";
                    }
                    if (self2.lastNeed > 2 && buf.length > 2) {
                      if ((buf[2] & 192) !== 128) {
                        self2.lastNeed = 2;
                        return "";
                      }
                    }
                  }
                }
                function utf8FillLast(buf) {
                  var p = this.lastTotal - this.lastNeed;
                  var r = utf8CheckExtraBytes(this, buf, p);
                  if (r !== void 0)
                    return r;
                  if (this.lastNeed <= buf.length) {
                    buf.copy(this.lastChar, p, 0, this.lastNeed);
                    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
                  }
                  buf.copy(this.lastChar, p, 0, buf.length);
                  this.lastNeed -= buf.length;
                }
                function utf8Text(buf, i) {
                  var total = utf8CheckIncomplete(this, buf, i);
                  if (!this.lastNeed)
                    return buf.toString("utf8", i);
                  this.lastTotal = total;
                  var end = buf.length - (total - this.lastNeed);
                  buf.copy(this.lastChar, 0, end);
                  return buf.toString("utf8", i, end);
                }
                function utf8End(buf) {
                  var r = buf && buf.length ? this.write(buf) : "";
                  if (this.lastNeed)
                    return r + "";
                  return r;
                }
                function utf16Text(buf, i) {
                  if ((buf.length - i) % 2 === 0) {
                    var r = buf.toString("utf16le", i);
                    if (r) {
                      var c = r.charCodeAt(r.length - 1);
                      if (c >= 55296 && c <= 56319) {
                        this.lastNeed = 2;
                        this.lastTotal = 4;
                        this.lastChar[0] = buf[buf.length - 2];
                        this.lastChar[1] = buf[buf.length - 1];
                        return r.slice(0, -1);
                      }
                    }
                    return r;
                  }
                  this.lastNeed = 1;
                  this.lastTotal = 2;
                  this.lastChar[0] = buf[buf.length - 1];
                  return buf.toString("utf16le", i, buf.length - 1);
                }
                function utf16End(buf) {
                  var r = buf && buf.length ? this.write(buf) : "";
                  if (this.lastNeed) {
                    var end = this.lastTotal - this.lastNeed;
                    return r + this.lastChar.toString("utf16le", 0, end);
                  }
                  return r;
                }
                function base64Text(buf, i) {
                  var n = (buf.length - i) % 3;
                  if (n === 0)
                    return buf.toString("base64", i);
                  this.lastNeed = 3 - n;
                  this.lastTotal = 3;
                  if (n === 1) {
                    this.lastChar[0] = buf[buf.length - 1];
                  } else {
                    this.lastChar[0] = buf[buf.length - 2];
                    this.lastChar[1] = buf[buf.length - 1];
                  }
                  return buf.toString("base64", i, buf.length - n);
                }
                function base64End(buf) {
                  var r = buf && buf.length ? this.write(buf) : "";
                  if (this.lastNeed)
                    return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
                  return r;
                }
                function simpleWrite(buf) {
                  return buf.toString(this.encoding);
                }
                function simpleEnd(buf) {
                  return buf && buf.length ? this.write(buf) : "";
                }
              }
            ),
            /***/
            805: (
              /***/
              function(module2, exports2, __webpack_require__2) {
                "use strict";
                var buffer = __webpack_require__2(636);
                var Buffer = buffer.Buffer;
                function copyProps(src, dst) {
                  for (var key in src) {
                    dst[key] = src[key];
                  }
                }
                if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
                  module2.exports = buffer;
                } else {
                  copyProps(buffer, exports2);
                  exports2.Buffer = SafeBuffer;
                }
                function SafeBuffer(arg, encodingOrOffset, length) {
                  return Buffer(arg, encodingOrOffset, length);
                }
                SafeBuffer.prototype = Object.create(Buffer.prototype);
                copyProps(Buffer, SafeBuffer);
                SafeBuffer.from = function(arg, encodingOrOffset, length) {
                  if (typeof arg === "number") {
                    throw new TypeError("Argument must not be a number");
                  }
                  return Buffer(arg, encodingOrOffset, length);
                };
                SafeBuffer.alloc = function(size, fill, encoding) {
                  if (typeof size !== "number") {
                    throw new TypeError("Argument must be a number");
                  }
                  var buf = Buffer(size);
                  if (fill !== void 0) {
                    if (typeof encoding === "string") {
                      buf.fill(fill, encoding);
                    } else {
                      buf.fill(fill);
                    }
                  } else {
                    buf.fill(0);
                  }
                  return buf;
                };
                SafeBuffer.allocUnsafe = function(size) {
                  if (typeof size !== "number") {
                    throw new TypeError("Argument must be a number");
                  }
                  return Buffer(size);
                };
                SafeBuffer.allocUnsafeSlow = function(size) {
                  if (typeof size !== "number") {
                    throw new TypeError("Argument must be a number");
                  }
                  return buffer.SlowBuffer(size);
                };
              }
            ),
            /***/
            863: (
              /***/
              function(module2, exports2, __webpack_require__2) {
                "use strict";
                exports2.__esModule = true;
                exports2.default = void 0;
                var _forEachArray = _interopRequireDefault(__webpack_require__2(695));
                var _forEachOwnProperties = _interopRequireDefault(__webpack_require__2(175));
                var _extend = _interopRequireDefault(__webpack_require__2(867));
                var _isArray = _interopRequireDefault(__webpack_require__2(383));
                var _isEmpty = _interopRequireDefault(__webpack_require__2(440));
                var _isFunction = _interopRequireDefault(__webpack_require__2(494));
                var _isNull = _interopRequireDefault(__webpack_require__2(948));
                var _isObject = _interopRequireDefault(__webpack_require__2(873));
                var _isUndefined = _interopRequireDefault(__webpack_require__2(895));
                function _interopRequireDefault(obj) {
                  return obj && obj.__esModule ? obj : {
                    "default": obj
                  };
                }
                function encodePairs(key, value) {
                  return encodeURIComponent(key) + "=" + encodeURIComponent((0, _isNull["default"])(value) || (0, _isUndefined["default"])(value) ? "" : value);
                }
                function serializeParams(key, value, serializedList) {
                  if ((0, _isArray["default"])(value)) {
                    (0, _forEachArray["default"])(value, function(arrVal, index) {
                      serializeParams(key + "[" + ((0, _isObject["default"])(arrVal) ? index : "") + "]", arrVal, serializedList);
                    });
                  } else if ((0, _isObject["default"])(value)) {
                    (0, _forEachOwnProperties["default"])(value, function(objValue, objKey) {
                      serializeParams(key + "[" + objKey + "]", objValue, serializedList);
                    });
                  } else {
                    serializedList.push(encodePairs(key, value));
                  }
                }
                function serialize(params) {
                  if (!params || (0, _isEmpty["default"])(params)) {
                    return "";
                  }
                  var serializedList = [];
                  (0, _forEachOwnProperties["default"])(params, function(value, key) {
                    serializeParams(key, value, serializedList);
                  });
                  return serializedList.join("&");
                }
                var getDefaultOptions = function getDefaultOptions2() {
                  return {
                    baseURL: "",
                    headers: {
                      common: {},
                      get: {},
                      post: {},
                      put: {},
                      "delete": {},
                      patch: {},
                      options: {},
                      head: {}
                    },
                    serializer: serialize
                  };
                };
                var HTTP_PROTOCOL_REGEXP = /^(http|https):\/\//i;
                function combineURL(baseURL, url) {
                  if (HTTP_PROTOCOL_REGEXP.test(url)) {
                    return url;
                  }
                  if (baseURL.slice(-1) === "/" && url.slice(0, 1) === "/") {
                    url = url.slice(1);
                  }
                  return baseURL + url;
                }
                function getComputedOptions(defaultOptions, customOptions) {
                  var baseURL = defaultOptions.baseURL, defaultHeaders = defaultOptions.headers, defaultSerializer = defaultOptions.serializer, defaultBeforeRequest = defaultOptions.beforeRequest, defaultSuccess = defaultOptions.success, defaultError = defaultOptions.error, defaultComplete = defaultOptions.complete;
                  var url = customOptions.url, contentType = customOptions.contentType, method = customOptions.method, params = customOptions.params, headers = customOptions.headers, serializer = customOptions.serializer, beforeRequest = customOptions.beforeRequest, success = customOptions.success, error = customOptions.error, complete = customOptions.complete, withCredentials = customOptions.withCredentials, mimeType = customOptions.mimeType;
                  var options = {
                    url: combineURL(baseURL, url),
                    method,
                    params,
                    headers: (0, _extend["default"])(defaultHeaders.common, defaultHeaders[method.toLowerCase()], headers),
                    serializer: serializer || defaultSerializer || serialize,
                    beforeRequest: [defaultBeforeRequest, beforeRequest],
                    success: [defaultSuccess, success],
                    error: [defaultError, error],
                    complete: [defaultComplete, complete],
                    withCredentials,
                    mimeType
                  };
                  options.contentType = contentType || options.headers["Content-Type"];
                  delete options.headers["Content-Type"];
                  return options;
                }
                function validateStatus(status) {
                  return status >= 200 && status < 300;
                }
                function hasRequestBody(method) {
                  return /^(?:POST|PUT|PATCH)$/.test(method.toUpperCase());
                }
                function executeCallback(callback, param) {
                  if ((0, _isArray["default"])(callback)) {
                    (0, _forEachArray["default"])(callback, function(fn) {
                      return executeCallback(fn, param);
                    });
                  } else if ((0, _isFunction["default"])(callback)) {
                    callback(param);
                  }
                }
                function parseHeaders(text) {
                  var headers = {};
                  (0, _forEachArray["default"])(text.split("\r\n"), function(header) {
                    var _header$split = header.split(": "), key = _header$split[0], value = _header$split[1];
                    if (key !== "" && !(0, _isUndefined["default"])(value)) {
                      headers[key] = value;
                    }
                  });
                  return headers;
                }
                function parseJSONData(data) {
                  var result = "";
                  try {
                    result = JSON.parse(data);
                  } catch (_) {
                    result = data;
                  }
                  return result;
                }
                var REQUEST_DONE = 4;
                function handleReadyStateChange(xhr, options) {
                  var readyState = xhr.readyState;
                  if (readyState != REQUEST_DONE) {
                    return;
                  }
                  var status = xhr.status, statusText = xhr.statusText, responseText = xhr.responseText;
                  var success = options.success, resolve = options.resolve, error = options.error, reject = options.reject, complete = options.complete;
                  if (validateStatus(status)) {
                    var contentType = xhr.getResponseHeader("Content-Type");
                    var data = responseText;
                    if (contentType && contentType.indexOf("application/json") > -1) {
                      data = parseJSONData(data);
                    }
                    executeCallback([success, resolve], {
                      status,
                      statusText,
                      data,
                      headers: parseHeaders(xhr.getAllResponseHeaders())
                    });
                  } else {
                    executeCallback([error, reject], {
                      status,
                      statusText
                    });
                  }
                  executeCallback(complete, {
                    status,
                    statusText
                  });
                }
                var QS_DELIM_REGEXP = /\?/;
                function open(xhr, options) {
                  var url = options.url, method = options.method, serializer = options.serializer, params = options.params;
                  var requestUrl = url;
                  if (!hasRequestBody(method) && params) {
                    var qs = (QS_DELIM_REGEXP.test(url) ? "&" : "?") + serializer(params);
                    requestUrl = "" + url + qs;
                  }
                  xhr.open(method, requestUrl);
                }
                function applyConfig(xhr, options) {
                  var method = options.method, contentType = options.contentType, mimeType = options.mimeType, headers = options.headers, _options$withCredenti = options.withCredentials, withCredentials = _options$withCredenti === void 0 ? false : _options$withCredenti;
                  if (withCredentials) {
                    xhr.withCredentials = withCredentials;
                  }
                  if (mimeType) {
                    xhr.overrideMimeType(mimeType);
                  }
                  (0, _forEachOwnProperties["default"])(headers, function(value, header) {
                    if (!(0, _isObject["default"])(value)) {
                      xhr.setRequestHeader(header, value);
                    }
                  });
                  if (hasRequestBody(method)) {
                    xhr.setRequestHeader("Content-Type", contentType + "; charset=UTF-8");
                  }
                  xhr.setRequestHeader("x-requested-with", "XMLHttpRequest");
                }
                var ENCODED_SPACE_REGEXP = /%20/g;
                function send(xhr, options) {
                  var method = options.method, serializer = options.serializer, beforeRequest = options.beforeRequest, _options$params = options.params, params = _options$params === void 0 ? {} : _options$params, _options$contentType = options.contentType, contentType = _options$contentType === void 0 ? "application/x-www-form-urlencoded" : _options$contentType;
                  var body = null;
                  if (hasRequestBody(method)) {
                    body = contentType.indexOf("application/x-www-form-urlencoded") > -1 ? serializer(params).replace(ENCODED_SPACE_REGEXP, "+") : JSON.stringify(params);
                  }
                  xhr.onreadystatechange = function() {
                    return handleReadyStateChange(xhr, options);
                  };
                  executeCallback(beforeRequest, xhr);
                  xhr.send(body);
                }
                function ajax(options) {
                  var xhr = new XMLHttpRequest();
                  var request = function request2(opts) {
                    return (0, _forEachArray["default"])([open, applyConfig, send], function(fn) {
                      return fn(xhr, opts);
                    });
                  };
                  options = getComputedOptions(ajax.defaults, options);
                  if (typeof Promise !== "undefined") {
                    return new Promise(function(resolve, reject) {
                      request((0, _extend["default"])(options, {
                        resolve,
                        reject
                      }));
                    });
                  }
                  request(options);
                  return null;
                }
                ajax.defaults = getDefaultOptions();
                ajax._reset = function() {
                  ajax.defaults = getDefaultOptions();
                };
                ajax._request = function(url, method, options) {
                  if (options === void 0) {
                    options = {};
                  }
                  return ajax((0, _extend["default"])(options, {
                    url,
                    method
                  }));
                };
                (0, _forEachArray["default"])(["get", "post", "put", "delete", "patch", "options", "head"], function(type) {
                  ajax[type] = function(url, options) {
                    return ajax._request(url, type.toUpperCase(), options);
                  };
                });
                var _default = ajax;
                exports2.default = _default;
                module2.exports = exports2["default"];
              }
            ),
            /***/
            187: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var isArray = __webpack_require__2(383);
                function inArray(searchElement, array, startIndex) {
                  var i;
                  var length;
                  startIndex = startIndex || 0;
                  if (!isArray(array)) {
                    return -1;
                  }
                  if (Array.prototype.indexOf) {
                    return Array.prototype.indexOf.call(array, searchElement, startIndex);
                  }
                  length = array.length;
                  for (i = startIndex; startIndex >= 0 && i < length; i += 1) {
                    if (array[i] === searchElement) {
                      return i;
                    }
                  }
                  return -1;
                }
                module2.exports = inArray;
              }
            ),
            /***/
            695: (
              /***/
              function(module2) {
                "use strict";
                function forEachArray(arr, iteratee, context) {
                  var index = 0;
                  var len = arr.length;
                  context = context || null;
                  for (; index < len; index += 1) {
                    if (iteratee.call(context, arr[index], index, arr) === false) {
                      break;
                    }
                  }
                }
                module2.exports = forEachArray;
              }
            ),
            /***/
            175: (
              /***/
              function(module2) {
                "use strict";
                function forEachOwnProperties(obj, iteratee, context) {
                  var key;
                  context = context || null;
                  for (key in obj) {
                    if (obj.hasOwnProperty(key)) {
                      if (iteratee.call(context, obj[key], key, obj) === false) {
                        break;
                      }
                    }
                  }
                }
                module2.exports = forEachOwnProperties;
              }
            ),
            /***/
            867: (
              /***/
              function(module2) {
                "use strict";
                function extend(target, objects) {
                  var hasOwnProp = Object.prototype.hasOwnProperty;
                  var source, prop, i, len;
                  for (i = 1, len = arguments.length; i < len; i += 1) {
                    source = arguments[i];
                    for (prop in source) {
                      if (hasOwnProp.call(source, prop)) {
                        target[prop] = source[prop];
                      }
                    }
                  }
                  return target;
                }
                module2.exports = extend;
              }
            ),
            /***/
            947: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var isExisty = __webpack_require__2(325);
                function isArguments(obj) {
                  var result = isExisty(obj) && (Object.prototype.toString.call(obj) === "[object Arguments]" || !!obj.callee);
                  return result;
                }
                module2.exports = isArguments;
              }
            ),
            /***/
            383: (
              /***/
              function(module2) {
                "use strict";
                function isArray(obj) {
                  return obj instanceof Array;
                }
                module2.exports = isArray;
              }
            ),
            /***/
            440: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var isString2 = __webpack_require__2(994);
                var isExisty = __webpack_require__2(325);
                var isArray = __webpack_require__2(383);
                var isArguments = __webpack_require__2(947);
                var isObject = __webpack_require__2(873);
                var isFunction = __webpack_require__2(494);
                function _isEmptyString(obj) {
                  return isString2(obj) && obj === "";
                }
                function _hasOwnProperty(obj) {
                  var key;
                  for (key in obj) {
                    if (obj.hasOwnProperty(key)) {
                      return true;
                    }
                  }
                  return false;
                }
                function isEmpty(obj) {
                  if (!isExisty(obj) || _isEmptyString(obj)) {
                    return true;
                  }
                  if (isArray(obj) || isArguments(obj)) {
                    return obj.length === 0;
                  }
                  if (isObject(obj) && !isFunction(obj)) {
                    return !_hasOwnProperty(obj);
                  }
                  return true;
                }
                module2.exports = isEmpty;
              }
            ),
            /***/
            325: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var isUndefined = __webpack_require__2(895);
                var isNull = __webpack_require__2(948);
                function isExisty(param) {
                  return !isUndefined(param) && !isNull(param);
                }
                module2.exports = isExisty;
              }
            ),
            /***/
            494: (
              /***/
              function(module2) {
                "use strict";
                function isFunction(obj) {
                  return obj instanceof Function;
                }
                module2.exports = isFunction;
              }
            ),
            /***/
            948: (
              /***/
              function(module2) {
                "use strict";
                function isNull(obj) {
                  return obj === null;
                }
                module2.exports = isNull;
              }
            ),
            /***/
            873: (
              /***/
              function(module2) {
                "use strict";
                function isObject(obj) {
                  return obj === Object(obj);
                }
                module2.exports = isObject;
              }
            ),
            /***/
            994: (
              /***/
              function(module2) {
                "use strict";
                function isString2(obj) {
                  return typeof obj === "string" || obj instanceof String;
                }
                module2.exports = isString2;
              }
            ),
            /***/
            895: (
              /***/
              function(module2) {
                "use strict";
                function isUndefined(obj) {
                  return obj === void 0;
                }
                module2.exports = isUndefined;
              }
            ),
            /***/
            485: (
              /***/
              function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                module2.exports = deprecate;
                function deprecate(fn, msg) {
                  if (config("noDeprecation")) {
                    return fn;
                  }
                  var warned = false;
                  function deprecated() {
                    if (!warned) {
                      if (config("throwDeprecation")) {
                        throw new Error(msg);
                      } else if (config("traceDeprecation")) {
                        console.trace(msg);
                      } else {
                        console.warn(msg);
                      }
                      warned = true;
                    }
                    return fn.apply(this, arguments);
                  }
                  return deprecated;
                }
                function config(name) {
                  try {
                    if (!__webpack_require__2.g.localStorage)
                      return false;
                  } catch (_) {
                    return false;
                  }
                  var val = __webpack_require__2.g.localStorage[name];
                  if (null == val)
                    return false;
                  return String(val).toLowerCase() === "true";
                }
              }
            ),
            /***/
            203: (
              /***/
              function(module2) {
                "use strict";
                module2.exports = __WEBPACK_EXTERNAL_MODULE__203__;
              }
            ),
            /***/
            854: (
              /***/
              function() {
              }
            ),
            /***/
            602: (
              /***/
              function() {
              }
            )
            /******/
          };
          var __webpack_module_cache__ = {};
          function __webpack_require__(moduleId) {
            var cachedModule = __webpack_module_cache__[moduleId];
            if (cachedModule !== void 0) {
              return cachedModule.exports;
            }
            var module2 = __webpack_module_cache__[moduleId] = {
              /******/
              // no module.id needed
              /******/
              // no module.loaded needed
              /******/
              exports: {}
              /******/
            };
            __webpack_modules__[moduleId](module2, module2.exports, __webpack_require__);
            return module2.exports;
          }
          !function() {
            __webpack_require__.n = function(module2) {
              var getter = module2 && module2.__esModule ? (
                /******/
                function() {
                  return module2["default"];
                }
              ) : (
                /******/
                function() {
                  return module2;
                }
              );
              __webpack_require__.d(getter, { a: getter });
              return getter;
            };
          }();
          !function() {
            __webpack_require__.d = function(exports2, definition) {
              for (var key in definition) {
                if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports2, key)) {
                  Object.defineProperty(exports2, key, { enumerable: true, get: definition[key] });
                }
              }
            };
          }();
          !function() {
            __webpack_require__.g = function() {
              if (typeof globalThis === "object")
                return globalThis;
              try {
                return this || new Function("return this")();
              } catch (e) {
                if (typeof window === "object")
                  return window;
              }
            }();
          }();
          !function() {
            __webpack_require__.o = function(obj, prop) {
              return Object.prototype.hasOwnProperty.call(obj, prop);
            };
          }();
          var __webpack_exports__ = {};
          !function() {
            "use strict";
            __webpack_require__.d(__webpack_exports__, {
              "default": function() {
                return (
                  /* binding */
                  chartPlugin
                );
              }
            });
            var chart_root_toastui_Chart_ = __webpack_require__(203);
            var chart_root_toastui_Chart_default = __webpack_require__.n(chart_root_toastui_Chart_);
            var isString2 = __webpack_require__(994);
            var isString_default = __webpack_require__.n(isString2);
            var isUndefined = __webpack_require__(895);
            var isUndefined_default = __webpack_require__.n(isUndefined);
            var inArray = __webpack_require__(187);
            var inArray_default = __webpack_require__.n(inArray);
            var extend = __webpack_require__(867);
            var extend_default = __webpack_require__.n(extend);
            var ajax = __webpack_require__(863);
            var ajax_default = __webpack_require__.n(ajax);
            ;
            var CSV = {};
            CSV.RELAXED = false;
            CSV.IGNORE_RECORD_LENGTH = false;
            CSV.IGNORE_QUOTES = false;
            CSV.LINE_FEED_OK = true;
            CSV.CARRIAGE_RETURN_OK = true;
            CSV.DETECT_TYPES = true;
            CSV.IGNORE_QUOTE_WHITESPACE = true;
            CSV.DEBUG = false;
            CSV.COLUMN_SEPARATOR = ",";
            CSV.ERROR_EOF = "UNEXPECTED_END_OF_FILE";
            CSV.ERROR_CHAR = "UNEXPECTED_CHARACTER";
            CSV.ERROR_EOL = "UNEXPECTED_END_OF_RECORD";
            CSV.WARN_SPACE = "UNEXPECTED_WHITESPACE";
            var QUOTE = '"', CR = "\r", LF = "\n", SPACE = " ", TAB = "	";
            var PRE_TOKEN = 0, MID_TOKEN = 1, POST_TOKEN = 2, POST_RECORD = 4;
            CSV.parse = function(str) {
              var result = CSV.result = [];
              CSV.COLUMN_SEPARATOR = CSV.COLUMN_SEPARATOR instanceof RegExp ? new RegExp("^" + CSV.COLUMN_SEPARATOR.source) : CSV.COLUMN_SEPARATOR;
              CSV.offset = 0;
              CSV.str = str;
              CSV.record_begin();
              CSV.debug("parse()", str);
              var c;
              while (1) {
                c = str[CSV.offset++];
                CSV.debug("c", c);
                if (c == null) {
                  if (CSV.escaped) {
                    CSV.error(CSV.ERROR_EOF);
                  }
                  if (CSV.record) {
                    CSV.token_end();
                    CSV.record_end();
                  }
                  CSV.debug("...bail", c, CSV.state, CSV.record);
                  CSV.reset();
                  break;
                }
                if (CSV.record == null) {
                  if (CSV.RELAXED && (c == LF || c == CR && str[CSV.offset + 1] == LF)) {
                    continue;
                  }
                  CSV.record_begin();
                }
                if (CSV.state == PRE_TOKEN) {
                  if ((c === SPACE || c === TAB) && CSV.next_nonspace() == QUOTE) {
                    if (CSV.RELAXED || CSV.IGNORE_QUOTE_WHITESPACE) {
                      continue;
                    } else {
                      CSV.warn(CSV.WARN_SPACE);
                    }
                  }
                  if (c == QUOTE && !CSV.IGNORE_QUOTES) {
                    CSV.debug("...escaped start", c);
                    CSV.escaped = true;
                    CSV.state = MID_TOKEN;
                    continue;
                  }
                  CSV.state = MID_TOKEN;
                }
                if (CSV.state == MID_TOKEN && CSV.escaped) {
                  if (c == QUOTE) {
                    if (str[CSV.offset] == QUOTE) {
                      CSV.debug("...escaped quote", c);
                      CSV.token += QUOTE;
                      CSV.offset++;
                    } else {
                      CSV.debug("...escaped end", c);
                      CSV.escaped = false;
                      CSV.state = POST_TOKEN;
                    }
                  } else {
                    CSV.token += c;
                    CSV.debug("...escaped add", c, CSV.token);
                  }
                  continue;
                }
                if (c == CR) {
                  if (str[CSV.offset] == LF)
                    CSV.offset++;
                  else if (!CSV.CARRIAGE_RETURN_OK)
                    CSV.error(CSV.ERROR_CHAR);
                  CSV.token_end();
                  CSV.record_end();
                } else if (c == LF) {
                  if (!(CSV.LINE_FEED_OK || CSV.RELAXED))
                    CSV.error(CSV.ERROR_CHAR);
                  CSV.token_end();
                  CSV.record_end();
                } else if (CSV.test_regex_separator(str) || CSV.COLUMN_SEPARATOR == c) {
                  CSV.token_end();
                } else if (CSV.state == MID_TOKEN) {
                  CSV.token += c;
                  CSV.debug("...add", c, CSV.token);
                } else if (c === SPACE || c === TAB) {
                  if (!CSV.IGNORE_QUOTE_WHITESPACE)
                    CSV.error(CSV.WARN_SPACE);
                } else if (!CSV.RELAXED) {
                  CSV.error(CSV.ERROR_CHAR);
                }
              }
              return result;
            };
            CSV.stream = function() {
              var stream = __webpack_require__(769);
              var s = new stream.Transform({ objectMode: true });
              s.EOL = "\n";
              s.prior = "";
              s.emitter = function(s2) {
                return function(e) {
                  s2.push(CSV.parse(e + s2.EOL));
                };
              }(s);
              s._transform = function(chunk, encoding, done) {
                var lines = this.prior == "" ? chunk.toString().split(this.EOL) : (this.prior + chunk.toString()).split(this.EOL);
                this.prior = lines.pop();
                lines.forEach(this.emitter);
                done();
              };
              s._flush = function(done) {
                if (this.prior != "") {
                  this.emitter(this.prior);
                  this.prior = "";
                }
                done();
              };
              return s;
            };
            CSV.test_regex_separator = function(str) {
              if (!(CSV.COLUMN_SEPARATOR instanceof RegExp)) {
                return false;
              }
              var match;
              str = str.slice(CSV.offset - 1);
              match = CSV.COLUMN_SEPARATOR.exec(str);
              if (match) {
                CSV.offset += match[0].length - 1;
              }
              return match !== null;
            };
            CSV.stream.json = function() {
              var os = __webpack_require__(983);
              var stream = __webpack_require__(769);
              var s = new streamTransform({ objectMode: true });
              s._transform = function(chunk, encoding, done) {
                s.push(JSON.stringify(chunk.toString()) + os.EOL);
                done();
              };
              return s;
            };
            CSV.reset = function() {
              CSV.state = null;
              CSV.token = null;
              CSV.escaped = null;
              CSV.record = null;
              CSV.offset = null;
              CSV.result = null;
              CSV.str = null;
            };
            CSV.next_nonspace = function() {
              var i = CSV.offset;
              var c;
              while (i < CSV.str.length) {
                c = CSV.str[i++];
                if (!(c == SPACE || c === TAB)) {
                  return c;
                }
              }
              return null;
            };
            CSV.record_begin = function() {
              CSV.escaped = false;
              CSV.record = [];
              CSV.token_begin();
              CSV.debug("record_begin");
            };
            CSV.record_end = function() {
              CSV.state = POST_RECORD;
              if (!(CSV.IGNORE_RECORD_LENGTH || CSV.RELAXED) && CSV.result.length > 0 && CSV.record.length != CSV.result[0].length) {
                CSV.error(CSV.ERROR_EOL);
              }
              CSV.result.push(CSV.record);
              CSV.debug("record end", CSV.record);
              CSV.record = null;
            };
            CSV.resolve_type = function(token) {
              if (token.match(/^[-+]?[0-9]+(\.[0-9]+)?([eE][-+]?[0-9]+)?$/)) {
                token = parseFloat(token);
              } else if (token.match(/^(true|false)$/i)) {
                token = Boolean(token.match(/true/i));
              } else if (token === "undefined") {
                token = void 0;
              } else if (token === "null") {
                token = null;
              }
              return token;
            };
            CSV.token_begin = function() {
              CSV.state = PRE_TOKEN;
              CSV.token = "";
            };
            CSV.token_end = function() {
              if (CSV.DETECT_TYPES) {
                CSV.token = CSV.resolve_type(CSV.token);
              }
              CSV.record.push(CSV.token);
              CSV.debug("token end", CSV.token);
              CSV.token_begin();
            };
            CSV.debug = function() {
              if (CSV.DEBUG)
                console.log(arguments);
            };
            CSV.dump = function(msg) {
              return [
                msg,
                "at char",
                CSV.offset,
                ":",
                CSV.str.substr(CSV.offset - 50, 50).replace(/\r/gm, "\\r").replace(/\n/gm, "\\n").replace(/\t/gm, "\\t")
              ].join(" ");
            };
            CSV.error = function(err) {
              var msg = CSV.dump(err);
              CSV.reset();
              throw msg;
            };
            CSV.warn = function(err) {
              if (!CSV.DEBUG) {
                return;
              }
              var msg = CSV.dump(err);
              try {
                console.warn(msg);
                return;
              } catch (e) {
              }
              try {
                console.log(msg);
              } catch (e) {
              }
            };
            var csv = CSV;
            ;
            function trimKeepingTabs(text) {
              return text.replace(/(^(\s*[\n\r])+)|([\n\r]+\s*$)/g, "");
            }
            function isNumeric(text) {
              var mayBeNum = Number(text);
              return !isNaN(mayBeNum) && isFinite(mayBeNum);
            }
            function clamp(value, min, max) {
              var _a;
              if (min > max) {
                _a = [min, max], max = _a[0], min = _a[1];
              }
              return Math.max(min, Math.min(value, max));
            }
            ;
            var __assign = function() {
              __assign = Object.assign || function(t) {
                for (var s, i = 1, n = arguments.length; i < n; i++) {
                  s = arguments[i];
                  for (var p in s)
                    if (Object.prototype.hasOwnProperty.call(s, p))
                      t[p] = s[p];
                }
                return t;
              };
              return __assign.apply(this, arguments);
            };
            csv.IGNORE_QUOTE_WHITESPACE = false;
            csv.IGNORE_RECORD_LENGTH = true;
            csv.DETECT_TYPES = false;
            var reEOL = /[\n\r]/;
            var reGroupByDelimiter = /([^:]+)?:?(.*)/;
            var DEFAULT_DELIMITER = /\s+/;
            var DELIMITERS = [",", "	"];
            var MINIMUM_DELIM_CNT = 2;
            var SUPPORTED_CHART_TYPES = ["bar", "column", "line", "area", "pie"];
            var CATEGORY_CHART_TYPES = ["line", "area"];
            var DEFAULT_DIMENSION_OPTIONS = {
              minWidth: 0,
              maxWidth: Infinity,
              minHeight: 0,
              maxHeight: Infinity,
              height: "auto",
              width: "auto"
            };
            var RESERVED_KEYS = ["type", "url"];
            var chart = {
              bar: chart_root_toastui_Chart_default().barChart,
              column: chart_root_toastui_Chart_default().columnChart,
              area: chart_root_toastui_Chart_default().areaChart,
              line: chart_root_toastui_Chart_default().lineChart,
              pie: chart_root_toastui_Chart_default().pieChart
            };
            var chartMap = {};
            function parse(text, callback) {
              var _a;
              text = trimKeepingTabs(text);
              var _b = text.split(/\n{2,}/), firstTexts = _b[0], secondTexts = _b[1];
              var urlOptions = parseToChartOption(firstTexts);
              var url = (_a = urlOptions === null || urlOptions === void 0 ? void 0 : urlOptions.editorChart) === null || _a === void 0 ? void 0 : _a.url;
              if (isString_default()(url)) {
                var success = function(_a2) {
                  var data2 = _a2.data;
                  callback({ data: parseToChartData(data2), options: parseToChartOption(firstTexts) });
                };
                var error = function() {
                  return callback();
                };
                ajax_default().get(url, { success, error });
              } else {
                var data = parseToChartData(firstTexts);
                var options = parseToChartOption(secondTexts);
                callback({ data, options });
              }
            }
            function detectDelimiter(text) {
              var delimiter = DEFAULT_DELIMITER;
              var delimCnt = 0;
              text = trimKeepingTabs(text);
              DELIMITERS.forEach(function(delim) {
                var matched = text.match(new RegExp(delim, "g"));
                if ((matched === null || matched === void 0 ? void 0 : matched.length) > Math.max(MINIMUM_DELIM_CNT, delimCnt)) {
                  delimiter = delim;
                  delimCnt = matched.length;
                }
              });
              return delimiter;
            }
            function parseToChartData(text, delimiter) {
              text = trimKeepingTabs(text);
              csv.COLUMN_SEPARATOR = delimiter || detectDelimiter(text);
              var dsv = csv.parse(text);
              dsv = dsv.map(function(arr) {
                return arr.map(function(val) {
                  return val.trim();
                });
              });
              var hasLegends = dsv[0].filter(function(_, i) {
                return i > 0;
              }).reduce(function(hasNaN, item) {
                return hasNaN || !isNumeric(item);
              }, false);
              var legends = hasLegends ? dsv.shift() : [];
              var hasCategories = dsv.slice(1).reduce(function(hasNaN, row) {
                return hasNaN || !isNumeric(row[0]);
              }, false);
              var categories = hasCategories ? dsv.map(function(arr) {
                return arr.shift();
              }) : [];
              if (hasCategories) {
                legends.shift();
              }
              var tdsv = dsv[0].map(function(_, i) {
                return dsv.map(function(x) {
                  return parseFloat(x[i]);
                });
              });
              var series = tdsv.map(function(data, i) {
                return hasLegends ? {
                  name: legends[i],
                  data
                } : {
                  data
                };
              });
              return { categories, series };
            }
            function createOptionKeys(keyString) {
              var keys = keyString.trim().split(".");
              var topKey = keys[0];
              if (inArray_default()(topKey, RESERVED_KEYS) >= 0) {
                keys.unshift("editorChart");
              } else if (keys.length === 1) {
                keys.unshift("chart");
              } else if (topKey === "x" || topKey === "y") {
                keys[0] = topKey + "Axis";
              }
              return keys;
            }
            function parseToChartOption(text) {
              var options = {};
              if (!isUndefined_default()(text)) {
                var lineTexts = text.split(reEOL);
                lineTexts.forEach(function(lineText) {
                  var matched = lineText.match(reGroupByDelimiter);
                  if (matched) {
                    var keyString = matched[1], value_1 = matched[2];
                    if (value_1) {
                      try {
                        value_1 = JSON.parse(value_1.trim());
                      } catch (e) {
                        value_1 = value_1.trim();
                      }
                      var keys_1 = createOptionKeys(keyString);
                      var refOptions_1 = options;
                      keys_1.forEach(function(key, index) {
                        refOptions_1[key] = refOptions_1[key] || (keys_1.length - 1 === index ? value_1 : {});
                        refOptions_1 = refOptions_1[key];
                      });
                    }
                  }
                });
              }
              return options;
            }
            function getAdjustedDimension(size, containerWidth) {
              return size === "auto" ? containerWidth : size;
            }
            function getChartDimension(chartOptions, pluginOptions, chartContainer) {
              var dimensionOptions = extend_default()(__assign({}, DEFAULT_DIMENSION_OPTIONS), pluginOptions);
              var maxWidth = dimensionOptions.maxWidth, minWidth = dimensionOptions.minWidth, maxHeight = dimensionOptions.maxHeight, minHeight = dimensionOptions.minHeight;
              var containerWidth = chartContainer.getBoundingClientRect().width;
              var _a = chartOptions.chart, _b = _a.width, width = _b === void 0 ? dimensionOptions.width : _b, _c = _a.height, height = _c === void 0 ? dimensionOptions.height : _c;
              width = getAdjustedDimension(width, containerWidth);
              height = getAdjustedDimension(height, containerWidth);
              return {
                width: clamp(width, minWidth, maxWidth),
                height: clamp(height, minHeight, maxHeight)
              };
            }
            function setDefaultOptions(chartOptions, pluginOptions, chartContainer) {
              chartOptions = extend_default()({
                editorChart: {},
                chart: {},
                exportMenu: {}
              }, chartOptions);
              var _a = getChartDimension(chartOptions, pluginOptions, chartContainer), width = _a.width, height = _a.height;
              chartOptions.chart.width = width;
              chartOptions.chart.height = height;
              chartOptions.editorChart.type = chartOptions.editorChart.type || "column";
              chartOptions.exportMenu.visible = !!chartOptions.exportMenu.visible;
              return chartOptions;
            }
            function destroyChart() {
              Object.keys(chartMap).forEach(function(id) {
                var container = document.querySelector("[data-chart-id=" + id + "]");
                if (!container) {
                  chartMap[id].destroy();
                  delete chartMap[id];
                }
              });
            }
            function renderChart(id, text, usageStatistics, pluginOptions) {
              var chartContainer = document.querySelector("[data-chart-id=" + id + "]");
              destroyChart();
              if (chartContainer) {
                try {
                  parse(text, function(parsedInfo) {
                    var _a = parsedInfo || {}, data = _a.data, options = _a.options;
                    var chartOptions = setDefaultOptions(options, pluginOptions, chartContainer);
                    var chartType = chartOptions.editorChart.type;
                    if (!data || CATEGORY_CHART_TYPES.indexOf(chartType) > -1 && data.categories.length !== data.series[0].data.length) {
                      chartContainer.innerHTML = "invalid chart data";
                    } else if (SUPPORTED_CHART_TYPES.indexOf(chartType) < 0) {
                      chartContainer.innerHTML = "invalid chart type. type: bar, column, line, area, pie";
                    } else {
                      var toastuiChart = chart[chartType];
                      chartOptions.usageStatistics = usageStatistics;
                      chartMap[id] = toastuiChart({ el: chartContainer, data, options: chartOptions });
                    }
                  });
                } catch (e) {
                  chartContainer.innerHTML = "invalid chart data";
                }
              }
            }
            function generateId() {
              return "chart-" + Math.random().toString(36).substr(2, 10);
            }
            function chartPlugin(_a, options) {
              var _b = _a.usageStatistics, usageStatistics = _b === void 0 ? true : _b;
              return {
                toHTMLRenderers: {
                  chart: function(node) {
                    var id = generateId();
                    setTimeout(function() {
                      renderChart(id, node.literal, usageStatistics, options);
                    });
                    return [
                      {
                        type: "openTag",
                        tagName: "div",
                        outerNewLine: true,
                        attributes: { "data-chart-id": id }
                      },
                      { type: "closeTag", tagName: "div", outerNewLine: true }
                    ];
                  }
                }
              };
            }
          }();
          __webpack_exports__ = __webpack_exports__.default;
          return __webpack_exports__;
        }()
      );
    });
  }
});
export default require_toastui_editor_plugin_chart();
/*! Bundled license information:

@toast-ui/chart/dist/toastui-chart.js:
  (*!
   * TOAST UI Chart 4th Edition
   * @version 4.6.1 | Wed Dec 21 2022
   * @author NHN Cloud. FE Development Lab <dl_javascript@nhn.com>
   * @license MIT
   *)
  (* @license RGB <-> HSV conversion utilities based off of http://www.cs.rit.edu/~ncs/color/t_convert.html *)

@toast-ui/editor-plugin-chart/dist/toastui-editor-plugin-chart.js:
  (*!
   * TOAST UI Editor : Chart Plugin
   * @version 3.0.1 | Wed Jul 07 2021
   * @author NHN FE Development Lab <dl_javascript@nhn.com>
   * @license MIT
   *)
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)
*/
//# sourceMappingURL=@toast-ui_editor-plugin-chart.js.map
